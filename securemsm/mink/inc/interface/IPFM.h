#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"

/**
 * Copyright (c) 2018 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
*/

#define IPFM_OPT_NO_OEMID_CHECK UINT64_C(0x00000001)
#define IPFM_OPT_NO_HWVERSION_CHECK UINT64_C(0x00000002)
#define IPFM_OPT_NO_FEATUREID_CHECK UINT64_C(0x00000004)
#define IPFM_OPT_NO_TIME_CHECK UINT64_C(0x00000008)
#define IPFM_OPT_CLOCK_NOT_SET_OK UINT64_C(0x00000010)
#define IPFM_OPT_SELECT_TEST_ROOT UINT64_C(0x00000020)
#define IPFM_OPT_USAGE_ENCRYPT UINT64_C(0x00000040)
#define IPFM_OPT_NO_PKHASH_CHECK UINT64_C(0x00000080)
#define IPFM_OPT_NO_DEVICE_ID_CHECK UINT64_C(0x00000100)
#define IPFM_OPT_NO_START_LICENSE_DATE_CHECK UINT64_C(0x00000200)
#define IPFM_OPT_TRUST_INSECURE_CLK UINT64_C(0x00000400)
#define IPFM_OPT_NO_PRODUCTID_CHECK UINT64_C(0x00000800)
#define IPFM_LICENSE_HAS_OEMID UINT64_C(0x00000001)
#define IPFM_LICENSE_HAS_HWVERSION UINT64_C(0x00000002)
#define IPFM_LICENSE_HAS_DEVICEID UINT64_C(0x00000004)
#define IPFM_LICENSE_HAS_PKHASH UINT64_C(0x00000008)
#define IPFM_LICENSE_HAS_LICENSEEHASH UINT64_C(0x00000010)
#define IPFM_LICENSE_HAS_VALIDTIME UINT64_C(0x00000020)
#define IPFM_LICENSE_HAS_PRODUCTID UINT64_C(0x00000040)

#define IPFM_ERROR_NOMEM INT32_C(10)
#define IPFM_ERROR_INVALID_PFM_EXTENSION INT32_C(11)
#define IPFM_ERROR_CBOR_ENCODE_ERR INT32_C(12)
#define IPFM_ERROR_CERT_PKHASH INT32_C(13)
#define IPFM_ERROR_INVALID_CERT INT32_C(14)
#define IPFM_ERROR_CERT_FEATUREID INT32_C(15)
#define IPFM_ERROR_CERT_EXPIRED INT32_C(16)
#define IPFM_ERROR_CERT_OEM INT32_C(17)
#define IPFM_ERROR_CERT_HWVERSION INT32_C(18)
#define IPFM_ERROR_CERT_LICENSEE_HASH INT32_C(19)
#define IPFM_ERROR_PFMFILER_FAILED INT32_C(20)
#define IPFM_ERROR_HASH_GENERATION INT32_C(21)
#define IPFM_ERROR_CERT_NOT_TRUSTED INT32_C(22)
#define IPFM_ERROR_CERT_GENERAL_ERR INT32_C(23)
#define IPFM_ERROR_CBOR_DECODE_ERR INT32_C(24)
#define IPFM_ERROR_CBOR_DECODE_DATATYPE_ERR INT32_C(25)
#define IPFM_ERROR_PFMFILER_FILE_REMOVE_FAILED INT32_C(26)
#define IPFM_ERROR_PFMCACHE_REMOVE_FAILED INT32_C(27)
#define IPFM_ERROR_FILENAME_TOO_LONG INT32_C(28)
#define IPFM_ERROR_FILE_NOT_FOUND INT32_C(29)
#define IPFM_ERROR_PFMFILER_GETFILECONTENTS_FAILED INT32_C(30)
#define IPFM_ERROR_LICENSE_TOO_BIG INT32_C(31)
#define IPFM_ERROR_PRIVILEGE_ERR INT32_C(32)
#define IPFM_ERROR_LICENSE_STORE_FULL INT32_C(33)
#define IPFM_ERROR_CERT_FIELD_TOO_BIG INT32_C(34)
#define IPFM_ERROR_INVALID_CURRENT_TIME INT32_C(35)
#define IPFM_ERROR_FID_LIST_TRUNCATED INT32_C(36)
#define IPFM_ERROR_BLOB_ENCAP_FAILED INT32_C(37)
#define IPFM_ERROR_BLOB_DECAP_FAILED INT32_C(38)
#define IPFM_ERROR_CERT_DEVICEID INT32_C(39)
#define IPFM_ERROR_SFS_ERR INT32_C(40)
#define IPFM_ERROR_CERT_NOTYETVALID INT32_C(41)
#define IPFM_ERROR_OPTS_NOT_SUPPORTED INT32_C(42)
#define IPFM_ERROR_OVERFLOW INT32_C(43)
#define IPFM_ERROR_CERT_RESERVE2 INT32_C(44)
#define IPFM_ERROR_CERT_PRODUCTID INT32_C(45)

#define IPFM_OP_InstallLicense 0
#define IPFM_OP_CheckInstalledLicense 1
#define IPFM_OP_GetInstalledLicenseInfo 2
#define IPFM_OP_CheckLicenseBuffer 3
#define IPFM_OP_CheckSecured 4
#define IPFM_OP_GetAllInstalledFeatureIDs 5
#define IPFM_OP_GetAllInstalledSerialNumbers 6
#define IPFM_OP_CheckFeatureIds 7
#define IPFM_OP_CheckFIDAndGetAllSerialNums 8
#define IPFM_OP_SetOptions 9
#define IPFM_OP_RemoveLicense 10
#define IPFM_OP_RemoveLicenseExpired 11
#define IPFM_OP_GetLicenseCertPFM 12

static inline int32_t
IPFM_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IPFM_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
IPFM_InstallLicense(Object self, const void *PFMLicense_ptr, size_t PFMLicense_len, void *LicenseSerialNumber_ptr, size_t LicenseSerialNumber_len, size_t *LicenseSerialNumber_lenout, void *FeatureIDsCBOR_ptr, size_t FeatureIDsCBOR_len, size_t *FeatureIDsCBOR_lenout, uint64_t *LicenseRestrictions_ptr)
{
  ObjectArg a[4];
  a[0].bi = (ObjectBufIn) { PFMLicense_ptr, PFMLicense_len * 1 };
  a[1].b = (ObjectBuf) { LicenseSerialNumber_ptr, LicenseSerialNumber_len * 1 };
  a[2].b = (ObjectBuf) { FeatureIDsCBOR_ptr, FeatureIDsCBOR_len * 1 };
  a[3].b = (ObjectBuf) { LicenseRestrictions_ptr, sizeof(uint64_t) };

  int32_t result = Object_invoke(self, IPFM_OP_InstallLicense, a, ObjectCounts_pack(1, 3, 0, 0));

  *LicenseSerialNumber_lenout = a[1].b.size / 1;
  *FeatureIDsCBOR_lenout = a[2].b.size / 1;

  return result;
}

static inline int32_t
IPFM_CheckInstalledLicense(Object self, uint32_t FeatureID_val, const void *LicenseeHash_ptr, size_t LicenseeHash_len, void *LicenseSerialNumber_ptr, size_t LicenseSerialNumber_len, size_t *LicenseSerialNumber_lenout)
{
  ObjectArg a[3];
  a[0].b = (ObjectBuf) { &FeatureID_val, sizeof(uint32_t) };
  a[1].bi = (ObjectBufIn) { LicenseeHash_ptr, LicenseeHash_len * 1 };
  a[2].b = (ObjectBuf) { LicenseSerialNumber_ptr, LicenseSerialNumber_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_CheckInstalledLicense, a, ObjectCounts_pack(2, 1, 0, 0));

  *LicenseSerialNumber_lenout = a[2].b.size / 1;

  return result;
}

static inline int32_t
IPFM_GetInstalledLicenseInfo(Object self, const void *LicenseSerialNumber_ptr, size_t LicenseSerialNumber_len, void *LicenseInfoCBOR_ptr, size_t LicenseInfoCBOR_len, size_t *LicenseInfoCBOR_lenout)
{
  ObjectArg a[2];
  a[0].bi = (ObjectBufIn) { LicenseSerialNumber_ptr, LicenseSerialNumber_len * 1 };
  a[1].b = (ObjectBuf) { LicenseInfoCBOR_ptr, LicenseInfoCBOR_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_GetInstalledLicenseInfo, a, ObjectCounts_pack(1, 1, 0, 0));

  *LicenseInfoCBOR_lenout = a[1].b.size / 1;

  return result;
}

static inline int32_t
IPFM_CheckLicenseBuffer(Object self, const void *PFMLicense_ptr, size_t PFMLicense_len, uint32_t FeatureID_val, const void *LicenseeHash_ptr, size_t LicenseeHash_len, void *LicenseBufferCBOR_ptr, size_t LicenseBufferCBOR_len, size_t *LicenseBufferCBOR_lenout)
{
  ObjectArg a[4];
  a[0].bi = (ObjectBufIn) { PFMLicense_ptr, PFMLicense_len * 1 };
  a[1].b = (ObjectBuf) { &FeatureID_val, sizeof(uint32_t) };
  a[2].bi = (ObjectBufIn) { LicenseeHash_ptr, LicenseeHash_len * 1 };
  a[3].b = (ObjectBuf) { LicenseBufferCBOR_ptr, LicenseBufferCBOR_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_CheckLicenseBuffer, a, ObjectCounts_pack(3, 1, 0, 0));

  *LicenseBufferCBOR_lenout = a[3].b.size / 1;

  return result;
}

static inline int32_t
IPFM_CheckSecured(Object self, const void *SecuredRequest_ptr, size_t SecuredRequest_len, void *SecuredResponse_ptr, size_t SecuredResponse_len, size_t *SecuredResponse_lenout)
{
  ObjectArg a[2];
  a[0].bi = (ObjectBufIn) { SecuredRequest_ptr, SecuredRequest_len * 1 };
  a[1].b = (ObjectBuf) { SecuredResponse_ptr, SecuredResponse_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_CheckSecured, a, ObjectCounts_pack(1, 1, 0, 0));

  *SecuredResponse_lenout = a[1].b.size / 1;

  return result;
}

static inline int32_t
IPFM_GetAllInstalledFeatureIDs(Object self, void *FeatureIDsCBOR_ptr, size_t FeatureIDsCBOR_len, size_t *FeatureIDsCBOR_lenout)
{
  ObjectArg a[1];
  a[0].b = (ObjectBuf) { FeatureIDsCBOR_ptr, FeatureIDsCBOR_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_GetAllInstalledFeatureIDs, a, ObjectCounts_pack(0, 1, 0, 0));

  *FeatureIDsCBOR_lenout = a[0].b.size / 1;

  return result;
}

static inline int32_t
IPFM_GetAllInstalledSerialNumbers(Object self, void *SerialNumbersCBOR_ptr, size_t SerialNumbersCBOR_len, size_t *SerialNumbersCBOR_lenout)
{
  ObjectArg a[1];
  a[0].b = (ObjectBuf) { SerialNumbersCBOR_ptr, SerialNumbersCBOR_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_GetAllInstalledSerialNumbers, a, ObjectCounts_pack(0, 1, 0, 0));

  *SerialNumbersCBOR_lenout = a[0].b.size / 1;

  return result;
}

static inline int32_t
IPFM_CheckFeatureIds(Object self, const void *RequestCBOR_ptr, size_t RequestCBOR_len, void *ResponseCBOR_ptr, size_t ResponseCBOR_len, size_t *ResponseCBOR_lenout)
{
  ObjectArg a[2];
  a[0].bi = (ObjectBufIn) { RequestCBOR_ptr, RequestCBOR_len * 1 };
  a[1].b = (ObjectBuf) { ResponseCBOR_ptr, ResponseCBOR_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_CheckFeatureIds, a, ObjectCounts_pack(1, 1, 0, 0));

  *ResponseCBOR_lenout = a[1].b.size / 1;

  return result;
}

static inline int32_t
IPFM_CheckFIDAndGetAllSerialNums(Object self, const void *RequestCBOR_ptr, size_t RequestCBOR_len, void *SerialNumAndLicRestrictionCBOR_ptr, size_t SerialNumAndLicRestrictionCBOR_len, size_t *SerialNumAndLicRestrictionCBOR_lenout)
{
  ObjectArg a[2];
  a[0].bi = (ObjectBufIn) { RequestCBOR_ptr, RequestCBOR_len * 1 };
  a[1].b = (ObjectBuf) { SerialNumAndLicRestrictionCBOR_ptr, SerialNumAndLicRestrictionCBOR_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_CheckFIDAndGetAllSerialNums, a, ObjectCounts_pack(1, 1, 0, 0));

  *SerialNumAndLicRestrictionCBOR_lenout = a[1].b.size / 1;

  return result;
}

static inline int32_t
IPFM_SetOptions(Object self, uint64_t uOpts_val)
{
  ObjectArg a[1];
  a[0].b = (ObjectBuf) { &uOpts_val, sizeof(uint64_t) };

  return Object_invoke(self, IPFM_OP_SetOptions, a, ObjectCounts_pack(1, 0, 0, 0));
}

static inline int32_t
IPFM_RemoveLicense(Object self, const void *LicenseSerialNumber_ptr, size_t LicenseSerialNumber_len)
{
  ObjectArg a[1];
  a[0].bi = (ObjectBufIn) { LicenseSerialNumber_ptr, LicenseSerialNumber_len * 1 };

  return Object_invoke(self, IPFM_OP_RemoveLicense, a, ObjectCounts_pack(1, 0, 0, 0));
}

static inline int32_t
IPFM_RemoveLicenseExpired(Object self)
{
  return Object_invoke(self, IPFM_OP_RemoveLicenseExpired, 0, 0);
}

static inline int32_t
IPFM_GetLicenseCertPFM(Object self, const void *LicenseSerialNumber_ptr, size_t LicenseSerialNumber_len, void *PFMLicense_ptr, size_t PFMLicense_len, size_t *PFMLicense_lenout)
{
  ObjectArg a[2];
  a[0].bi = (ObjectBufIn) { LicenseSerialNumber_ptr, LicenseSerialNumber_len * 1 };
  a[1].b = (ObjectBuf) { PFMLicense_ptr, PFMLicense_len * 1 };

  int32_t result = Object_invoke(self, IPFM_OP_GetLicenseCertPFM, a, ObjectCounts_pack(1, 1, 0, 0));

  *PFMLicense_lenout = a[1].b.size / 1;

  return result;
}



