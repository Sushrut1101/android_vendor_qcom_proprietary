/*!
 *
 * Copyright (c) 2019 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 */

package vendor.qti.spu@1.0;

import ISpcomSharedBuffer;
import ISpcomSSREvent;

// Generated by ISpcom::getSpcomClient()

interface ISpcomClient {

    /**
     * Register as a client to spcom channel
     *
     * On Hana:
     * Shareable channel is not supported, in case isShareable is true return
     * non zero error code (see errno.h)
     *
     * On Kona:
     * Creates spcom channel and registers as spcom client. The channel could be
     * shared by atmost 2 clients.
     * If the channel was already created as single spcom client not shareable
     * then the call will fail.
     *
     * @param isShareable if true channel could be shared if false only one
     *                    spcom client could use the channel
     *
     * @return error 0 on success, non zero otherwise
     */
    registerClient(bool isShareable) generates (int32_t error);

     /**
     * Client unregister spcom channel
     *
     * @return 0 on success, nonzero otherwise (see errno.h)
     */
    unregisterClient() generates(int32_t error);

    /**
     * Check if spcom client is fully connected to remote spcom server
     *
     * This API checks there is spcom channel connection between spcom
     * client and spcom server
     * Spcom server should be up and connect before spcom client tries to
     * register
     *
     * @return status true if server connected, false otherwise
     */
    isConnected() generates (bool status);

    /**
     * Send a synchronous request and response
     *
     * param request request buffer
     * param timeoutMs timeout in msec between command and response, 0=no
     *                 timeout
     * @return nBytes num of response bytes on success, negative error code on
     *                 failure (see errno.h)
     * @return response response buffer
     */
    sendMessage(vec<uint8_t> request, uint32_t timeoutMs)
        generates (int32_t nBytes, vec<uint8_t> response);

    /**
     * Get an instance of SPU shared buffer object with direct access to
     * shared buffer
     *
     * @param mem HIDL shared memory allocated and mapped by HIDL client
     * @return ISPUSharedBuffer shared buffer to be shared with SPU by sending
     *                          modified command, nullptr on failure
     */
    getSpcomSharedBuffer(memory mem) generates (ISpcomSharedBuffer buffer);

    /**
     * Send a message with shared buffer physical address in predefined offset
     *
     * @param request request buffer
     * @param sharedBuffer shared buffer to share with spcom server
     * @param timeoutMs timeout in msec between command and response, 0 means
     *                  no timeout
     *
     * @return nBytes num of response bytes on success, negative error code on
     *                 failure (see errno.h)
     * @return response response buffer
     */
    sendSharedBufferMessage(vec<uint8_t> request, ISpcomSharedBuffer
        sharedBuffer, uint32_t offset, uint32_t timeoutMs)
        generates (int32_t nBytes, vec<uint8_t> response);

     /**
     * Setup a callback to be called on SPU SSR event
     * More than one callback can be called
     * In case there is more than one they will be called in the same order
     * on which they were set.
     *
     * @param eventCb to be called on SPU SSR
     *
     * @return 0 on success, nonzero otherwise
     */
    addSSRCallback(ISpcomSSREvent eventCb) generates (int32_t error);
};
