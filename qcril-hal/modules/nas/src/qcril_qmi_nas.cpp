/******************************************************************************
#  Copyright (c) 2010-2015, 2017 - 2018 Qualcomm Technologies, Inc.
#  All Rights Reserved.
#  Confidential and Proprietary - Qualcomm Technologies, Inc.
#******************************************************************************/
/******************************************************************************
  @file    qcril_qmi_nas.c
  @brief   qcril qmi - NAS

  DESCRIPTION
    Handles RIL requests, Callbacks, indications for QMI NAS.

******************************************************************************/


//===========================================================================
//
//                           INCLUDE FILES
//
//===========================================================================

#include <string.h>
#include "qcril_qmi_pdc.h"
#include <fstream>
#include <errno.h>
#include <cutils/memory.h>
#include <cutils/properties.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <log.h>

#ifdef QMI_RIL_UTF
#include <signal.h>
#include <time.h>
#endif
#include "modules/nas/NasModule.h"
#include "modules/dms/DmsModule.h"

#include "qcril_qmi_cell_info.h"
#include "qcril_qmi_cell_info_v12.h"
#include "modules/voice/qcril_qmi_voice.h"
extern "C" {
#include "qcril_log.h"
#include "telephony/ril.h"
#include <telephony/librilutils.h>
#include "IxErrno.h"
#include "comdef.h"
#include "qcrili.h"
#include "qcril_reqlist.h"
#include "qcril_cm_ss.h"
#include "qcril_other.h"
#include "qcril_other.h"
#include "qcril_mbn_hw_update.h"
#include "qcril_mbn_meta.h"
#include "qcril_am.h"

#include "qmi_ril_platform_dep.h"
#include "qmi_ril_file_observer.h"
#include "time_genoff.h"
}

#include "qcril_pbm.h"
#include "qcril_file_utils.h"
#include "qcril_log.h"

#include "qcril_qmi_imsa.h"
#include "qcril_cm_util.h"
#include "qcril_qmi_oem_events.h"
#include "qcril_mbn_sw_update.h"
#include "modules/sms/qcril_qmi_sms.h"
#include "modules/nas/qcril_db.h"
#include "modules/nas/qcril_arb.h"
#include "modules/nas/qcril_qmi_nas.h"
#include "modules/nas/qcril_qmi_nas2.h"
#include "modules/nas/qcril_qmi_prov.h"
#include "modules/nas/qcril_nas_legacy.h"

#include "modules/qmi/QmiStruct.h"
#include "modules/qmi/NasModemEndPoint.h"
#include "modules/qmi/ModemEndPointFactory.h"
#include "modules/nas/NasGetMccMncCallback.h"
#include "modules/nas/NasFlexMapStatusIndMessage.h"
#include "modules/nas/NasEnableIndicationsIndMessage.h"
#include "modules/nas/NasUimHeaders.h"
#include "modules/nas/NasImsHelper.h"
#include "modules/nas/NasDataCallbacks.h"
#include "modules/nas/Nas5gStatusIndMessage.h"
#include "modules/nas/NasEndcDcnrIndMessage.h"
#include "modules/nas/Nas5gSignalStrengthIndMessage.h"
#include "modules/nas/NasUpperLayerIndInfoIndMessage.h"
#include "modules/nas/Nas5gConfigInfoIndMessage.h"

#include "interfaces/suppress.h"
#include "interfaces/nas/nas_types.h"
#include "interfaces/RilAcknowledgeRequestMessage.h"
#include "interfaces/nas/RilUnsolNetworkStateChangedMessage.h"
#include "interfaces/nas/RilUnsolNitzTimeReceivedMessage.h"
#include "interfaces/nas/RilUnsolVoiceRadioTechChangedMessage.h"
#include "interfaces/nas/RilUnsolNetworkScanResultMessage.h"
#include "interfaces/nas/RilUnsolSignalStrengthMessage.h"
#include "interfaces/nas/RilUnsolEmergencyCallbackModeMessage.h"
#include "interfaces/nas/RilUnsolRadioCapabilityMessage.h"
#include "interfaces/nas/RilUnsolCdmaPrlChangedMessage.h"
#include "interfaces/nas/RilUnsolRestrictedStateChangedMessage.h"
#include "interfaces/nas/RilUnsolUiccSubsStatusChangedMessage.h"

//UIM Messages
#include "modules/uim/UimGetIccIdRequestSyncMsg.h"
#include "modules/uim/UimGetImsiRequestSyncMsg.h"
#include "modules/uim/UimGetCardStatusRequestSyncMsg.h"

#include "interfaces/dms/dms_types.h"

//DATA Messages
#include "ProcessStackSwitchMessage.h"
#include "UpdateMtuMessage.h"
#include "ToggleLimitedSysIndMessage.h"
#include "ToggleDormancyIndMessage.h"
#include "ProcessScreenStateChangeMessage.h"
#include "SetIsDataEnabledMessage.h"
#include "SetIsDataRoamingEnabledMessage.h"
#include "SetApnInfoMessage.h"
#include "CallStatusMessage.h"
#include "SetLteAttachProfileMessage.h"
#include "GetDdsSubIdMessage.h"
#include "RequestDdsSwitchMessage.h"
#include "RilDataEmbmsActiveMessage.h"
#include "EmbmsEnableDataReqMessage.h"
#include "SetLinkCapFilterMessage.h"

// required for glibc compile
#include <limits.h>

//TODO: need to change
#include "modules/nas/NasDataCache.h"

// NAS broadcast
#include "modules/nas/NasSrvDomainPrefIndMessage.h"
#include "interfaces/ims/QcRilUnsolImsVopsIndication.h"
#include "interfaces/ims/QcRilUnsolImsSsacInfoIndication.h"
#include "interfaces/ims/QcRilUnsolImsExitEcbmIndication.h"
#include "interfaces/ims/QcRilUnsolImsEnterEcbmIndication.h"
#include "modules/device_info/DeviceInteractiveInfoIndMessage.h"
#include "modules/device_info/DevicePowerInfoIndMessage.h"

using qcril::interfaces::RIL_EccNumberSourceMask;
//===========================================================================

//                    INTERNAL DEFINITIONS AND TYPES

//===========================================================================

#define TAG                            "qcril_qmi_nas"

#define NAS_INVALID_VOPS   -1
#define NAS_NITZ_STR_BUF_MAX       (30)
#define NAS_SMALL_STR_BUF_MAX       (16)

#define NAS_RADIO_IF_NONE           0x00 // - None (no service)
#define NAS_RADIO_IF_CDMA2000       0x01 // - cdma2000 1X
#define NAS_RADIO_IF_CDMA2000_HRPD  0x02 // - cdma2000 HRPD (1xEV-DO)
#define NAS_RADIO_IF_AMPS           0x03 // - AMPS
#define NAS_RADIO_IF_GSM            0x04 // - GSM
#define NAS_RADIO_IF_UMTS           0x05 // - UMTS
#define NAS_RADIO_IF_LTE            0x08 // - LTE
#define NAS_RADIO_IF_TDSCDMA        0x09 // - TDSCDMA
#define NAS_RADIO_IF_NR5G           0x0A // - NR5G

#define NAS_UNKNOWN                 (-1)
#define NAS_SIGNAL_STRENGTH_UNK     (-1)
#define NAS_SIGNAL_STRENGTH_UNK_GW  (99)
#define NAS_SIGNAL_STRENGTH_UNK_RSCP  (255)
#define NAS_SIGNAL_STRENGTH_UNK_ECIO  (255)

#define NAS_3GPP2_MCC_MAX_SIZE     (5)

#define NAS_REQ_MASK_SIG_STRENGTH_RSSI          0x0001
#define NAS_REQ_MASK_SIG_STRENGTH_ECIO          0x0002
#define NAS_REQ_MASK_SIG_STRENGTH_IO            0x0004
#define NAS_REQ_MASK_SIG_STRENGTH_SINR          0x0008
#define NAS_REQ_MASK_SIG_STRENGTH_ERROR_RATE    0x0010
#define NAS_REQ_MASK_SIG_STRENGTH_RSRQ          0x0020
#define NAS_REQ_MASK_SIG_STRENGTH_MANDATORY_FLD 0x0040
#define NAS_REQ_MASK_SIG_STRENGTH_VALID_MASK    ( NAS_REQ_MASK_SIG_STRENGTH_RSSI | \
                                                  NAS_REQ_MASK_SIG_STRENGTH_ECIO | \
                                                  NAS_REQ_MASK_SIG_STRENGTH_IO |   \
                                                  NAS_REQ_MASK_SIG_STRENGTH_SINR |  \
                                                  NAS_REQ_MASK_SIG_STRENGTH_ERROR_RATE | \
                                                  NAS_REQ_MASK_SIG_STRENGTH_RSRQ )

#define NAS_CMN_EMERGENCY_MODE_OFF         0x00
#define NAS_CMN_EMERGENCY_MODE_ON          0x01

#define NAS_REQ_REPORT                               (1)
#define NAS_REQ_DO_NOT_REPORT                        (0)



#define NAS_VAL_NOT_REGISTERED                       (0)
#define NAS_VAL_REGISTERED                           (1)
#define NAS_VAL_NOT_REGISTERED_SEARCHING             (2)
#define NAS_VAL_REGISTRATION_DENIED                  (3)
#define NAS_VAL_REGISTRATION_UNKNOWN                 (4)

#define NAS_VAL_RTRE_CARD_ONLY                       (0x01)
#define NAS_VAL_RTRE_NV_ONLY                         (0x02)

#define NAS_VAL_NO_SERVICE                           (0)
#define NAS_VAL_LIMITED_SERVICE                      (1)
#define NAS_VAL_SERVICE_AVAILABLE                    (2)
#define NAS_VAL_LIMITED_REGIONAL_SERVICE             (3)
#define NAS_VAL_POWER_SAVE_OR_DEEP_SLEEP             (4)

#define DMS_VAL_ONLINE                                0x00
#define DMS_VAL_LOW_POWER                             0x01
#define DMS_VAL_FACTORY_TEST_MODE                     0x02
#define DMS_VAL_OFFLINE                               0x03
#define DMS_VAL_RESETTING                             0x04
#define DMS_VAL_SHUTTING_DOWN                         0x05

#define NAS_VAL_ROAMING_ROAMING                       (0)
#define NAS_VAL_ROAMING_HOME                          (1)
#define NAS_VAL_ROAMING_FLASHING                      (2)
#define NAS_VAL_ROAMING_HOME_EX_64                    (64)
#define NAS_VAL_ROAMING_HOME_EX_65                    (65)
#define NAS_VAL_ROAMING_HOME_EX_76                    (76)
#define NAS_VAL_ROAMING_HOME_EX_83                    (83)

#define NAS_CMN_DEFAULT_MODEM                         (0)

#define NAS_VAL_RADIO_TECH_3GPP                       0x02
#define NAS_VAL_RADIO_TECH_3GPP2                      0x01
#define NAS_VAL_RADIO_TECH_UNKNOWN                    0x00

#define NAS_VAL_DATA_TECH_NONE                        0x00

#define NAS_VAL_DATA_ATTACH_UNKNOWN                   (0)
#define NAS_VAL_DATA_ATTACH_ATTACHED                  (1)
#define NAS_VAL_DATA_ATTACH_DETACHED                  (2)

#define NAS_VAL_CS_ATTACH_UNKNOWN                     (0)
#define NAS_VAL_CS_ATTACH_ATTACHED                    (1)
#define NAS_VAL_CS_ATTACH_DETACHED                    (2)

#define NAS_VAL_BAND_PREF_BC0_A                       ( (uint64_t) 1 << 0 )
#define NAS_VAL_BAND_PREF_BC0_B                       ( (uint64_t) 1 << 1 )
#define NAS_VAL_BAND_PREF_BC1                         ( (uint64_t) 1 << 2 )
#define NAS_VAL_BAND_PREF_BC2                         ( (uint64_t) 1 << 3 )
#define NAS_VAL_BAND_PREF_BC3                         ( (uint64_t) 1 << 4 )
#define NAS_VAL_BAND_PREF_BC4                         ( (uint64_t) 1 << 5 )
#define NAS_VAL_BAND_PREF_BC5                         ( (uint64_t) 1 << 6 )
#define NAS_VAL_BAND_PREF_GSM_DCS_1800                ( (uint64_t) 1 << 7 )
#define NAS_VAL_BAND_PREF_GSM_EGSM_900                ( (uint64_t) 1 << 8 )
#define NAS_VAL_BAND_PREF_GSM_PGSM_900                ( (uint64_t) 1 << 9 )
#define NAS_VAL_BAND_PREF_BC6                         ( (uint64_t) 1 << 10 )
#define NAS_VAL_BAND_PREF_BC7                         ( (uint64_t) 1 << 11 )
#define NAS_VAL_BAND_PREF_BC8                         ( (uint64_t) 1 << 12 )
#define NAS_VAL_BAND_PREF_BC9                         ( (uint64_t) 1 << 13 )
#define NAS_VAL_BAND_PREF_BC10                        ( (uint64_t) 1 << 14 )
#define NAS_VAL_BAND_PREF_BC11                        ( (uint64_t) 1 << 15 )
#define NAS_VAL_BAND_PREF_GSM_450                     ( (uint64_t) 1 << 16 )
#define NAS_VAL_BAND_PREF_GSM_480                     ( (uint64_t) 1 << 17 )
#define NAS_VAL_BAND_PREF_GSM_750                     ( (uint64_t) 1 << 18 )
#define NAS_VAL_BAND_PREF_GSM_850                     ( (uint64_t) 1 << 19 )
#define NAS_VAL_BAND_PREF_GSM_RGSM_900                ( (uint64_t) 1 << 20 )
#define NAS_VAL_BAND_PREF_GSM_PCS_1900                ( (uint64_t) 1 << 21 )
#define NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000            ( (uint64_t) 1 << 22 )
#define NAS_VAL_BAND_PREF_WCDMA_II_PCS_1900           ( (uint64_t) 1 << 23 )
#define NAS_VAL_BAND_PREF_WCDMA_III_1700              ( (uint64_t) 1 << 24 )
#define NAS_VAL_BAND_PREF_WCDMA_IV_1700               ( (uint64_t) 1 << 25 )
#define NAS_VAL_BAND_PREF_WCDMA_V_850                 ( (uint64_t) 1 << 26 )
#define NAS_VAL_BAND_PREF_WCDMA_VI_800                ( (uint64_t) 1 << 27 )
#define NAS_VAL_BAND_PREF_BC12                        ( (uint64_t) 1 << 28 )
#define NAS_VAL_BAND_PREF_BC14                        ( (uint64_t) 1 << 29 )
#define NAS_VAL_BAND_PREF_BC15                        ( (uint64_t) 1 << 31 )
#define NAS_VAL_BAND_PREF_WCDMA_VII_2600              ( (uint64_t) 1 << 48 )
#define NAS_VAL_BAND_PREF_WCDMA_VIII_900              ( (uint64_t) 1 << 49 )
#define NAS_VAL_BAND_PREF_WCDMA_IX_1700               ( (uint64_t) 1 << 50 )
#define NAS_VAL_BAND_PREF_BBC16                       ( (uint64_t) 1 << 56 )
#define NAS_VAL_BAND_PREF_BC17                        ( (uint64_t) 1 << 57 )
#define NAS_VAL_BAND_PREF_BC18                        ( (uint64_t) 1 << 58 )
#define NAS_VAL_BAND_PREF_BC19                        ( (uint64_t) 1 << 59 )

#define NAS_VAL_BAND_PREF_COMB_ANY                   (NAS_VAL_BAND_PREF_BC0_A  | \
                                                      NAS_VAL_BAND_PREF_BC0_B  | \
                                                      NAS_VAL_BAND_PREF_BC1    | \
                                                      NAS_VAL_BAND_PREF_BC2    | \
                                                      NAS_VAL_BAND_PREF_BC3    | \
                                                      NAS_VAL_BAND_PREF_BC4    | \
                                                      NAS_VAL_BAND_PREF_BC5    | \
                                                      NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                      NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                      NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                      NAS_VAL_BAND_PREF_BC6    | \
                                                      NAS_VAL_BAND_PREF_BC7    | \
                                                      NAS_VAL_BAND_PREF_BC8    | \
                                                      NAS_VAL_BAND_PREF_BC9    | \
                                                      NAS_VAL_BAND_PREF_BC10   | \
                                                      NAS_VAL_BAND_PREF_BC11   | \
                                                      NAS_VAL_BAND_PREF_GSM_450 | \
                                                      NAS_VAL_BAND_PREF_GSM_480 | \
                                                      NAS_VAL_BAND_PREF_GSM_750 | \
                                                      NAS_VAL_BAND_PREF_GSM_850 | \
                                                      NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                      NAS_VAL_BAND_PREF_GSM_PCS_1900 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_II_PCS_1900 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_III_1700 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_IV_1700 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_V_850 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_VI_800 | \
                                                      NAS_VAL_BAND_PREF_BC12 | \
                                                      NAS_VAL_BAND_PREF_BC14 | \
                                                      NAS_VAL_BAND_PREF_BC15 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_VII_2600 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_VIII_900 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_IX_1700 | \
                                                      NAS_VAL_BAND_PREF_BBC16 | \
                                                      NAS_VAL_BAND_PREF_BC17 | \
                                                      NAS_VAL_BAND_PREF_BC18 | \
                                                      NAS_VAL_BAND_PREF_BC19)

#define NAS_VAL_BAND_PREF_COMB_EURO                   ( NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                        NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                        NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                        NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                        NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 )

#define NAS_VAL_BAND_PREF_COMB_US                      ( NAS_VAL_BAND_PREF_GSM_850 | \
                                                         NAS_VAL_BAND_PREF_GSM_PCS_1900 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_V_850 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_II_PCS_1900 )

#define NAS_VAL_BAND_PREF_COMB_JPN                     ( NAS_VAL_BAND_PREF_WCDMA_VI_800 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 )

#define NAS_VAL_BAND_PREF_COMB_AUS                     ( NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_V_850 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 )

#define NAS_VAL_BAND_PREF_COMB_AUS2                    ( NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_V_850 )

#define NAS_VAL_BAND_PREF_COMB_CELLULAR                 ( NAS_VAL_BAND_PREF_BC0_A | \
                                                          NAS_VAL_BAND_PREF_BC0_B )

#define NAS_VAL_BAND_PREF_COMB_PCS                      ( NAS_VAL_BAND_PREF_BC1 )

#define NAS_VAL_BAND_PREF_COMB_JTACS                    ( NAS_VAL_BAND_PREF_BC3 )

#define NAS_VAL_BAND_PREF_COMB_KOREAN_PCS               ( NAS_VAL_BAND_PREF_BC4 )

#define NAS_VAL_BAND_PREF_COMB_450_MHZ                  ( NAS_VAL_BAND_PREF_BC5 )

#define NAS_VAL_BAND_PREF_COMB_2_GHZ                    ( NAS_VAL_BAND_PREF_BC6 )

#define NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ            ( NAS_VAL_BAND_PREF_BC7 )

#define NAS_VAL_BAND_PREF_COMB_1800_MHZ                 ( NAS_VAL_BAND_PREF_BC8 )

#define NAS_VAL_BAND_PREF_COMB_900_MHZ                  ( NAS_VAL_BAND_PREF_BC9 )

#define NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ              ( NAS_VAL_BAND_PREF_BC10 )

#define NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR           ( NAS_VAL_BAND_PREF_BC11 )

#define NAS_VAL_BAND_PREF_COMB_AWS                      ( NAS_VAL_BAND_PREF_BC15 )

#define NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ               ( NAS_VAL_BAND_PREF_BBC16 )

#define NAS_VAL_SRV_CAPABILITY_NO_SERVICE               0x00
#define NAS_VAL_SRV_CAPABILITY_CS_ONLY                  0x01
#define NAS_VAL_SRV_CAPABILITY_PS_ONLY                  0x02
#define NAS_VAL_SRV_CAPABILITY_CS_AND_PS                0x03
#define NAS_VAL_SRV_CAPABILITY_SYS_FOUND_NOT_YET_REG    0x04
#define RIL_VAL_BAND_ANY        (0)
#define RIL_VAL_BAND_EURO       (1)
#define RIL_VAL_BAND_US         (2)
#define RIL_VAL_BAND_JPN        (3)
#define RIL_VAL_BAND_AUS        (4)
#define RIL_VAL_BAND_AUS2       (5)
#define RIL_VAL_BAND_CELLULAR   (6)
#define RIL_VAL_BAND_PCS        (7)
#define RIL_VAL_BAND_JTACS      (8)
#define RIL_VAL_BAND_KOREAN_PCS (9)
#define RIL_VAL_BAND_450_MHZ    (10)
#define RIL_VAL_BAND_2_GHZ      (11)
#define RIL_VAL_BAND_UPPER_700_MHZ      (12)
#define RIL_VAL_BAND_1800_MHZ   (13)
#define RIL_VAL_BAND_900_MHZ    (14)
#define RIL_VAL_BAND_SEC_800_MHZ   (15)
#define RIL_VAL_BAND_SEC_EUOROPEAN_PAMR   (16)
#define RIL_VAL_BAND_SEC_AWS    (17)
#define RIL_VAL_BAND_SEC_US_2_5_GHZ  (18)

#define NAS_RIL_MAX_BAND_CAPACITY_LIST_SIZE  (32)

#define NAS_VAL_TDD_LTE_BAND_MASK (0xFFFFFFFF00000000)
#define NAS_VAL_FDD_LTE_BAND_MASK (0xFFFFFFFF)


#define NAS_NW_SCAN_RES_ENTRY_PREFERRED              ( (uint8_t) 1 << 6 )
#define NAS_NW_SCAN_RES_ENTRY_NOT_PREFERRED          ( (uint8_t) 1 << 7 )
#define NAS_NW_SCAN_RES_ENTRY_FORBIDDEN              ( (uint8_t) 1 << 4 )
#define NAS_NW_SCAN_RES_ENTRY_NOT_FORBIDDEN          ( (uint8_t) 1 << 5 )
#define NAS_NW_SCAN_RES_ENTRY_HOME                   ( (uint8_t) 1 << 2 )
#define NAS_NW_SCAN_RES_ENTRY_ROAM                   ( (uint8_t) 1 << 3 )
#define NAS_NW_SCAN_RES_ENTRY_CUR_SERVING            ( (uint8_t) 1 << 0 )
#define NAS_NW_SCAN_RES_ENTRY_AVAILABLE              ( (uint8_t) 1 << 1 )


#define NAS_DMS_PRL_VER_RESP_MAX_LEN                (6)
#define QCRIL_QMI_NAS_REGISTRATION_REJECT_CAUSE_ILLEGAL_MS     (3)

#define NAS_VAL_ROAM_PREF_CDMA_AUTOMATIC            (0x00)
#define NAS_VAL_ROAM_PREF_CDMA_HOME_ONLY            (0x01)
#define NAS_VAL_ROAM_PREF_CDMA_ROAM_ONLY            (0x02)
#define NAS_VAL_ROAM_PREF_CDMA_HOME_AND_AFFILIATES  (0x03)


#define RIL_VAL_RADIO_POWER_MODE_LPM                0
#define RIL_VAL_RADIO_POWER_MODE_ONLINE             1

#define QMI_RIL_OP_NAME_NITZ_PLMN                "persist.vendor.radio.nitz_plmn_"
#define QMI_RIL_OP_NAME_NITZ_LONS_0              "persist.vendor.radio.nitz_lons_0_"
#define QMI_RIL_OP_NAME_NITZ_LONS_1              "persist.vendor.radio.nitz_lons_1_"
#define QMI_RIL_OP_NAME_NITZ_LONS_2              "persist.vendor.radio.nitz_lons_2_"
#define QMI_RIL_OP_NAME_NITZ_LONS_3              "persist.vendor.radio.nitz_lons_3_"
#define QMI_RIL_OP_NAME_NITZ_SONS_0              "persist.vendor.radio.nitz_sons_0_"
#define QMI_RIL_OP_NAME_NITZ_SONS_1              "persist.vendor.radio.nitz_sons_1_"
#define QMI_RIL_OP_NAME_NITZ_SONS_2              "persist.vendor.radio.nitz_sons_2_"
#define QMI_RIL_OP_NAME_NITZ_SONS_3              "persist.vendor.radio.nitz_sons_3_"

#define QMI_RIL_TUNE_AWAY                        "persist.vendor.radio.tuneaway_"
#define QMI_RIL_LTE_TUNE_AWAY                    "persist.vendor.radio.lte_tuneaway_"
#define QMI_RIL_PAGING_PRIORITY                  "persist.vendor.radio.paging_priority_"

#define QMI_RIL_SIMO_CS_PS_SVLTE                 "ro.vendor.ril.svlte1x"
#define QMI_RIL_SIMO_CS_PS_SVDO                  "ro.vendor.ril.svdo"
#define QMI_RIL_APM_ON                           "persist.radio.airplane_mode_on"
#define QMI_RIL_FILL_EONS                        "persist.vendor.radio.fill_eons"
#define QMI_RIL_SNAPSHOT_DATA_ENABLED            "persist.vendor.radio.snapshot_data"
#define QMI_RIL_SNAPSHOT_DATA_TIMER_VALUE        "persist.vendor.radio.data_timer"
#define QMI_RIL_SNAPSHOT_FEATURE_ENABLED         "persist.vendor.radio.snapshot_enabled"
#define QMI_RIL_SNAPSHOT_TIMER_VALUE             "persist.vendor.radio.snapshot_timer"
#define QMI_RIL_GET_MODE_PREF_FROM_NV_10         "persist.vendor.radio.mode_pref_nv10"
#define QMI_RIL_LIMIT_SYS_INFO                   "persist.vendor.radio.limit_sys_info"

#define QMI_RIL_TELEPHONY_EONS_SUPPORTED         "persist.vendor.radio.eons.enabled"
#define QMI_RIL_PREFER_SPN_OVER_PLMN_NAME        "persist.vendor.radio.prefer_spn"
#define QMI_RIL_ALWAYS_SEND_PLMN_NAME            "persist.vendor.radio.always_send_plmn"
#define QMI_RIL_PROCESS_DUPLICATE_NW_SCAN_NAMES  "persist.vendor.radio.proc_nw_scan"
#define QMI_RIL_SGLTE_EONS_PREF_DOMAIN_PROPERTY  "persist.vendor.radio.sglte.eons_domain"
#define QMI_RIL_SGLTE_EONS_PREF_ROAMING_PROPERTY "persist.vendor.radio.sglte.eons_roam"
#define QMI_RIL_CONSIDER_LTE_LTD_SRV_VRTE_UPDATE "persist.vendor.radio.lte_vrte_ltd"
#define QMI_RIL_CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE "persist.vendor.radio.3gpp_drte_ltd"
#define QMI_RIL_PROVISION_EMERGENCY_CALL_IN_LPM  "persist.vendor.radio.prov_emer_in_lpm"
#define QMI_RIL_RELAY_OPRT_CHANGE                "persist.vendor.radio.relay_oprt_change"
#define QMI_RIL_REG_DENIED_ON_REJ_CAUSE          "persist.vendor.radio.reg_den_rej_cause"
#define QMI_RIL_1X_ROAM_MTU_SIZE                 "persist.vendor.radio.1x_roam_mtu_size"
#define QMI_RIL_MANUAL_NW_REJECT_COUNTER_ENABLE  "persist.vendor.radio.manual_nw_rej_ct"
#define QMI_RIL_IGNORE_SRV_DOMAIN_CAMPED_TIMER   "persist.vendor.radio.ignore_dom_time"
#define QMI_RIL_SYS_PROP_NAME_SGLTE              "persist.vendor.radio.sglte_target"
#define QMI_RIL_VOICE_SRV_TYPE                   "persist.vendor.radio.cs_srv_type"
#define QMI_RIL_LIMIT_RAC_CHANGE                 "persist.vendor.radio.limit_rac_change"
#define QMI_RIL_POWER_OPT_MODE_PREF              "persist.vendor.radio.pwropt_modepref_"
#define QMI_RIL_SYS_PROP_POWERON_OPT             "persist.vendor.radio.poweron_opt"
#define QMI_RIL_FORCE_NO_SRV_ON_REJ_REJCT_17     "persist.vendor.radio.no_srv_rc_17"
#define QMI_RIL_SHUTDOWN_PROPERTY                "sys.shutdown.requested"
#define QMI_RIL_PLMN_UNICODE_SUPPORT             "persist.vendor.radio.unicode_op_names"
#define QMI_RIL_READ_SYS_LOCALE                  "persist.sys.locale"
#define QMI_RIL_5G_MODE_PREF                     "persist.vendor.radio.5g_mode_pref_"
#define QMI_RIL_5G_MODE_PREF_LEGACY              "persist.vendor.radio.5g_mode_pref"


#define QMI_RIL_MANUAL_NW_REJECT_MAX_COUNT       (4)


#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_ENABLED                         "persist.vendor.radio.custom_ecc"
#define QMI_RIL_CUSTOM_NW_EMERGENCY_NUMBERS_ENABLED                      "persist.vendor.radio.custom_nw_ecc"
#define QMI_RIL_CUSTOM_HARDCODED_EMERGENCY_NUMBERS_LIST_PREFIX           "persist.vendor.radio.ecc_hard_"
#define QMI_RIL_CUSTOM_HARDCODED_EMERGENCY_NUMBERS_LIST_FALLBACK_PREFIX  "vendor.radio.nosim.ecc_list_"

#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_MAX_COUNT                            (20)
#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_COUNT_PROPERTY_SUFFFIX               "count"
#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_PROPERTIES_DELIMITER                 ","
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_START_DELIMITER       '{'
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_END_DELIMITER         '}'
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_INTERNAL_DELIMITER_1  ','
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_INTERNAL_DELIMITER_2  ':'

#define QMI_RIL_USE_STATIC_CC_OP_NAMES                     "persist.vendor.radio.use_cc_names"
#define QMI_RIL_DO_NOT_USE_RIL_3GPP_OPERATOR_TABLE            "persist.vendor.radio.do_not_use_ril_optr_db"

#define QMI_RIL_BAR_FAKE_GCELL                               "persist.vendor.radio.bar_fake_gcell"
#define QMI_RIL_FAKE_GCELL_BAR_TIME_MS                       600000
#define QMI_RIL_GCELL_LOW_FAKING_SCORE                       2
#define QMI_RIL_GCELL_MEDIAL_FAKING_SCORE                    3
#define QMI_RIL_GCELL_HIGH_FAKING_SCORE                      5
#define QMI_RIL_GCELL_FAKING_SCORE_LEVEL                     15
#define QMI_RIL_GCELL_RXLEV_ACCESS_MIN_LOW_FAKING_VALUE      5
#define QMI_RIL_GCELL_RXLEV_ACCESS_MIN_HIGH_FAKING_VALUE     0
#define QMI_RIL_GCELL_RESEL_OFFSET_LOW_FAKING_VALUE          55
#define QMI_RIL_GCELL_RESEL_OFFSET_HIGH_FAKING_VALUE         63
#define QMI_RIL_GCELL_T3212_LOW_FAKING_VALUE                 5
#define QMI_RIL_GCELL_T3212_HIGH_FAKING_VALUE                1
#define QCRIL_BAR_GCELL_INFO_FILE                            "data/vendor/radio/bar_fake_gcell"

#define QMI_RIL_VRTE_LOGIC_CONSIDER_DATA           1
#define QMI_RIL_VRTE_LOGIC_SKIP_MODE_PREF          2

#define RIL_VAL_REG_UNKNOWN                                 4
#define RIL_VAL_REG_REGISTERED_HOME_NET                     1
#define RIL_VAL_REG_NOT_REGISTERED_SEARCHING                2
#define RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING            0
#define RIL_VAL_REG_REGISTRATION_DENIED                     3
#define RIL_VAL_REG_REGISTERED_ROAMING                      5
#define RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV        12
#define RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV             13

#define RIL_VAL_REG_MANAGED_ROAMING_CAUSE                   10

#define QCRIL_QMI_NAS_GET_DEVICE_SERIAL_NUMBERS_SYNC_TIMEOUT   5000
#define QCRIL_QMI_NAS_GET_3GPP2_INFO_SYNC_TIMEOUT       5000
#define QCRIL_QMI_DMS_SET_OPERATING_MODE_SYNC_TIMEOUT   74000

#define NAS_SYS_EGPRS_SUPPORT_NOT_AVAIL             0x00
#define NAS_SYS_EGPRS_SUPPORT_AVAIL                 0x01

#define NAS_SYS_DTM_SUPPORT_NOT_AVAIL               0x00
#define NAS_SYS_DTM_SUPPORT_AVAIL                   0x01

#ifndef QMI_RIL_UTF
#define QCRIL_META_BUILD_VER_INFO "/data/vendor/modem_config/ver_info.txt"
#else
#define QCRIL_META_BUILD_VER_INFO "./ver_info.txt"
#endif

#define QCRIL_ALWAYS_REPORT_RESTRICTED_STATE  "persist.vendor.radio.report_rstate"
#define QCRIL_FORCE_NW_SEARCH                 "persist.vendor.radio.force_nw_search"
#define QCRIL_ADD_POWER_SAVE                  "persist.vendor.radio.add_power_save"
#define QCRIL_APM_SIM_NOT_PWDN                "persist.vendor.radio.apm_sim_not_pwdn"
#define QCRIL_NO_WAIT_FOR_CARD                "persist.vendor.radio.no_wait_for_card"
#define QCRIL_IS_VOIP_ENABLED                 "persist.vendor.radio.is_voip_enabled"
#define QCRIL_VOICE_SUPPORT_ON_LTE            "persist.vendor.radio.voice_on_lte"
#define QCRIL_RECEIVE_DATA_DORMANCY_IND       "persist.vendor.radio.rcv_dormancy_ind"
#define QCRIL_DATA_LTD_SYS_IND                "persist.vendor.radio.data_ltd_sys_ind"
#define QCRIL_USE_SE_TABLE_ONLY               "persist.vendor.radio.use_se_table_only"
#define QCRIL_DFR_MODE_PREF_SET_UNTIL_ONLINE  "persist.vendor.radio.dfr_mode_set"
#define QCRIL_ERI_64_HOME                     "persist.vendor.radio.eri64_as_home"
#define QCRIL_DO_NOT_CONSIDER_MANAGED_ROAM    "persist.vendor.radio.no_cons_man_roam"
#define QCRIL_CSG_INFO_AVAILABLE              "persist.vendor.radio.csg_info_avlbl"
#define QCRIL_APM_MDM_NOT_PWDN                "persist.vendor.radio.apm_mdm_not_pwdn"
#define QCRIL_DEFAULT_NETWORK                 "persist.vendor.radio.default_network"
#define QCRIL_ENABLE_ADVANCED_SCAN             "persist.vendor.radio.enableadvancedscan"

#define QMI_RIL_WAIT_FOR_PBM_IND                 "persist.vendor.radio.wait_for_pbm"
#define QMI_RIL_WAIT_FOR_PBM_IND_TIMER           "persist.vendor.radio.wait_for_pbm_time"
#define QMI_RIL_WAIT_FOR_PBM_IND_TIMER_DEFAULT   (90)

#define QMI_RIL_SIB16_SUPPORT                 "persist.vendor.radio.sib16_support"

#define QMI_RIL_FULL_LTE_BAND_PREF            "persist.vendor.radio.lte_full_band"
//like adb shell setprop persist.vendor.radio.lte_full_band 0x7ff5bdf3fff

#define QCRIL_CELL_INFO_RATE_SWEEP_LIMIT          "persist.vendor.radio.cinfo_sweep_limit"
#define QMI_RIL_WAIT_TIME_FOR_FAKE_ECC           "persist.vendor.radio.wait_time_for_fake_ecc"
#define QMI_RIL_WAIT_TIME_FOR_FAKE_ECC_DEFAULT   (30)

#define QMI_RIL_STACK_STATUS "persist.vendor.radio.stack_"

#define STACK_STATUS_UNKNOWN  (-1)
#define STACK_STATUS_DISABLED 0
#define STACK_STATUS_ENABLED  1

#define QCRIL_IS_RAT_TLV_SUPPORTED            "is_rat_tlv_supported"
#define QCRIL_IS_RIL_VRTE_LEARNING_ENABLED    "is_ril_vrte_learning_enabled"

#define NAS_CELL_LOCATION_VALID(resp_ptr) \
   ((resp_ptr) && ((resp_ptr)->geran_info_valid || \
    (resp_ptr)->umts_info_valid || \
    (resp_ptr)->cdma_info_valid || \
    (resp_ptr)->lte_intra_valid || \
    (resp_ptr)->lte_inter_valid || \
    (resp_ptr)->lte_gsm_valid || \
    (resp_ptr)->lte_wcdma_valid || \
    (resp_ptr)->umts_cell_id_valid || \
    (resp_ptr)->wcdma_lte_valid))

#define QCRIL_MS_TO_TIMEVAL( tvptr, ms ) \
    do { \
        (tvptr)->tv_sec = ms / 1000; \
        (tvptr)->tv_usec = (ms % 1000) * 1000; \
    } while(0);

/* Operator name  System Property */
#define QCRIL_OPERATOR_PROP              "persist.vendor.env.spec"
#define QCRIL_CT_OPERATOR_NAME           "ChinaTelecom"

typedef enum
{
  QMI_RIL_NAS_SUBSCRIPTION_DEACTIVATED = 0,        /* subscription deactivated at modem */
  QMI_RIL_NAS_SUBSCRIPTION_ACTIVATED = 1     /* subscription activated at modem */
}qcril_nas_subscription_status;

#define MCC_MNC_PCS_DIGIT_LEN   (6)
#define MCC_MNC_PCS_DIGIT_POS   (3)

#define NAS_REQUEST_CONCURRENCY_NUM (1)
#define NAS_REQUEST_PENDING_NUM (50)

#define QMI_DMS_IMEISV_MAX_VALUE                                             (99)

#define QMI_DMS_RADIO_POWER_MULTIPLE_RILD_MAX_RETRIES                        (10)
#define QMI_NAS_REJ_CAUSE_PLMN_NOT_ALLOWED                                  (13)
#define QMI_NAS_REJ_CAUSE_NO_SUITABLE_CELL_LA                               (15)

//Permanent Reg Rejection Causes
#define IMSI_UNKNOWN_IN_HLR                             0x02
#define ILLEGAL_MS                                      0x03
#define ILLEGAL_ME                                      0x06
#define GPRS_SERVICES_NOT_ALLOWED                       0x07
#define GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED 0x08
#define PLMN_NOT_ALLOWED                                0x0B
#define LA_NOT_ALLOWED                                  0x0C
#define NATIONAL_ROAMING_NOT_ALLOWED                    0x0D
#define GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN          0x0E
#define NO_SUITABLE_CELLS_IN_LA                         0x0F
#define CSG_NOT_AUTHORIZED                              0x19

/* Network Failure rejection cause */
#define QCRIL_REJECT_CAUSE_NETWORK_FAIL                 (0x11)

typedef enum
{
    QMI_RIL_NAS_NW_SELECT_NONE = 0,
    QMI_RIL_NAS_NW_SELECT_WAKING_UP,
    QMI_RIL_NAS_NW_SELECT_AWAKEN,
    QMI_RIL_NAS_NW_SELECT_SETTING_PREF,
    QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD,
    QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD,
    QMI_RIL_NAS_NW_SELECT_AWAITING_REG,
    QMI_RIL_NAS_NW_SELECT_CANCELLING_REQ,
    QMI_RIL_NAS_NW_SELECT_DONE,
    QMI_RIL_NAS_NW_SELECT_ROLLBACK
} qmi_ril_nas_nw_select_state_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN = 0,
    QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_WAITING,
    QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_DONE,
} qmi_ril_dms_radio_pwr_multiple_rild_radio_power_sync_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_REQUEST_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_REQUEST_BOOTUP_RADIO_POWER_OFF,
    QMI_RIL_DMS_RADIO_PWR_REQUEST_OTHER,
} qmi_ril_dms_radio_pwr_request_e_type;


typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_STATE_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_STATE_INITIALIZED,
    QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_CARD_STATUS,
    QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_CARD_STATUS,
    QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET,
    QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_OP_MODE,
    QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET,
    QMI_RIL_DMS_RADIO_PWR_STATE_DONE,
    QMI_RIL_DMS_RADIO_PWR_STATE_INITIATING_MULTIPLE_RILD_SYNC,
    QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_MULTIPLE_RILD_SYNC,
    QMI_RIL_DMS_RADIO_PWR_STATE_MULTIPLE_RILD_SYNC_DONE,
} qmi_ril_dms_radio_pwr_state_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM,
    QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD,
    QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_WAITING_FOR_DMS_SERVICE,
} qmi_ril_dms_radio_pwr_signal_cond_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_COMMAND_INITIATE = 0,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_TRIGGER_MODEM,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_TRIGGER_CARD,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_TIMEOUT,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_COMPLETE
} qmi_ril_dms_radio_pwr_command_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE,
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NO_ACTION,
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE,
} qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON
} qmi_ril_embms_op_enable_transaction_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_NONE,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_INITIATE,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_CON,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_IND,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_DATA_CON,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT
} qmi_ril_embms_op_enable_transaction_command_e_type;

typedef enum
{
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND
} qmi_ril_embms_op_disable_transaction_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_NONE,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_INITIATE,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_CON,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_HALT
} qmi_ril_embms_op_disable_transaction_command_e_type;

typedef enum
{
    QMI_RIL_EMBMS_IN_COVERAGE = 0,
    QMI_RIL_EMBMS_OUT_OF_COVERAGE,
    QMI_RIL_EMBMS_OUT_OF_COVERAGE_DUE_TO_UEMODE,
    QMI_RIL_EMBMS_OUT_OF_COVERAGE_E911,
} qmi_ril_embms_coverage_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_RESP_CODE_MIN = -1,
    QMI_RIL_EMBMS_SUCCESS = 0,
    QMI_RIL_EMBMS_ERROR_UNKNOWN = 1,
    QMI_RIL_EMBMS_RESP_CODE_MAX
} qmi_ril_embms_resp_code_e_type;

#define QMI_RIL_EMBMS_LOG_PACKET_ID_MIN (0x1757)
#define QMI_RIL_EMBMS_LOG_PACKET_ID_MAX (0x17D7)
#define QMI_RIL_EMBMS_MIN_SIB_MCC_MNC_PARSE_LEN 6 // byte stream like: mcc[0] = '0', we parse from 0] = '0'. This is at least 6 chars

#define QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION  ( QMI_RIL_RTE_WCDMA )

typedef enum
{
    QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE = 0,
    QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING
} qmi_ril_nas_restricted_details_state_e_type;

typedef enum
{
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_NONE = 0,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_RESET,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_REPOST,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHANGE_REPOST
} qmi_ril_nas_restricted_details_event_e_type;

typedef enum
{
    QMI_RIL_NAS_DO_NOT_PREFER_SPN = 0,
    QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_NAME_ONLY,
    QMI_RIL_NAS_PREFER_SPN_FOR_NW_SCAN_ONLY,
    QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_AND_NW_SCAN,
    QMI_RIL_NAS_PREFER_MAX_VALUE
} qmi_ril_nas_spn_plmn_name_preference_e_type;


/* Index to MCC that is used for finding emergency number */
typedef enum {
    QCRIL_IMSI_MCC_MATCH_INDEX = 0,
    QCRIL_NW_MCC_MATCH_INDEX,
    QCRIL_CARD_MCC_MATCH_INDEX,
    QCRIL_MCC_MATCH_MAX
} qcril_mcc_match_index;

/* Index to MNC that is used for finding emergency number */
typedef enum {
    QCRIL_NW_MNC_MATCH_INDEX = 0,
    QCRIL_CARD_MNC_MATCH_INDEX,
    QCRIL_MNC_MATCH_MAX
} qcril_mnc_match_index;


//radio power process handling
#define RADIO_POWER_LOCK() do { \
        QCRIL_LOG_ADDITIONAL("LOCK RADIO_POWER_LOCK"); \
        nas_common_info.radio_pwr_mutex.lock(); \
    } while(0)

#define RADIO_POWER_UNLOCK() do { \
        QCRIL_LOG_ADDITIONAL("UNLOCK RADIO_POWER_LOCK"); \
        nas_common_info.radio_pwr_mutex.unlock(); \
    }while(0)

#define RADIO_POWER_WAIT()      qcril_qmi_nas_radio_power_process_condition_wait_helper()
#define RADIO_POWER_SIGNAL()    nas_common_info.radio_pwr_cond_var.notify_one();

#define NAS_NW_SEL_LOCK() do { \
        QCRIL_LOG_ADDITIONAL("LOCK NAS_NW_SEL_LOCK"); \
        nas_common_info.nw_sel_lock_mutex.lock(); \
    }while(0)

#define NAS_NW_SEL_UNLOCK() do { \
        QCRIL_LOG_ADDITIONAL("UNLOCK NAS_NW_SEL_LOCK"); \
        nas_common_info.nw_sel_lock_mutex.unlock(); \
    }while(0)



// cache handling
#define NAS_CACHE_LOCK() do { \
        QCRIL_LOG_ADDITIONAL("LOCK NAS_CACHE_LOCK"); \
        nas_common_info.cache_lock_mutex.lock(); \
    }while(0)

#define NAS_CACHE_UNLOCK() do { \
        QCRIL_LOG_ADDITIONAL("UNLOCK NAS_CACHE_LOCK"); \
        nas_common_info.cache_lock_mutex.unlock(); \
    }while(0)

#define NAS_CACHE_STORE_ENTRY_ARR( placeholder, value )   {   if (value ## _valid) { \
                                                                                         if ( placeholder ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE;  }   \
                                                                                         placeholder = (decltype(placeholder)) qcril_malloc( sizeof( * placeholder ) ); \
                                                                                         if ( placeholder ) { memcpy(placeholder, value, sizeof(* placeholder) );  placeholder ## _len = value ## _len; placeholder ## _valid = TRUE; } \
                                                                                   } \
                                                           }

#define NAS_CACHE_STORE_ENTRY_FIXED_LEN_ARR( placeholder, value )   {   if (value ## _valid) { \
                                                                                         memcpy(placeholder, value, sizeof(placeholder));  placeholder ## _len = value ## _len; placeholder ## _valid = TRUE;\
                                                                                   } \
                                                           }

#define NAS_CACHE_STORE_ENTRY( placeholder, value ) {   if (value ## _valid) { \
                                                                                         if ( placeholder ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE;  }   \
                                                                                         placeholder = (decltype(placeholder)) qcril_malloc( sizeof( * placeholder ) ); \
                                                                                         if ( placeholder ) { memcpy(placeholder, & value, sizeof(* placeholder) ); placeholder ## _valid = TRUE; } \
                                                                             } \
                                                    }
#define NAS_CACHE_STORE_ENTRY_VALID_VAL( placeholder, value ) {   \
                                                                                         if ( placeholder ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE;  }   \
                                                                                         placeholder = (decltype(placeholder)) qcril_malloc( sizeof( * placeholder ) ); \
                                                                                         if ( placeholder ) { memcpy(placeholder, & value, sizeof(* placeholder) ); placeholder ## _valid = TRUE;  } \
                                                              }


#define NAS_CACHE_IS_ENTRY_VALID( placeholder )                                          (placeholder ## _valid)
#define NAS_CACHE_IS_ENTRY_VALID_ARR( placeholder )                                          ( (placeholder ## _valid) && (NULL != placeholder) )

#define NAS_CACHE_INVALIDATE_ENTRY( placeholder )         { if ((placeholder ## _valid) && ( NULL != placeholder ) ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE; } }
#define NAS_CACHE_INVALIDATE_ENTRY_ARR( placeholder )         { if ((placeholder ## _valid) && ( NULL != placeholder ) ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE; } }
#define NAS_CACHE_INVALIDATE_ENTRY_FIXED_LEN_ARR( placeholder ) { memset(placeholder, 0, sizeof(placeholder));  placeholder ## _len = 0; placeholder ## _valid = FALSE; }

#define NAS_CACHE_STORE_TINY_ENTRY( placeholder, value ) {   if (value ## _valid) { \
                                                                                          placeholder = value; placeholder ## _valid = TRUE;  \
                                                                             } \
                                                         }

#define NAS_CACHE_STORE_TINY_ENTRY_VAL( placeholder, value ) {  placeholder = value; placeholder ## _valid = TRUE;  }

#define NAS_CACHE_INVALIDATE_TINY_ENTRY( placeholder )         { if ( placeholder ## _valid  ) { placeholder ## _valid = FALSE; } }

// cache handling
#define NAS_SIB_CACHE_LOCK() do { \
        QCRIL_LOG_ADDITIONAL("LOCK NAS_SIB_CACHE_LOCK"); \
        nas_common_info.sib_cache_lock_mutex.lock(); \
    }while(0)

#define NAS_SIB_CACHE_UNLOCK() do { \
        QCRIL_LOG_ADDITIONAL("UNLOCK NAS_SIB_CACHE_LOCK"); \
        nas_common_info.sib_cache_lock_mutex.unlock(); \
    }while(0)

// cache handling
#define NAS_EMBMS_CACHE_LOCK() do { \
        QCRIL_LOG_ADDITIONAL("LOCK NAS_EMBMS_CACHE_LOCK"); \
        nas_common_info.embms_cache_lock_mutex.lock(); \
    }while(0)

#define NAS_EMBMS_CACHE_UNLOCK() do { \
        QCRIL_LOG_ADDITIONAL("UNLOCK NAS_EMBMS_CACHE_LOCK"); \
        nas_common_info.embms_cache_lock_mutex.unlock(); \
    }while(0)

typedef struct
{
    int                                cs_rejected;
    int                                ps_rejected;

    uint8_t                            cs_reject_cause;
    uint8_t                            ps_reject_cause;
    int                                cs_reject_cause_relayed;
    int                                ps_reject_cause_relayed;
    int                                cs_reject_cause_expired;
    int                                ps_reject_cause_expired;

    char                               org_mcc [NAS_MCC_MNC_MAX_V01];
    char                               org_mnc [NAS_MCC_MNC_MAX_V01];

    char                               data_org_mcc [NAS_MCC_MNC_MAX_V01];
    char                               data_org_mnc [NAS_MCC_MNC_MAX_V01];

    int                                cs_rejected_managed_roaming;

    int                                cs_rejected_assumed;

} qmi_ril_reg_reject_cached_summary_type;

typedef struct
{
    uint8_t rat;
    uint8_t rac;
} qmi_ril_rat_rac_info;

typedef enum
{
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_EXPIRED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED
} qmi_ril_reg_reject_perception_event_e_type;

typedef struct
{
  qmi_ril_nw_reg_rte_kind_type rte_kind;
  qmi_ril_nw_reg_rte_type      rte;
} qmi_ril_reg_reject_tmr_expry_passover_type;

typedef struct
{
  int      valid;
  uint32_t registration_state;
  int      lac_valid;
  uint32_t lac;
  int      cid_valid;
  uint32_t cid;
  uint32_t data_radio_tech;
  uint32_t tac;
  int      tac_valid;
} qmi_ril_nw_reg_data_reg_snapshot_info_type;

typedef struct
{
  int32_t dbg_trace_id;

  /*  SIB Length */
  uint16_t current_size; /**< Current length (in bytes) of the interrogated serving cell SIB. */

  /*  SIB Sequence */
  uint8_t sequence; /**< Expected equence number for next QMI IND. */

  /*  SIB Buffer */
  qcril_binary_data_type bin_data;
} nas_srv_cell_sib_info_type;

struct nas_cached_info_type
{
  uint8_t nitz_information_valid;
  nas_plmn_network_name_type_v01 * nitz_information;

  uint8_t plmn_id_valid;
  nas_plmn_id_ext_type_v01 * plmn_id;

  uint8_t spn_valid;
  nas_spn_type_v01 * spn;

  uint8_t short_name_valid;
  nas_plmn_name_type_v01 * short_name;

  uint8_t long_name_valid;
  nas_plmn_name_type_v01 * long_name;

  // ** from nas_system_selection_preference_ind_msg_v01
  uint8_t emergency_mode_valid;
  uint8_t emergency_mode;

  uint8_t mode_pref_valid;
  uint16_t mode_pref;

  uint8_t acq_order_valid;
  uint32_t acq_order_len;
  struct { nas_radio_if_enum_v01 arr[NAS_ACQ_ORDER_LIST_MAX_V01]; } *acq_order;

  uint8_t prev_mode_pref_valid;
  uint16_t prev_mode_pref;

  uint8_t gw_acq_order_pref_valid;
  uint16_t gw_acq_order_pref;

  uint8_t band_pref_valid;
  uint64_t band_pref;

  uint8_t prl_pref_valid;
  uint16_t prl_pref;

  uint8_t roam_pref_valid;
  uint16_t roam_pref;

  uint8_t lte_band_pref_valid;
  uint64_t lte_band_pref;

  uint8_t deferred_lte_band_pref_valid;
  uint64_t deferred_lte_band_pref;
  qcril_qmi_band_pref_e_type deferred_lte_band_pref_map;

  uint8_t net_sel_pref_valid;
  uint8_t net_sel_pref;


  uint8_t srv_domain_pref_valid;
  uint8_t srv_domain_pref;

  uint8_t lte_disable_cause_valid;
  nas_lte_disable_cause_enum_type_v01 lte_disable_cause;

  uint8_t rat_disabled_mask_valid;
  mode_pref_mask_type_v01 rat_disabled_mask;

  uint8_t voice_domain_pref_valid;
  nas_voice_domain_pref_enum_type_v01 voice_domain_pref;

  uint8_t roaming_indicator_valid;
  uint8_t roaming_indicator;

  uint8_t current_plmn_valid;
  nas_plmn_type_v01 * current_plmn;

  uint8_t cdma_sys_id_valid;
  nas_cdma_system_id_type_v01 cdma_sys_id;

  uint8_t roam_status_valid;
  nas_roam_status_enum_type_v01 roam_status;
  uint8_t voice_roam_status_reported;

  uint8_t is_sys_prl_match_valid;
  uint8_t is_sys_prl_match;

  uint8_t def_roam_ind_valid;
  uint8_t def_roam_ind;

  uint8_t p_rev_in_use_valid;
  uint8_t p_rev_in_use;

  uint8_t tac_valid;
  uint16_t tac;

  uint8_t call_barring_status_valid;
  nas_gw_sys_info3_type_v01 * call_barring_status;

  uint8_t umts_psc_valid;
  uint16_t umts_psc;

  uint8_t mnc_includes_pcs_digit_valid;
  nas_mnc_pcs_digit_include_status_type_v01 * mnc_includes_pcs_digit;

  uint8_t hs_call_status_valid;
  nas_hs_support_enum_type_v01 hs_call_status;


  // ** from nas_event_report_ind_msg_v01
  uint8_t rf_band_info_list_valid;
  uint32_t rf_band_info_list_len;
  struct { nas_rf_band_info_type_v01 arr[NAS_RADIO_IF_LIST_MAX_V01]; } * rf_band_info_list;

  uint8_t registration_reject_reason_valid;
  nas_registration_reject_reason_type_v01 * registration_reject_reason;

  uint8_t rssi_valid;
  uint32_t rssi_len;
  struct { nas_rssi_type_v01 arr[NAS_RSSI_LIST_MAX_V01]; } * rssi;

  uint8_t ecio_valid;
  uint32_t ecio_len;
  struct { nas_ecio_type_v01 arr[NAS_ECIO_LIST_MAX_V01]; } * ecio;

  uint8_t io_valid;
  int32_t io;

  uint8_t sinr_valid;
  uint8_t sinr;

  uint8_t error_rate_valid;
  uint32_t error_rate_len;
  struct { nas_error_rate_type_v01 arr[NAS_ERROR_RATE_LIST_MAX_V01]; } * error_rate;

  uint8_t rsrq_valid;
  nas_rsrq_type_v01 * rsrq;

  uint8_t lac_valid;
  uint16_t lac;

  uint8_t cell_id_valid;
  uint32_t cell_id;

  uint8_t ccs_valid;
  uint8_t ccs;

  uint8_t prl_ind_valid;
  uint8_t prl_ind;

  uint8_t hdr_personality_valid;
  nas_hdr_personality_enum_v01 hdr_personality;

  uint8_t dsds_standby_pref_valid;
  nas_standby_pref_type_v01 dsds_standby_pref;

  uint8_t dsds_is_priority_subs_valid;
  nas_is_priority_subs_enum_v01 dsds_is_priority_subs;

  uint8_t dsds_is_active_valid;
  nas_active_subs_info_enum_v01 dsds_is_active;

  uint8_t is_default_data_subs_valid;
  uint8_t is_default_data_subs;

  uint8_t dds_type_valid;
  nas_dds_type_enum_v01 dds_type;

  uint8_t voice_system_id_valid;
  uint32 voice_system_id;

  uint8_t cdma_srv_status_info_valid;
  nas_3gpp2_srv_status_info_type_v01 * cdma_srv_status_info;

  uint8_t hdr_srv_status_info_valid;
  nas_3gpp2_srv_status_info_type_v01 * hdr_srv_status_info;

  uint8_t gsm_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * gsm_srv_status_info;

  uint8_t wcdma_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * wcdma_srv_status_info;

  uint8_t tdscdma_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * tdscdma_srv_status_info;

  uint8_t lte_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * lte_srv_status_info;

  uint8_t cdma_sys_info_valid;
  nas_cdma_sys_info_type_v01 * cdma_sys_info;

  uint8_t hdr_sys_info_valid;
  nas_hdr_sys_info_type_v01 * hdr_sys_info;

  uint8_t gsm_sys_info_valid;
  nas_gsm_sys_info_type_v01 * gsm_sys_info;

  uint8_t wcdma_sys_info_valid;
  nas_wcdma_sys_info_type_v01 * wcdma_sys_info;

  uint8_t tdscdma_sys_info_valid;
  nas_tdscdma_sys_info_type_v01 * tdscdma_sys_info;

  uint8_t lte_sys_info_valid;
  nas_lte_sys_info_type_v01 * lte_sys_info;

  uint8_t cdma_sys_info2_valid;
  nas_cdma_sys_info2_type_v01 * cdma_sys_info2;

  uint8_t hdr_sys_info2_valid;
  nas_hdr_sys_info2_type_v01 * hdr_sys_info2;

  uint8_t gsm_sys_info2_valid;
  nas_gsm_sys_info2_type_v01 * gsm_sys_info2;

  uint8_t wcdma_sys_info2_valid;
  nas_wcdma_sys_info2_type_v01 * wcdma_sys_info2;

  uint8_t lte_sys_info2_valid;
  nas_lte_sys_info2_type_v01 * lte_sys_info2;

  uint8_t gsm_sys_info3_valid;
  nas_gw_sys_info3_type_v01 * gsm_sys_info3;

  uint8_t wcdma_sys_info3_valid;
  nas_gw_sys_info3_type_v01 * wcdma_sys_info3;

  uint8_t lte_cell_status_valid;
  nas_cell_access_status_e_type_v01 lte_cell_status;

  uint8_t voice_support_on_lte_valid;
  uint8_t voice_support_on_lte;

  uint8_t lte_is_eb_supported_valid;
  nas_tri_state_boolean_type_v01 lte_is_eb_supported;

  uint8_t emergency_access_barred_valid;
  nas_tri_state_boolean_type_v01 emergency_access_barred;

  uint8_t cdma_sig_info_valid;
  nas_common_sig_info_param_type_v01 *cdma_sig_info;

  uint8_t hdr_sig_info_valid;
  nas_hdr_sig_info_type_v01 *hdr_sig_info;

  uint8_t gsm_sig_info_valid;
  int8_t gsm_sig_info;

  uint8_t wcdma_sig_info_valid;
  nas_common_sig_info_param_type_v01 *wcdma_sig_info;

  /*Belongs to WCDMA RSCP*/
  uint8_t wcdma_rscp_valid;
  int16_t wcdma_rscp;

  /*Belongs to TDSCDMA*/
  uint8_t rscp_valid;
  int8_t rscp;

  uint8_t lte_sig_info_valid;
  nas_lte_sig_info_type_v01 *lte_sig_info;

  uint8_t gsm_bit_err_rate_valid;
  uint8_t gsm_bit_err_rate;

  uint8_t wcdma_block_err_rate_valid;
  uint8_t wcdma_block_err_rate;

  uint8_t tdscdma_block_err_rate_valid;
  uint8_t tdscdma_block_err_rate;

  uint8_t lte_sib16_acquired_valid;
  uint8_t lte_sib16_acquired;
  uint8_t sntp_available_valid;
  uint8_t sntp_available;
  uint8_t day_light_saving_valid;
  uint8_t day_light_saving;
  uint8_t leap_seconds_valid;
  int8_t  leap_seconds;
  uint8_t local_time_offset_valid;
  int8_t  local_time_offset;

  char  * persistent_cached_nitz_op_name_long;
  char  * persistent_cached_nitz_op_name_short;
  char persistent_cached_mobile_country_code[NAS_MCC_MNC_MAX_SIZE];
  char persistent_cached_mobile_network_code[NAS_MCC_MNC_MAX_SIZE];

  qmi_ril_emergency_callback_mode_state_type eme_cbm;

  // handle sending unsol ecbm
  boolean nas_enter_ecbm_propagation_pending;
  boolean eme_call_end_recently;
  boolean is_eme_ip_call;
  uint32  eme_call_end_recently_tcb_id;

  // only applicable when sys_info supported
  qmi_ril_nw_reg_rte_type voice_rte;
  qmi_ril_nw_reg_rte_type data_rte;
  qmi_ril_nw_reg_rte_type ims_rte;

  // nw select tracking
  qmi_ril_nas_nw_select_state_e_type nw_select_state;
  qmi_client_type                    nw_select_nas_client;
  uint32                             nw_select_timeout_watch;
  uint32                             nw_select_limited_timeout_watch;
  int                                nw_select_nw_reg_received;
  RIL_Errno                          nw_select_nw_reg_result;
  int                                nw_select_nw_set_pref_ackd;
  RIL_Errno                          nw_select_nw_set_pref_result;
  int nw_select_is_manual;
  char nw_select_manual_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char nw_select_manual_mnc_str[NAS_MCC_MNC_MAX_SIZE];
  int nw_select_is_current;
  int nw_select_is_modem_sel_pref_auto;
  nas_radio_if_enum_v01 nw_select_manual_rat;

  // nas attach request state
  qmi_ril_nas_attch_state_e_type          attch_state;
  uint32                                  attch_timeout_watch;
  uint32                                  dds_timeout_watch;
  uint32                                  active_subs_timeout_watch;

  // reg reject tracking
  qmi_ril_reg_reject_cached_summary_type reg_reject_sys_info [QMI_RIL_RTE_CAP];
  qmi_ril_reg_reject_cached_summary_type reg_reject_legacy;
  uint32                                 reg_reject_expiry_tmr_id[ QMI_RIL_RTE_KIND_CAP ];
  uint8_t managed_roaming_radio_if_valid;
  nas_radio_if_enum_v01 managed_roaming_radio_if;



  // PRL version change relaying support
  uint16_t                           prl_version;
  int                                prl_version_is_set;

  // IMS registration
  int                                is_registered_on_ims;

  // eMBMS
  uint8_t                            embms_enabled;
  uint8_t                            embms_ssr_in_progress;
  uint8_t                            embms_enable_success_sent_to_atel;
  uint8_t                            embms_cell_id_sent_after_enabled;
  uint8_t                            embms_coverage_sent_after_enabled;

  qmi_ril_embms_op_enable_transaction_state_e_type
                                     embms_enable_txn_state;
  qmi_ril_embms_op_disable_transaction_state_e_type
                                     embms_disable_txn_state;
  uint32                             embms_enable_timeout_timerid;
  uint32                             embms_disable_timeout_timerid;
  uint8_t                            embms_disable_resp_call_id;

  uint8_t                            lte_embms_coverage_valid;
  uint8_t                            lte_embms_coverage;

  uint8_t                            embms_coverage_status_valid;
  nas_lte_rrc_embms_coverage_status_enum_v01
                                     embms_coverage_status;

  int32_t                            embms_enable_dbg_trace_id;
  int32_t                            embms_disable_dbg_trace_id;

  uint8_t                            embms_data_con_payload_valid;
  qcril_embms_enable_response_payload_type*
                                     embms_data_con_payload;

  uint8_t                            is_embms_available;

  uint8_t sim_rej_info_valid;
  nas_sim_rej_info_enum_type_v01 sim_rej_info;

  //voice radio tech reported to Telephony
  RIL_RadioTechnology          reported_voice_radio_tech;

  // is considered registared cache
  int                                is_considered_registered_cached_result_valid;
  int                                is_considered_registered_cached_result;

  /* cache is valid when is_considered_registered_cached_result_valid is valid */
  qmi_ril_nw_reg_rte_type            registered_cached_rtes[QMI_RIL_RTE_LAST];

  // is in service on technology cache
  int                                is_in_service_of_technology_cache_result_valid;
  int                                is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 + NAS_SELECTED_NETWORK_3GPP_V01 ];

  // data reg report snapshot (applicable for in service only)
  qmi_ril_nw_reg_data_reg_snapshot_info_type
                                     data_reg_report_snapshot;
  uint32                             data_reg_report_expiry;
  uint32                             extrapolation_ban_expiry;

  qmi_ril_nw_reg_rat_confidence_tag_type
                                     voice_rte_confidence_tag;
  qmi_ril_nw_reg_rat_confidence_tag_type
                                     data_rte_confidence_tag;
  qmi_ril_nw_reg_rat_confidence_tag_type
                                     ims_rte_confidence_tag;

  qmi_ril_nas_restricted_details_state_e_type
                                     restricted_details_state;
  int                                cached_restricted_details;

  //Simultaneous Voice and Data Capability
  uint8_t simul_voice_and_data_capability_valid;
  dms_simul_voice_and_data_capability_mask_v01 simul_voice_and_data_capability;

  //Device feature mode
  uint8_t subs_device_feature_mode_valid;
  dms_device_subs_feature_mode_enum_v01 subs_device_feature_mode;

  //Modem max subscriptions
  uint8_t  modem_max_subscriptions;

  //last considered Telephony data technology as part of VOICE_REGISTRATION_STATE handling
  uint8_t                            considered_data_technology_valid;
  int                                considered_data_technology;

  //last reported Telephony data technology through DATA_REGISTRATION_STATE
  uint8_t                            reported_data_technology_valid;
  int                                reported_data_technology;

  //last reported Telephony data registration status through DATA_REGISTRATION_STATE
  uint8_t                            reported_data_reg_status_valid;
  int                                reported_data_reg_status;

  //last reported Telephony pref data technology for DATA_REGISTRATION_STATE
  uint8_t                            reported_pref_data_technology_valid;
  qcril_arb_pref_data_tech_e_type    reported_pref_data_technology;

  // deferred mode pref
  int                                deferred_mode_pref_set_valid;
  int                                deferred_mode_pref_set_android_param;

  // deferred acq order
  uint8_t                            deferred_acq_order_valid;
  uint32_t                           deferred_acq_order_len;
  nas_radio_if_enum_v01              deferred_acq_order[NAS_ACQ_ORDER_LIST_MAX_V01];
  qcril_qmi_acq_order_e_type         deferred_acq_order_map;

  int                                data_reg_roaming_status_latest;
  int                                data_reg_roaming_status_latest_val;
  uint32                             data_reg_roaming_status_latest_expiry;

  // common ind subscription status
  int                                common_indications_is_subscribed;

  // emergency number added for designated country
  uint32         designated_number_added_for_designated_country_status;
  char           designated_number_mcc [QCRIL_MCC_MATCH_MAX][ NAS_MCC_MNC_MAX_V01 + 1 ];
  char           designated_number_mnc [QCRIL_MNC_MATCH_MAX][ NAS_MCC_MNC_MAX_V01 + 1 ];
  char           mcc_from_imsi_cache [ NAS_MCC_MNC_MAX_V01 + 1 ];
  char           mcc_from_device_reg [ NAS_MCC_MNC_MAX_V01 + 1];

  qcril::interfaces::RIL_EccMapType ril_ecc_map;

  qmi_ril_nw_reg_rte_type sglte_current_eons_rte;

  RIL_CELL_INFO_LIST_TYPE *cell_info_list;
  unsigned          cell_info_list_cells;
  uint64_t cell_location_info_time;

  uint8_t prev_reported_csg_id_valid;
  uint32_t prev_reported_csg_id;

  uint8_t wcdma_csg_info_valid;
  nas_csg_info_type_v01 *wcdma_csg_info;

  uint8_t lte_csg_info_valid;
  nas_csg_info_type_v01 *lte_csg_info;

  /*  LTE Voice Domain */
  uint8_t lte_voice_status_valid;
  nas_lte_voice_status_enum_type_v01 lte_voice_status;

  /*  LTE SMS Domain */
  uint8_t lte_sms_status_valid;
  nas_sms_status_enum_type_v01 lte_sms_status;

  uint32_t sys_sel_pref_tmr;
  uint8_t is_indication_received;

  /* track if voice radio tech is calculated atleast once */
  uint8_t is_calculated_vrte_used;

  /* LTE band priority*/
  uint8_t band_priority_list_valid;
  uint32_t band_priority_list_len;
  nas_active_band_enum_v01 band_priority_list[NAS_LTE_BAND_PRIORITY_LIST_MAX_V01];

  /*  GSM RAC */
  uint8_t gsm_rac_valid;  /**< Must be set to true if gsm_rac is being passed */
  uint8_t gsm_rac;

  /*  WCDMA RAC */
  uint8_t wcdma_rac_valid;  /**< Must be set to true if wcdma_rac is being passed */
  uint8_t wcdma_rac;

  /* GW RAT RAT*/
  uint8_t prev_reported_rat_rac_valid;
  qmi_ril_rat_rac_info prev_reported_rat_rac;

  /* Bootup Power Optimization State*/
  uint8_t bootup_power_optimization_state;

  /* ATEL UI Status */
  uint8_t atel_ui_status_valid;
  uint8_t atel_ui_status;

  /*ATEL READY request came status*/
  uint8_t is_atel_ready_request;

  /* in APM leave window */
  uint8_t is_in_apm_leave_window;
  uint32_t apm_timer_id;

  /*Cached CCS status*/
  int ccs_status;

  /*Blocked status*/
  uint8_t is_blocked_valid;
  uint8_t is_blocked;

  /* flag for advanced network scan */
  int is_adv_nw_scan;

  /*snapshot reported data reg state*/
  RIL_DataRegistrationStateResponse reported_data_reg_state_snapshot;

  /*snapshot reported data reg state*/
  uint8_t is_proper_data_reg_to_report;
  uint32 reported_data_reg_expiry;

  /* flag for voice over PS*/
  uint8_t lte_ims_voice_avail_valid;
  uint8_t lte_ims_voice_avail;
  uint8_t old_lte_ims_voice_avail;

  /************************** 5G **************************/
  uint8_t nr5g_sig_info_valid;
  nas_nr5g_sig_info_type_v01 *nr5g_sig_info;

  /* 5G Signal Strength Info */
  uint8_t nr5g_rsrq_valid;
  int16_t nr5g_rsrq;

  uint8_t endc_available_valid;
  uint8_t endc_available;

  uint8_t restrict_dcnr_valid;
  uint8_t restrict_dcnr;

  uint8_t plmn_infolist_r15_available_valid;
  uint8_t plmn_infolist_r15_available;

  uint8_t nr5g_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 *nr5g_srv_status_info;

  uint8_t nr5g_sys_info_valid;
  nas_nr5g_sys_info_type_v01 *nr5g_sys_info;

  uint8_t nr5g_cell_status_valid;
  nas_cell_access_status_e_type_v01 nr5g_cell_status;

  uint8_t nr5g_tac_info_valid;
  nas_nr5g_tac_info_type_v01 *nr5g_tac_info;

  uint8_t tracking_area_is_restricted_valid;
  uint8_t tracking_area_is_restricted;

  uint8_t n1_sms_is_registered_valid;
  uint8_t n1_sms_is_registered;

  uint8_t nr5g_sms_domain_valid;
  nas_sms_status_enum_type_v01 nr5g_sms_domain;

  uint8_t voice_support_on_nr5g_valid;
  uint8_t voice_support_on_nr5g;

  uint8_t nr5g_voice_domain_valid;
  nas_nr5g_voice_domain_enum_type_v01 nr5g_voice_domain;
  /************************** 5G **************************/

  qmi_ril_nas_modem_shutdown_states_e_type modem_shutdown_state;
  uint32 modem_shutdown_ims_shutdown_timer;
};

#ifndef QMI_RIL_UTF
typedef struct
{
  log_hdr_type hdr;
  int8_t log_payload[LOG_PACKET_SIZE_MAX_V01];
} qcril_qmi_nas_embms_log_type;
#endif

#define  QMI_RIL_NWREG_INVALID_TUPLE_ID                                                                 (-1)

#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NONE                                                 ((uint32)0)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_FETCHED                                      ((uint32)1 << 5)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH                                        ((uint32)1 << 6)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH                                  ((uint32)1 << 7)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED             ((uint32)1 << 8)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED                   ((uint32)1 << 9)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED                                         ((uint32)1 << 10)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH                                       ((uint32)1 << 11)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH                                     ((uint32)1 << 12)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED                             ((uint32)1 << 13)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED                                       ((uint32)1 << 14)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH                                         ((uint32)1 << 15)


#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH_IDX_MASK                              ((uint32)0x00FF)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK                                ((uint32)0xFF000000)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK_NUM_SHIFT                      (24)

struct nas_dms_cached_info_type
{
    // ** from dms_event_report_ind_msg_v01
    uint8_t operating_mode_valid;
    dms_operating_mode_enum_v01 operating_mode;

    uint8_t band_capability_valid;
    uint64_t band_capability;

    int card_shutdown_initiated;

    uint8_t max_subscriptions;
    uint8_t max_subscriptions_active;

    uint8_t current_sub_capability_valid;
    uint32_t current_sub_capability;

    uint8_t subs_voice_data_capability_valid;
    uint8_t subs_voice_data_capability;

    uint8_t max_active_data_subs_valid;
    uint8_t max_active_data_subs;

    uint8_t both_sub_support_all_rat_cap_valid;
    uint8_t both_sub_support_all_rat_cap;
};

struct nas_evt_post_info_type
{
  void * ril_evt_payload;
  int    ril_evt_payload_len;
  int    ril_evt;
  int    engaged;
};

#define MAX_NOF_NAS_EVT_POST_REC       (4)

#define NAS_REG_STATE_RESP_MAX_ARR_SIZE (15)

typedef struct
{
  char *registration_info_array[ NAS_REG_STATE_RESP_MAX_ARR_SIZE ];
  char registration_state[ 3 ];
  char lac[ 7 ];
  char cid[ 11 ];
  char radio_tech[ 3 ];
  char base_id[ 6 ];
  char base_latitude[ 12 ];
  char base_longitude[ 12 ];
  char ccs[ 4 ];
  char prl_ind[ 4 ];
  char sid[ 6 ];
  char nid[ 6 ];
  char roam_status[ 4 ];
  char def_roam_ind[ 4 ];
  char reg_reject_cause[12];
  char primary_scrambling_code[12];
} qcril_qmi_nas_registration_state_resp_helper_type;

#define NAS_REG_DATA_STATE_RESP_MAX_ARR_SIZE (11)

#define NAS_REG_DATA_MAX_DATA_CALLS 20

typedef struct
{
  char *registration_info_array[ NAS_REG_DATA_STATE_RESP_MAX_ARR_SIZE ];
  char registration_state[ 3 ];
  char lac[ 7 ];
  char cid[ 11 ];
  char data_radio_tech[ 3 ];
  char registration_denied_cause[ 12 ];
  char max_data_call_no[12];
  char tac[ 7 ];          // "16-bit Tracking Area Code", hence 5 chars in dec plus null terminator, but keep 7 for consistency with lac
  char phys_cell_id[ 4 ]; // "0-503 Physical Cell Identifier", hence 3 chars in decimal representation plus null terminator
  char eci[ 10 ];         // "28-bit E-UTRAN Cell Identifier", hence 9 characters in decimal representation plus null terminator
  char csgid[ 10 ];       // "27-bit Closed Subscriber Group Identity",  hence 9 characters in decimal representation plus null terminator
  char tadv[ 3 ];         // "6-bit timing advance value", hence 2 digits plus null terminator
} qcril_qmi_nas_registration_data_state_resp_helper_type;

#define NAS_OPERATOR_RESP_MAX_ARR_SIZE (3)

#define NAS_OPERATOR_RESP_MAX_EONS_LEN (512)

#define NAS_OPERATOR_RESP_MAX_MCC_MNC_LEN (16) //length of MNC_MNC should be 5-7 characters. Extra space is a safeguard.

#define NAS_MCC_WILDCARD_ENTRY 0x33
#define NAS_MNC_WILDCARD_ENTRY 0x37
#define NAS_MCC_MNC_WILDCARD_ENTRY 0xFF
#define NAS_PLACEHOLDER_MCC_STR "123" //any 3 digit entry would suffice
#define NAS_PLACEHOLDER_MNC_STR "456" //any 3 digit entry would suffice

typedef struct
{
  char *operator_info_array[ NAS_OPERATOR_RESP_MAX_ARR_SIZE ];
  char long_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
  char short_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
  char mcc_mnc_ascii[ NAS_OPERATOR_RESP_MAX_MCC_MNC_LEN ];
} qcril_qmi_operator_resp_helper_type;


#define NAS_NW_SCAN_RESP_ENTRY_SIZE     (5)

#define NAS_NW_SCAN_RESP_MCCMNC_SIZE    (12)

#define NAS_NW_SCAN_RESP_RAT_SIZE       (3)

typedef struct
{
    char *nw_scan_info_array[ NAS_NW_SCAN_RESP_ENTRY_SIZE * NAS_3GPP_NETWORK_INFO_LIST_MAX_V01 ];
    char long_eons [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
    char short_eons [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
    char mccmnc_info [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_NW_SCAN_RESP_MCCMNC_SIZE ] ;
    char rat [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_NW_SCAN_RESP_RAT_SIZE ] ;
} qcril_qmi_nw_scan_resp_helper_type;

//TODO need to remove this support!
#define QCRIL_DATA_MAX_CALL_RECORDS 20
typedef struct
{
  RIL_DcRtInfo *data_call_real_time_info_list_ptr [ QCRIL_DATA_MAX_CALL_RECORDS ];
  RIL_DcRtInfo data_call_real_time_info_list [ QCRIL_DATA_MAX_CALL_RECORDS ];
} qcril_qmi_nas_dc_rt_info_helper_type;

typedef struct
{
  int                      pwr_oprt_in_progress;                // Indicates whether the power down or up operation is in progress
  qcril_uim_card_status_e_type status;                          // Card status
  int                      card_ever_present;
  char                     iccid[QMI_DMS_UIM_ID_MAX_V01 + 1];
  int                      iccid_len;
  int                      iccid_len_from_uim;
  char                     iccid_from_uim[QMI_DMS_UIM_ID_MAX_V01 + 1];
  int                      valid;
  char                     mcc[QCRIL_MCC_MNC_MAX_SIZE];
  char                     mnc[QCRIL_MCC_MNC_MAX_SIZE];
  char                     *mcc_from_iccid;
} qcril_qmi_nas_dms_card_info_type;

struct nas_dsds_runtime_info_type
{
    RIL_SelectUiccSub           cur_info;
    int                         is_tune_away;
    nas_standby_pref_enum_v01   standby_pref;
    nas_subs_type_enum_v01      paging_priority;
    nas_subs_type_enum_v01      default_voice_sub;
    nas_subs_type_enum_v01      default_data_sub;
    int                         valid;
    qcril_modem_stack_id_e_type modem_stack_id;
    qcril_flexi_map_status      fm_status;
    qcril_instance_id_e_type    default_data_instance_id;
    int                         default_data_reason;
    int                         is_default_data_set;
    int                         is_lte_tune_away;
    int                         dds_data_sub_valid;
    DDSSubIdInfo                dds_data_sub;
    nas_active_subs_mask_type_v01 active_subs_mask;
};

typedef struct
{
    int version;
    int session;
    int phase;
} nas_dsds_fm_req_resp_info_type;

typedef struct
{
    boolean                         is_not_bootup_radio_power_on;
    boolean                         radio_power_process_pending;
    int                             apm_mdm_not_pwdn;
} qcril_qmi_modem_power_runtime_info_type;


typedef struct
{
    uint16_t cdma_ecio_delta;
    uint16_t cdma_rssi_delta;
    uint16_t gsm_rssi_delta;
    uint16_t hdr_ecio_delta;
    uint16_t hdr_rssi_delta;
    uint16_t hdr_sinr_delta;
    uint16_t lte_rsrp_delta;
    uint16_t lte_rsrq_delta;
    uint16_t lte_rssi_delta;
    uint16_t lte_snr_delta;
    uint16_t lte_rpt_rate;
    uint16_t lte_avg_period;
    uint16_t tdscdma_ecio_delta;
    uint16_t tdscdma_rscp_delta;
    uint16_t tdscdma_rssi_delta;
    uint16_t tdscdma_sinr_delta;
    uint16_t wcdma_ecio_delta;
    uint16_t wcdma_rssi_delta;
    uint16_t nr5g_rsrp_delta;
    uint16_t nr5g_snr_delta;
    uint16_t nr5g_rpt_rate;
    uint16_t nr5g_avg_period;
} qcril_qmi_sig_delta_info_type;

/* The unsolicited response filter received as part of
RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER is broken up,
and the state of each filter is stored as a boolean in this
structure. This will help avoid multiple bitmasking operations
that'll otherwise be required each time the state of a filter
is queried. */
typedef struct
{
    bool signal_strength_notification_enabled;
    bool full_network_state_notification_enabled;
    bool data_call_dormancy_notification_enabled;
} qcril_unsol_response_filter_type;

struct nas_common_runtime_info_type
{
    int location_updates_enabled;
    int is_screen_off;
    qcril_unsol_response_filter_type unsol_response_filter;
    int apm_sim_not_pwdn;
    int no_wait_for_card;
    int add_power_save_enabled;
    int force_nw_search;
    int limit_sys_info_logic_change;
    int data_snapshot_feature_enabled;
    int data_snapshot_timer_value;
    int data_snapshot_timer_value_valid;
    int fill_eons;
    int voice_support_on_lte;
    int voice_support_on_lte_valid;
    int use_se_table_only;
    int dfr_mode_pref_set_until_online;
    int data_dormancy_ind_enabled;
    qmi_ril_nas_data_dormancy_ind_type receive_data_dormancy_ind;
    int data_limited_sys_ind_toggle;
    int always_report_restricted_state;
    int get_mode_pref_from_nv_10;
    qmi_ril_nas_spn_plmn_name_preference_e_type prefer_spn_over_plmn_name;
    boolean                                     always_send_plmn_name;

    int process_duplicate_nw_scan_names;
    int csg_info_available;
    int roam_mtu_size_1x;

    int ignore_srv_domain_camped_timer;
    int ignore_srv_domain_camped_timer_id_valid;
    uint32 ignore_srv_domain_camped_timer_id;
    int prev_srv_domain_valid;
    nas_service_domain_enum_type_v01 prev_srv_domain;

    int sglte_eons_is_domain_cs;
    int sglte_eons_is_roam_enabled;
    int sglte_eons_is_set;
    int consider_lte_ltd_srv_vrte_update;
    int consider_3gpp_ltd_srv_drte_update;
    int do_not_consider_managed_roam;
    int is_restore_prev_mode_pref;

    int is_rat_tlv_supported;

    int wait_for_pbm_ind;
    int wait_for_pbm_ind_timer;
    int wait_for_pbm_ind_timer_id_valid;
    uint32 wait_for_pbm_ind_timer_id;

    // for polling operating mode when CM is not ready
    int opmode_query_timer_id_valid;
    uint32_t opmode_query_timer_id;

    //set lpm to modem after ssr if apm on
    int set_lpm_after_ssr_in_apm;

    uint8 permanent_lte_band_pref_valid;
    uint64_t permanent_lte_band_pref;

    int is_reg_denied_on_rej_cause;

    int manual_nw_reject_cause_counter_enabled;
    int manual_nw_reject_cause_counter;

    int sib16_support;

    int prov_emer_call_in_lpm;
    int relay_oprt_change;

    int eri_64_home;

    int ct_operator_name;

    qcril_qmi_nas_dms_card_info_type card_info[ RIL_UIM_MAX_CARD_COUNT ];
    struct nas_dsds_runtime_info_type dsds;
    nas_dsds_fm_req_resp_info_type fm_req_resp_info;

    boolean prov_in_progress;
    boolean prov_status;
    boolean card_prov_pending;

    qtimutex::QtiRecursiveMutex cache_lock_mutex;
    qtimutex::QtiSharedMutex nw_sel_lock_mutex;
    qtimutex::QtiSharedMutex sib_cache_lock_mutex;
    qtimutex::QtiSharedMutex embms_cache_lock_mutex;

    // radio power tracking
    qmi_ril_dms_radio_pwr_request_e_type        radio_power_request_type;
    qmi_ril_dms_radio_pwr_cancel_e_type         radio_power_cancel_type;
    boolean                                     is_radio_power_check_enabled;
    qtimutex::QtiRecursiveMutex                   radio_pwr_mutex;
    std::condition_variable_any                 radio_pwr_cond_var;
    qmi_ril_dms_radio_pwr_signal_cond_e_type    radio_pwr_signal_cond;
    qmi_ril_dms_radio_pwr_multiple_rild_radio_power_sync_e_type  radio_power_sync_type;
    int                                         radio_power_multiple_rild_process_complete_num;
    int                                         radio_power_multiple_rild_process_timer_valid;
    uint32                                      radio_power_multiple_rild_process_timer;
    qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type radio_pwr_prov_emer_call_lpm_state;
    dms_operating_mode_enum_v01                 radio_pwr_prov_emer_call_desired_modem_operating_mode;

    int custom_emergency_numbers_enabled;
    char *custom_hardcoded_emergency_numbers_list;
    int custom_emergency_numbers_enabled_for_nw;
    int unsol_cell_info_rate; // Value set by telephony for minimum period between updates

    int unsol_cell_info_rate_sweep_limit; // Maximum timer value between polls for cell info
                                          // Should be high enough to give good battery performance,
                                          // yet low enough to alow enough location updates.
                                          // If this is less than or equal to unsol_cell_info_rate,
                                          // No exponential backoff happens.
    int unsol_cell_info_current_rate; // Current timer value for polling.
    boolean cell_info_poll_timer_id_valid;                      // Timer id of currently scheduled poll
    uint32 cell_info_poll_timer_id;                      // Timer id of currently scheduled poll
    qcril_qmi_modem_power_runtime_info_type modem_power_info;

    mode_pref_mask_type_v01 rat_disabled_mask_during_on_demand_attach;

    /* rtre config info */
    nas_rtre_cfg_enum_v01  nas_rtre_cfg;

    /* is voice radio tech learning enabled */
    uint8_t is_ril_vrte_learning_enabled;

    /* VOICE SRV TYPE */
    boolean cs_srv_type;

    // sig config info
    qcril_qmi_sig_delta_info_type sig_config;

    // Limit by RAC change
    uint8_t is_limit_by_rac_change;

    // Feature to enable msim advanced scan
    uint8_t is_feature_msim_adv_scan;

    // Feature to enable Power Opt
    uint8_t is_feature_power_opt_enabled;

    // cache for storing current modem stack is enabled/disbaled
    int modem_stack_status;

    boolean use_cc_names;                  // Use Country-specific operator names
    boolean force_no_srv_on_rej_reject_17;
    pthread_t shutdown_monitor_thread;
    boolean shutdown_monitor_thread_valid;
    boolean sim_provisioned;

    // Feature to bar the fake gcell
    boolean bar_fake_gcell;

    // Feature to enable/disable RIL 3gpp operator table
    boolean use_ril_3gpp_operator_table;

    // time of waiting for full service before dial fake ecc number
    uint8_t wait_time_for_fake_ecc;

    // support to read op_name from uncode table
    boolean unicode_operator_names_support;

    // Feature to snapshot reported data reg state
    boolean is_snapshot_reported_data_reg_state;
    boolean reported_data_timer_value_valid;
    int reported_data_timer_value;

    // 5G mode preference
    RIL_5G_MODE five_g_mode_pref;

    // Most recent mode pref requested by Android
    int last_android_mode_pref;
    bool last_android_mode_pref_valid;
};

enum
{
  NAS_CDMA_SUBSCRIPTION_INFO_MDN = 0,
  NAS_CDMA_SUBSCRIPTION_INFO_H_SID,
  NAS_CDMA_SUBSCRIPTION_INFO_H_NID,
  NAS_CDMA_SUBSCRIPTION_INFO_MIN,
  NAS_CDMA_SUBSCRIPTION_INFO_PRL_VER,
  NAS_CDMA_SUBSCRIPTION_INFO_MAX
};


#define NAS_SID_NID_ELEMENT_MAX_SIZE ( 6 )
#define NAS_SID_NID_STR_MAX_SIZE     ( NAS_SID_NID_ELEMENT_MAX_SIZE * 20 + 1 )
#define NAS_MIN_S_STR_MAX_SIZE       ( 11 )
#define NAS_NEIGHBOR_LIST_MAX_SIZE   ( 64 )
#define NAS_PRL_VERSION_MAX_SIZE     ( 7 )
#define NAS_CID_ASCII_MAX_LEN        ( 9 )
#define NAS_MDN_STR_MAX_SIZE         ( MDN_MAX_LEN_V01 + 1)

typedef struct
{
  char *cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_MAX ];
  char mob_dir_number[ NAS_MDN_STR_MAX_SIZE ];
  char home_sid[ NAS_SID_NID_STR_MAX_SIZE ];
  char home_nid[ NAS_SID_NID_STR_MAX_SIZE ];
  char min_s[ NAS_IMSI_MIN1_LEN_V01 + NAS_IMSI_MIN2_LEN_V01 + 1 ];
  char prl_version[ NAS_PRL_VERSION_MAX_SIZE ];
} qcril_nas_cdma_subscription_type;

typedef struct
{
    RIL_NeighboringCell *neighbor_cell_list[NAS_NEIGHBOR_LIST_MAX_SIZE];
    RIL_NeighboringCell neighbor_cell[NAS_NEIGHBOR_LIST_MAX_SIZE];
    char cid[ NAS_NEIGHBOR_LIST_MAX_SIZE ][ NAS_CID_ASCII_MAX_LEN ];
} qcril_nas_neighboring_cell_type;

enum
{
  NAS_DMS_DEVICE_ID_IMEI,
  NAS_DMS_DEVICE_ID_IMEISV,
  NAS_DMS_DEVICE_ID_ESN,
  NAS_DMS_DEVICE_ID_MEID,
  NAS_DMS_DEVICE_ID_MAX
};

#define NAS_DMS_IMEI_MAX_STR_SIZE         (17)
#define NAS_DMS_IMEISV_MAX_STR_SIZE         (3)
#define NAS_DMS_ESN_MAX_STR_SIZE          (9)
#define NAS_DMS_MEID_MAX_STR_SIZE         (15)

typedef struct
{
  char *device_identity[ NAS_DMS_DEVICE_ID_MAX ];
  char imei[ NAS_DMS_IMEI_MAX_STR_SIZE ];
  char imeisv[ NAS_DMS_IMEISV_MAX_STR_SIZE ];
  char esn[ NAS_DMS_ESN_MAX_STR_SIZE ];
  char meid[ NAS_DMS_MEID_MAX_STR_SIZE ];
} qcril_nas_dms_device_identity_type;

typedef void (*qcril_qmi_cb_func_ptr) ( RIL_Errno resp_res );

typedef struct
{
    int is_reject_case;
    int reject_cause;
    int is_managed_roaming;
} qcril_qmi_nas_srv_status_convertion_extra_results_type;

#define NAS_SYS_INFO_IS_EMPTY                           ( (uint32_t) 0 )
#define NAS_SYS_INFO_IS_3GPP                            ( (uint32_t) 1 << 0 )
#define NAS_SYS_INFO_IS_DATA                            ( (uint32_t) 1 << 1 )
#define NAS_SYS_INFO_IS_HDR                             ( (uint32_t) 1 << 2 )
#define NAS_SYS_INFO_IS_LTE                             ( (uint32_t) 1 << 3 )
#define NAS_SYS_INFO_IS_5G                              ( (uint32_t) 1 << 4 )

#define NAS_RADIO_POWER_REQUEST_NAME_OFFSET                 ( 1 )
#define NAS_DMS_OP_MODE_START                               ( DMS_OP_MODE_ONLINE_V01 )
#define NAS_DMS_OP_MODE_END                                 ( DMS_OP_MODE_MODE_ONLY_LOW_POWER_V01 )

#define NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_1_1900_IN_MILLI_SEC   (-2208988800000)
#define NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_6_1980_IN_MILLI_SEC   (315964800000)

#define NAS_SET_BIT( flag_variable, value)              flag_variable |= value;
#define NAS_IS_BIT_SET( flag_variable, value)           ((flag_variable & value)? TRUE: FALSE)

typedef struct
{
  nas_3gpp2_srv_status_info_type_v01 * threegpp2_srv_status;
  nas_3gpp_srv_status_info_type_v01 * threegpp_srv_status;
  nas_common_sys_info_type_v01 * common_sys_info;
  nas_cdma_hdr_only_sys_info_type_v01 * cdma_hdr_only_sys_info;
  nas_cdma_only_sys_info_type_v01 * cdma_only_sys_info;
  nas_hdr_only_sys_info_type_v01 * hdr_only_sys_info;
  nas_3gpp_only_sys_info_type_v01 * threegpp_only_sys_info;
  nas_gsm_only_sys_info_type_v01 * gsm_only_sys_info;
  nas_wcdma_only_sys_info_type_v01 * wcdma_only_sys_info;
  nas_tdscdma_only_sys_info_type_v01 * tdscdma_only_sys_info;
  nas_lte_only_sys_info_type_v01 * lte_only_sys_info;
  nas_nr5g_only_sys_info_type_v01 *nr5g_only_sys_info;
  uint8_t * voice_support_on_lte;
  nas_tri_state_boolean_type_v01 *lte_is_eb_supported;
  nas_tri_state_boolean_type_v01 *emergency_access_barred;
  qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results;
}nas_sys_info_helper_type;

typedef struct
{
    unsigned long     message_id;
    void *            payload;
    int               payload_len;
} qmi_ril_nw_reg_nw_select_passover_params_type;

static const char *qmi_ril_op_name_persist_store_prop_list_long[] =
                                            { QMI_RIL_OP_NAME_NITZ_LONS_0,
                                              QMI_RIL_OP_NAME_NITZ_LONS_1,
                                              QMI_RIL_OP_NAME_NITZ_LONS_2,
                                              QMI_RIL_OP_NAME_NITZ_LONS_3 };

static const char *qmi_ril_op_name_persist_store_prop_list_short[] =
                                             { QMI_RIL_OP_NAME_NITZ_SONS_0,
                                               QMI_RIL_OP_NAME_NITZ_SONS_1,
                                               QMI_RIL_OP_NAME_NITZ_SONS_2,
                                               QMI_RIL_OP_NAME_NITZ_SONS_3 };

#define NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE                      (0xFF)

#define QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD 8
#define QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD 13

#define QCRIL_QMI_NAS_MAX_OPLMN_LIST 2503 // (500 * (3+2)) + 2 + 1

typedef struct {

  uint16_t mcc;
  /**<   A 16-bit integer representation of MCC. Range: 0 to 999.
  */

  uint16_t mnc;
  /**<   A 16-bit integer representation of MNC. Range: 0 to 999.
  */
  boolean mnc_includes_pcs_digit;

  nas_csg_list_cat_enum_v01 csg_list_cat;
  /**<   Closed subscriber group category. Values: \n
       - 0 -- NAS_CSG_LIST_CAT_UNKNOWN -- Unknown CSG list \n
       - 1 -- NAS_CSG_LIST_CAT_ALLOWED -- Allowed CSG list \n
       - 2 -- NAS_CSG_LIST_CAT_OPERATOR -- Operator CSG list
  */

  nas_csg_info_type_v01 csg_info;
  /**<   Closed subscriber group information.
  */
}qcril_qmi_nas_csg_nw_info_type;  /* Type */

typedef struct {

  uint16_t mcc;
  /**<   A 16-bit integer representation of MCC. Range: 0 to 999.
  */

  uint16_t mnc;
  /**<   A 16-bit integer representation of MNC. Range: 0 to 999.
  */

  boolean mnc_includes_pcs_digit;

  uint32_t csg_id;
  /**<   Closed subscriber group identifier.
  */

  int32_t signal_strength;
  /**<   Signal strength information in dBm.
  */
}qcril_qmi_nas_csg_nw_signal_strength_info_type;

typedef struct {
uint16_t mcc;
uint16_t mnc;
boolean mnc_includes_pcs_digit;
uint8_t network_status;
uint8_t plmn_rat_valid;
uint8_t plmn_rat;
}qcril_qmi_nas_nw_scan_info_helper_type;

#define NUM_OF_STRINGS_WITH_LEGACY_RAT                  5
#define NUM_OF_STRINGS_WITH_COMBINED_RAT_OR_NO_RAT      4

typedef struct {

  /* Mandatory */
  /*  Result Code */
  qmi_response_type_v01 resp;
  /**<   Standard response type.
 Standard response type. Contains the following data members:
     - qmi_result_type -- QMI_RESULT_SUCCESS or QMI_RESULT_FAILURE \n
     - qmi_error_type  -- Error code. Possible error code values are described in
                          the error codes section of each message definition.
  */

  /* 0x13 */
  /*  Network Scan Result */
  uint8_t scan_result_tag;  /**< Must be set to true if scan_result is being passed */
  uint16_t scan_result_len;
  uint32_t scan_result;

  /* 0x14+mnc_pcs_bit */
  /*  CSG Information */
  uint8_t csg_info_tag;  /**< Must be set to true if csg_info is being passed */
  uint16_t csg_info_total_len;  /**< Must be set to # of elements in csg_info */
  uint8_t csg_info_no_of_entries;
  qcril_qmi_nas_csg_nw_info_type csg_info[NAS_3GPP_NETWORK_INFO_LIST_MAX_V01];

  /* 0x15+mnc_pcs_bit */
  /*  CSG Signal Strength Information */
  uint8_t csg_sig_info_tag;  /**< Must be set to true if csg_sig_info is being passed */
  uint16_t csg_sig_info_total_len;  /**< Must be set to # of elements in csg_sig_info */
  uint8_t csg_sig_info_no_of_entries;
  qcril_qmi_nas_csg_nw_signal_strength_info_type csg_sig_info[NAS_3GPP_NETWORK_INFO_LIST_MAX_V01];
}qcril_qmi_nas_perform_network_scan_csg_resp_msg;

/* APN info input */
typedef struct
{
    int32   apn_type_len;

    /* null terminated string */
    char   *apn_type;

    int32   apn_name_len;

    /* null terminated string */
    char   *apn_name;

    /* confirms whether apn is removed */
    int32   is_apn_valid;
} qcril_qmi_oem_evt_hook_set_set_apn_info_type;

//===========================================================================

//                     GLOBALS

//===========================================================================

static int qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status_direct
(
 nas_service_status_enum_type_v01 nas_srv_status,
 nas_common_sys_info_type_v01 *common_sys_info,
 boolean ignore_srv_domain
);

static int qcril_qmi_nas_util_adjust_hdr_ril_reg_state
(
     int reg_state,
     nas_hdr_only_sys_info_type_v01 *hdr_only_sys_info
);

void qcril_qmi_nas_report_change_in_csg_id();

static struct nas_cached_info_type                  nas_cached_info;
static struct nas_dms_cached_info_type              nas_dms_cached_info;
static struct nas_common_runtime_info_type          nas_common_info;

/* serv cell sib info*/
static nas_srv_cell_sib_info_type sib_info;


static const char *card_status_name[] = { "UNKNOWN",
                                          "NOT APPLICABLE",
                                          "DOWN",
                                          "UP",
                                          "NOT ACCESSIBLE",
                                          "REFRESH",
                                          "PWR UP FAILED",
                                          "PWR DOWN FAILED",
                                          "ILLEGAL",
                                          "ABSENT" };

static const char *radio_power_request_name[] = { "NONE",
                                                  "BOOTUP_RADIO_POWER_OFF",
                                                  "OTHER" };

static const char *radio_power_cancel_name[] = { "NONE",
                                                 "SSR" };

static const char *radio_power_state_name[] = { "NONE",
                                                "INITIALIZED",
                                                "WAITING_FOR_CARD_STATUS",
                                                "SETTING_CARD_STATUS",
                                                "CARD_STATUS_SET",
                                                "SETTING_OP_MODE",
                                                "OP_MODE_SET",
                                                "DONE",
                                                "INITIATING_MULTIPLE_RILD_SYNC",
                                                "WAITING_FOR_MULTIPLE_RILD_SYNC",
                                                "MULTIPLE_RILD_SYNC_DONE"};

static const char *radio_power_telephony_request_name[] = { "UNKNOWN",
                                                            "LPM",
                                                            "ONLINE",
                                                            "OFF" };

static const char *dms_op_mode_name[] = { "ONLINE",
                                          "LPM",
                                          "FTM",
                                          "OFFLINE",
                                          "RESETTING",
                                          "SHUTTING_DOWN",
                                          "PERSISTENT_LPM",
                                          "MODE_ONLY_LPM" };

// TODO: Convert to a map
static const char *radio_tech_name[] =  { "UNKNOWN",
                                          "GPRS",
                                          "EDGE",
                                          "UMTS",
                                          "IS95A",
                                          "IS95B",
                                          "1xRTT",
                                          "EVDO_0",
                                          "EVDO_A",
                                          "HSDPA",
                                          "HSUPA",
                                          "HSPA",
                                          "EVDO_B",
                                          "EHRPD",
                                          "LTE",
                                          "HSPAP",
                                          "GSM",
                                          "TDSCDMA",
                                          "IWLAN",
                                          "LTE CA",
                                          "5G",
                                          "INVALID" };

static const char *pref_data_tech_name[] =  { "INVALID",
                                              "UNKNOWN",
                                              "CDMA",
                                              "EVDO",
                                              "GSM",
                                              "UMTS",
                                              "EHRPD",
                                              "LTE",
                                              "TDSCDMA",
                                              "5G",
                                              "MAX"};


static const qcril_arb_pref_data_tech_e_type qmi_ril_data_reg_tech_priorities[QCRIL_ARB_PREF_DATA_TECH_MAX ] = { QCRIL_ARB_PREF_DATA_TECH_5G,
                                                                                                                 QCRIL_ARB_PREF_DATA_TECH_LTE,
                                                                                                                 QCRIL_ARB_PREF_DATA_TECH_EHRPD,
                                                                                                                 QCRIL_ARB_PREF_DATA_TECH_EVDO,
                                                                                                                 QCRIL_ARB_PREF_DATA_TECH_UMTS,
                                                                                                                 QCRIL_ARB_PREF_DATA_TECH_TDSCDMA,
                                                                                                                 QCRIL_ARB_PREF_DATA_TECH_CDMA,
                                                                                                                 QCRIL_ARB_PREF_DATA_TECH_GSM
                                                                                                                };

typedef struct
{
  timer_t timer_id;
  qcril_instance_id_e_type instance_id;
  boolean timer_started;
  oem_hook_ftm_subscription_source_e_type subs_type;
}qcril_qmi_nas_get_engineer_mode_info_timer_type;

static qcril_qmi_nas_get_engineer_mode_info_timer_type qcril_qmi_nas_get_engineer_mode_info_timer;

static const qcril_qmi_enum_log_type nas_active_band_enum_v01_name[] =
{
    { NAS_ACTIVE_BAND_ENUM_MIN_ENUM_VAL_V01, "NAS_ACTIVE_BAND_ENUM_MIN_ENUM_VAL" },
    { NAS_ACTIVE_BAND_BC_0_V01, "NAS_ACTIVE_BAND_BC_0" },
    { NAS_ACTIVE_BAND_BC_1_V01, "NAS_ACTIVE_BAND_BC_1" },
    { NAS_ACTIVE_BAND_BC_3_V01, "NAS_ACTIVE_BAND_BC_3" },
    { NAS_ACTIVE_BAND_BC_4_V01, "NAS_ACTIVE_BAND_BC_4" },
    { NAS_ACTIVE_BAND_BC_5_V01, "NAS_ACTIVE_BAND_BC_5" },
    { NAS_ACTIVE_BAND_BC_6_V01, "NAS_ACTIVE_BAND_BC_6" },
    { NAS_ACTIVE_BAND_BC_7_V01, "NAS_ACTIVE_BAND_BC_7" },
    { NAS_ACTIVE_BAND_BC_8_V01, "NAS_ACTIVE_BAND_BC_8" },
    { NAS_ACTIVE_BAND_BC_9_V01, "NAS_ACTIVE_BAND_BC_9" },
    { NAS_ACTIVE_BAND_BC_10_V01, "NAS_ACTIVE_BAND_BC_10" },
    { NAS_ACTIVE_BAND_BC_11_V01, "NAS_ACTIVE_BAND_BC_11" },
    { NAS_ACTIVE_BAND_BC_12_V01, "NAS_ACTIVE_BAND_BC_12" },
    { NAS_ACTIVE_BAND_BC_13_V01, "NAS_ACTIVE_BAND_BC_13" },
    { NAS_ACTIVE_BAND_BC_14_V01, "NAS_ACTIVE_BAND_BC_14" },
    { NAS_ACTIVE_BAND_BC_15_V01, "NAS_ACTIVE_BAND_BC_15" },
    { NAS_ACTIVE_BAND_BC_16_V01, "NAS_ACTIVE_BAND_BC_16" },
    { NAS_ACTIVE_BAND_BC_17_V01, "NAS_ACTIVE_BAND_BC_17" },
    { NAS_ACTIVE_BAND_BC_18_V01, "NAS_ACTIVE_BAND_BC_18" },
    { NAS_ACTIVE_BAND_BC_19_V01, "NAS_ACTIVE_BAND_BC_19" },
    { NAS_ACTIVE_BAND_GSM_450_V01, "NAS_ACTIVE_BAND_GSM_450" },
    { NAS_ACTIVE_BAND_GSM_480_V01, "NAS_ACTIVE_BAND_GSM_480" },
    { NAS_ACTIVE_BAND_GSM_750_V01, "NAS_ACTIVE_BAND_GSM_750" },
    { NAS_ACTIVE_BAND_GSM_850_V01, "NAS_ACTIVE_BAND_GSM_850" },
    { NAS_ACTIVE_BAND_GSM_900_EXTENDED_V01, "NAS_ACTIVE_BAND_GSM_900_EXTENDED" },
    { NAS_ACTIVE_BAND_GSM_900_PRIMARY_V01, "NAS_ACTIVE_BAND_GSM_900_PRIMARY" },
    { NAS_ACTIVE_BAND_GSM_900_RAILWAYS_V01, "NAS_ACTIVE_BAND_GSM_900_RAILWAYS" },
    { NAS_ACTIVE_BAND_GSM_1800_V01, "NAS_ACTIVE_BAND_GSM_1800" },
    { NAS_ACTIVE_BAND_GSM_1900_V01, "NAS_ACTIVE_BAND_GSM_1900" },
    { NAS_ACTIVE_BAND_WCDMA_2100_V01, "NAS_ACTIVE_BAND_WCDMA_2100" },
    { NAS_ACTIVE_BAND_WCDMA_PCS_1900_V01, "NAS_ACTIVE_BAND_WCDMA_PCS_1900" },
    { NAS_ACTIVE_BAND_WCDMA_DCS_1800_V01, "NAS_ACTIVE_BAND_WCDMA_DCS_1800" },
    { NAS_ACTIVE_BAND_WCDMA_1700_US_V01, "NAS_ACTIVE_BAND_WCDMA_1700_US" },
    { NAS_ACTIVE_BAND_WCDMA_850_V01, "NAS_ACTIVE_BAND_WCDMA_850" },
    { NAS_ACTIVE_BAND_WCDMA_800_V01, "NAS_ACTIVE_BAND_WCDMA_800" },
    { NAS_ACTIVE_BAND_WCDMA_2600_V01, "NAS_ACTIVE_BAND_WCDMA_2600" },
    { NAS_ACTIVE_BAND_WCDMA_900_V01, "NAS_ACTIVE_BAND_WCDMA_900" },
    { NAS_ACTIVE_BAND_WCDMA_1700_JAPAN_V01, "NAS_ACTIVE_BAND_WCDMA_1700_JAPAN" },
    { NAS_ACTIVE_BAND_WCDMA_1500_JAPAN_V01, "NAS_ACTIVE_BAND_WCDMA_1500_JAPAN" },
    { NAS_ACTIVE_BAND_WCDMA_850_JAPAN_V01, "NAS_ACTIVE_BAND_WCDMA_850_JAPAN" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_1_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_1" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_2_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_2" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_3_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_3" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_4_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_4" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_5_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_5" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_6_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_6" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_7_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_7" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_8_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_8" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_9_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_9" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_10_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_10" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_11_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_11" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_12_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_12" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_13_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_13" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_14_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_14" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_17_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_17" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_33_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_33" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_34_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_34" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_35_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_35" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_36_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_36" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_37_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_37" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_38_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_38" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_39_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_39" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_40_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_40" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_18_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_18" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_19_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_19" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_20_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_20" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_21_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_21" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_24_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_24" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_25_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_25" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_41_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_41" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_42_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_42" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_43_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_43" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_23_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_23" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_26_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_26" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_32_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_32" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_125_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_125" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_126_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_126" },
    { NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_127_V01, "NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_127" },
    { NAS_ACTIVE_BAND_TDSCDMA_BAND_A_V01, "NAS_ACTIVE_BAND_TDSCDMA_BAND_A" },
    { NAS_ACTIVE_BAND_TDSCDMA_BAND_B_V01, "NAS_ACTIVE_BAND_TDSCDMA_BAND_B" },
    { NAS_ACTIVE_BAND_TDSCDMA_BAND_C_V01, "NAS_ACTIVE_BAND_TDSCDMA_BAND_C" },
    { NAS_ACTIVE_BAND_TDSCDMA_BAND_D_V01, "NAS_ACTIVE_BAND_TDSCDMA_BAND_D" },
    { NAS_ACTIVE_BAND_TDSCDMA_BAND_E_V01, "NAS_ACTIVE_BAND_TDSCDMA_BAND_E" },
    { NAS_ACTIVE_BAND_TDSCDMA_BAND_F_V01, "NAS_ACTIVE_BAND_TDSCDMA_BAND_F" },
    { NAS_ACTIVE_BAND_ENUM_MAX_ENUM_VAL_V01, "NAS_ACTIVE_BAND_ENUM_MAX_ENUM_VAL" }
};

static const qcril_qmi_enum_log_type ril_lte_band_pref_name[] =
{
    { E_UTRA_Operating_Band_1, "E_UTRA_Operating_Band_1" },
    { E_UTRA_Operating_Band_2, "E_UTRA_Operating_Band_2" },
    { E_UTRA_Operating_Band_3, "E_UTRA_Operating_Band_3" },
    { E_UTRA_Operating_Band_4, "E_UTRA_Operating_Band_4" },
    { E_UTRA_Operating_Band_5, "E_UTRA_Operating_Band_5" },
    { E_UTRA_Operating_Band_6, "E_UTRA_Operating_Band_6" },
    { E_UTRA_Operating_Band_7, "E_UTRA_Operating_Band_7" },
    { E_UTRA_Operating_Band_8, "E_UTRA_Operating_Band_8" },
    { E_UTRA_Operating_Band_9, "E_UTRA_Operating_Band_9" },
    { E_UTRA_Operating_Band_10, "E_UTRA_Operating_Band_10" },
    { E_UTRA_Operating_Band_11, "E_UTRA_Operating_Band_11" },
    { E_UTRA_Operating_Band_12, "E_UTRA_Operating_Band_12" },
    { E_UTRA_Operating_Band_13, "E_UTRA_Operating_Band_13" },
    { E_UTRA_Operating_Band_14, "E_UTRA_Operating_Band_14" },
    { E_UTRA_Operating_Band_17, "E_UTRA_Operating_Band_17" },
    { E_UTRA_Operating_Band_33, "E_UTRA_Operating_Band_33" },
    { E_UTRA_Operating_Band_34, "E_UTRA_Operating_Band_34" },
    { E_UTRA_Operating_Band_35, "E_UTRA_Operating_Band_35" },
    { E_UTRA_Operating_Band_36, "E_UTRA_Operating_Band_36" },
    { E_UTRA_Operating_Band_37, "E_UTRA_Operating_Band_37" },
    { E_UTRA_Operating_Band_38, "E_UTRA_Operating_Band_38" },
    { E_UTRA_Operating_Band_39, "E_UTRA_Operating_Band_39" },
    { E_UTRA_Operating_Band_40, "E_UTRA_Operating_Band_40" },
    { E_UTRA_Operating_Band_18, "E_UTRA_Operating_Band_18" },
    { E_UTRA_Operating_Band_19, "E_UTRA_Operating_Band_19" },
    { E_UTRA_Operating_Band_20, "E_UTRA_Operating_Band_20" },
    { E_UTRA_Operating_Band_21, "E_UTRA_Operating_Band_21" },
    { E_UTRA_Operating_Band_24, "E_UTRA_Operating_Band_24" },
    { E_UTRA_Operating_Band_25, "E_UTRA_Operating_Band_25" },
    { E_UTRA_Operating_Band_41, "E_UTRA_Operating_Band_41" },
    { E_UTRA_Operating_Band_42, "E_UTRA_Operating_Band_42" },
    { E_UTRA_Operating_Band_43, "E_UTRA_Operating_Band_43" },
    { E_UTRA_Operating_Band_23, "E_UTRA_Operating_Band_23" },
    { E_UTRA_Operating_Band_26, "E_UTRA_Operating_Band_26" },
    { E_UTRA_Operating_Band_32, "E_UTRA_Operating_Band_32" },
    { E_UTRA_Operating_Band_125, "E_UTRA_Operating_Band_125" },
    { E_UTRA_Operating_Band_126, "E_UTRA_Operating_Band_126" },
    { E_UTRA_Operating_Band_127, "E_UTRA_Operating_Band_127" }
};

//===========================================================================

//                                FUNCTIONS

//===========================================================================

//INLINE functions
static void qcril_qmi_nas_get_meta_build_id_from_file(char *ap_sw_version, size_t len);
static inline int qcril_qmi_nas_is_atel_rat_3gpp(RIL_RadioTechnology atel_rat);
static inline int qcril_qmi_nas_is_atel_rat_3gpp2(RIL_RadioTechnology atel_rat);
static inline RIL_RadioTechnology process_3gpp_radio_technology(RIL_RadioTechnology reported_radio_technology, uint16_t mode_pref);
static inline RIL_RadioTechnology process_3gpp2_radio_technology(RIL_RadioTechnology reported_radio_technology,uint16_t mode_pref);

static inline int qcril_qmi_nas_is_3gpp2_roaming(uint8_t reg_state_valid,
                                                 int reg_state,
                                                 uint8_t reg_tech_valid,
                                                 int reg_tech);

void qcril_qmi_nas_report_change_in_csg_id();

IxErrnoType qcril_mbn_sw_update_init
(
    boolean is_ssr_or_bootup
);

static const char* qcril_qmi_util_retrieve_regstate_name(RIL_RegState reg);
static int qcril_qmi_nas_event_report_ind_conv_qmi2ril(nas_event_report_ind_msg_v01* qmi_msg, int * network_state_updated, int * data_nw_state_updated);
static int qcril_qmi_nas_is_using_radio_if(uint8_t radio_if);
static int qcril_qmi_nas_is_using_rte(qmi_ril_nw_reg_rte_type rte, qmi_ril_nw_reg_rte_kind_type rte_kind);
static int qcril_qmi_nas_sig_info_ind_conv_qmi2ril(nas_sig_info_ind_msg_v01* qmi_msg);
static int qcril_qmi_nas_err_rate_ind_conv_qmi2ril(nas_err_rate_ind_msg_v01* qmi_msg);

static int qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril(nas_system_selection_preference_ind_msg_v01 * qmi_msg,
                                                  int * emergency_mode_entered,
                                                  int * emergency_mode_left
                                                );

static int qcril_qmi_nas_current_plmn_name_ind_conv_qmi2ril(nas_current_plmn_name_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated
                                                );

static void qcril_qmi_nas_network_time_ind_conv_qmi2ril(nas_network_time_ind_msg_v01* ind_msg,
                                                        char *nitz_time_msg,
                                                        int *nitz_updated
                                                        );

static void qcril_qmi_nas_rtre_config_ind_conv_qmi2ril(nas_rtre_cfg_ind_msg_v01* ind_msg,
                                                        RIL_CdmaSubscriptionSource *sub_source,
                                                        int *sub_source_updated
                                                        );

static int qcril_qmi_nas_dms_event_report_qmi2ril(dms_event_report_ind_msg_v01 * qmi_msg,
                                                  int * radio_state_updated
                                                );

static void qcril_qmi_nas_dms_activity_info_ind_hndlr(dms_activity_info_ind_msg_v01* qmi_msg);
static void qcril_qmi_nas_dms_device_power_info_ind_hdlr(
                                    dms_device_power_info_request_ind_msg_v01 *power_ind_msg);
static void qcril_qmi_nas_dms_device_interactive_state_ind_hdlr(
                                    dms_device_interactive_state_request_ind_msg_v01 *interactive_ind_msg);
static RIL_Errno qcril_qmi_nas_dms_config_activity_info
(
    uint8_t enable_statistics
);

static void qcril_qmi_nas_set_subscription_source_generic
(
  const qcril_request_params_type *const params_ptr,
  int spc_present,
  qcril_request_return_type *const ret_ptr // Output parameter
);

/*static void qcril_qmi_nas_empty_command_cb
(
  qmi_client_type              user_handle,
  unsigned long                message_id,
  void                         *resp_c_struct,
  int                          resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
); */

static void qcril_qmi_nas_perform_network_scan_command_cb
(
    unsigned int                   message_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
);

static void qcril_qmi_nas_get_neighboring_cells_cb
(
    unsigned int                   message_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
);

static void qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb
(
    unsigned int                   message_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
);


RIL_Errno qcril_qmi_nas_parse_csg_scan_oem_req(uint8 *oem_hook_data,nas_perform_network_scan_req_msg_v01 *filled_data,uint8 oem_data_len );

RIL_Errno qcril_qmi_nas_parse_csg_sys_selection_req(uint8 *oem_hook_data,nas_set_system_selection_preference_req_msg_v01 *filled_data,uint8 oem_data_len );

static void qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler(nas_system_selection_preference_ind_msg_v01* qmi_ind);

static int qcril_qmi_nas_util_calculate_neighbor_cell_rssi(int cell_value);
static void qcril_qmi_util_initiate_network_selection_check(std::shared_ptr<QcRilRequestMessage> msg, int is_automatic, int mcc, int mnc, int move_on,int pcs_digit_present, RIL_RadioTechnology rat);
static RIL_Errno qcril_qmi_util_initiate_network_selection(std::shared_ptr<QcRilRequestMessage> msg, int is_automatic, int mcc, int mnc, int move_on, int pcs_digit_present, RIL_RadioTechnology rat);
static void qcril_qmi_nas_restore_modem_pref();

static void qcril_qmi_nas_set_nw_selection_command_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
);

RIL_Errno qcril_qmi_util_enable_networking_indications( int enable_nwreg, int enable_signal_strength, int force_update );

static void qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch
(
  qcril_instance_id_e_type instance_id,
  uint8 slot,
  boolean pwr_oprt_in_progress,
  qcril_uim_card_status_e_type card_status
);

static void qcril_qmi_nas_fill_up_operator_name( int is_current_nw,
                                                 char * mcc_str,
                                                 char * mnc_str,
                                                 char * mcc_mnc_str_ref,
                                                 char *long_ons_ptr,
                                                 size_t long_ons_ptr_size,
                                                 char *short_ons_ptr,
                                                 size_t short_ons_ptr_size
                                               );

static int qcril_qmi_nas_fill_up_3gpp2_operator_name( char * mcc_str,
                                                      char * mnc_str,
                                                      uint16_t sid,
                                                      uint16_t nid,
                                                      char *long_ons_ptr,
                                                      size_t long_ons_ptr_size,
                                                      char *short_ons_ptr,
                                                      size_t short_ons_ptr_size
                                                    );
static void qcril_qmi_nas_get_plmn_name_from_modem
(
  char *mcc_str,
  char *mnc_str,
  char *short_eons,
  size_t short_eons_sz,
  char *long_eons,
  size_t long_eons_sz,
  boolean use_static_table_only,
  boolean is_always_send_plmn_name,
  int  is_nw_scan,
  nas_radio_if_enum_v01 plmn_rat,
  uint8_t csg_id_valid,
  uint32_t csg_id
);

static void qcril_qmi_nas_drop_sig_info_cache_if_not_extrapolating(void);

static void qcril_qmi_nas_dump_sign_strength_report(RIL_SignalStrength* ril_signal_strength);

static void qcril_qmi_nas_dms_update_common_modem_state();

static void qcril_qmi_voice_technology_updated();

static void qcril_qmi_nas_dms_update_multisim_config_property();

static int qcril_qmi_nas_is_in_service_of_technology(int technology);

static void qcril_qmi_nas_dsds_dual_standby_pref_ind_handler( nas_dual_standby_pref_ind_msg_v01* ind_msg );
static void qcril_qmi_nas_subscription_info_ind_handler( nas_subscription_info_ind_msg_v01* ind_msg );
static void qcril_qmi_nas_dsds_subscription_info_ind_handle_helper( nas_subscription_info_ind_msg_v01* ind_msg );

RIL_Errno qcril_qmi_nas_send_data_subscription_request(nas_dds_duration_enum_v01 dds_duration);
static RIL_Errno qcril_qmi_nas_dsds_util_request_set_subscription_mode( nas_standby_pref_enum_v01 *standby_pref,
                                                                 dds_sub_pref_cause * data_sub_cause,
                                                                 nas_subs_type_enum_v01 *priority_subs,
                                                                 nas_subs_type_enum_v01 *voice_subs,
                                                                 nas_active_subs_mask_type_v01 *active_subs_mask,
                                                                 qcril_qmi_cb_func_ptr  standby_pref_res_cb );

static void qcril_qmi_dsds_set_pref_ril_req_cb ( RIL_Errno resp_res );
static void qcril_qmi_nas_drop_nw_info_cache(void);
static RIL_Errno qcril_qmi_nas_dms_handle_modem_operating_mode(dms_operating_mode_enum_v01 requested_operating_mode,int * is_operating_mode_change_needed);
static RIL_Errno qcril_qmi_nas_dms_handle_card_status(qcril_evt_e_type uim_evt);
static void qcril_qmi_nas_radio_power_transaction_handler( int requested_telephony_power_state );
static RIL_Errno qcril_qmi_nas_radio_power_wait_for_dms_service();
void qcril_qmi_nas_boot_up_optimization_state_machine(void);

RIL_Errno qcril_qmi_nas_register_for_5g_modem_vote_indication(void);

static int qcril_qmi_nas_is_considered_registered
(
    qmi_ril_nw_reg_rte_type *registered_rte
);

static RIL_Errno qcril_qmi_nas_fetch_signal_strength_observations(void);
static RIL_Errno qcril_qmi_nas_propagate_known_signal_strength_ind(void);
RIL_Errno qcril_qmi_nas_get_cell_location_data_sync( nas_get_cell_location_info_resp_msg_v01 *get_cell_location_info_resp, uint64_t *timestamp, qmi_ril_err_context_e_type context );
static void qcril_qmi_nas_queue_cell_info_poll();
void qcril_qmi_nas_cell_location_update_timer_cl( qmi_ril_cell_location_period_action action);

static int qcril_qmi_nas_is_ignore_nas_srv_domain(nas_service_status_enum_type_v01 nas_srv_status,
                                                  uint8_t srv_domain_valid,
                                                  nas_service_domain_enum_type_v01 srv_domain,
                                                  bool is_lte,
                                                  uint8_t *is_voice_supported_on_lte,
                                                  bool is_5g);
static void qcril_qmi_nas_start_srv_domain_camped_timer();
static void qcril_qmi_nas_cancel_srv_domain_camped_timer();
static void qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb(void * params);

static int qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status( uint32_t nas_sys_info_flag, nas_sys_info_helper_type * nas_sys_info_helper );
static void qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info( int is_data,
                                                                     int * res,
                                                                     nas_reg_reject_info_type_v01 * reg_reject_info,
                                                                     qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results );
static int qcril_qmi_nas_sys_info_ind_conv_qmi2ril( nas_sys_info_ind_msg_v01 * qmi_msg,
                                            int * network_state_updated,
                                            int * radio_tech_changed,
                                            int * data_nw_state_changed
                                                );
static IxErrnoType qcril_qmi_nas_update_presist_nitz_cache_shadow(char * op_name_long, char * op_name_short, char * op_mcc_str, char * op_mnc_str);
static void qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow(void);
static void qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow(void);
static IxErrnoType qcril_qmi_nas_persist_entry_fetch_to_shadow(char * op_name_to_read, size_t op_name_to_read_size, const char ** prop_name_prefix, int prop_name_prefix_domain_size, int prop_name_suffix );
static int qcril_qmi_nas_nitz_persistent_cache_is_shadow_available(void);
static void qcril_qmi_nas_update_voice_rte(void);
static void qcril_qmi_nas_update_data_rte(void);
static void qcril_qmi_nas_update_ims_rte(void);
static void qcril_qmi_sys_info_roll_details(int * rte_reg_status,
                                            int is_data,
                                            qcril_qmi_nas_srv_status_convertion_extra_results_type* extra_results_vector_param);
static int qcril_qmi_nas_util_determine_cdma_rev(nas_cdma_only_sys_info_type_v01 * cdma_details_info);
static int qcril_qmi_nas_util_determine_hdr_rev(nas_hdr_only_sys_info_type_v01 * hdr_details_info);
static int qcril_qmi_util_determine_cdma_rev_direct( uint8_t p_rev );
static void qcril_qmi_nas_query_cur_power_state(int * op_mode_valid, dms_operating_mode_enum_v01 * op_mode);
static RIL_Errno qcril_qmi_nas_set_nw_select_state(qmi_ril_nas_nw_select_state_e_type new_state);
static qmi_ril_nas_nw_select_state_e_type qcril_qmi_nas_get_nw_select_state(void);
static void qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb
        (
          qmi_client_type                user_handle,
          unsigned int                   message_id,
          void                          *ind_buf,
          unsigned int                   ind_buf_len,
          void                          *ind_cb_data
        );
static void qcril_qmi_nas_nw_select_timeout_handler();
static void qcril_qmi_nas_nw_select_timeout_cb(void * params);
static void qcril_qmi_nas_nw_select_limited_timeout_cb(void * params);
static void qcril_qmi_nas_select_nw_conclusion_check(void);
void qcril_qmi_nas_attach_timeout_handler(void *param);
qmi_ril_nas_attch_state_e_type qcril_qmi_nas_get_attch_state();
static int qcril_qmi_nas_find_current_mcc_mnc
(
    char * mcc_str_ptr,
    char * mnc_str_ptr,
    int is_full_service_required,
    nas_radio_if_enum_v01 *plmn_rat
);

static void qcril_qmi_util_proper_network_status_notify_for_plmn(char *mcc_str, char *mnc_str, qcril::interfaces::NetworkStatus nw_status, std::vector<qcril::interfaces::NetworkInfo>& list);
static void qcril_qmi_util_proper_network_status_notify_for_plmn(char *mcc_str, char *mnc_str, int no_of_entries, char *nw_status, qcril_qmi_nw_scan_resp_helper_type  * unique_network_scan_plmns_table, int no_of_unique_network_scan_plmns);
static void qcril_qmi_nas_evaluate_sglte_current_eons_rte();
static int qcril_qmi_nas_is_radio_if_plmn_available(uint8_t radio_if);
static void qmi_ril_nwr_update_reg_rej_from_sys_info(void);
static void qmi_ril_nwr_util_log_mccmnc_str(const char * ctx, char *mcc_or_mnc_arr);
static int qmi_ril_nwr_conv_reg_reject_cause_voice(uint8_t org_cause, uint8_t radio_if);
static int qmi_ril_nwr_conv_reg_reject_cause_data(uint8_t org_cause, uint8_t radio_if);
static int qmi_ril_nwr_conv_reg_reject_cause_lte(uint8_t org_cause);
static int qmi_ril_nwr_is_mcc_or_mnc_empty(char * mcc_or_mnc_str);

static void qcril_qmi_nas_retranslate_cs_ps_bar_info_handler(void * param);
static void qcril_qmi_nas_fill_up_restricted_state_details(nas_gw_sys_info3_type_v01 * cs_gw_sys_info3,
                                                           nas_gw_sys_info3_type_v01 * ps_gw_sys_info3,
                                                           int * restricted_state_details);
static void qcril_qmi_nas_dms_op_state_update_handler(dms_operating_mode_enum_v01 new_op_state);
static IxErrnoType qcril_qmi_nas_radio_power_process_condition_wait_helper();
static void qmi_ril_process_oem_hook_shutdown(void * param);
static void qcril_qmi_nas_log_radio_power_process_state(int requested_telephony_power_state,qmi_ril_dms_radio_pwr_state_e_type cur_state);
static RIL_Errno qcril_qmi_nas_radio_power_handle_card_transition( int requested_telephony_power_state );
static RIL_Errno qcril_qmi_nas_radio_power_handle_modem_transition( int requested_telephony_power_state, int* p_op_mode_change_needed);
static int qcril_qmi_nas_is_mcc_mnc_wildcard_entry(char *mcc, char *mnc);
static void qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper(char *mcc, char *mnc);
static void qcril_qmi_nas_fillup_mcc_mnc_helper(char *src_arr, char *dest_str);
static RIL_Errno qcril_qmi_nas_dms_fetch_cur_prl_version(uint16_t * prl_version);
static void qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed(void);
static void qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp(void*);
static void qcril_qmi_nas_dms_update_ap_sw_ver_info_to_modem(void);
static int qcril_qmi_nas_is_mcc_mnc_info_available();
static RIL_Errno qcril_qmi_nas_fetch_system_info_helper();
static nas_service_status_enum_type_v01 qcril_qmi_util_retrieve_srv_status(nas_sys_info_helper_type * nas_sys_info_helper, int is_3gpp);
static uint8 qcril_qmi_nas_is_voip_enabled();
static RIL_Errno qcril_qmi_nas_embms_fetch_embms_status();
static void qcril_qmi_nas_embms_txn_enable_act( qmi_ril_embms_op_enable_transaction_command_e_type command, RIL_Errno status, void* extra );
static void qcril_qmi_nas_embms_set_enable_timeout_handler_handler(void * param);
static void qcril_qmi_nas_embms_set_enable_cmd_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
);

static void qcril_qmi_nas_embms_embms_status_ind_handler(nas_embms_status_ind_msg_v01* status_ind);
static void qcril_qmi_nas_embms_embms_status_ind_handler_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_enable_data_con_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_txn_disable_act( qmi_ril_embms_op_disable_transaction_command_e_type command, RIL_Errno status, void* extra );
static void qcril_qmi_nas_embms_set_disable_cmd_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
);

static void qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_disable_data_ind_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void  qcril_qmi_nas_embms_set_disable_timeout_handler_handler(void * param);
static void qcril_qmi_nas_embms_enable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_disable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params);


static RIL_RadioTechnology qcril_qmi_get_voice_radio_technology();
static RIL_RadioTechnology qcril_qmi_convert_rte_to_radio_technology(qmi_ril_nw_reg_rte_type rte);
static int qcril_qmi_nas_fetch_mode_pref(mode_pref_mask_type_v01 *mode_pref);


static void qcril_qmi_dms_set_simo_cs_ps_property(dms_simul_voice_and_data_capability_mask_v01 simul_cap);

static void qcril_qmi_dms_save_prl_info(int prl_version_is_set, uint16_t prl_version);
static void qcril_qmi_nas_force_network_search();
static int qmi_ril_nwr_map_roam_status_from_qmi_to_android( nas_roam_status_enum_type_v01 qmi_roam_status );
static void qcril_qmi_nas_update_radio_power_request_info();
static int qcril_qmi_nas_is_bootup_radio_power_off_request();
static void qcril_qmi_nas_handle_multiple_rild_radio_power_sync(int requested_telephony_power_state);
static void qcril_qmi_nas_multiple_rild_radio_power_timeout_cb(void * param);

static void qcril_qmi_nas_evaluate_voice_rte_propagation();

static void qcril_qmi_nas_report_eutra_status(nas_eutra_cell_status_enum_type_v01 * eutra_status);
static void qcril_qmi_nas_dms_handle_prl_change_helper();

static void qmi_ril_nw_reg_snapshot_dump_log( qmi_ril_nw_reg_rte_snapshot_type* snapshot );
static void qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler(void * param);
// NAS REFACTOR static void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler(void * param);
// NAS REFACTOR static void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler(void * param);
static void qmi_ril_nw_reg_update_sys_info_cache_from_ind( nas_sys_info_ind_msg_v01 * qmi_msg );
static int qcril_qmi_nas_util_check_request_need(qcril_arb_pref_data_tech_e_type pref_data_tech, qmi_ril_nw_reg_rte_type drte);
static int qcril_qmi_nas_util_check_roaming_status(qcril_arb_pref_data_tech_e_type pref_data_tech, int * data_reg_status, int *confident_response );
static int qcril_qmi_nas_decide_data_roam_status(qcril_arb_pref_data_tech_e_type pref_data_tech, int *reg_state);
static int qcril_qmi_util_prefer_spn_over_plmn_name(int is_spn_present, int is_plmn_name_present, int is_nw_scan, char *mcc, char *mnc);
static int qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(char *mcc_str, char *mnc_str, char *short_eons, char *long_eons, qcril_qmi_nw_scan_resp_helper_type * unique_network_scan_plmns_table, int no_of_unique_network_scan_plmns);
static int qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(char *mcc_str, char *mnc_str, char *short_eons, char *long_eons, std::vector<qcril::interfaces::NetworkInfo>& list);
static int qcril_qmi_ril_domestic_service_is_power_save_enabled();
static void qmi_ril_nw_reg_redo_reg_report(void * param);
static void qmi_ril_nw_reg_redo_data_reg_report(void * param);
static qmi_ril_nw_reg_rte_type qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(qcril_arb_pref_data_tech_e_type pref_data_tech);
static void qmi_ril_nw_reg_refresh_cache_main_thrd(void * param);
static int qcril_qmi_nas_is_data_nw_state_updated(nas_sys_info_ind_msg_v01 * qmi_msg);
static void qmi_ril_nw_reg_extend_pref_data_tech_cl( qcril_arb_pref_data_type * pref_data, int * is_extrapolation, int * extrapolation_is_roaming );
static void qcril_qmi_nas_restricted_state_handle_event( qmi_ril_nas_restricted_details_event_e_type event );
static void qcril_qmi_nas_calculate_restricted_details(int * restricted_details);
static void qcril_qmi_nas_report_restricted_details(int restricted_details);
static void qcril_qmi_nas_retranslate_cs_ps_bar_info_handler(void * param);

static void qmi_ril_nwr_reg_reject_init(void);
static void qmi_ril_nwr_reg_reject_tmr_expiry(qcril_timed_callback_handler_params_type * handler_params);
static void qmi_ril_nwr_reg_reject_post_refresher(qcril_timed_callback_handler_params_type * handler_params);
static void qmi_ril_nwr_reg_reject_handle_event_cl( qmi_ril_nw_reg_rte_kind_type rte_kind, qmi_ril_nw_reg_rte_type rte, qmi_ril_reg_reject_perception_event_e_type evt );
static void qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl( void );
static void qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl( void );
static void qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search( void );
static void qmi_ril_nwreg_enforce_voice_ind_as_applicable_ncl( void );

static void qcril_qmi_nas_set_builtin_plmn_list_ind_handler(nas_set_builtin_plmn_list_ind_msg_v01 * plmn_list_ind);

static int qmi_ril_nwreg_spawn_snapshot_timer_cl( int is_maintanance );

static void qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired(void * param);

static qmi_ril_embms_coverage_state_e_type qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(
        nas_lte_rrc_embms_coverage_status_enum_v01 qmi_embms_coverage);


static void qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed
(
    uint8_t prev_lte_embms_coverage_valid,
    uint8_t prev_lte_embms_coverage,
    uint8_t prev_embms_coverage_status_valid,
    nas_lte_rrc_embms_coverage_status_enum_v01 prev_embms_coverage_status
);

static void qcril_qmi_nas_embms_send_cell_info_changed_if_needed(boolean prev_lte_sys_info_valid, const nas_lte_sys_info_type_v01* prev_lte_sys_info);
static void qcril_qmi_nas_embms_send_e911_state_changed_if_needed
(
    uint8_t new_mode_valid,
    uint8_t new_mode
);

void qcril_qmi_nas_get_subscription_info();
int qcril_qmi_dms_construct_modem_cap_response(uint8_t * resp_byte_stream);
void qcril_qmi_nas_send_unsol_modem_capability();
uint32_t qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();
uint32_t qcril_qmi_dms_convert_sub_capability_to_ril_radio_family();
void qcril_qmi_nas_fm_handle_start_cmd ( int modem_stack_id, std::shared_ptr<RilRequestSetRadioCapMessage> msg );
void qcril_qmi_nas_fm_handle_apply_cmd ( int modem_stack_id, std::shared_ptr<RilRequestSetRadioCapMessage> msg );
void qcril_qmi_nas_fm_handle_finish_cmd ( int modem_stack_id, int status, std::shared_ptr<RilRequestSetRadioCapMessage> msg );
qcril_modem_stack_id_e_type qcril_qmi_get_modem_stack_id();

static void qcril_qmi_nas_process_custom_emergency_numbers();
static void* qcril_qmi_nas_process_custom_emergency_numbers_helper(qmi_ril_custom_emergency_numbers_source_type source, int *number_of_tuples);
static void qcril_qmi_nas_cleanup_custom_emergency_numbers();
static int qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers
(
    char *number,
    char *mcc,
    qmi_ril_custom_emergency_numbers_source_type source
);

static int qcril_qmi_nas_retrieve_number_of_tuples(char *emergency_list);
static char* qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value
(
    char *property_prefix,
    char *fallback_property_prefix
);
static void qcril_qmi_nas_cleanup_custom_emergency_numbers_helper(void * emergency_numbers, int is_cleanup_table, int *number_of_tuples);
static void qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc();
static void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card(const qcril_request_params_type *const params_ptr, boolean ensure_fresh_check);
static void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw(boolean ensure_fresh_check);

static int qcril_qmi_nas_retrieve_scan_network_type(nas_network_type_mask_type_v01 *scan_network_type, uint8_t is_incremental_scan);
static void qcril_qmi_nas_wait_for_pbm_ind_timeout_cb(void * params);
static void qcril_qmi_nas_eme_call_end_recently_timeout_cb(void * params);

static void qmi_ril_report_data_connection_information(void * param);
#if 0
static int qmi_ril_retrieve_data_connection_information_from_data_call_list(int *nof_data_calls, qcril_qmi_nas_dc_rt_info_helper_type **data_call_real_time_info_list);
#endif

static void qcril_qmi_nas_fetch_sib16_network_time
(
   bool time_zone_valid,
   int8_t time_zone,
   bool daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
);

static void qcril_qmi_nas_process_sib16_network_time
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
);
static void qcril_qmi_nas_process_sib16_network_time_for_ats_utc
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
);
static void qcril_qmi_nas_process_sib16_network_time_for_ats_modem(uint64_t abs_time);

static void qcril_qmi_nas_sib16_network_time_ind_hdlr(const nas_lte_sib16_network_time_ind_msg_v01* decoded_payload);

static void qcril_qmi_nas_get_field_test_mode_info_for_cdma( struct cdma_ftm_data *cdma_data);
static void qcril_qmi_nas_get_field_test_mode_info_for_gsm( struct gsm_ftm_data *gsm_data);
static void qcril_qmi_nas_get_field_test_mode_info_for_wcdma( struct wcdma_ftm_data *wcdma_data);

static uint64_t qcril_qmi_nas_convert_julian_time_to_abs_time(uint16_t year, uint8_t month, uint8_t day,
                                                              uint8_t hour, uint8_t minute, uint8_t second, uint16_t milli_second);
void qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(uint8_t prev_lte_sib16_coverage_valid,
                                                       uint8_t prev_lte_sib16_coverage,
                                                       uint8_t curr_lte_sib16_coverage_valid,
                                                       uint8_t curr_lte_sib16_coverage);

static void qcril_qmi_nas_data_update_mtu_size_if_needed(uint8_t prev_reported_state_valid,
                                                         int prev_reported_state,
                                                         uint8_t prev_reported_tech_valid,
                                                         int prev_reported_tech);

static void qcril_qmi_nas_perform_incremental_network_scan_ind_handler
(
    nas_perform_incremental_network_scan_ind_msg_v01 * nw_scan_ind
);

static void qcril_qmi_nas_get_serv_cell_sib_ind_handler
(
    nas_get_serv_cell_sib_ind_msg_v01 * serv_cell_sib_ind
);

static qmi_ril_nw_reg_rte_type qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name_info
(
    qmi_ril_nw_reg_rte_type  registered_rtes[QMI_RIL_RTE_LAST]
);

static void qcril_qmi_nas_get_ssac_change_info_ind_handler
(
    nas_ssac_change_info_ind_msg_v01 * ssac_change_info
);

static void qcril_qmi_nas_vops_info_ind_handler(bool value);

RIL_Errno qcril_qmi_nas_embms_parse_embms_plmn
(
   qcril_binary_data_type bin_data,
   uint32_t max_plmn_len,
   uint32_t *plmn_len,
   embms_plmn_type_v01 plmn[]
);

static void qcril_qmi_nas_info_flexmap_status(NasFlexmapState state);

static void qcril_qmi_nas_send_enable_indications(int state);

static void qcril_qmi_nas_start_apm_leave_timer();
static void qcril_qmi_nas_clear_apm_leave_timer();
static void qcril_qmi_nas_apm_leave_timeout_handler(void* params);

int qcril_qmi_nas_fetch_imsi_from_cache_or_iccid(uint32 *cur_status);

void qcril_qmi_dms_get_msisdn_resp_hldr
(
    const qcril_request_params_type *const param_ptr
);

void qcril_qmi_nas_embms_set_enable_cmd_cb_helper_handler
(
   qcril_timed_callback_handler_params_type *handler_params
);

RIL_Errno qcril_qmi_nas_request_shutdown_helper
(
    std::shared_ptr<RilRequestShutDownMessage> msg
);

void onRequest
(
  qcril_instance_id_e_type  instance_id,
  int                       request,
  void                      *data,
  size_t                    datalen,
  RIL_Token                 t
);

static void qcril_qmi_nas_gcell_info_ind_handler
(
    nas_gcell_info_ind_v01 * gcell_info_ind
);

boolean qcril_qmi_nas_check_fake_bs
(
    nas_gcell_info_ind_v01 * gcell_info_ind
);

boolean qcril_qmi_nas_log_fake_bs
(
    geran_grr_gcell_identifier_s_v01    uid_camped_cell
);

void qcril_qmi_nas_trigger_polling_operating_mode();
void qcril_qmi_nas_poll_operating_mode_handler(void *params);
dms_operating_mode_enum_v01 qcril_qmi_nas_dms_get_current_operating_mode();

boolean qcril_qmi_nas_read_unicode_operator_names(nas_get_plmn_name_resp_msg_v01 *, char *, size_t ,char *, size_t);

RIL_Errno qcril_qmi_nas_retrieve_opl_pnn_or_spn
(
    char *short_eons,
    size_t short_eons_sz,
    char *long_eons,
    size_t long_eons_sz,
    char *card_mcc_str,
    char *card_mnc_str
);

static void qcril_qmi_nas_respond_to_last_modem_shutdown_request(
    RIL_Errno ril_req_res);

static inline bool qcril_qmi_nas_is_card_shutdown_required();

static inline bool qcril_qmi_nas_request_data_shutdown();

static void qcril_qmi_nas_notify_ims_shutdown_timeout(void *param);
static RIL_Errno qcril_qmi_nas_enforce_modem_stack_status(void);
static RIL_Errno qcril_qmi_nas_enable_modem_stack_helper(bool, bool&);

//===========================================================================
// qcril_qmi_nas_dms_commmon_pre_init
//===========================================================================
void qcril_qmi_nas_dms_commmon_pre_init()
{
    QCRIL_LOG_FUNC_ENTRY();
    nas_cached_info.old_lte_ims_voice_avail = NAS_INVALID_VOPS;
    nas_cached_info.embms_ssr_in_progress = FALSE;
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_dms_commmon_post_init
//===========================================================================
void qcril_qmi_nas_dms_commmon_post_init()
{
    QCRIL_LOG_FUNC_ENTRY();
    //TODO: NAS-DATA:Evaluate and remove this function if necessary.
    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_dms_commmon_post_init

boolean qcril_qmi_nas_is_sim_provisioned()
{
    boolean res;

    NAS_CACHE_LOCK();
    res = nas_common_info.sim_provisioned;
    NAS_CACHE_UNLOCK();

    return res;
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_update_iccid_from_uim

===========================================================================*/
/*!
    @brief
    Function that reads the ICCID from the SIM Card

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_nas_update_iccid_from_uim
(
  int slot
)
{
    auto                    iccid_ptr = std::make_shared<UimGetIccIdRequestSyncMsg>(slot);
    std::shared_ptr<string> respPtr   = NULL;

    QCRIL_LOG_DEBUG("%s", __FUNCTION__);

    if (iccid_ptr == NULL ||
        iccid_ptr->dispatchSync(respPtr) != Message::Callback::Status::SUCCESS ||
        respPtr == NULL)
    {
        QCRIL_LOG_ERROR("Failed to get iccid through SIM_IO");
        NAS_CACHE_LOCK();
        memset(nas_common_info.card_info[slot].iccid_from_uim, 0x0,
               sizeof(nas_common_info.card_info[slot].iccid_from_uim));
        nas_common_info.card_info[slot].iccid_len_from_uim = 0;
        NAS_CACHE_UNLOCK();
    }
    else
    {
        NAS_CACHE_LOCK();
        strlcpy(nas_common_info.card_info[slot].iccid_from_uim, respPtr->c_str(),
                    QMI_DMS_UIM_ID_MAX_V01 + 1);
        nas_common_info.card_info[slot].iccid_len_from_uim = respPtr->length();
        nas_common_info.card_info[slot].mcc_from_iccid = qcril_qmi_nas2_retrieve_mcc_from_iccid((char *)respPtr->c_str());
        QCRIL_LOG_DEBUG("mcc_from_iccid = <%s>", nas_common_info.card_info[slot].mcc_from_iccid? "xxxx" : "NULL");
        NAS_CACHE_UNLOCK();
    }
} /* qcril_qmi_nas_update_iccid_from_uim */

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_update_prov_iccid

===========================================================================*/
/*!
    @brief
    Send updated iccid to prov module.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_nas_update_prov_iccid
(
  int slot
)
{
    char iccid[QMI_DMS_UIM_ID_MAX_V01 + 1];

    memset(iccid,0,sizeof(iccid));

    strlcpy(iccid,
            nas_common_info.card_info[slot].iccid_from_uim,
            sizeof(iccid));

    qcril_event_queue(QCRIL_DEFAULT_INSTANCE_ID,
                      QCRIL_DEFAULT_MODEM_ID,
                      QCRIL_DATA_ON_STACK,
                      QCRIL_EVT_QMI_PROV_UPDATE_ICCID,
                      iccid,
                      sizeof(iccid),
                      (RIL_Token)QCRIL_TOKEN_ID_INTERNAL);
} /* qcril_qmi_nas_update_prov_iccid */

void qcril_qmi_nas_shutdown_monitor_action(const char *property_name, size_t name_size, const char *value, size_t value_size)
{
    QCRIL_LOG_INFO("Property %s updated. New value: %s", property_name, value);
    int arguments_valid = property_name != NULL && name_size > 0 && value_size > 0 && value != NULL;
    if (qcril_qmi_nas_dms_is_in_ftm_mode() && arguments_valid && isdigit(value[0]))
    {
        QCRIL_LOG_INFO("Detected shutdown");
        std::shared_ptr<MessageContext> ctx =
            std::make_shared<MessageContext>(qmi_ril_get_process_instance_id());
        auto msg = std::make_shared<RilRequestShutDownMessage>(ctx);
        qcril_qmi_nas_request_shutdown_helper(msg);
    }
}

void *qcril_qmi_nas_shutdown_monitor_thread(void *args)
{
#ifndef QMI_RIL_UTF
    unsigned int state = 0;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(args);
    QCRIL_LOG_INFO("Waiting for shutdown property update");
    while(1)
    {
        state = qmi_ril_wait_for_properties(state, qcril_qmi_nas_shutdown_monitor_action, QMI_RIL_SHUTDOWN_PROPERTY, NULL);
    }
#endif

    return NULL;
}

void qcril_qmi_nas_monitor_shutdown()
{
    int rc = 0;
    NAS_CACHE_LOCK();
    if (!nas_common_info.shutdown_monitor_thread_valid)
    {
        rc = pthread_create(
                &nas_common_info.shutdown_monitor_thread,
                NULL,
                qcril_qmi_nas_shutdown_monitor_thread,
                NULL);
        if (!rc)
        {
            nas_common_info.shutdown_monitor_thread_valid = TRUE;
        }
        else
        {
            QCRIL_LOG_ERROR("Unable to create shutdown monitor thread");
        }
    }
    NAS_CACHE_UNLOCK();
}
//===========================================================================
// qcril_qmi_nas_pre_init
//===========================================================================
void qcril_qmi_nas_pre_init()
{
    int temp_len;
    unsigned long ret_val;
    uint64_t ret_value;
    char property_name[ PROPERTY_NAME_MAX ];
    char args[ PROPERTY_VALUE_MAX ];
    char *end_ptr;

    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_nas_dms_commmon_pre_init();

    NAS_CACHE_LOCK();

    // read from properties and db settings
#ifdef QMI_RIL_UTF
    nas_common_info.is_screen_off = FALSE;
#endif
    nas_common_info.ct_operator_name = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_OPERATOR_PROP );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      nas_common_info.ct_operator_name = !strncmp( args, QCRIL_CT_OPERATOR_NAME, strlen( QCRIL_CT_OPERATOR_NAME ));
    }
    else
    {
      QCRIL_LOG_ERROR( "QCRIL_OPERATOR_NAME is %s,  property_name is %s. Failed to get operator name\n", QCRIL_OPERATOR_PROP, property_name );
    }
    QCRIL_LOG_DEBUG( "CT Operator name =%d", nas_common_info.ct_operator_name);

    nas_common_info.apm_sim_not_pwdn = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_APM_SIM_NOT_PWDN );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert APM_SIM_NOT_PWDN %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved APM_SIM_NOT_PWDN %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.apm_sim_not_pwdn = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "APM_SIM_NOT_PWDN=%d", nas_common_info.apm_sim_not_pwdn);

    nas_common_info.add_power_save_enabled = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ADD_POWER_SAVE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert ADD_POWER_SAVE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved ADD_POWER_SAVE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.add_power_save_enabled = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_INFO( "ADD_POWER_SAVE=%d", nas_common_info.add_power_save_enabled);

    nas_common_info.force_nw_search = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_FORCE_NW_SEARCH );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert FORCE_NW_SEARCH %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved FORCE_NW_SEARCH %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.force_nw_search = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "FORCE_NW_SEARCH=%d", nas_common_info.force_nw_search);

    nas_common_info.voice_support_on_lte       = NAS_NIL;
    nas_common_info.voice_support_on_lte_valid = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_VOICE_SUPPORT_ON_LTE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert VOICE_SUPPORT_ON_LTE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved VOICE_SUPPORT_ON_LTE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.voice_support_on_lte       = ( uint8 ) ret_val;
        nas_common_info.voice_support_on_lte_valid = TRUE;
      }
    }
    QCRIL_LOG_DEBUG( "VOICE_SUPPORT_ON_LTE=%d", nas_common_info.voice_support_on_lte);

    nas_common_info.always_report_restricted_state = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ALWAYS_REPORT_RESTRICTED_STATE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert QCRIL_ALWAYS_REPORT_RESTRICTED_STATE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved QCRIL_ALWAYS_REPORT_RESTRICTED_STATE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.always_report_restricted_state = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "QCRIL_ALWAYS_REPORT_RESTRICTED_STATE=%d", nas_common_info.always_report_restricted_state);


    nas_common_info.fill_eons = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_FILL_EONS );
    property_get( property_name, args, "1" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert FILL_EONS %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved FILL_EONS %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.fill_eons = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "FILL_EONS=%d", nas_common_info.fill_eons);

    nas_common_info.limit_sys_info_logic_change = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_LIMIT_SYS_INFO );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert limit_sys_info %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid value %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.limit_sys_info_logic_change = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "limit_sys_info=%d", nas_common_info.limit_sys_info_logic_change);

    nas_common_info.no_wait_for_card = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_NO_WAIT_FOR_CARD );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert NO_WAIT_FOR_CARD %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved NO_WAIT_FOR_CARD %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.no_wait_for_card = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "NO_WAIT_FOR_CARD=%d", nas_common_info.no_wait_for_card);

    nas_common_info.data_snapshot_timer_value       = NAS_NIL;
    nas_common_info.data_snapshot_timer_value_valid = TRUE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SNAPSHOT_TIMER_VALUE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert SNAPSHOT_TIMER %s", args );
      }
      else
      {
        nas_common_info.data_snapshot_timer_value = ( uint8 ) ret_val;
        nas_common_info.data_snapshot_timer_value_valid = TRUE;
      }
    }
    QCRIL_LOG_DEBUG( "SNAPSHOT_TIMER=%d", nas_common_info.data_snapshot_timer_value);

    nas_common_info.data_snapshot_feature_enabled = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SNAPSHOT_FEATURE_ENABLED );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert SNAPSHOT_FEATURE_ENABLED %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved SNAPSHOT_FEATURE_ENABLED %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.data_snapshot_feature_enabled = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "SNAPSHOT_FEATURE_ENABLED=%d", nas_common_info.data_snapshot_feature_enabled);

    nas_common_info.receive_data_dormancy_ind = QMI_RIL_NAS_RECEIVE_DATA_DORMANCY_IND_ON_SCREEN_STATE;
    property_get( QCRIL_RECEIVE_DATA_DORMANCY_IND, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      if(!strcmp(args, "on"))
      {
        nas_common_info.receive_data_dormancy_ind = QMI_RIL_NAS_RECEIVE_DATA_DORMANCY_IND_ON;
      }
      else if(!strcmp(args,"on_screen_state"))
      {
        nas_common_info.receive_data_dormancy_ind =
                QMI_RIL_NAS_RECEIVE_DATA_DORMANCY_IND_ON_SCREEN_STATE;
      }
      else if(!strcmp(args, "off"))
      {
        nas_common_info.receive_data_dormancy_ind = QMI_RIL_NAS_RECEIVE_DATA_DORMANCY_IND_OFF;
      }
    }
    QCRIL_LOG_DEBUG( "RECEIVE_DATA_DORMANCY_IND=%d",
                     nas_common_info.receive_data_dormancy_ind);

    nas_common_info.data_limited_sys_ind_toggle = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_DATA_LTD_SYS_IND);
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert DATA_LIMITED_SYS_IND_TOGGLE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved DATA_LIMITED_SYS_IND_TOGGLE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.data_limited_sys_ind_toggle = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "DATA_LIMITED_SYS_IND_TOGGLE=%d",
                     nas_common_info.data_limited_sys_ind_toggle);

    nas_common_info.use_se_table_only = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_USE_SE_TABLE_ONLY );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert USE_SE_TABLE_ONLY %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved USE_SE_TABLE_ONLY %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.use_se_table_only = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "USE_SE_TABLE_ONLY=%d", nas_common_info.use_se_table_only);

    nas_common_info.get_mode_pref_from_nv_10 = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_GET_MODE_PREF_FROM_NV_10 );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert GET_MODE_PREF_FROM_NV_10 %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved GET_MODE_PREF_FROM_NV_10 %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.get_mode_pref_from_nv_10 = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "GET_MODE_PREF_FROM_NV_10=%d", nas_common_info.get_mode_pref_from_nv_10);


    nas_common_info.custom_emergency_numbers_enabled = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_ENABLED );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert CUSTOM_EMERGENCY_NUMBERS_ENABLED %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved CUSTOM_EMERGENCY_NUMBERS_ENABLED %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.custom_emergency_numbers_enabled = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "CUSTOM_EMERGENCY_NUMBERS_ENABLED=%d", nas_common_info.custom_emergency_numbers_enabled );

    nas_common_info.custom_emergency_numbers_enabled_for_nw = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_CUSTOM_NW_EMERGENCY_NUMBERS_ENABLED );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert CUSTOM_NW_EMERGENCY_NUMBERS_ENABLED %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved CUSTOM_NW_EMERGENCY_NUMBERS_ENABLED %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.custom_emergency_numbers_enabled_for_nw = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "CUSTOM_NW_EMERGENCY_NUMBERS_ENABLED=%d", nas_common_info.custom_emergency_numbers_enabled_for_nw );

    nas_common_info.eri_64_home = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ERI_64_HOME );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert ERI_64_HOME %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved ERI_64_HOME %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.eri_64_home = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "ERI_64_HOME=%d", nas_common_info.eri_64_home);

    nas_common_info.prefer_spn_over_plmn_name = QMI_RIL_NAS_DO_NOT_PREFER_SPN;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_PREFER_SPN_OVER_PLMN_NAME );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert PREFER_SPN_OVER_PLMN_NAME %s", args );
      }
      else if ( ret_val >= QMI_RIL_NAS_PREFER_MAX_VALUE )
      {
        QCRIL_LOG_ERROR( "Invalid saved PREFER_SPN_OVER_PLMN_NAME %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.prefer_spn_over_plmn_name = (qmi_ril_nas_spn_plmn_name_preference_e_type)ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "PREFER_SPN_OVER_PLMN_NAME=%d", nas_common_info.prefer_spn_over_plmn_name );

    nas_common_info.always_send_plmn_name = FALSE;
    qmi_ril_get_property_value_from_boolean( QMI_RIL_ALWAYS_SEND_PLMN_NAME,
                                             (boolean *)&nas_common_info.always_send_plmn_name,
                                             FALSE );
    QCRIL_LOG_DEBUG( "ALWAYS SEND PLMN NAME=%d", nas_common_info.always_send_plmn_name);

    nas_common_info.force_no_srv_on_rej_reject_17 = FALSE;
    qmi_ril_get_property_value_from_boolean( QMI_RIL_FORCE_NO_SRV_ON_REJ_REJCT_17,
                                             (boolean *)&nas_common_info.force_no_srv_on_rej_reject_17,
                                             FALSE );
    QCRIL_LOG_DEBUG( "FORCE NO SRV ON REJ REJECT CAUSE 17=%d", nas_common_info.force_no_srv_on_rej_reject_17);

    nas_common_info.process_duplicate_nw_scan_names = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_PROCESS_DUPLICATE_NW_SCAN_NAMES );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert PROCESS_DUPLICATE_NW_SCAN_NAMES %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved PROCESS_DUPLICATE_NW_SCAN_NAMES %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.process_duplicate_nw_scan_names = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "PROCESS_DUPLICATE_NW_SCAN_NAMES=%d", nas_common_info.process_duplicate_nw_scan_names );

    nas_common_info.sglte_eons_is_domain_cs = TRUE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SGLTE_EONS_PREF_DOMAIN_PROPERTY );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      if(!strcmp(args, "ps"))
      {
        nas_common_info.sglte_eons_is_domain_cs = FALSE;
      }
      nas_common_info.sglte_eons_is_set = TRUE;
    }
    QCRIL_LOG_DEBUG( "SGLTE_EONS_PREF_DOMAIN_PROPERTY=%d", nas_common_info.sglte_eons_is_domain_cs );

    nas_common_info.sglte_eons_is_roam_enabled = TRUE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SGLTE_EONS_PREF_ROAMING_PROPERTY );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      if(!strcmp(args, "false"))
      {
          nas_common_info.sglte_eons_is_roam_enabled = FALSE;
      }
      nas_common_info.sglte_eons_is_set = TRUE;
    }

    QCRIL_LOG_DEBUG( "SGLTE_EONS_PREF_ROAMING_PROPERTY=%d", nas_common_info.sglte_eons_is_roam_enabled );

    nas_common_info.prov_emer_call_in_lpm = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_PROVISION_EMERGENCY_CALL_IN_LPM );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert PROVISION_EMERGENCY_CALL_IN_LPM %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved PROVISION_EMERGENCY_CALL_IN_LPM %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.prov_emer_call_in_lpm = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "PROVISION_EMERGENCY_CALL_IN_LPM=%d", nas_common_info.prov_emer_call_in_lpm );

    nas_common_info.relay_oprt_change = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_RELAY_OPRT_CHANGE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert RELAY_OPRT_CHANGE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved RELAY_OPRT_CHANGE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.relay_oprt_change = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "RELAY_OPRT_CHANGE=%d", nas_common_info.relay_oprt_change );

    nas_common_info.consider_lte_ltd_srv_vrte_update = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_CONSIDER_LTE_LTD_SRV_VRTE_UPDATE );
    property_get( property_name, args, "1" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert CONSIDER_LTE_LTD_SRV_VRTE_UPDATE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved CONSIDER_LTE_LTD_SRV_VRTE_UPDATE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.consider_lte_ltd_srv_vrte_update = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "CONSIDER_LTE_LTD_SRV_VRTE_UPDATE=%d", nas_common_info.consider_lte_ltd_srv_vrte_update);

    nas_common_info.consider_3gpp_ltd_srv_drte_update = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.consider_3gpp_ltd_srv_drte_update = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE=%d", nas_common_info.consider_3gpp_ltd_srv_drte_update);

    nas_common_info.do_not_consider_managed_roam = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_DO_NOT_CONSIDER_MANAGED_ROAM );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert DO_NOT_CONSIDER_MANAGED_ROAM %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved DO_NOT_CONSIDER_MANAGED_ROAM %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.do_not_consider_managed_roam = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "DO_NOT_CONSIDER_MANAGED_ROAM=%d", nas_common_info.do_not_consider_managed_roam);

    nas_common_info.wait_for_pbm_ind = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_WAIT_FOR_PBM_IND );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert WAIT_FOR_PBM_IND %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved WAIT_FOR_PBM_IND %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.wait_for_pbm_ind = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "WAIT_FOR_PBM_IND=%d", nas_common_info.wait_for_pbm_ind);

    nas_common_info.wait_for_pbm_ind_timer = QMI_RIL_WAIT_FOR_PBM_IND_TIMER_DEFAULT; //default timer value is 90 seconds
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_WAIT_FOR_PBM_IND_TIMER );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert WAIT_FOR_PBM_IND_TIMER %s", args );
      }
      else
      {
        nas_common_info.wait_for_pbm_ind_timer = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "WAIT_FOR_PBM_IND_TIMER=%d", nas_common_info.wait_for_pbm_ind_timer);

    nas_common_info.wait_time_for_fake_ecc = QMI_RIL_WAIT_TIME_FOR_FAKE_ECC_DEFAULT;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_WAIT_TIME_FOR_FAKE_ECC );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert WAIT_TIME_FOR_FAKE_ECC %s", args );
      }
      else
      {
        nas_common_info.wait_time_for_fake_ecc = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "WAIT_TIME_FOR_FAKE_ECC=%d", nas_common_info.wait_time_for_fake_ecc);




    nas_common_info.sib16_support = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SIB16_SUPPORT );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert SIB16_SUPPORT %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved SIB16_SUPPORT %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.sib16_support = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "SIB16_SUPPORT=%d", nas_common_info.sib16_support);

    nas_common_info.permanent_lte_band_pref = NAS_NIL;
    nas_common_info.permanent_lte_band_pref_valid = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_FULL_LTE_BAND_PREF);
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_value = strtoull( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_value == ULLONG_MAX) )
      {
        QCRIL_LOG_ERROR( "Fail to convert lte_full_band_pref %s", args );
      }
      else
      {
        nas_common_info.permanent_lte_band_pref = ret_value;
        nas_common_info.permanent_lte_band_pref_valid = TRUE;
      }
    }
    QCRIL_LOG_DEBUG( "valid:%d lte_full_band_pref=%llx",
        nas_common_info.permanent_lte_band_pref_valid, nas_common_info.permanent_lte_band_pref);

    qmi_ril_get_property_value_from_integer(QCRIL_RESTORE_MODE_PREF_SUPPORT,
                                            &nas_common_info.is_restore_prev_mode_pref,
                                            NAS_NIL);
    QCRIL_LOG_DEBUG( "RESTORE_MODE_PREF_SUPPORT = %d",
                     nas_common_info.is_restore_prev_mode_pref);

    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_CELL_INFO_RATE_SWEEP_LIMIT );
    property_get( property_name, args, "10000" );

    if ((strlen(args) > 0))
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Failed to convert CELL_INFO_RATE_SWEEP_LIMIT %s", args );
      }
      else if ( ret_val & 0x80000000 )
      {
        QCRIL_LOG_ERROR( "Invalid value for CELL_INFO_RATE_SWEEP_LIMIT: %s", args);
      }
      else
      {
        nas_common_info.unsol_cell_info_rate_sweep_limit = (int)ret_val;
        QCRIL_LOG_INFO("Cell Info Sweep limit: %d",
                nas_common_info.unsol_cell_info_rate_sweep_limit);
      }
    }

    nas_common_info.use_cc_names = FALSE;
    property_get( QMI_RIL_USE_STATIC_CC_OP_NAMES, args, "false" );

    if (args[0] != 0)
    {
      if (strncasecmp(args, "true", 4) == 0 || strcmp(args, "1") == 0)
      {
        nas_common_info.use_cc_names = TRUE;
      }
    }

    nas_common_info.bar_fake_gcell = FALSE;
    property_get( QMI_RIL_BAR_FAKE_GCELL, args, "false" );

    if (args[0] != 0)
    {
      if (strncasecmp(args, "true", 4) == 0 || strcmp(args, "1") == 0)
      {
        nas_common_info.bar_fake_gcell = TRUE;
      }
    }

    nas_common_info.unicode_operator_names_support = FALSE;
    qmi_ril_get_property_value_from_boolean(QMI_RIL_PLMN_UNICODE_SUPPORT,
        &nas_common_info.unicode_operator_names_support, FALSE);

    nas_common_info.is_snapshot_reported_data_reg_state = FALSE;
    qmi_ril_get_property_value_from_boolean(QMI_RIL_SNAPSHOT_DATA_ENABLED,
        &nas_common_info.is_snapshot_reported_data_reg_state, FALSE);
    QCRIL_LOG_INFO("is_snapshot_reported_data_reg_state: %d",
        nas_common_info.is_snapshot_reported_data_reg_state);

    if(nas_common_info.is_snapshot_reported_data_reg_state)
    {
        memset(&nas_cached_info.reported_data_reg_state_snapshot, 0,
            sizeof(RIL_DataRegistrationStateResponse));
        nas_cached_info.is_proper_data_reg_to_report = TRUE;
        if (NAS_NIL != nas_cached_info.reported_data_reg_expiry) //cancel timer
        {
            QCRIL_LOG_INFO("Cancelling timer");
            qcril_cancel_timed_callback((void*)(uintptr_t)
                nas_cached_info.reported_data_reg_expiry);
            nas_cached_info.reported_data_reg_expiry = NAS_NIL;
        }
        nas_common_info.reported_data_timer_value       = NAS_NIL;
        nas_common_info.reported_data_timer_value_valid = FALSE;
        qmi_ril_get_property_value_from_integer(QMI_RIL_SNAPSHOT_DATA_TIMER_VALUE,
            &nas_common_info.reported_data_timer_value, NAS_NIL);
        QCRIL_LOG_DEBUG( "reported_data_timer_value_valid=%d",
            nas_common_info.reported_data_timer_value_valid);
    }

    nas_common_info.dfr_mode_pref_set_until_online = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_DFR_MODE_PREF_SET_UNTIL_ONLINE );

    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert DFR_MODE_PREF_SET_UNTIL_ONLINE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved DFR_MODE_PREF_SET_UNTIL_ONLINE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.dfr_mode_pref_set_until_online = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "DFR_MODE_PREF_SET_UNTIL_ONLINE=%d", nas_common_info.dfr_mode_pref_set_until_online);

    nas_common_info.use_ril_3gpp_operator_table = TRUE;
    property_get( QMI_RIL_DO_NOT_USE_RIL_3GPP_OPERATOR_TABLE, args, "false" );

    if (args[0] != 0)
    {
      if (strncasecmp(args, "true", 4) == 0 || strcmp(args, "1") == 0)
      {
        nas_common_info.use_ril_3gpp_operator_table = FALSE;
      }
    }

    QCRIL_LOG_INFO("use_ril_3gpp_operator_table: %d", nas_common_info.use_ril_3gpp_operator_table);

    // check if rat tlv can be used for network selection
    qcril_db_query_properties_table(QCRIL_IS_RAT_TLV_SUPPORTED,args);
    nas_common_info.is_rat_tlv_supported = atoi(args) ? TRUE : FALSE;

    nas_common_info.is_reg_denied_on_rej_cause = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_REG_DENIED_ON_REJ_CAUSE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert REG_DENIED_ON_REJ_CAUSE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved REG_DENIED_ON_REJ_CAUSE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.is_reg_denied_on_rej_cause = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "REG_DENIED_ON_REJ_CAUSE=%d", nas_common_info.is_reg_denied_on_rej_cause);

    nas_common_info.manual_nw_reject_cause_counter_enabled = FALSE;
    qmi_ril_get_property_value_from_integer(QMI_RIL_MANUAL_NW_REJECT_COUNTER_ENABLE,
                                            &nas_common_info.manual_nw_reject_cause_counter_enabled,
                                            NAS_NIL);

    QCRIL_LOG_DEBUG("MANUAL_NW_REJECT_COUNTER_ENABLE=%d",
                     nas_common_info.manual_nw_reject_cause_counter_enabled);

    qmi_ril_get_property_value_from_integer(QMI_RIL_IGNORE_SRV_DOMAIN_CAMPED_TIMER,
                                            &nas_common_info.ignore_srv_domain_camped_timer,
                                            NAS_NIL);

    QCRIL_LOG_DEBUG("IGNORE_SRV_DOMAIN_CAMPED_TIMER=%d",
                     nas_common_info.ignore_srv_domain_camped_timer);
    nas_common_info.ignore_srv_domain_camped_timer_id_valid = FALSE;
    nas_common_info.ignore_srv_domain_camped_timer_id = NAS_NIL;
    nas_common_info.prev_srv_domain_valid = FALSE;
    nas_common_info.prev_srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;


    qcril_db_query_properties_table(QCRIL_IS_RIL_VRTE_LEARNING_ENABLED,
                                    args);

    temp_len = strlen(args);
    if (temp_len > 0)
    {
        nas_common_info.is_ril_vrte_learning_enabled = atoi(args) ? TRUE : FALSE;
    }
    else
    {
        nas_common_info.is_ril_vrte_learning_enabled = TRUE;
    }

    QCRIL_LOG_DEBUG("is_ril_vrte_learning_enabled = %d",
                     nas_common_info.is_ril_vrte_learning_enabled);

    nas_common_info.csg_info_available = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_CSG_INFO_AVAILABLE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert QCRIL_CSG_INFO_AVAILABLE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved QCRIL_CSG_INFO_AVAILABLE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.csg_info_available = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_INFO( "QCRIL_CSG_INFO_AVAILABLE=%d", nas_common_info.csg_info_available);

    qmi_ril_get_property_value_from_boolean(QMI_RIL_VOICE_SRV_TYPE,
        &nas_common_info.cs_srv_type, TRUE);
    QCRIL_LOG_DEBUG("CS_SRV_TYPE %d", nas_common_info.cs_srv_type);

    nas_common_info.is_limit_by_rac_change = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_LIMIT_RAC_CHANGE );
    property_get( property_name, args, "" );
    nas_common_info.is_limit_by_rac_change = ( (strcmp(args, "true") == 0) || (strcmp(args, "1") == 0) );
    QCRIL_LOG_DEBUG("IS LIMIT BY RAC CHANGE %d", nas_common_info.is_limit_by_rac_change);

    nas_common_info.is_feature_power_opt_enabled = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SYS_PROP_POWERON_OPT );
    property_get( property_name, args, "" );
    nas_common_info.is_feature_power_opt_enabled = ( (strcmp(args, "1") == 0) );
    QCRIL_LOG_DEBUG("Is feature Power Optimization enabled %d", nas_common_info.is_feature_power_opt_enabled);

    nas_common_info.is_feature_msim_adv_scan = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ENABLE_ADVANCED_SCAN );
    property_get( property_name, args, "" );
    nas_common_info.is_feature_msim_adv_scan = ( (strcmp(args, "true") == 0) || (strcmp(args, "1") == 0) );
    QCRIL_LOG_DEBUG("Is feature advanced scan supported %d", nas_common_info.is_feature_msim_adv_scan);

    qmi_ril_get_property_value_from_integer(QMI_RIL_1X_ROAM_MTU_SIZE,
                                            &nas_common_info.roam_mtu_size_1x,
                                            NAS_NIL);
    qcril_qmi_nas_clean_atel_ui_status_from_cache();
    qcril_qmi_nas_clean_atel_ui_ready_req_came_from_cache();
    qcril_qmi_nas_set_bootup_power_optimization_state(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_LPM);
    qcril_qmi_nas_cleanup();

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_pre_init

RIL_5G_MODE qcril_qmi_nas_get_5g_mode_pref()
{
    int five_g_mode_pref = FIVE_G_MODE_DISABLED;
    qcril_instance_id_e_type cur_proc_instance;
    char property_name[ PROPERTY_VALUE_MAX ];

    cur_proc_instance = qmi_ril_get_process_instance_id();
    snprintf( property_name, sizeof(property_name),
        "%s%d", QMI_RIL_5G_MODE_PREF, cur_proc_instance );

    // read the 5g mode preference property
    qmi_ril_get_property_value_from_integer(property_name,
                                            &five_g_mode_pref,
                                            std::numeric_limits<int>::max());

    // If the 5G mode preference property isn't set, fallback to the
    // legacy property (persist.vendor.radio.5g_mode_pref) for the
    // default (i.e. first) RIL instance.
    if (five_g_mode_pref == std::numeric_limits<int>::max()) {
        if (cur_proc_instance == QCRIL_DEFAULT_INSTANCE_ID) {
            snprintf(property_name, sizeof(property_name),
                     "%s", QMI_RIL_5G_MODE_PREF_LEGACY);
            qmi_ril_get_property_value_from_integer(property_name,
                                                    &five_g_mode_pref,
                                                    FIVE_G_MODE_DISABLED);
        } else {
            five_g_mode_pref = FIVE_G_MODE_DISABLED;
        }
    }

    if (five_g_mode_pref > FIVE_G_MODE_EXCLUSIVE || five_g_mode_pref < FIVE_G_MODE_DISABLED)
    {
        QCRIL_LOG_ERROR("Invalid 5G mode (%d) specified in property %s",
                five_g_mode_pref, property_name);
        five_g_mode_pref = FIVE_G_MODE_DISABLED;
    }

    NAS_CACHE_LOCK();
    nas_common_info.five_g_mode_pref = static_cast<RIL_5G_MODE>(five_g_mode_pref);
    NAS_CACHE_UNLOCK();

    return static_cast<RIL_5G_MODE>(five_g_mode_pref);
}

bool qcril_qmi_nas_set_5g_mode_pref(RIL_5G_MODE five_g_mode)
{
    qcril_instance_id_e_type cur_proc_instance;
    char property_name[ PROPERTY_VALUE_MAX ];

    cur_proc_instance = qmi_ril_get_process_instance_id();
    snprintf( property_name, sizeof(property_name),
        "%s%d", QMI_RIL_5G_MODE_PREF, cur_proc_instance );

    if (property_set(property_name,
            std::to_string(five_g_mode).c_str()))
    {
        QCRIL_LOG_ERROR("Failed to set property %s", property_name);
        return false;
    }

    // For the first/default RIL instance, set the legacy property used as the 5G mode
    // preference (persist.vendor.radio.5g_mode_pref). This is done to keep the legacy
    // property in sync with the new property (persist.vendor.radio.5g_mode_pref_0).
    if (cur_proc_instance == QCRIL_DEFAULT_INSTANCE_ID) {
        snprintf(property_name, sizeof(property_name),
                 "%s", QMI_RIL_5G_MODE_PREF_LEGACY);

        if (property_set(property_name, std::to_string(five_g_mode).c_str()))
        {
            QCRIL_LOG_ERROR("Failed to set property %s", property_name);
            return false;
        }
    }

    return true;
}

bool qcril_qmi_nas_get_last_android_mode_pref(int *last_android_mode_pref)
{
    if (nas_common_info.last_android_mode_pref_valid && last_android_mode_pref)
    {
        *last_android_mode_pref = nas_common_info.last_android_mode_pref;
        return true;
    }
    return false;
}

void qcril_qmi_nas_save_android_mode_pref(int android_mode_pref)
{
    nas_common_info.last_android_mode_pref = android_mode_pref;
    nas_common_info.last_android_mode_pref_valid = true;
}

//===========================================================================
// qcril_qmi_nas_init
//===========================================================================
void qcril_qmi_nas_init()
{
    QCRIL_LOG_FUNC_ENTRY();

#ifdef QMI_RIL_UTF
    usleep(500000);
#endif

    NAS_CACHE_LOCK();
    qcril_qmi_nas_populate_sig_config_delta_info();
    qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow();
    qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow();
    NAS_CACHE_UNLOCK();

    NAS_EMBMS_CACHE_LOCK();
    nas_cached_info.embms_enabled = FALSE;
    nas_cached_info.embms_enable_success_sent_to_atel = FALSE;
    nas_cached_info.embms_cell_id_sent_after_enabled = FALSE;
    nas_cached_info.embms_coverage_sent_after_enabled = FALSE;
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.embms_data_con_payload);
    NAS_EMBMS_CACHE_UNLOCK();


    qcril_qmi_nas_set_reported_voice_radio_tech(RADIO_TECH_IS95A);

    qcril_qmi_nas_clear_reported_rat_rac_cache();

    qmi_ril_nwr_reg_reject_init();

    qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_NOT_ACTIVE );

    qcril_qmi_fetch_system_selection_preference();

    qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed();

    int                         op_mode_valid;
    dms_operating_mode_enum_v01 op_mode;
    qcril_qmi_nas_query_cur_power_state( &op_mode_valid, &op_mode ); // need to have current oprt mode prior to qcril_qmi_util_enable_networking_indications() call

    qcril_qmi_nas_monitor_shutdown();

    qcril_qmi_nas_configure_sig_info2();

    qcril_qmi_util_enable_networking_indications( TRUE, TRUE, FALSE );

    if ( qcril_qmi_is_secondary_modem_present() )
    {
        qcril_qmi_nas_register_for_5g_modem_vote_indication();
    }

    if( TRUE == nas_common_info.custom_emergency_numbers_enabled )
    {
        qcril_qmi_nas_process_custom_emergency_numbers();
    }

    qcril_qmi_nas_fetch_sib16_network_time(false, 0, false, 0);

    if ( qmi_ril_is_multi_sim_feature_supported() ) {
        qcril_qmi_nas_enforce_modem_stack_status();
    }

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                   NULL,
                   QMI_RIL_ZERO,
                   (RIL_Token) QCRIL_CUSTOM_ECC_INTERNAL_TOKEN );

    qcril_qmi_nas_get_subscription_info();

    if(qmi_ril_is_multi_sim_feature_supported() && !nas_common_info.dsds.dds_data_sub_valid)
    {
        QCRIL_LOG_DEBUG("Query DDS sub from DATA layer as cache not valid");
#ifndef QMI_RIL_UTF
        std::shared_ptr<rildata::GetDdsSubIdMessage> msg =
                std::make_shared<rildata::GetDdsSubIdMessage>();
        if (msg != nullptr) {
            NasDataGetDdsSubIdCallback cb("set-cb-token", (uint32_t)(-1), FALSE);
            msg->setCallback(&cb);
            msg->dispatch();
        }
#endif
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_init

void qcril_qmi_nas_multi_sim_init()
{
  int res = RIL_E_SUCCESS;
  QCRIL_LOG_FUNC_ENTRY();

  res = qcril_qmi_nas_get_device_capability(TRUE, TRUE, TRUE, TRUE);

  NAS_CACHE_LOCK();
  nas_common_info.dsds.valid = FALSE;

  if( NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) &&
      (TRUE == nas_dms_cached_info.both_sub_support_all_rat_cap) &&
      NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
      (2 == nas_dms_cached_info.max_active_data_subs) &&
      (!nas_common_info.dsds.dds_data_sub_valid)
    )
  {
#ifndef QMI_RIL_UTF
    std::shared_ptr<rildata::GetDdsSubIdMessage> msg =
                std::make_shared<rildata::GetDdsSubIdMessage>();
    if (msg != nullptr) {
        NasDataGetDdsSubIdCallback cb("set-cb-token", (uint32_t)(-1), FALSE);
        msg->setCallback(&cb);
        msg->dispatch();
    }
#endif
  }

  NAS_CACHE_UNLOCK();

  QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_get_subscription_info()
{
  nas_get_subscription_info_resp_msg_v01 qmi_response;
  qmi_client_error_type qmi_transport_error;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_response, 0, sizeof(qmi_response));
  qmi_transport_error = qmi_client_nas_send_sync( QMI_NAS_GET_SUBSCRIPTION_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp );
  QCRIL_LOG_INFO( ".. transport error %d, ril_error %d", (int)qmi_transport_error, (int)ril_req_res );
  NAS_CACHE_LOCK();
  if ( RIL_E_SUCCESS == ril_req_res )
  {
    if ( qmi_response.voice_system_id_valid )
    {
      QCRIL_LOG_INFO("VSID %d", qmi_response.voice_system_id);
      if(qmi_response.voice_system_id)
      {
        NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_system_id, qmi_response.voice_system_id );
        qcril_am_set_vsid(QCRIL_AM_VS_VOICE, qmi_response.voice_system_id);
      }
    }

    if ( qmi_response.lte_voice_system_id_valid )
    {
        QCRIL_LOG_DEBUG ("LTE Voice System ID %x\n", qmi_response.lte_voice_system_id);
        if ( qmi_response.lte_voice_system_id )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS, qmi_response.lte_voice_system_id);
        }
    }

    if ( qmi_response.wlan_voice_system_id_valid )
    {
        QCRIL_LOG_DEBUG ("WLAN Voice System ID %x\n", qmi_response.wlan_voice_system_id);
        if ( qmi_response.wlan_voice_system_id )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS_WLAN, qmi_response.wlan_voice_system_id);
        }
    }

    if ( qmi_ril_is_multi_sim_feature_supported() && qmi_response.is_priority_subs_valid )
    {
      QCRIL_LOG_INFO("is_priority_subs %d", qmi_response.is_priority_subs);
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_priority_subs, qmi_response.is_priority_subs );
    }
    if ( qmi_ril_is_multi_sim_feature_supported() && qmi_response.is_active_valid )
    {
      QCRIL_LOG_INFO("is_active %d", qmi_response.is_active);
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_active, qmi_response.is_active );
    }
    if ( qmi_ril_is_multi_sim_feature_supported() && qmi_response.is_default_data_subs_valid )
    {
      QCRIL_LOG_INFO("is_default_data_subs %d", qmi_response.is_default_data_subs);
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.is_default_data_subs, qmi_response.is_default_data_subs );
    }
    if ( qmi_ril_is_multi_sim_feature_supported() && qmi_response.dds_type_valid )
    {
      QCRIL_LOG_INFO("DDS Type %d", qmi_response.dds_type);
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dds_type, qmi_response.dds_type );
    }
  }
  NAS_CACHE_UNLOCK();
  QCRIL_LOG_FUNC_RETURN();
}

uint8_t qcril_qmi_nas_get_max_subscriptions()
{
    uint8_t max_subs;

    NAS_CACHE_LOCK();
    max_subs = nas_dms_cached_info.max_subscriptions;
    NAS_CACHE_UNLOCK();

    return max_subs;
}

RIL_Errno qcril_qmi_nas_get_device_capability
(
  int need_msim_capability,
  int need_feature_mode,
  int need_sub_capability,
  int need_ims_capability
)
{
  dms_get_device_cap_resp_msg_v01 qmi_dev_cap_response;
  qmi_client_error_type qmi_transport_error;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  int instance_id = qmi_ril_get_process_instance_id();
  uint8_t modem_stack_id = (uint8_t) qcril_qmi_get_modem_stack_id();

  memset( &qmi_dev_cap_response, 0, sizeof( qmi_dev_cap_response ) );
  qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_GET_DEVICE_CAP_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_dev_cap_response,
                                                       sizeof( qmi_dev_cap_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_dev_cap_response.resp);
  QCRIL_LOG_INFO( "[MSIM] requested device caps %d, %d", (int)qmi_transport_error, (int)ril_req_res );

  if( RIL_E_SUCCESS == ril_req_res )
  {
      if ( ( instance_id == QCRIL_DEFAULT_INSTANCE_ID ) && ( need_msim_capability == TRUE ) && ( qmi_dev_cap_response.multisim_capability_valid == TRUE ) )
      {
        QCRIL_LOG_INFO(" max_subscriptions %d ", (int) qmi_dev_cap_response.multisim_capability.max_subscriptions);
        NAS_CACHE_LOCK();
        nas_dms_cached_info.max_subscriptions = qmi_dev_cap_response.multisim_capability.max_subscriptions;
        if ( qmi_dev_cap_response.multisim_capability.subscription_config_list_len > 0 )
        {
          QCRIL_LOG_INFO(" max_subscriptions_active %d ", (int) qmi_dev_cap_response.multisim_capability.subscription_config_list[0].max_active );
          // Currently max_active will be uniform for all config in config list.
          // So, pick first config type.
          nas_dms_cached_info.max_subscriptions_active = qmi_dev_cap_response.multisim_capability.subscription_config_list[0].max_active;
          qcril_qmi_nas_dms_update_multisim_config_property();
        }
        NAS_CACHE_UNLOCK();
      }
      if ( ( instance_id == QCRIL_DEFAULT_INSTANCE_ID ) && ( need_feature_mode == TRUE ) && ( qmi_dev_cap_response.subs_device_feature_mode_valid == TRUE ) )
      {
        QCRIL_LOG_INFO(" subs_device_feature_mode_len %d", (int) qmi_dev_cap_response.subs_device_feature_mode_len);
        if ( qmi_dev_cap_response.subs_device_feature_mode_len > 0 )
        {
          QCRIL_LOG_INFO(" subs_device_feature_mode[0] %d", (int) qmi_dev_cap_response.subs_device_feature_mode[0]);
          if ( qmi_dev_cap_response.subs_device_feature_mode[0] == DMS_DEVICE_SUBS_FEATURE_MODE_SGLTE_V01 )
          {
            if ( property_set( QMI_RIL_SYS_PROP_NAME_SGLTE, "1" ) != E_SUCCESS )
            {
              QCRIL_LOG_ERROR("Failed to set property for %s as 1", QMI_RIL_SYS_PROP_NAME_SGLTE);
            }
          }
          else
          {
            if ( property_set( QMI_RIL_SYS_PROP_NAME_SGLTE, "0" ) != E_SUCCESS )
            {
              QCRIL_LOG_ERROR("Failed to set property for %s as 0", QMI_RIL_SYS_PROP_NAME_SGLTE);
            }
          }
        }
      }

      if(( need_sub_capability == TRUE ) && qmi_dev_cap_response.device_max_subscription_static_capability_valid &&
         (qmi_dev_cap_response.device_max_subscription_static_capability_len > modem_stack_id)
        )
      {
        QCRIL_LOG_DEBUG("[MSIM] Device Max SUBS static Stack capability %x", qmi_dev_cap_response.device_max_subscription_static_capability[modem_stack_id]);
        NAS_CACHE_LOCK();
        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.current_sub_capability, qmi_dev_cap_response.device_max_subscription_static_capability[modem_stack_id]);
        NAS_CACHE_UNLOCK();

        if(qmi_dev_cap_response.device_config_list_valid && (qmi_dev_cap_response.device_config_list.device_cfg_list_len > 0) &&
           (qmi_dev_cap_response.device_config_list.device_cfg_list[qmi_dev_cap_response.device_config_list.current_config_index].subs_cfg_list_len >= 2) &&
           (qmi_dev_cap_response.device_config_list.device_cfg_list[qmi_dev_cap_response.device_config_list.current_config_index].subs_cfg_list[0] & DMS_SUBS_CAPABILITY_LTE_V01) &&
           (qmi_dev_cap_response.device_config_list.device_cfg_list[qmi_dev_cap_response.device_config_list.current_config_index].subs_cfg_list[1] & DMS_SUBS_CAPABILITY_LTE_V01))
        {
            QCRIL_LOG_DEBUG("Both subs support LTE simultaneously i.e L+L mode");
            NAS_CACHE_LOCK();
            nas_dms_cached_info.both_sub_support_all_rat_cap_valid = TRUE;
            nas_dms_cached_info.both_sub_support_all_rat_cap = TRUE;
            NAS_CACHE_UNLOCK();
        }
      }
      else if ( ( need_sub_capability == TRUE ) &&
           ( qmi_dev_cap_response.multisim_capability.subscription_config_list_len > 0 &&
             qmi_dev_cap_response.multisim_capability.subscription_config_list[0].subscription_list_len > modem_stack_id ) )
      {
        QCRIL_LOG_DEBUG("[MSIM] Stack capability %x", qmi_dev_cap_response.multisim_capability.subscription_config_list[0].subscription_list[modem_stack_id]);
        NAS_CACHE_LOCK();
        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.current_sub_capability, qmi_dev_cap_response.multisim_capability.subscription_config_list[0].subscription_list[modem_stack_id] );
        NAS_CACHE_UNLOCK();
      }
      if ( ( need_sub_capability == TRUE ) &&
           ( qmi_dev_cap_response.subs_voice_data_capability_valid == TRUE ) &&
           ( qmi_dev_cap_response.subs_voice_data_capability_len > modem_stack_id ) )
      {
        NAS_CACHE_LOCK();
        QCRIL_LOG_DEBUG("[MSIM] Current sub voice data capability %d ", (int) qmi_dev_cap_response.subs_voice_data_capability[modem_stack_id].subs_voice_data_capability);
        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.subs_voice_data_capability, qmi_dev_cap_response.subs_voice_data_capability[modem_stack_id].subs_voice_data_capability );
        NAS_CACHE_UNLOCK();
      }
      if ((need_sub_capability == TRUE) &&
           (qmi_dev_cap_response.max_active_data_subscriptions_valid == TRUE))
      {
        QCRIL_LOG_DEBUG("[MSIM] Max Active Data : %d", qmi_dev_cap_response.max_active_data_subscriptions);
        if (!NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs)
            || nas_dms_cached_info.max_active_data_subs != qmi_dev_cap_response.max_active_data_subscriptions)
        {
          NAS_CACHE_LOCK();
          NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_dms_cached_info.max_active_data_subs,
                                         qmi_dev_cap_response.max_active_data_subscriptions);
          NAS_CACHE_UNLOCK();
          qcril_qmi_nas_send_unsol_max_data_changed();
        }
      }
      if(need_ims_capability)
      {
        qcril_qmi_imsa_store_ims_capability(qmi_dev_cap_response.max_ims_instances_valid,
                                           qmi_dev_cap_response.max_ims_instances,
                                           qmi_dev_cap_response.ims_capability_valid,
                                           qmi_dev_cap_response.ims_capability_len,
                                           qmi_dev_cap_response.ims_capability);
      }
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_req_res);
  return ril_req_res;
}

void qcril_qmi_nas_request_get_phone_capability
(
  std::shared_ptr<RilRequestGetPhoneCapabilityMessage> msg
)
{
  QCRIL_LOG_FUNC_ENTRY();

  dms_get_device_cap_resp_msg_v01 qmi_dev_cap_response;
  qmi_client_error_type qmi_transport_error;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril::interfaces::RIL_PhoneCapability phoneCap = {};

  memset(&qmi_dev_cap_response, 0, sizeof(qmi_dev_cap_response));
  qmi_transport_error = qmi_client_send_msg_sync_with_shm(qcril_qmi_client_get_user_handle(QCRIL_QMI_CLIENT_DMS),
                                                       QMI_DMS_GET_DEVICE_CAP_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void *)&qmi_dev_cap_response,
                                                       sizeof(qmi_dev_cap_response),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT);
  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_dev_cap_response.resp);
  QCRIL_LOG_INFO( "[MSIM] requested device caps %d, %d", (int)qmi_transport_error, (int)ril_req_res );

  if (ril_req_res == RIL_E_SUCCESS)
  {
    if (qmi_dev_cap_response.max_active_data_subscriptions_valid == TRUE)
    {
      phoneCap.maxActiveData = qmi_dev_cap_response.max_active_data_subscriptions;
    }

    if (qmi_dev_cap_response.multisim_capability_valid == TRUE &&
        qmi_dev_cap_response.multisim_capability.subscription_config_list_len > 0 &&
        qmi_dev_cap_response.multisim_capability.max_subscriptions == QMI_RIL_NUM_DUAL_SUB)
    {
      phoneCap.maxActiveInternetData = qmi_dev_cap_response.multisim_capability.subscription_config_list[0].max_active;
    }

    qcril::interfaces::RIL_ModemInfo modem1 = {0};
    qcril::interfaces::RIL_ModemInfo modem2 = {1};
    phoneCap.logicalModemList.push_back(modem1);
    phoneCap.logicalModemList.push_back(modem2);

    phoneCap.isInternetLingeringSupported = false;
  }

  std::shared_ptr<qcril::interfaces::RilPhoneCapabilityResult_t> payload = nullptr;
  if (ril_req_res == RIL_E_SUCCESS) {
    payload = std::make_shared<qcril::interfaces::RilPhoneCapabilityResult_t>(phoneCap);
  }

  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);

  if (payload == nullptr || respData == nullptr) {
      msg->sendResponse(msg, Message::Callback::Status::FAILURE, nullptr);
  } else {
      msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_req_res);
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_dsds_is_active

===========================================================================*/
int qcril_qmi_nas_dsds_is_active(void)
{
    int res = FALSE;
    NAS_CACHE_LOCK();
    res = (nas_cached_info.dsds_is_active_valid && nas_cached_info.dsds_is_active);
    NAS_CACHE_UNLOCK();
    return res;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_get_flexi_map_status

===========================================================================*/
qcril_flexi_map_status qcril_qmi_nas_get_flexi_map_status()
{
    qcril_flexi_map_status status;
    NAS_CACHE_LOCK();
    status = nas_common_info.dsds.fm_status;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN_WITH_RET(status);
    return status;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_set_flexi_map_status

===========================================================================*/
RIL_Errno qcril_qmi_nas_set_flexi_map_status(qcril_flexi_map_status fm_status)
{
    qcril_flexi_map_status cur_status;
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qcril_flexi_map_status failure_status;

    QCRIL_LOG_FUNC_ENTRY();

    cur_status = qcril_qmi_nas_get_flexi_map_status();

    QCRIL_LOG_DEBUG("Cur status: %d new status: %d", cur_status, fm_status);
    switch(fm_status)
    {
      case QCRIL_FLEXI_MAP_STATUS_NONE:
      case QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE_FAIL:
      case QCRIL_FLEXI_MAP_STATUS_START_UNBIND_FAIL:
      case QCRIL_FLEXI_MAP_STATUS_APPLY_BIND_FAIL:
      case QCRIL_FLEXI_MAP_STATUS_APPLY_ACTIVATE_FAIL:
      case QCRIL_FLEXI_MAP_STATUS_FINISH_FAIL:
        res = RIL_E_SUCCESS;
        break;

      case QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE:
        if ( cur_status == QCRIL_FLEXI_MAP_STATUS_NONE )
        {
          res = RIL_E_SUCCESS;
        }
        else
        {
          failure_status = QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE_FAIL;
        }
        break;

      case QCRIL_FLEXI_MAP_STATUS_START_UNBIND:
        if ( cur_status == QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE )
        {
          res = RIL_E_SUCCESS;
        }
        else
        {
          failure_status = QCRIL_FLEXI_MAP_STATUS_START_UNBIND_FAIL;
        }
        break;

      case QCRIL_FLEXI_MAP_STATUS_APPLY_BIND:
        if ( cur_status == QCRIL_FLEXI_MAP_STATUS_START_UNBIND )
        {
          res = RIL_E_SUCCESS;
        }
        else
        {
          failure_status = QCRIL_FLEXI_MAP_STATUS_APPLY_BIND_FAIL;
        }
        break;

      case QCRIL_FLEXI_MAP_STATUS_APPLY_ACTIVATE:
        if ( cur_status == QCRIL_FLEXI_MAP_STATUS_APPLY_BIND )
        {
          res = RIL_E_SUCCESS;
        }
        else
        {
          failure_status = QCRIL_FLEXI_MAP_STATUS_APPLY_ACTIVATE_FAIL;
        }
        break;

      /* For FINISH always send success */
      case QCRIL_FLEXI_MAP_STATUS_FINISH:
        res = RIL_E_SUCCESS;
        break;

      default:
        res = RIL_E_GENERIC_FAILURE;
        break;
    }
    if ( res == RIL_E_SUCCESS )
    {
      NAS_CACHE_LOCK();
      nas_common_info.dsds.fm_status = fm_status;
      NAS_CACHE_UNLOCK();
      QCRIL_LOG_DEBUG("[MSIM] FM Status set %d", (int) nas_common_info.dsds.fm_status);
    }
    else
    {
      QCRIL_LOG_DEBUG("Invalid state transition! Setting fm status %d", failure_status);
      NAS_CACHE_LOCK();
      nas_common_info.dsds.fm_status = failure_status;
      NAS_CACHE_UNLOCK();
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_reset_fm_req_resp_info

===========================================================================*/
void qcril_qmi_nas_reset_fm_req_resp_info()
{
  QCRIL_LOG_FUNC_ENTRY();
  NAS_CACHE_LOCK();
  memset(&nas_common_info.fm_req_resp_info, 0, sizeof(nas_common_info.fm_req_resp_info));
  NAS_CACHE_UNLOCK();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_set_fm_req_resp_info

===========================================================================*/
void qcril_qmi_nas_set_fm_req_resp_info(int version, int session, int phase)
{
  QCRIL_LOG_FUNC_ENTRY();
  NAS_CACHE_LOCK();
  nas_common_info.fm_req_resp_info.version = version;
  nas_common_info.fm_req_resp_info.session = session;
  nas_common_info.fm_req_resp_info.phase = phase;
  NAS_CACHE_UNLOCK();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_perform_unbind_operation

===========================================================================*/
void qcril_qmi_nas_perform_unbind_operation()
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_client_dsds_cri_client_reset();
  qmi_ril_set_operational_status( QMI_RIL_GEN_OPERATIONAL_STATUS_UNBIND);
  qmi_ril_fw_android_request_flow_control_drop_legacy_book_records( FALSE, TRUE );
  qmi_ril_fw_android_request_flow_control_abandon_all_requests_main_thrd( RIL_E_CANCELLED, TRUE );
  // invalidate cache
  NAS_CACHE_LOCK();
  qcril_qmi_nas_drop_nw_info_cache();
  qcril_qmi_drop_sig_info_cache();
  NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_default_data_subs);
  NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.dds_type);
  NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.srv_domain_pref );
  NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
  NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.mode_pref );
  NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.roam_pref );
  nas_common_info.dsds.is_default_data_set = FALSE;
  nas_common_info.dsds.default_data_reason = NONE;
  NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_blocked);
  qcril_qmi_nas_set_reported_voice_radio_tech(RADIO_TECH_IS95A);
  NAS_CACHE_UNLOCK();
  // Clear pending requests in case of UNBIND
  QCRIL_LOG_DEBUG("[MSIM] Cleanup pending requests as we are unbinding!");
  // Clear the snapshot info and cancel timer
  qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
  qcril_qmi_arb_reset_pref_data_snapshot();
  qcril_qmi_arb_reset_dsd_system_status_info();
}


/*===========================================================================

  FUNCTION qcril_qmi_nas_info_flexmap_status

===========================================================================*/
/*!
    @brief
    Inform flexmap status

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_info_flexmap_status(NasFlexmapState state)
{
    auto ind_msg_ptr =
         std::make_shared<NasFlexMapStatusIndMessage>(state);
    if (ind_msg_ptr != nullptr)
    {
        ind_msg_ptr->broadcast();
    }
}

/*===========================================================================

  FUNCTION qcril_qmi_nas_send_enable_indications

===========================================================================*/
/*!
    @brief
    Inform screen state change to other modules.

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_send_enable_indications(int state)
{
    auto ind_msg_ptr =
         std::make_shared<NasEnableIndicationsIndMessage>(state);
    if (ind_msg_ptr != nullptr)
    {
        ind_msg_ptr->broadcast();
    }
}



/*=========================================================================
  FUNCTION:  qcril_qmi_nas_perform_bind_operation

===========================================================================*/
RIL_Errno qcril_qmi_nas_perform_bind_operation(int modem_stack_id)
{
  int curr_stack_id = (int) qcril_qmi_get_modem_stack_id();
  int slot = qmi_ril_get_sim_slot();
  RIL_Errno result;

  QCRIL_LOG_FUNC_ENTRY();

  if ( modem_stack_id != curr_stack_id )
  {
    result = qcril_qmi_client_dsds_bind_to_subscription((RIL_SubscriptionType)modem_stack_id);
    qcril_qmi_nas_nw_select_handle_total_cleanup();
    qcril_qmi_nas_perform_unbind_operation();
    nas_common_info.card_info[slot].iccid_from_uim[0] = '\0';
    nas_common_info.card_info[slot].iccid_len_from_uim = 0;
    qcril_qmi_nas_info_flexmap_status(NasFlexmapState::NAS_FLEXMAP_STATE_APPLY);
  }
  // Return success if already bound to same stack
  else
  {
    QCRIL_LOG_DEBUG("[MSIM] Already bound to stack %d", (RIL_SubscriptionType)modem_stack_id);
    result = RIL_E_SUCCESS;
  }
  if ( result == RIL_E_SUCCESS )
  {
    qmi_ril_set_operational_status( QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING);
    qcril_qmi_client_dsds_cri_client_reinit((RIL_SubscriptionType)modem_stack_id);

#ifndef QMI_RIL_UTF
    std::shared_ptr<rildata::ProcessStackSwitchMessage> msg =
         std::make_shared<rildata::ProcessStackSwitchMessage>((qcril_modem_stack_id_e_type)curr_stack_id,
                                                               (qcril_modem_stack_id_e_type)modem_stack_id,
                                                               qmi_ril_get_process_instance_id() );
    if(msg)
    {
        msg->dispatch();
    }
#endif

    qcril_qmi_nas_get_device_capability(FALSE, FALSE, TRUE, FALSE);
    qcril_qmi_nas_get_subscription_info();
    qcril_am_set_vsid(QCRIL_AM_VS_VOICE, nas_cached_info.voice_system_id);

    /* Reevaluate indication registration after binding is done */
    qmi_ril_nwreg_common_ind_subscribe_consider_action_handler();
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET(result);
  return result;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_fill_radio_cap_resp

===========================================================================*/
void qcril_qmi_nas_fill_radio_cap_resp (int is_get_resp, int status, RIL_RadioCapability * radio_cap_resp)
{
  QCRIL_LOG_FUNC_ENTRY();

  radio_cap_resp->rat = qcril_qmi_dms_convert_sub_capability_to_ril_radio_family();
  snprintf(radio_cap_resp->logicalModemUuid, sizeof(radio_cap_resp->logicalModemUuid), "%d", (int)
           qcril_qmi_get_modem_stack_id());
  radio_cap_resp->status = status;
  if (is_get_resp == FALSE)
  {
    NAS_CACHE_LOCK();
    radio_cap_resp->version = nas_common_info.fm_req_resp_info.version;
    radio_cap_resp->session = nas_common_info.fm_req_resp_info.session;
    NAS_CACHE_UNLOCK();
  }
  QCRIL_LOG_INFO("version: %d session: %d rat: %d status: %d modem id: %d", radio_cap_resp->version,
                  radio_cap_resp->session, (int) radio_cap_resp->rat,
                  radio_cap_resp->status, atoi(radio_cap_resp->logicalModemUuid));
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_send_unsol_radio_cap_resp

===========================================================================*/
void qcril_qmi_nas_send_unsol_radio_cap_resp (int status)
{
  RIL_RadioCapability radio_cap_unsol_resp;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&radio_cap_unsol_resp, 0, sizeof(radio_cap_unsol_resp));
  qcril_qmi_nas_fill_radio_cap_resp( FALSE, status, &radio_cap_unsol_resp);
  auto msg = std::make_shared<RilUnsolRadioCapabilityMessage>(radio_cap_unsol_resp);
  Dispatcher::getInstance().dispatchSync(msg);

  qcril_qmi_nas_notify_embms_status();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_send_set_radio_cap_resp

===========================================================================*/
void qcril_qmi_nas_send_set_radio_cap_resp
(
  std::shared_ptr<RilRequestSetRadioCapMessage> msg,
  int status,
  RIL_Errno result
)
{
  QCRIL_LOG_FUNC_ENTRY();

  auto payload = new qcril::interfaces::RilRadioCapResult_t();
  if (payload == nullptr) {
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_NO_MEMORY, nullptr));
    return;
  }
  auto& radio_cap_resp = payload->respData;

  memset(&radio_cap_resp, 0, sizeof(radio_cap_resp));
  qcril_qmi_nas_fill_radio_cap_resp( FALSE, status, &radio_cap_resp);
  NAS_CACHE_LOCK();
  radio_cap_resp.phase = nas_common_info.fm_req_resp_info.phase;
  QCRIL_LOG_INFO("phase: %d", radio_cap_resp.phase);
  NAS_CACHE_UNLOCK();

  std::shared_ptr<qcril::interfaces::RilRadioCapResult_t> shared_resp(payload);
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(result, shared_resp);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

  if ((radio_cap_resp.phase == RC_PHASE_FINISH) && (RC_STATUS_SUCCESS == status))
  {
      qcril_qmi_nas_info_flexmap_status(NasFlexmapState::NAS_FLEXMAP_STATE_FINISH);
  }
}

//===========================================================================
// qcril_qmi_nas_get_mode_pref_from_nv_10
//===========================================================================
boolean qcril_qmi_nas_get_mode_pref_from_nv_10()
{
    return nas_common_info.get_mode_pref_from_nv_10;
} // qcril_qmi_nas_get_mode_pref_from_nv_10

//===========================================================================
// qcril_qmi_nas_is_sglte3
//===========================================================================
int qcril_qmi_nas_is_sglte3()
{
    return nas_common_info.sglte_eons_is_set;
} // qcril_qmi_nas_is_sglte3

//===========================================================================
// qcril_qmi_nas_get_ril_ecc_map
//===========================================================================
void qcril_qmi_nas_get_ril_ecc_map(qcril::interfaces::RIL_EccMapType& ecc_map)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    ecc_map = nas_cached_info.ril_ecc_map;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_centralized_pbm_ecc_support
//===========================================================================
void qcril_qmi_nas_centralized_pbm_ecc_support(int enable)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO("enable - %d", enable);

    /* Only in first boot, nas_common_info.custom_emergency_numbers_enabled will be true.
       from second boot onwards, as we are setting QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_ENABLED to "0"
 */
    if (!enable)
    {
        NAS_CACHE_LOCK();
        if (nas_common_info.custom_emergency_numbers_enabled == TRUE)
        {
            if (property_set(QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_ENABLED, "0") != E_SUCCESS)
            {
                QCRIL_LOG_FATAL("Failed to save system property - %s", QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_ENABLED);
            }
            nas_common_info.custom_emergency_numbers_enabled = FALSE;
            QCRIL_LOG_INFO("disabled ril based ecc");
        }
        else
        {
            QCRIL_LOG_INFO("ril based ecc already disabled");
        }
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
}


//===========================================================================
// qcril_qmi_nas_start_wait_for_pbm_ind_timer
//===========================================================================
void qcril_qmi_nas_start_wait_for_pbm_ind_timer()
{
   struct timeval wait_for_pbm_ind_timeout;

   QCRIL_LOG_FUNC_ENTRY();

   wait_for_pbm_ind_timeout.tv_sec = nas_common_info.wait_for_pbm_ind_timer;
   wait_for_pbm_ind_timeout.tv_usec = NAS_NIL;

   NAS_CACHE_LOCK();
   if( nas_common_info.wait_for_pbm_ind && !nas_common_info.wait_for_pbm_ind_timer_id_valid) //persist.vendor.radio.wait_for_pbm is set to "1" and timer is NOT currently running
   {
       qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
                                   qcril_qmi_nas_wait_for_pbm_ind_timeout_cb,
                                   &wait_for_pbm_ind_timeout, &nas_common_info.wait_for_pbm_ind_timer_id);
       nas_common_info.wait_for_pbm_ind_timer_id_valid = TRUE;
       QCRIL_LOG_INFO("wait_for_pbm_ind_timer started");
   }
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_start_wait_for_pbm_ind_timer

//===========================================================================
// qcril_qmi_nas_cancel_wait_for_pbm_ind_timer
//===========================================================================
void qcril_qmi_nas_cancel_wait_for_pbm_ind_timer()
{
   QCRIL_LOG_FUNC_ENTRY();

   NAS_CACHE_LOCK();
   if( nas_common_info.wait_for_pbm_ind && nas_common_info.wait_for_pbm_ind_timer_id_valid) //persist.vendor.radio.wait_for_pbm is set to "1" and timer is currently running
   {
       qcril_cancel_timed_callback((void *)(uintptr_t)nas_common_info.wait_for_pbm_ind_timer_id);
       nas_common_info.wait_for_pbm_ind_timer_id_valid = FALSE;
       nas_common_info.wait_for_pbm_ind_timer_id = NAS_NIL;
       QCRIL_LOG_INFO("wait_for_pbm_ind_timer cancelled");
   }
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_cancel_wait_for_pbm_ind_timer

//===========================================================================
// qcril_qmi_nas_wait_for_pbm_ind_timeout_cb
//===========================================================================
void qcril_qmi_nas_wait_for_pbm_ind_timeout_cb(void * params)
{
   int action_needed;
   QCRIL_LOG_FUNC_ENTRY();

   QCRIL_NOTUSED(params);

   action_needed = FALSE;

   NAS_CACHE_LOCK();
   if( nas_common_info.wait_for_pbm_ind ) //Ideally this function is called only when nas_common_info.wait_for_pbm_ind is "1"
   {
#if (QCRIL_RIL_VERSION < 15)
       QCRIL_LOG_INFO("wait_for_pbm_ind_timer timed out, operating mode %d, is screen off %d", nas_dms_cached_info.operating_mode, nas_common_info.is_screen_off);
#else
       QCRIL_LOG_INFO("wait_for_pbm_ind_timer timed out, operating mode %d, full_network_state_notification_enabled %d", nas_dms_cached_info.operating_mode,
            nas_common_info.unsol_response_filter.full_network_state_notification_enabled);
#endif
       nas_common_info.wait_for_pbm_ind_timer_id_valid = FALSE;
       nas_common_info.wait_for_pbm_ind_timer_id = NAS_NIL;

       //As the window for keeping the PBM indications enabled
       //has passed, We would need to disable the PBM indications now
       //If the modem is in LPM or the Screen is OFF to save power
#if (QCRIL_RIL_VERSION < 15)
       if( DMS_OP_MODE_ONLINE_V01 != nas_dms_cached_info.operating_mode || TRUE == nas_common_info.is_screen_off )
#else
       if( DMS_OP_MODE_ONLINE_V01 != nas_dms_cached_info.operating_mode || FALSE == nas_common_info.unsol_response_filter.full_network_state_notification_enabled )
#endif
       {
           action_needed = TRUE;
       }
   }
   NAS_CACHE_UNLOCK();

   if( action_needed )
   {
       qcril_qmi_pbm_enable_emergency_number_indications( FALSE );
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_wait_for_pbm_ind_timeout_cb

//===========================================================================
// qcril_qmi_dms_get_max_apss_subscritions
//===========================================================================
int qcril_qmi_dms_get_max_apss_subscritions()
{
    int max_subscriptions = QMI_RIL_NUM_SINGLE_ACTIVE;

    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_TSTS))
    {
        max_subscriptions = QMI_RIL_NUM_TRIPLE_SUB;
    }
    else if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_DSDS))
    {
        max_subscriptions = QMI_RIL_NUM_DUAL_SUB;
    }
    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_DSDA))
    {
        max_subscriptions = QMI_RIL_NUM_DUAL_ACTIVE;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(max_subscriptions);
    return max_subscriptions;
} //qcril_qmi_dms_get_max_apss_subscritions

//===========================================================================
// qcril_qmi_dms_get_max_modem_subscritions
//===========================================================================
int qcril_qmi_dms_get_max_modem_subscritions()
{
    int max_subscriptions = 1;

    NAS_CACHE_LOCK();
    max_subscriptions = nas_cached_info.modem_max_subscriptions;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(max_subscriptions);
    return max_subscriptions;
} //qcril_qmi_dms_get_max_modem_subscritions

//===========================================================================
// qcril_qmi_dms_fusion_csfb_init
//===========================================================================
static void qcril_qmi_dms_fusion_csfb_init()
{
    QCRIL_LOG_FUNC_ENTRY();

    // empty

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_dms_fusion_csfb_init

//===========================================================================
// qcril_qmi_dms_get_device_caps
//===========================================================================
void qcril_qmi_dms_get_device_caps()
{
    QCRIL_LOG_FUNC_ENTRY();

    dms_get_device_cap_resp_msg_v01 qmi_response;
    RIL_Errno ril_err;
    qmi_client_error_type qmi_transport_error;

    memset( &qmi_response, 0, sizeof( qmi_response ) );
    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_GET_DEVICE_CAP_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_response,
                                                       sizeof( qmi_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);
    QCRIL_LOG_INFO( "requested device caps %d, %d", (int)qmi_transport_error, (int)ril_err );

    nas_cached_info.modem_max_subscriptions = QMI_RIL_NUM_SINGLE_ACTIVE;
    if( RIL_E_SUCCESS == ril_err )
    {
        NAS_CACHE_LOCK();
        if( TRUE == qmi_response.simul_voice_and_data_capability_valid )
        {
            QCRIL_LOG_INFO( "simul_voice_and_data_capability is valid %d",
                  (int)qmi_response.simul_voice_and_data_capability );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.simul_voice_and_data_capability,
                  qmi_response.simul_voice_and_data_capability );
        }
        // Check if device_capabilities TLV is valid. For older targets like
        // SVLTE2 this will be valid and voice_support_capability TLV will not be
        // present.
        else
        {
            QCRIL_LOG_INFO( "simul_voice_and_data_capability not valid, %d",
                  (int)qmi_response.device_capabilities.data_service_capability );
            if (qmi_response.device_capabilities.data_service_capability ==
                  DMS_DATA_CAP_SIMUL_CS_AND_PS_V01)
            {
               nas_cached_info.simul_voice_and_data_capability_valid = TRUE;
               nas_cached_info.simul_voice_and_data_capability =
                  QMI_DMS_MASK_SVLTE_CAPABLE_V01 | QMI_DMS_MASK_SVDO_CAPABLE_V01;
            }
            else
            {
               nas_cached_info.simul_voice_and_data_capability_valid = FALSE;
               nas_cached_info.simul_voice_and_data_capability = NAS_NIL;
            }
        }
        qcril_qmi_dms_set_simo_cs_ps_property( nas_cached_info.simul_voice_and_data_capability );

        if( (TRUE == qmi_response.subs_device_feature_mode_valid) &&
            (qcril_qmi_get_modem_stack_id() < (qcril_modem_stack_id_e_type)qmi_response.subs_device_feature_mode_len) )
        {
            nas_cached_info.subs_device_feature_mode_valid = TRUE;
            nas_cached_info.subs_device_feature_mode = qmi_response.subs_device_feature_mode[qcril_qmi_get_modem_stack_id()];
        }

        if (qmi_response.multisim_capability_valid == TRUE)
        {
            nas_cached_info.modem_max_subscriptions = qmi_response.multisim_capability.max_subscriptions;
        }
        NAS_CACHE_UNLOCK();
    }
    else
    {
        QCRIL_LOG_ESSENTIAL( "Fail to retrieve device capabilities" );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET( ril_err );
} // qcril_qmi_dms_get_device_caps

//===========================================================================
// qcril_qmi_is_srlte_supported
//===========================================================================
int qcril_qmi_is_srlte_supported()
{
    int ret = FALSE;

    NAS_CACHE_LOCK();
    if( TRUE == nas_cached_info.subs_device_feature_mode_valid )
    {
        ret = (nas_cached_info.subs_device_feature_mode == DMS_DEVICE_SUBS_FEATURE_MODE_SRLTE_V01);
    }
    NAS_CACHE_UNLOCK();

    return ret;
} // qcril_qmi_is_srlte_supported

//===========================================================================
// qcril_qmi_dms_set_simo_cs_ps_property
//===========================================================================
void qcril_qmi_dms_set_simo_cs_ps_property(dms_simul_voice_and_data_capability_mask_v01 simul_cap)
{
    QCRIL_LOG_FUNC_ENTRY();

    char args[ PROPERTY_VALUE_MAX ];

    QCRIL_LOG_INFO( "simul cap %ld", simul_cap );

    if( QMI_DMS_MASK_SVLTE_CAPABLE_V01 & simul_cap )    //checking svlte
    {
        strlcpy(args,"true",sizeof(args));
    }
    else
    {
        strlcpy(args,"false",sizeof(args));
    }
    QCRIL_LOG_INFO("Setting %s property to %s", QMI_RIL_SIMO_CS_PS_SVLTE, args);
    if ( property_set( QMI_RIL_SIMO_CS_PS_SVLTE, args ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to save %s to system property", QMI_RIL_SIMO_CS_PS_SVLTE );
    }

    if( QMI_DMS_MASK_SVDO_CAPABLE_V01 & simul_cap )    //checking svdo
    {
        strlcpy(args,"true",sizeof(args));
    }
    else
    {
        strlcpy(args,"false",sizeof(args));
    }
    QCRIL_LOG_INFO("Setting %s property to %s", QMI_RIL_SIMO_CS_PS_SVDO, args);
    if ( property_set( QMI_RIL_SIMO_CS_PS_SVDO, args ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to save %s to system property", QMI_RIL_SIMO_CS_PS_SVDO );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_dms_set_simo_cs_ps_property

//===========================================================================
// qcril_qmi_nas_retrieve_sv_capability
//===========================================================================
dms_simul_voice_and_data_capability_mask_v01 qcril_qmi_nas_retrieve_sv_capability()
{
    dms_simul_voice_and_data_capability_mask_v01 sv_capability = NAS_NIL;;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ) )
    {
        sv_capability = nas_cached_info.simul_voice_and_data_capability;
    }
    NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN_WITH_RET(sv_capability);
   return sv_capability;
} //qcril_qmi_nas_retrieve_sv_capability

//===========================================================================
// qcril_qmi_nas_copy_state_change_handler
//===========================================================================
void qcril_qmi_nas_copy_state_change_handler
(
    const qmi_ril_file_observer_change_event event
)
{
    if (QMI_RIL_FILE_OBSERVER_CHANGE_CLOSE_WRITE == event)
    {
        if (qcril_mbn_is_copy_completed())
        {
            qmi_ril_file_observer_deregister_for_change_event(
                            (char *) QCRIL_MBN_COPY_COMPLETE_FILE,
                            qcril_qmi_nas_copy_state_change_handler);
            qcril_qmi_nas_check_for_hardware_update(TRUE);
        }
    }
}

//===========================================================================
// qcril_qmi_nas_check_for_hardware_update
//===========================================================================
void qcril_qmi_nas_check_for_hardware_update(boolean is_on_request)
{
    int                   apss_subscriptions  = 0;
    int                   modem_subscriptions = 0;
    int                   op_mode_valid;
    dms_operating_mode_enum_v01 op_mode = DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
    int                   is_modem_state_valid = 0;
    IxErrnoType           ret;
    struct stat           st;
    FILE                  *fd = NULL;

    memset(&st, 0x0, sizeof(struct stat));
    apss_subscriptions  = qcril_qmi_dms_get_max_apss_subscritions();
    modem_subscriptions = qcril_qmi_dms_get_max_modem_subscritions();

    NAS_CACHE_LOCK();
#ifdef QMI_RIL_UTF
    if ( !NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
#endif
    {
        qcril_qmi_nas_query_cur_power_state(&op_mode_valid, &op_mode);
    }
    NAS_CACHE_UNLOCK();

    if ((op_mode == DMS_VAL_ONLINE) || (op_mode == DMS_VAL_LOW_POWER) ||
        (op_mode == DMS_VAL_SHUTTING_DOWN))
    {
        is_modem_state_valid = 1;
    }

    ret = qcril_mbn_hw_update_init(apss_subscriptions,
                             modem_subscriptions,
                             is_modem_state_valid,
                             is_on_request);

    if (ret == E_NO_ENTRY)
    {
        if (stat(QCRIL_MBN_COPY_COMPLETE_DIR, &st) == -1)
        {
            QCRIL_LOG_ERROR("Directory %s doesn't exist", QCRIL_MBN_COPY_COMPLETE_DIR);
        }
        else
        {
            if (stat(QCRIL_MBN_COPY_COMPLETE_FILE, &st) == -1)
            {
                //Create and close the file if it doesnt exist. Then
                //register for the file change events for this file.
                fd = qcril_file_create_file(QCRIL_MBN_COPY_COMPLETE_FILE);
                if(fd)
                {
                    qcril_file_close_file(fd);
                }
            }

            qmi_ril_file_observer_register_for_change_event(
                                        (char *) QCRIL_MBN_COPY_COMPLETE_FILE,
                                        (qmi_ril_file_observer_state_change_handler)qcril_qmi_nas_copy_state_change_handler);
        }
    }
}

//===========================================================================
// qcril_qmi_dms_init
//===========================================================================
void qcril_qmi_dms_init()
{
    dms_set_event_report_req_msg_v01 qmi_request;
    dms_set_event_report_resp_msg_v01 qmi_response;

    qmi_client_error_type qmi_transport_error;

    memset( &qmi_request, 0, sizeof( qmi_request ) );
    memset( &qmi_response, 0, sizeof( qmi_response ) );

    qmi_request.report_oprt_mode_state_valid = TRUE;
    qmi_request.report_oprt_mode_state = NAS_REQ_REPORT;

    qmi_request.report_prl_init_valid = TRUE;
    qmi_request.report_prl_init = NAS_REQ_REPORT;

    if ( qmi_ril_is_multi_sim_feature_supported() )
    {
      qmi_request.report_device_multisim_info_valid = TRUE;
      qmi_request.report_device_multisim_info = NAS_REQ_REPORT;
    }

    qmi_transport_error = qmi_client_send_msg_sync_with_shm(
                                        qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                        QMI_DMS_SET_EVENT_REPORT_REQ_V01,
                                        (void*) &qmi_request,
                                        sizeof( qmi_request ),
                                        (void*) &qmi_response,
                                        sizeof( qmi_response ),
                                        QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );
    QCRIL_LOG_INFO( "requested dms_set_event_report reports %d", (int)qmi_transport_error);

    dms_indication_register_req_msg_v01  indication_req;
    dms_indication_register_resp_msg_v01 indication_resp;

    memset(&indication_req, 0, sizeof(indication_req));
    indication_req.report_ims_capability_valid = TRUE;
    indication_req.report_ims_capability = 0x01;

    qmi_transport_error = qmi_client_send_msg_sync_with_shm(
                                        qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS),
                                        QMI_DMS_INDICATION_REGISTER_REQ_V01,
                                        &indication_req,
                                        sizeof(indication_req),
                                        &indication_resp,
                                        sizeof(indication_resp),
                                        QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT);
    QCRIL_LOG_INFO( "requested dms_indication_register reports %d", (int)qmi_transport_error);

    if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_FUSION_CSFB) )
    {  // Fusion specific init
        qcril_qmi_dms_fusion_csfb_init();
    }

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_dms_cached_info.operating_mode);
    qcril_qmi_dms_get_device_caps();

    qcril_qmi_nas_dms_config_activity_info(1);

    qcril_qmi_nas_start_timer_if_early_radio_power_req_came();

    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp, NULL, NULL );
} // qcril_qmi_dms_init

//===========================================================================
// qmi_ril_report_data_connection_information
//===========================================================================
void qmi_ril_report_data_connection_information(void * param)
{
    qcril_unsol_resp_params_type    unsol_resp_params;
    int                             report;
    int                             nof_data_calls;
    qcril_qmi_nas_dc_rt_info_helper_type *qcril_qmi_nas_dc_rt_info_helper;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    report = FALSE;
    nof_data_calls = NAS_NIL;
    qcril_qmi_nas_dc_rt_info_helper = NULL;

    /*
    report = qmi_ril_retrieve_data_connection_information_from_data_call_list(&nof_data_calls, &qcril_qmi_nas_dc_rt_info_helper);
    */

    if( report )
    {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_DC_RT_INFO_CHANGED, &unsol_resp_params );
        if( qcril_qmi_nas_dc_rt_info_helper )
        {
            unsol_resp_params.resp_pkt    = (void*) &qcril_qmi_nas_dc_rt_info_helper->data_call_real_time_info_list_ptr;
            unsol_resp_params.resp_len    = nof_data_calls * sizeof( RIL_DcRtInfo* );
        }
        qcril_send_unsol_response( &unsol_resp_params );
    }

    if( qcril_qmi_nas_dc_rt_info_helper )
    {
        qcril_free(qcril_qmi_nas_dc_rt_info_helper);
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_report_data_connection_information

//===========================================================================
//RIL_REQUEST_GET_DC_RT_INFO
//===========================================================================
void qcril_qmi_nas_request_get_dc_rt_info
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    qcril_request_resp_params_type        resp;
    RIL_Errno                             ril_req_res;
    int                                   nof_data_calls;
    qcril_qmi_nas_dc_rt_info_helper_type *qcril_qmi_nas_dc_rt_info_helper;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    //currently we are not doing any processing for this req
    ril_req_res = RIL_E_REQUEST_NOT_SUPPORTED;
    nof_data_calls = NAS_NIL;
    qcril_qmi_nas_dc_rt_info_helper = NULL;

    /*
    if( qmi_ril_retrieve_data_connection_information_from_data_call_list(&nof_data_calls, &qcril_qmi_nas_dc_rt_info_helper) )
    {
        ril_req_res = RIL_E_SUCCESS;
    }
    */

    // ** respond
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    if( qcril_qmi_nas_dc_rt_info_helper && RIL_E_SUCCESS == ril_req_res )
    {
        resp.resp_pkt    = (void*) &qcril_qmi_nas_dc_rt_info_helper->data_call_real_time_info_list_ptr;
        resp.resp_len    = nof_data_calls * sizeof( RIL_DcRtInfo* );
    }
    qcril_send_request_response( &resp );
    QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);

    if( qcril_qmi_nas_dc_rt_info_helper )
    {
        qcril_free(qcril_qmi_nas_dc_rt_info_helper);
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_data_update_mtu_size_if_needed
//===========================================================================
void qcril_qmi_nas_data_update_mtu_size_if_needed(uint8_t prev_reported_state_valid,
                                                  int prev_reported_state,
                                                  uint8_t prev_reported_tech_valid,
                                                  int prev_reported_tech)
{
    uint8_t curr_reported_state_valid;
    int curr_reported_state;
    uint8_t curr_reported_tech_valid;
    int curr_reported_tech;
    int is_prev_3gpp2_roaming;
    int is_curr_3gpp2_roaming;

    QCRIL_LOG_FUNC_ENTRY();

    curr_reported_state_valid = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.reported_data_reg_status);
    curr_reported_state = nas_cached_info.reported_data_reg_status;
    curr_reported_tech_valid = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.reported_data_technology);
    curr_reported_tech = nas_cached_info.reported_data_technology;
    is_prev_3gpp2_roaming = FALSE;
    is_curr_3gpp2_roaming = FALSE;

    QCRIL_LOG_INFO("mtu size for 3gpp2 roaming %d",nas_common_info.roam_mtu_size_1x);
    QCRIL_LOG_INFO("prev reg state valid %d, value %d, reg tech valid %d, value %d",
                   prev_reported_state_valid,
                   prev_reported_state,
                   prev_reported_tech_valid,
                   prev_reported_tech);
    QCRIL_LOG_INFO("curr reg state valid %d, value %d, reg tech valid %d, value %d",
                   curr_reported_state_valid,
                   curr_reported_state,
                   curr_reported_tech_valid,
                   curr_reported_tech);

    if(NAS_NIL != nas_common_info.roam_mtu_size_1x)
    {
        is_prev_3gpp2_roaming = qcril_qmi_nas_is_3gpp2_roaming(prev_reported_state_valid,
                                                               prev_reported_state,
                                                               prev_reported_tech_valid,
                                                               prev_reported_tech);

        is_curr_3gpp2_roaming = qcril_qmi_nas_is_3gpp2_roaming(curr_reported_state_valid,
                                                               curr_reported_state,
                                                               curr_reported_tech_valid,
                                                               curr_reported_tech);

        if((is_prev_3gpp2_roaming != is_curr_3gpp2_roaming) &&
           ((TRUE == is_prev_3gpp2_roaming) || (TRUE == is_curr_3gpp2_roaming))
           )
        {
#ifndef QMI_RIL_UTF
            if(TRUE == is_curr_3gpp2_roaming)
            {
                QCRIL_LOG_INFO("mtu size being changed to %d",nas_common_info.roam_mtu_size_1x);
                std::shared_ptr<rildata::UpdateMtuMessage> msg =
                    std::make_shared<rildata::UpdateMtuMessage>(nas_common_info.roam_mtu_size_1x);
                if(msg)
                {
                    msg->dispatch();
                }
            }
            else
            {
                QCRIL_LOG_INFO("mtu size being changed to default value");
                std::shared_ptr<rildata::UpdateMtuMessage> msg =
                    std::make_shared<rildata::UpdateMtuMessage>(NAS_ZERO);
                if(msg)
                {
                    msg->dispatch();
                }
            }
#endif
        }
        else
        {
            QCRIL_LOG_INFO("mtu size unchanged");
        }
    }
} //qcril_qmi_nas_data_update_mtu_size_if_needed



//===========================================================================
// DMS unsolicited event handler
//===========================================================================

void qcril_qmi_dms_unsolicited_indication_cb
(
  qmi_client_type                user_handle,
  unsigned int                   message_id,
  void                          *ind_buf,
  unsigned int                   ind_buf_len,
  void                          *ind_cb_data
)
{
  qmi_ind_callback_type qmi_callback;

  QCRIL_LOG_FUNC_ENTRY();

  qmi_callback.data_buf = (unsigned char*)qcril_malloc(ind_buf_len);

  if( qmi_callback.data_buf )
  {
    qmi_callback.user_handle = user_handle;
    qmi_callback.msg_id = message_id;
    memcpy(qmi_callback.data_buf,ind_buf,ind_buf_len);
    qmi_callback.data_buf_len = ind_buf_len;
    qmi_callback.cb_data = ind_cb_data;

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_DMS_HANDLE_INDICATIONS,
                   (void*) &qmi_callback,
                   sizeof(qmi_callback),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
  }
  else
  {
    QCRIL_LOG_FATAL("malloc failed");
  }

  QCRIL_LOG_FUNC_RETURN();
}// qcril_qmi_dms_unsolicited_indication_cb

#ifdef QMI_RIL_UTF
void qcril_qmi_dsd_ind_cb
(
  qmi_client_type                user_handle,
  unsigned int                   message_id,
  void                          *ind_buf,
  unsigned int                   ind_buf_len,
  void                          *ind_cb_data
)
{
  qmi_ind_callback_type qmi_callback;

  QCRIL_LOG_FUNC_ENTRY();

  qmi_callback.data_buf = (unsigned char*)qcril_malloc(ind_buf_len);

  if( qmi_callback.data_buf )
  {
    qmi_callback.user_handle = user_handle;
    qmi_callback.msg_id = message_id;
    memcpy(qmi_callback.data_buf,ind_buf,ind_buf_len);
    qmi_callback.data_buf_len = ind_buf_len;
    qmi_callback.cb_data = ind_cb_data;

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_DSD_HANDLE_INDICATIONS,
                   (void*) &qmi_callback,
                   sizeof(qmi_callback),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
  }
  else
  {
    QCRIL_LOG_FATAL("malloc failed");
  }

  QCRIL_LOG_FUNC_RETURN();
}//qcril_qmi_dsd_ind_cb

/*=========================================================================
  FUNCTION:  qcril_qmi_dms_unsolicited_indication_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_DSD_HANDLE_INDICATIONS

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_dsd_unsolicited_indication_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   void * decoded_payload = NULL;
   dsd_system_status_ind_msg_v01  *dsd_ind = NULL;
   qmi_client_error_type qmi_err;
   uint32_t decoded_payload_len;
   int result = 0;

   int idx;

   qmi_ind_callback_type * qmi_callback = (qmi_ind_callback_type*) params_ptr->data;

   QCRIL_NOTUSED(ret_ptr);

   do {

      if(! qmi_callback )
      {
         QCRIL_LOG_ERROR("qmi_callback is NULL");
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      QCRIL_LOG_INFO("invoked msg 0x%x", (int) qmi_callback->msg_id);

      qmi_err = qmi_idl_get_message_c_struct_len( dsd_get_service_object_v01(),
                                                  QMI_IDL_INDICATION,
                                                  qmi_callback->msg_id,
                                                  &decoded_payload_len);
      if ( qmi_err != QMI_NO_ERR )
      {
         QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      if( !decoded_payload_len )
      {
         // ok, this is a null payload - don't need to process it.
      }
      else
      {
         // process the payload

         decoded_payload = qcril_malloc( decoded_payload_len );
         if (! decoded_payload )
         {
            QCRIL_LOG_ERROR("Failed to alloc memory for decoded payload");
            break;
         }
         memset( decoded_payload, 0, decoded_payload_len );

         qmi_err = qmi_client_message_decode(
                       qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DSD ),
                       QMI_IDL_INDICATION,
                       qmi_callback->msg_id,
                       qmi_callback->data_buf,
                       qmi_callback->data_buf_len,
                       decoded_payload,
                       (int)decoded_payload_len );

         if (qmi_err != QMI_NO_ERR)
         {
            QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
            QCRIL_ASSERT(0); // this is a noop in release build
            qcril_free(decoded_payload);
            break;
         }

         dsd_ind = (dsd_system_status_ind_msg_v01  *) decoded_payload;
         /* If the available systems in invalid, report NULL bearer to RIL */
         if (FALSE == dsd_ind->avail_sys_valid)
         {
          QCRIL_LOG_DEBUG( "invalid avail sys, reporting NULL bearer" );

          dsd_ind->avail_sys_valid = TRUE;
          dsd_ind->avail_sys_len = 1;
          dsd_ind->avail_sys[0].technology = DSD_SYS_NETWORK_3GPP_V01;
          dsd_ind->avail_sys[0].rat_value = DSD_SYS_RAT_EX_NULL_BEARER_V01;
          dsd_ind->avail_sys[0].so_mask = 0ull;
         }
         qcril_arb_set_dsd_sys_status(dsd_ind);

         qcril_free( decoded_payload );
      }


   } while(0);


   if( qmi_callback && qmi_callback->data_buf )
   {
     qcril_free(qmi_callback->data_buf);
   }
}// qcril_qmi_dsd_unsolicited_indication_cb_helper

void qcril_qmi_nas_reboot_cleanup(void)
{
  NAS_CACHE_LOCK();
  nas_cached_info.cached_restricted_details = 0;
  NAS_CACHE_UNLOCK();
}// qcril_qmi_nas_reboot_cleanup
#endif

/*=========================================================================
  FUNCTION:  qcril_qmi_dms_unsolicited_indication_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_DMS_HANDLE_INDICATIONS

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_dms_unsolicited_indication_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   void * decoded_payload = NULL;
   qmi_client_error_type qmi_err;
   uint32_t decoded_payload_len;
   int result = 0;

   qcril_unsol_resp_params_type unsol_resp_params;

   struct nas_evt_post_info_type evt_post_info[MAX_NOF_NAS_EVT_POST_REC];
   int idx;

   qmi_ind_callback_type * qmi_callback = (qmi_ind_callback_type*) params_ptr->data;

   QCRIL_NOTUSED(ret_ptr);
   memset(&evt_post_info, 0, sizeof(evt_post_info));

   do {

      if(! qmi_callback )
      {
         QCRIL_LOG_ERROR("qmi_callback is NULL");
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      QCRIL_LOG_INFO("invoked msg 0x%x", (int) qmi_callback->msg_id);
      qcril_qmi_nas_print_atel_ui_status();

      qmi_err = qmi_idl_get_message_c_struct_len( dms_get_service_object_v01(),
                                                  QMI_IDL_INDICATION,
                                                  qmi_callback->msg_id,
                                                  &decoded_payload_len);
      if ( qmi_err != QMI_NO_ERR )
      {
         QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      if( !decoded_payload_len )
      {
         // ok, this is a null payload - don't need to process it.
      }
      else
      {
         // process the payload

         decoded_payload = qcril_malloc( decoded_payload_len );
         if (! decoded_payload )
         {
            QCRIL_LOG_ERROR("Failed to alloc memory for decoded payload");
            QCRIL_ASSERT(0); // this is a noop in release build
            break;
         }
         memset( decoded_payload, 0, decoded_payload_len );

         qmi_err = qmi_client_message_decode(
                       qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                       QMI_IDL_INDICATION,
                       qmi_callback->msg_id,
                       qmi_callback->data_buf,
                       qmi_callback->data_buf_len,
                       decoded_payload,
                       (int)decoded_payload_len );

         if (qmi_err != QMI_NO_ERR)
         {
            QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
            QCRIL_ASSERT(0); // this is a noop in release build
            qcril_free(decoded_payload);
            break;
         }

         switch ( qmi_callback->msg_id )
         {
            case QMI_DMS_EVENT_REPORT_IND_V01:

               result = qcril_qmi_nas_dms_event_report_qmi2ril(
                               (dms_event_report_ind_msg_v01*) decoded_payload,
                               &evt_post_info[0].engaged );

               if ( (E_SUCCESS == result) && evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED;
               }
               break;

            case QMI_DMS_MODEM_ACTIVITY_INFO_IND_V01:
            {
                qcril_qmi_nas_dms_activity_info_ind_hndlr(
                            (dms_activity_info_ind_msg_v01 *)decoded_payload);
                break;
            }

            case QMI_DMS_IMS_CAPABILITY_IND_V01:
                qcril_qmi_imsa_ims_capability_ind_hdlr(
                        (dms_ims_capability_ind_msg_v01 *) decoded_payload);
                break;
            case QMI_DMS_DEVICE_POWER_INFO_REQUEST_IND_V01:
                {
                    qcril_qmi_nas_dms_device_power_info_ind_hdlr(
                            (dms_device_power_info_request_ind_msg_v01 *) decoded_payload);
                    break;
                }
            case QMI_DMS_DEVICE_INTERACTIVE_STATE_REQUEST_IND_V01:
                {
                    qcril_qmi_nas_dms_device_interactive_state_ind_hdlr(
                            (dms_device_interactive_state_request_ind_msg_v01 *) decoded_payload);
                    break;
                }
            default:
               QCRIL_LOG_ERROR("Unknown DSM unsol message 0x%x", (int) qmi_callback->msg_id);
               QCRIL_ASSERT(0); // this is a noop in release build
               break;
         }

         qcril_free( decoded_payload );
      }

      // submit events
      for ( idx = 0; idx < MAX_NOF_NAS_EVT_POST_REC; idx++ )
      {
         if (! evt_post_info[idx].engaged )
         {
            // No response necessary for this rec
            continue;
         }

         // send a response
         if ( RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED == evt_post_info[idx].ril_evt )
         {
            qcril_qmi_nas_initiate_radio_state_changed_ind();
         }
         else
         {
            qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                              evt_post_info[idx].ril_evt, &unsol_resp_params );
            unsol_resp_params.resp_pkt = evt_post_info[idx].ril_evt_payload;
            unsol_resp_params.resp_len = evt_post_info[idx].ril_evt_payload_len;
            qcril_send_unsol_response( &unsol_resp_params );
            QCRIL_LOG_INFO("posted RIL indication %d", (int) evt_post_info[idx].ril_evt );
         }
      }

   } while(0);

   if( qmi_callback && qmi_callback->data_buf )
   {
     qcril_free(qmi_callback->data_buf);
   }
}// qcril_qmi_dms_unsolicited_indication_cb_helper

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_unsolicited_indication_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_NAS_HANDLE_INDICATIONS

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_nas_unsolicited_indication_cb_helper
(
  unsigned int   msg_id,
  unsigned char *decoded_payload,
  uint32_t       decoded_payload_len
)
{
   struct nas_evt_post_info_type evt_post_info[MAX_NOF_NAS_EVT_POST_REC];
   char ril_nitz_time[NAS_NITZ_STR_BUF_MAX];
   RIL_CdmaSubscriptionSource sub_source;

   int is_pre_registered = FALSE;
   int is_post_registered = FALSE;
   int restricted_details;
   int result = 0;
   int is_now_registered;
   int emergency_callback_mode_state;

   do {

      QCRIL_LOG_INFO("invoked msg 0x%x", (int) msg_id);
      NAS_CACHE_LOCK();
      qcril_qmi_nas_print_atel_ui_status();

      is_pre_registered = qcril_qmi_nas_is_considered_registered(NULL);

      if(! decoded_payload_len )
      {
         // NULL payload
         switch ( msg_id )
         {
            case QMI_NAS_DDTM_IND_MSG_V01:
            case QMI_NAS_CSP_PLMN_MODE_BIT_IND_MSG_V01:
               // no handling
               break;

            default:
               QCRIL_LOG_ERROR("Unknown message or missing payload");
               QCRIL_ASSERT(0); // this is a noop in release build
               break;
         }
      }
      else
      {
         memset( &evt_post_info, 0, sizeof( evt_post_info ) );
         // Handle messages w/payload required
         switch ( msg_id )
         {
            case QMI_NAS_EVENT_REPORT_IND_MSG_V01:
               result = qcril_qmi_nas_event_report_ind_conv_qmi2ril(
                               (nas_event_report_ind_msg_v01*) decoded_payload,
                               &evt_post_info[0].engaged,
                               &evt_post_info[1].engaged );
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed event_report_ind_conv_qmi2ril w/%d",
                                  result);
                  break;
               }

               is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);

               if ( is_now_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }

               if (evt_post_info[0].engaged || evt_post_info[1].engaged)
               {
                 qcril_qmi_nas_wave_voice_data_status();
               }
               break;

            case QMI_NAS_SIG_INFO_IND_MSG_V01:
               result = qcril_qmi_nas_sig_info_ind_conv_qmi2ril(
                                 (nas_sig_info_ind_msg_v01*) decoded_payload);
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed sig_info_ind_conv_qmi2ril w/%d",
                                   result);
                  break;
               }

               is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);

               if ( is_now_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               break;

            case QMI_NAS_ERR_RATE_IND_MSG_V01:
               result = qcril_qmi_nas_err_rate_ind_conv_qmi2ril(
                                 (nas_err_rate_ind_msg_v01*) decoded_payload);
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed err_rate_ind_conv_qmi2ril w/%d",
                                   result);
                  break;
               }

               is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);

               if ( is_now_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               break;

            case QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01:
               result = qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril(
                   (nas_system_selection_preference_ind_msg_v01*) decoded_payload,
                   &evt_post_info[0].engaged,
                   &evt_post_info[1].engaged );
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed system_selection_preference_ind_conv_qmi2ril w/%d", result);
                  break;
               }

               if ( ! (evt_post_info[0].engaged || evt_post_info[1].engaged) )
               {
                  // nothing engaged, ignore
                  break;
               }

               if ( evt_post_info[0].engaged )
               {
                   emergency_callback_mode_state = (int) qmi_ril_nwr_get_eme_cbm();
                   QCRIL_LOG_INFO(".. EME CB set event, however relying on"
                                  " manual setting of eme cb, cur_mode %d",
                                   emergency_callback_mode_state);

                   qcril_qmi_nas_emergency_mode_on_hdlr();
               }
               if ( evt_post_info[1].engaged )
               {
                   qcril_qmi_nas_emergency_mode_off_hdlr();
               }

               qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler((nas_system_selection_preference_ind_msg_v01*) decoded_payload);
               break;

            case QMI_NAS_DDTM_IND_MSG_V01:
               // no handling
               break;

            case QMI_NAS_SYS_INFO_IND_MSG_V01:
               restricted_details = RIL_RESTRICTED_STATE_NONE;
               result = qcril_qmi_nas_sys_info_ind_conv_qmi2ril(
                                  (nas_sys_info_ind_msg_v01 *) decoded_payload,
                                  &evt_post_info[0].engaged,
                                  &evt_post_info[2].engaged,
                                  &evt_post_info[1].engaged);
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed sys_info_ind_conv_qmi2ril w/%d",
                                   result);
                  break;
               }

               if ( !(evt_post_info[0].engaged || evt_post_info[1].engaged
                     || evt_post_info[2].engaged) )
               {
                  // Nothing engaged
                  break;
               }

               is_post_registered = qcril_qmi_nas_is_considered_registered(NULL);

               if (evt_post_info[0].engaged || evt_post_info[1].engaged)
               {
                 qcril_qmi_nas_wave_voice_data_status();
               }

               if ( evt_post_info[2].engaged )
               {
                  // follow the old logic
                  qmi_ril_gen_operational_status_type op_status = qmi_ril_get_operational_status();
                  QCRIL_LOG_INFO(".. operational state %d", op_status);
                  if (op_status != QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED &&
                      QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag)
                  {
                    qcril_qmi_nas_initiate_voice_rte_change_propagation();
                  }
                  else
                  {
                    qcril_qmi_nas_post_voice_rte_change_ind_handler(nullptr, nullptr);
                  }
               }
               if ( ( is_post_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update ) && !is_pre_registered )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               break;

             case QMI_NAS_CURRENT_PLMN_NAME_IND_V01:
                result = qcril_qmi_nas_current_plmn_name_ind_conv_qmi2ril(
                          (nas_current_plmn_name_ind_msg_v01*) decoded_payload,
                          &evt_post_info[0].engaged );
                if ( result != E_SUCCESS ) {
                   QCRIL_LOG_ERROR("Failed current_plmn_name_ind_conv_qmi2ril w/%d", result);
                   break;
                }
                if (evt_post_info[0].engaged)
                {
                   qcril_qmi_nas_wave_voice_data_status();
                   is_post_registered = qcril_qmi_nas_is_considered_registered(NULL);
                   if ( ( is_post_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update ) && !is_pre_registered )
                   {
                      qcril_qmi_nas_send_known_signal_strength();
                   }
                }
                break;

            case QMI_NAS_CSP_PLMN_MODE_BIT_IND_MSG_V01:
               // no handling
               break;

            case QMI_NAS_DUAL_STANDBY_PREF_IND_MSG_V01:
               qcril_qmi_nas_dsds_dual_standby_pref_ind_handler( (nas_dual_standby_pref_ind_msg_v01*) decoded_payload );
               break;

            case QMI_NAS_SUBSCRIPTION_INFO_IND_MSG_V01:
               qcril_qmi_nas_subscription_info_ind_handler( (nas_subscription_info_ind_msg_v01*) decoded_payload );
               break;

            case QMI_NAS_NETWORK_TIME_IND_MSG_V01:
               qcril_qmi_nas_network_time_ind_conv_qmi2ril(
                               (nas_network_time_ind_msg_v01*) decoded_payload,
                               ril_nitz_time, &evt_post_info[0].engaged);
               if ( evt_post_info[0].engaged )
               {
                  // no operational state restrict for NITZ message
                  auto msg = std::make_shared<RilUnsolNitzTimeReceivedMessage>(ril_nitz_time);
                  Dispatcher::getInstance().dispatchSync(msg);
               }
               break;

            case QMI_NAS_LTE_SIB16_NETWORK_TIME_IND_V01:
               qcril_qmi_nas_sib16_network_time_ind_hdlr((nas_lte_sib16_network_time_ind_msg_v01*) decoded_payload);
               break;

            case QMI_NAS_RTRE_CONFIG_IND_V01:
               qcril_qmi_nas_rtre_config_ind_conv_qmi2ril(
                               (nas_rtre_cfg_ind_msg_v01*) decoded_payload,
                               &sub_source, &evt_post_info[0].engaged);
               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED;
                  evt_post_info[0].ril_evt_payload = &sub_source;
                  evt_post_info[0].ril_evt_payload_len = sizeof(sub_source);
               }
               break;

            case QMI_NAS_EMBMS_STATUS_IND_V01:
               qcril_qmi_nas_embms_embms_status_ind_handler( (nas_embms_status_ind_msg_v01*)decoded_payload );
               break;

            case QMI_NAS_SET_BUILTIN_PLMN_LIST_IND_MSG_V01:
              qcril_qmi_nas_set_builtin_plmn_list_ind_handler( (nas_set_builtin_plmn_list_ind_msg_v01*)decoded_payload );
            break;

            case QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_IND_MSG_V01:
              qcril_qmi_nas_perform_incremental_network_scan_ind_handler( (nas_perform_incremental_network_scan_ind_msg_v01*)decoded_payload );
              break;

           case QMI_NAS_GET_SERV_CELL_SIB_IND_MSG_V01:
              qcril_qmi_nas_get_serv_cell_sib_ind_handler((nas_get_serv_cell_sib_ind_msg_v01*)decoded_payload);
              break;

           case QMI_NAS_GCELL_INFO_IND_V01:
               if (TRUE == nas_common_info.bar_fake_gcell)
               {
                  qcril_qmi_nas_gcell_info_ind_handler((nas_gcell_info_ind_v01*)decoded_payload);
               }
               break;

           case QMI_NAS_SSAC_CHANGE_INFO_IND_V01:
              qcril_qmi_nas_get_ssac_change_info_ind_handler(
                      (nas_ssac_change_info_ind_msg_v01*)decoded_payload);
              break;

           case QMI_NAS_SUB_BLOCKED_STATUS_IND_V01:
               qcril_qmi_nas_sub_blocked_status_ind_handler(
                         (nas_sub_blocked_status_ind_msg_v01*) decoded_payload,
                         &evt_post_info[0].engaged );

               if (evt_post_info[0].engaged)
               {
                  qcril_qmi_nas_wave_voice_data_status();
               }
               break;

           case QMI_NAS_5G_MODEM_VOTE_IND_V01:
               if (((nas_5g_modem_vote_ind_v01*) decoded_payload)->vote_ind_for_5g_modem == 1)
               {
                   qcril_qmi_vote_up_secondary_modem();
               }
               else
               {
                   qcril_qmi_vote_down_secondary_modem();
               }
               break;

            default:
               break;
         } // end_switch

      } // end_else process event w/payload

   } while(0);
   NAS_CACHE_UNLOCK();
   QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_unsolicited_indication_cb_helper

//===========================================================================
//qcril_qmi_dms_save_prl_info
//===========================================================================
void qcril_qmi_dms_save_prl_info(int prl_version_is_set, uint16_t prl_version)
{
    QCRIL_LOG_INFO("prl_version_is_set %d, prl_version %d",prl_version_is_set,prl_version);

    NAS_CACHE_LOCK();
    nas_cached_info.prl_version_is_set = prl_version_is_set;
    nas_cached_info.prl_version = prl_version;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
}// qcril_qmi_dms_save_prl_info

//===========================================================================
//qcril_qmi_dms_is_prl_info_available
//===========================================================================
int qcril_qmi_dms_is_prl_info_available(uint16_t * prl_version)
{
    int ret;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    ret = nas_cached_info.prl_version_is_set;
    if( TRUE == nas_cached_info.prl_version_is_set && NULL != prl_version )
    {
        *prl_version = nas_cached_info.prl_version;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}// qcril_qmi_dms_is_prl_info_available

boolean qmi_ril_in_apm_leave_window(void)
{
    boolean res;

    NAS_CACHE_LOCK();
    res = nas_cached_info.is_in_apm_leave_window;
    NAS_CACHE_UNLOCK();

    return res;
}

void qcril_qmi_nas_apm_leave_timeout_handler(void* params)
{
    QCRIL_NOTUSED(params);
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    nas_cached_info.is_in_apm_leave_window = FALSE;
    nas_cached_info.apm_timer_id = 0;
    NAS_CACHE_UNLOCK();

    qcril_qmi_voice_trigger_possible_pending_emergency_call();
}

void qcril_qmi_nas_clear_apm_leave_timer()
{
    uint32_t timer_id;

    NAS_CACHE_LOCK();
    nas_cached_info.is_in_apm_leave_window = FALSE;
    timer_id = nas_cached_info.apm_timer_id;
    nas_cached_info.apm_timer_id = 0;
    NAS_CACHE_UNLOCK();

    /* do not care about the cancellation results */
    if (timer_id)
    {
      QCRIL_LOG_DEBUG("cancelling the existed apm leave timer");
      (void) qcril_cancel_timed_callback((void*)(uintptr_t)timer_id);
    }
}

void qcril_qmi_nas_start_apm_leave_timer()
{
    struct timeval apm_leave_timeout;
    uint32_t timer_id = NAS_NIL;
    int res;

    QCRIL_LOG_FUNC_ENTRY();
    /* before start the apm timer, clear any existed */
    qcril_qmi_nas_clear_apm_leave_timer();

    apm_leave_timeout.tv_sec = nas_common_info.wait_time_for_fake_ecc;
    apm_leave_timeout.tv_usec = NAS_NIL;
    res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID,
            qcril_qmi_nas_apm_leave_timeout_handler,
            &apm_leave_timeout,
            &timer_id);

    if (E_SUCCESS == res && NAS_NIL != timer_id)
    {
      NAS_CACHE_LOCK();
      nas_cached_info.is_in_apm_leave_window = TRUE;
      nas_cached_info.apm_timer_id = timer_id;
      NAS_CACHE_UNLOCK();
    }
    else
    {
      QCRIL_LOG_ERROR("failed to start apm timer...un-set the apm leave window");
      NAS_CACHE_LOCK();
      nas_cached_info.is_in_apm_leave_window = FALSE;
      nas_cached_info.apm_timer_id = 0;
      NAS_CACHE_UNLOCK();
    }
}

void qcril_qmi_nas_boot_up_optimization_state_machine(void)
{
    int android_mode_pref = -1;
    uint8 mode_pref_changed = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    uint8_t bootup_power_optimization_state = qcril_qmi_nas_get_bootup_power_optimization_state();
    if( QCRIL_POWER_OPT_BOOT_UP_TRIGGER_ONLINE == bootup_power_optimization_state
        && DMS_OP_MODE_LOW_POWER_V01 == nas_dms_cached_info.operating_mode )
    {
        qcril_qmi_nas_decide_mode_pref_to_set_on_modem(&android_mode_pref);
        if( android_mode_pref != -1 )
        {
            if (qmi_ril_nwreg_request_mode_pref(android_mode_pref, &mode_pref_changed) == RIL_E_SUCCESS
                && (mode_pref_changed == TRUE || !nas_common_info.last_android_mode_pref_valid))
            {
                qcril_qmi_nas_save_android_mode_pref(android_mode_pref);
            }
        }

        if( !qcril_qmi_nas_get_atel_ui_ready_req_came_from_cache() )
        {
            qcril_qmi_nas_set_atel_ui_status_to_modem(FALSE); //ATEL_UI NOT_READY
            qcril_qmi_nas_set_atel_ui_status_to_cache(FALSE); //Update RIL cache, ATEL_UI NOT_READY
        }

        /* Do not care whether the setting succeeds or not. Set COMPLETE always */
        (void)qcril_qmi_nas_set_operating_mode_state(DMS_OP_MODE_ONLINE_V01);
        qcril_qmi_nas_set_bootup_power_optimization_state(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_COMPLETE);
    }
    else if (nas_dms_cached_info.operating_mode_valid &&
            DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode)
    {
        // if modem is online, set the bootup optimization state as COMPLETE
        qcril_qmi_nas_set_bootup_power_optimization_state(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_COMPLETE);
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//dms evt report update
//===========================================================================
int qcril_qmi_nas_dms_event_report_qmi2ril(dms_event_report_ind_msg_v01 * qmi_msg,
                                                  int * radio_state_updated
                                                )
{
  int common_modem_state_update   = FALSE;
  int operating_state_update      = FALSE;
  int follow_up_deferred_mode_set = FALSE;
  uint8_t modem_stack_id = (uint8_t) qcril_qmi_get_modem_stack_id();

  QCRIL_LOG_FUNC_ENTRY();

  if ( qmi_msg )
  {
    QCRIL_LOG_INFO("oprt %d / %d", qmi_msg->operating_mode_valid, qmi_msg->operating_mode );
    QCRIL_LOG_INFO("prl_init %d / %d", qmi_msg->prl_init_valid, qmi_msg->prl_init );

    if (qmi_msg->multisim_capability_valid == TRUE )
    {
        QCRIL_LOG_INFO(" max_subscriptions %d ", (int) qmi_msg->multisim_capability.max_subscriptions);
        NAS_CACHE_LOCK();
        nas_dms_cached_info.max_subscriptions = qmi_msg->multisim_capability.max_subscriptions;
        if ( qmi_msg->multisim_capability.subscription_config_list_len > 0 )
        {
          QCRIL_LOG_INFO(" max_subscriptions_active %d ", (int) qmi_msg->multisim_capability.subscription_config_list[0].max_active );
          // Currently max_active will be uniform for all config in config list.
          // So, pick first config type.
          nas_dms_cached_info.max_subscriptions_active = qmi_msg->multisim_capability.subscription_config_list[0].max_active;
          if ( qmi_ril_get_process_instance_id() == QCRIL_DEFAULT_INSTANCE_ID )
          {
            qcril_qmi_nas_dms_update_multisim_config_property();
          }
        }
        NAS_CACHE_UNLOCK();
    }

    if ( qmi_msg->max_active_data_subscriptions_valid == TRUE )
    {
        QCRIL_LOG_DEBUG("[MSIM] Max Active Data : %d", qmi_msg->max_active_data_subscriptions);

        // Unsol modem capability shall be sent only for change in max data subscription.
        if (!NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) || nas_dms_cached_info.max_active_data_subs != qmi_msg->max_active_data_subscriptions)
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_dms_cached_info.max_active_data_subs,
                                           qmi_msg->max_active_data_subscriptions);
            NAS_CACHE_UNLOCK();
            qcril_qmi_nas_send_unsol_modem_capability();
            qcril_qmi_nas_send_unsol_max_data_changed();
        }
    }
    // Handle sub/stack capability for msim
    if ( ( qmi_msg->subs_voice_data_capability_valid == TRUE ) &&
         ( qmi_msg->subs_voice_data_capability_len > modem_stack_id ) )
    {
        NAS_CACHE_LOCK();
        QCRIL_LOG_DEBUG("[MSIM] Current sub voice data capability %d ", (int) qmi_msg->subs_voice_data_capability[modem_stack_id].subs_voice_data_capability);
        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.subs_voice_data_capability, qmi_msg->subs_voice_data_capability[modem_stack_id].subs_voice_data_capability );
        NAS_CACHE_UNLOCK();
    }

    if ( qmi_msg->operating_mode_valid )
    {
        NAS_CACHE_LOCK();
        NAS_CACHE_STORE_TINY_ENTRY( nas_dms_cached_info.operating_mode, qmi_msg->operating_mode );
        if ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode && nas_cached_info.deferred_mode_pref_set_valid )
        {
            follow_up_deferred_mode_set = TRUE;
        }
        qcril_qmi_nas_boot_up_optimization_state_machine();
        NAS_CACHE_UNLOCK();

        qmi_ril_nwreg_common_ind_subscribe_consider_action_handler();

        if( qmi_msg->operating_mode == DMS_VAL_FACTORY_TEST_MODE )
        {
            common_modem_state_update = TRUE;
            operating_state_update = TRUE;
        }
        else
        {
            //XXX: should we start timer in request power handler
            // to start the timer earlier?
            if ( DMS_OP_MODE_ONLINE_V01 == qmi_msg->operating_mode )
                qcril_qmi_nas_start_apm_leave_timer();
            else if ( DMS_OP_MODE_LOW_POWER_V01 == qmi_msg->operating_mode )
                qcril_qmi_nas_clear_apm_leave_timer();
            qcril_qmi_nas_dms_op_state_update_handler(qmi_msg->operating_mode);
        }

        if ( DMS_OP_MODE_ONLINE_V01 == qmi_msg->operating_mode )
        {
            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                           QCRIL_DEFAULT_MODEM_ID,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_RIL_POST_OPRT_ONLINE_ACTION,
                           NULL,
                           NAS_NIL,
                           (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        }
    }

    if ( qmi_msg->prl_init_valid && qmi_msg->prl_init )
    { // initiate recheck if PRL ver has changed or not
        qcril_qmi_nas_dms_handle_prl_change_helper();
    }
  }
  else
  {
    QCRIL_LOG_DEBUG("qmi_msg ptr is passed NULL");
  }

    NAS_CACHE_LOCK();

    if ( common_modem_state_update )
    {
        qcril_qmi_nas_dms_update_common_modem_state();
    }

    NAS_CACHE_UNLOCK();

    *radio_state_updated = operating_state_update;

    if ( follow_up_deferred_mode_set )
    {
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_ENFORCE_DEFERRED_MODE_PREF_SET,
                       NULL,
                       NAS_NIL,
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }

    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
}

//===========================================================================
//qcril_qmi_nas_dms_fetch_cur_prl_version
//===========================================================================
RIL_Errno qcril_qmi_nas_dms_fetch_cur_prl_version(uint16_t * prl_version)
{
    qmi_client_error_type qmi_client_error;
    dms_get_current_prl_info_resp_msg_v01  qmi_current_prl_info_response;

    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    memset(&qmi_current_prl_info_response, 0, sizeof(qmi_current_prl_info_response) );

    if ( prl_version )
    {
        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                         QMI_DMS_GET_CURRENT_PRL_INFO_REQ_V01,
                                                         NULL, // no request payload for QMI_DMS_GET_CURRENT_PRL_INFO_REQ_V01
                                                         NAS_NIL,
                                                         (void*) &qmi_current_prl_info_response,
                                                         sizeof( qmi_current_prl_info_response ),
                                                         QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_current_prl_info_response.resp );
        if ( RIL_E_SUCCESS == res )
        {
            if( TRUE == qmi_current_prl_info_response.prl_version_valid )
            {
              *prl_version = qmi_current_prl_info_response.prl_version;
              QCRIL_LOG_INFO( ".. Current prl_version  %d", (int) qmi_current_prl_info_response.prl_version );
            }
            else
            {
              QCRIL_LOG_INFO("Current PRL info unavailable" );
              QCRIL_LOG_ERROR("Modem error..prl version not present in the response");
              res = RIL_E_MODEM_ERR;
            }
        }
    }
    else
    {
      QCRIL_LOG_ERROR("Internal error..null params for prl_version");
      res = RIL_E_INTERNAL_ERR;
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) res );
    return res;
}

//===========================================================================
//qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed
//===========================================================================
void qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed(void)
{
    int is_set;

    is_set = qcril_qmi_dms_is_prl_info_available(NULL);

    QCRIL_LOG_INFO("is_set: %d", (int) is_set );
    if ( !is_set )
    {
        qcril_qmi_nas_dms_handle_fetch_prl_request();
    }

} // qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed

//===========================================================================
// QCRIL_EVT_QMI_RIL_PRL_VER_FETCH_ATTEMPT
//===========================================================================
void qcril_qmi_nas_dms_handle_fetch_prl_request()
{
    QCRIL_LOG_FUNC_ENTRY();
    qcril_qmi_nas_dms_handle_prl_change_helper();
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_handle_fetch_prl_request

//===========================================================================
// qcril_qmi_nas_dms_handle_prl_change_helper
//===========================================================================
void qcril_qmi_nas_dms_handle_prl_change_helper()
{
  uint16_t    prl_version;
  RIL_Errno   res;

  uint16_t    previous_prl_version;
  int         previous_prl_version_was_set;

  QCRIL_LOG_FUNC_ENTRY();

  res = qcril_qmi_nas_dms_fetch_cur_prl_version( &prl_version );
  if ( RIL_E_SUCCESS == res )
  {
      previous_prl_version_was_set = qcril_qmi_dms_is_prl_info_available(&previous_prl_version);
      qcril_qmi_dms_save_prl_info(TRUE, prl_version);

      QCRIL_LOG_INFO( "prl ver prev %d, ver cur %d, was set %d ", (int) previous_prl_version, (int)prl_version, previous_prl_version_was_set  );

      if ( FALSE == previous_prl_version_was_set || previous_prl_version != prl_version )
      {
            auto msg = std::make_shared<RilUnsolCdmaPrlChangedMessage>(prl_version);
            Dispatcher::getInstance().dispatchSync(msg);
      }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_handle_prl_change_helper


//===========================================================================
//qcril_qmi_nas_dms_op_state_update_handler
//===========================================================================
void qcril_qmi_nas_dms_op_state_update_handler(dms_operating_mode_enum_v01 new_op_state)
{
    errno_enum_type                       found_qcril_request;
    dms_operating_mode_enum_v01           required_operating_mode;
    int operating_mode_match;

    QCRIL_LOG_FUNC_ENTRY();

    operating_mode_match = FALSE;

    if( new_op_state >= NAS_DMS_OP_MODE_START && new_op_state <= NAS_DMS_OP_MODE_END)
    {
        QCRIL_LOG_ESSENTIAL("reported op mode %s", dms_op_mode_name[new_op_state]);
    }

    auto& msgList = getDmsModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestRadioPowerMessage::get_class_message_id());
    found_qcril_request = pendingMsg ? E_SUCCESS : E_FAILURE;
    QCRIL_LOG_INFO("found qcril request %d", (int) found_qcril_request);

    if( E_SUCCESS == found_qcril_request )
    {
        auto msg = std::static_pointer_cast<RilRequestRadioPowerMessage>(pendingMsg);

        if ( msg != nullptr) {

            required_operating_mode =
                msg->getRadioState() ? DMS_OP_MODE_ONLINE_V01 : DMS_OP_MODE_LOW_POWER_V01;
           if( required_operating_mode >= NAS_DMS_OP_MODE_START && required_operating_mode <= NAS_DMS_OP_MODE_END)
            {
                QCRIL_LOG_ESSENTIAL("expected op mode %s", dms_op_mode_name[required_operating_mode]);
            }

            if( required_operating_mode == new_op_state )
            {
                operating_mode_match = TRUE;
                RADIO_POWER_LOCK();
                if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM == nas_common_info.radio_pwr_signal_cond )
                {
                    RADIO_POWER_SIGNAL();
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                }
                RADIO_POWER_UNLOCK();
            }
        }
    }
    else
    {
        if( nas_common_info.prov_emer_call_in_lpm )
        {
            RADIO_POWER_LOCK();
            QCRIL_LOG_INFO("current state %d", nas_common_info.radio_pwr_prov_emer_call_lpm_state);
            if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE == nas_common_info.radio_pwr_prov_emer_call_lpm_state )
            {
                if( nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode >= NAS_DMS_OP_MODE_START && nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode <= NAS_DMS_OP_MODE_END)
                {
                    QCRIL_LOG_ESSENTIAL("expected op mode %s", dms_op_mode_name[nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode]);
                }
                if( nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode == new_op_state)
                {
                    operating_mode_match = TRUE;
                    nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE;
                    if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM == nas_common_info.radio_pwr_signal_cond )
                    {
                        RADIO_POWER_SIGNAL();
                        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                    }
                }
            }
            RADIO_POWER_UNLOCK();
        }
        if( nas_common_info.relay_oprt_change )
        {
            qcril_qmi_nas_initiate_radio_state_changed_ind();
        }
    }

    if( FALSE == operating_mode_match )
    {
        QCRIL_LOG_INFO("reported op mode does not match with expected op mode");
    }

    if( DMS_OP_MODE_ONLINE_V01 != new_op_state )
    {
        qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
        qcril_qmi_arb_reset_pref_data_snapshot();
        qcril_qmi_drop_sig_info_cache();
        NAS_CACHE_LOCK();
        NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_blocked);
        qcril_qmi_nas_update_voice_rte();
        qcril_qmi_nas_update_data_rte();
        qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );
        qmi_ril_nwr_update_reg_rej_from_sys_info();
        NAS_CACHE_UNLOCK();
        qcril_qmi_nas_send_response_for_pending_network_selection_request();
        qcril_qmi_nas_reset_extrapolation_ban_expiry();
        qcril_qmi_nas_wave_voice_data_status();
    }
    else
    {
        NAS_CACHE_LOCK();
        NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_blocked);
        qcril_qmi_nas_fetch_sub_blocked_status();
        qcril_qmi_nas_drop_nw_info_cache();
        qcril_qmi_nas_fetch_sys_info();
        NAS_CACHE_UNLOCK();
        qcril_qmi_nas_wave_voice_data_status();
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_dms_op_state_update_handler

typedef struct
{
  uint16                      sid;
  uint16                      nid;
  uint16                      mnc;
  uint16                      mcc;
} sdprl_sid_nid_pair_type;

//===========================================================================
//QCRIL_EVT_HOOK_CDMA_GET_AVOIDANCE_LIST
//===========================================================================
void qcril_qmi_nas_get_cdma_avoid_system_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    int i = 0;
    qmi_client_error_type qmi_client_error;
    qcril_instance_id_e_type instance_id;
    qcril_modem_id_e_type modem_id;
    qcril_request_resp_params_type resp;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    int result_array[NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01*4+1];
    sdprl_sid_nid_pair_type temp[NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01];
    nas_get_cdma_avoid_system_list_resp_msg_v01 cdma_get_avoid_info_list_resp;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    do
    {
        if( NULL == params_ptr )
            break;

        instance_id = params_ptr->instance_id;
        if( instance_id >= QCRIL_MAX_INSTANCE_ID )
            break;

        modem_id = params_ptr->modem_id;
        if( modem_id >= QCRIL_MAX_MODEM_ID )
            break;

        memset(result_array, 0, sizeof(result_array));
        memset(temp, 0, sizeof(temp));
        memset(&cdma_get_avoid_info_list_resp, 0, sizeof(cdma_get_avoid_info_list_resp));
        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_CDMA_AVOID_SYSTEM_LIST_REQ_MSG_V01,
                                                      NULL,
                                                      QMI_RIL_ZERO,
                                                      (void*) &cdma_get_avoid_info_list_resp,
                                                      sizeof( cdma_get_avoid_info_list_resp ),
                                                      ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        QCRIL_LOG_INFO("qmi_client_error=%d",qmi_client_error);
        if (qmi_client_error != QMI_NO_ERR)
        {
            qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
            qcril_send_request_response( &resp );
            break;
        }

        QCRIL_LOG_INFO("nam1_systems_valid=%d",cdma_get_avoid_info_list_resp.nam1_systems_valid);
        if( TRUE == cdma_get_avoid_info_list_resp.nam1_systems_valid )
        {
            QCRIL_LOG_INFO("nam1_systems_len=%d",cdma_get_avoid_info_list_resp.nam1_systems_len);
            ril_req_res = RIL_E_SUCCESS;
            memcpy(temp, cdma_get_avoid_info_list_resp.nam1_systems, sizeof(temp));
            result_array[0] = cdma_get_avoid_info_list_resp.nam1_systems_len;
            for (i = 0; i < NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01; i++)
            {
                result_array[i*4+1] = temp[i].sid;
                result_array[i*4+2] = temp[i].nid;
                result_array[i*4+3] = temp[i].mnc;
                result_array[i*4+4] = temp[i].mcc;
            }
        }

        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );

        resp.resp_pkt = (void *) result_array;
        resp.resp_len = sizeof( result_array);
        qcril_send_request_response( &resp );
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_get_cdma_avoid_system_list

/*==========================================================================
  QCRIL_EVT_HOOK_CDMA_AVOID_CUR_NWK
===========================================================================
  FUNCTION: qcril_qmi_nas_cdma_avoid_system
=========================================================================*/
void qcril_qmi_nas_cdma_avoid_system
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;

  nas_cdma_avoid_system_req_msg_v01 cdma_avoid_info;
  nas_cdma_avoid_system_resp_msg_v01 qmi_response;
  qcril_request_resp_params_type resp;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_client_error_type qmi_transport_error;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    memset(&cdma_avoid_info, 0, sizeof(cdma_avoid_info));
    memset(&qmi_response, 0, sizeof(qmi_response));

    if( NULL == params_ptr )
      break;

    instance_id = params_ptr->instance_id;
    if( instance_id >= QCRIL_MAX_INSTANCE_ID )
      break;

    modem_id = params_ptr->modem_id;
    if( modem_id >= QCRIL_MAX_MODEM_ID )
      break;

    QCRIL_NOTUSED( ret_ptr );

    cdma_avoid_info.avoid_type = NAS_AVOID_SYS_IDLE_V01;

    QCRIL_LOG_INFO("Avoid Type:%d",cdma_avoid_info.avoid_type);

    qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_CDMA_AVOID_SYSTEM_REQ_MSG_V01,
                                                     &cdma_avoid_info,
                                                     sizeof(cdma_avoid_info),
                                                     &qmi_response,
                                                     sizeof(qmi_response));

    QCRIL_LOG_INFO("%s  qmi_transport_error:%d","AVOID CDMA SYSTEM ",qmi_transport_error);
    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_transport_error, &qmi_response.resp );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_cdma_avoid_system

/*==========================================================================
  QCRIL_EVT_HOOK_CDMA_CLEAR_AVOIDANCE_LIST
===========================================================================
  FUNCTION: qcril_qmi_nas_cdma_clear_avoid_list
=========================================================================*/
void qcril_qmi_nas_cdma_clear_avoid_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;

  nas_cdma_avoid_system_req_msg_v01 cdma_avoid_info;
  nas_cdma_avoid_system_resp_msg_v01 qmi_response;
  qcril_request_resp_params_type resp;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_client_error_type qmi_transport_error;

  QCRIL_LOG_FUNC_ENTRY();
  do
  {
    memset(&cdma_avoid_info, 0, sizeof(cdma_avoid_info));
    memset(&qmi_response, 0, sizeof(qmi_response));

    if( NULL == params_ptr )
      break;

    instance_id = params_ptr->instance_id;
    if( instance_id >= QCRIL_MAX_INSTANCE_ID )
      break;

    modem_id = params_ptr->modem_id;
    if( modem_id >= QCRIL_MAX_MODEM_ID )
      break;

    QCRIL_NOTUSED( ret_ptr );

    cdma_avoid_info.avoid_type = NAS_AVOID_SYS_CLR_LIST_V01;
    QCRIL_LOG_INFO("Clear Avoid Type:%d",cdma_avoid_info.avoid_type);

    qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_CDMA_AVOID_SYSTEM_REQ_MSG_V01,
                                                     &cdma_avoid_info,
                                                     sizeof(cdma_avoid_info),
                                                     &qmi_response,
                                                     sizeof(qmi_response));

    QCRIL_LOG_INFO("%s  qmi_transport_error:%d","CLEAR AVOID CDMA LIST ",qmi_transport_error);
    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_transport_error, &qmi_response.resp );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_cdma_clear_avoid_list

//===========================================================================
//QCRIL_EVT_HOOK_SET_BUILTIN_PLMN_LIST
//===========================================================================
void qcril_qmi_nas_set_builtin_plmn_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  nas_set_builtin_plmn_list_req_msg_v01 req_msg;
  uint8 set_builtin_plmn_req[QCRIL_QMI_NAS_MAX_OPLMN_LIST];
  uint16 no_of_oplmn = 0;
  RIL_Errno result = RIL_E_SUCCESS;
  qmi_client_error_type qmi_client_error;
  nas_set_builtin_plmn_list_resp_msg_v01  qmi_response;
  qcril_request_resp_params_type resp;
  qcril_reqlist_public_type qcril_req_info_ptr;
  int oem_data_len = 0, i, j=0;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  do
  {

    if( NULL ==  params_ptr->data || 0 == params_ptr->datalen )
    {
      result = RIL_E_GENERIC_FAILURE;
      break;
    }

    oem_data_len = params_ptr->datalen;
    QCRIL_LOG_DEBUG ("oem_data_len = %d",oem_data_len);
    memset(&req_msg,0,sizeof(nas_set_builtin_plmn_list_req_msg_v01));
    memset(&set_builtin_plmn_req,0,oem_data_len);
    memcpy(&set_builtin_plmn_req, (void*)params_ptr->data, oem_data_len);
    memcpy(&no_of_oplmn, (void *)&set_builtin_plmn_req[0], sizeof(uint16));

    QCRIL_LOG_DEBUG ("No. of OPLMN = %d", no_of_oplmn);

    if (no_of_oplmn > 0)
    {
      req_msg.oplmn_list_valid = TRUE;
      req_msg.oplmn_list.list_id = (intptr_t)params_ptr->t;
      // total_list_entries may vary only when we send multiple oplmn lists.
      // Currently Android will send only max 500 entries.
      req_msg.oplmn_list.total_list_entries = no_of_oplmn;
      req_msg.oplmn_list.oplmn_len = no_of_oplmn;
    }
    else
    {
      result = RIL_E_GENERIC_FAILURE;
      break;
    }

    for ( i = 0; i + 6 < oem_data_len; )
    {
      if (j < no_of_oplmn)
      {
        memcpy (&req_msg.oplmn_list.oplmn[j].plmn, (void *)&set_builtin_plmn_req[i + 2], 3);
        memcpy (&req_msg.oplmn_list.oplmn[j].access_tech, (void *)&set_builtin_plmn_req[i + 5], 2);
        j++;
      }
      i = i + 5;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                 QCRIL_EVT_HOOK_SET_BUILTIN_PLMN_LIST,
                                 NULL,
                                 &qcril_req_info_ptr );
    if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) == E_SUCCESS )
    {
      memset(&qmi_response,0,sizeof(qmi_response));
      qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_SET_BUILTIN_PLMN_LIST_REQ_MSG_V01,
                                                    &req_msg,
                                                    NAS_ZERO,
                                                    (void*) &qmi_response,
                                                    sizeof( qmi_response ),
                                                    ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

      result = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;

      if ( RIL_E_SUCCESS == result )
      {
        if (qmi_response.resp.result != QMI_RESULT_SUCCESS_V01)
        {
          QCRIL_LOG_ERROR("Set Built-in PLMN request,QMI Result = %d,error=%d\n", qmi_response.resp.result,qmi_response.resp.error);
          result =  RIL_E_GENERIC_FAILURE;
        }
        else
        {
          QCRIL_LOG_DEBUG("Waiting for Set Buil-in PLMN indication from QMI-NAS..");
        }
      }
      else
      {
        result =  RIL_E_GENERIC_FAILURE;
      }
    }
    else
    {
      result =  RIL_E_GENERIC_FAILURE;
    }
  } while (FALSE);

  if (result == RIL_E_GENERIC_FAILURE)
  {
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           result,
                                           &resp );
    qcril_send_request_response( &resp );
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_set_builtin_plmn_list

void qcril_qmi_nas_set_builtin_plmn_list_ind_handler
(
nas_set_builtin_plmn_list_ind_msg_v01* plmn_list_ind
)
{
  qcril_reqlist_public_type qcril_req_info;
  errno_enum_type           found_qcril_request;
  RIL_Errno result = RIL_E_SUCCESS;
  qcril_request_resp_params_type resp;

  QCRIL_LOG_FUNC_ENTRY();

  found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                      QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_HOOK_SET_BUILTIN_PLMN_LIST,
                                                      &qcril_req_info );

  if ( E_SUCCESS == found_qcril_request )
  {
    if ( plmn_list_ind && plmn_list_ind->error != QMI_ERR_NONE_V01 )
    {
      result = RIL_E_GENERIC_FAILURE;
    }
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                                   qcril_req_info.t,
                                                   qcril_req_info.request,
                                                   result,
                                                   &resp );
    qcril_send_request_response( &resp );
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_set_builtin_plmn_list_ind_handler

//===========================================================================
//qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp
//===========================================================================
void qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp(void *param)
{
    qmi_client_error_type qmi_transport_error;
    dms_set_ap_version_req_msg_v01 device_ap_ver_info_req;
    dms_set_ap_version_resp_msg_v01 device_ap_ver_info_resp;
    QCRIL_NOTUSED(param);
    QCRIL_LOG_FUNC_ENTRY();

    memset(&device_ap_ver_info_req,0,sizeof(device_ap_ver_info_req));
    memset(&device_ap_ver_info_resp,0,sizeof(device_ap_ver_info_resp));

    qcril_qmi_nas_get_meta_build_id_from_file(device_ap_ver_info_req.ap_sw_version, sizeof(device_ap_ver_info_req.ap_sw_version));
    device_ap_ver_info_req.ap_sw_version_valid = TRUE;
    QCRIL_LOG_INFO( "length of SW Version string %d", strlen(device_ap_ver_info_req.ap_sw_version));
    QCRIL_LOG_INFO( "SW Version string %s", device_ap_ver_info_req.ap_sw_version);

    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                    QMI_DMS_SET_AP_VERSION_REQ_V01,
                                                    &device_ap_ver_info_req,
                                                    sizeof(device_ap_ver_info_req),
                                                    &device_ap_ver_info_resp,
                                                    sizeof(device_ap_ver_info_resp),
                                                    QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

    QCRIL_LOG_INFO( "QMI_DMS_SET_AP_VERSION_REQ_V01 transport error code %d", qmi_transport_error);

    QCRIL_LOG_INFO( "device_ap_ver_info_resp.resp.result %d, device_ap_ver_info_resp.resp.error %d",
        device_ap_ver_info_resp.resp.result, device_ap_ver_info_resp.resp.error);

    if((QMI_RESULT_FAILURE_V01 == device_ap_ver_info_resp.resp.result) &&
       (QMI_ERR_OP_DEVICE_UNSUPPORTED_V01 == device_ap_ver_info_resp.resp.error))
    {
        qcril_qmi_nas_dms_update_ap_sw_ver_info_to_modem();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp


//===========================================================================
//qcril_qmi_nas_dms_update_ap_sw_ver_info_to_modem
//===========================================================================
void qcril_qmi_nas_dms_update_ap_sw_ver_info_to_modem(void)
{
    const char* sw_version_property = "ro.build.display.id";
    qmi_client_error_type qmi_transport_error;
    dms_set_ap_sw_version_req_msg_v01 device_sw_ver_info;
    dms_set_ap_sw_version_resp_msg_v01 qmi_response;
    char args[ PROPERTY_VALUE_MAX ];
    QCRIL_LOG_FUNC_ENTRY();

    memset(args,0,sizeof(args));
    memset(&device_sw_ver_info,0,sizeof(device_sw_ver_info));
    memset(&qmi_response,0,sizeof(qmi_response));
    property_get(sw_version_property,args,"123456");
    strlcpy( device_sw_ver_info.ap_sw_version, args, sizeof(device_sw_ver_info.ap_sw_version) );
    QCRIL_LOG_INFO( "length of SW Version string %d", strlen(device_sw_ver_info.ap_sw_version));
    QCRIL_LOG_INFO( "size of SW Version string %d", sizeof(device_sw_ver_info.ap_sw_version));

    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                    QMI_DMS_SET_AP_SW_VERSION_REQ_V01,
                                                    &device_sw_ver_info,
                                                    sizeof(device_sw_ver_info),
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

    QCRIL_LOG_INFO( "QMI_DMS_SET_AP_SW_VERSION_REQ_V01 transport error code %d", qmi_transport_error);
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_update_ap_sw_ver_info_to_modem

//===========================================================================
//current plmn name ind
//===========================================================================
int qcril_qmi_nas_current_plmn_name_ind_conv_qmi2ril(nas_current_plmn_name_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated
                                               )
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    *network_state_updated = qmi_msg->plmn_id_valid     ||
                             qmi_msg->short_name_valid  ||
                             qmi_msg->long_name_valid ||
                             (nas_common_info.unicode_operator_names_support &&
                             qmi_msg->lang_plmn_names_valid) ;

    NAS_CACHE_STORE_ENTRY( nas_cached_info.plmn_id,  qmi_msg->plmn_id );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.spn,  qmi_msg->spn );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.short_name,  qmi_msg->short_name );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.long_name,  qmi_msg->long_name );

    QCRIL_LOG_INFO( "plmn_id cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id ) );
    QCRIL_LOG_INFO( "spn cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn ) );
    QCRIL_LOG_INFO( "short_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) );
    QCRIL_LOG_INFO( "long_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) );

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
}

//===========================================================================
//qcril_qmi_nas_update_presist_nitz_cache_shadow
//===========================================================================
IxErrnoType qcril_qmi_nas_update_presist_nitz_cache_shadow(char * op_name_long, char * op_name_short, char * op_mcc_str, char * op_mnc_str)
{
    IxErrnoType res = E_SUCCESS;
    char * persist_store_name_long = NULL;
    char * persist_store_name_short = NULL;
    int len;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_LOG_INFO( ".. long %s, short %s, mcc %s, mnc %s", op_name_long, op_name_short, op_mcc_str, op_mnc_str  );

    do
    {
        len = strlen(op_name_long) + 1;
        persist_store_name_long = (char *)qcril_malloc( len );
        if ( persist_store_name_long )
        {
            strlcpy(persist_store_name_long, op_name_long, len);
        }
        else
        {
            res = E_FAILURE;
            break;
        }

        len = strlen(op_name_short) + 1;
        persist_store_name_short = (char *)qcril_malloc( len );
        if ( persist_store_name_short )
        {
            strlcpy(persist_store_name_short, op_name_short, len);
        }
        else
        {
            res = E_FAILURE;
            break;
        }

    } while ( FALSE );

    if ( E_SUCCESS == res )
    {
        if ( nas_cached_info.persistent_cached_nitz_op_name_long )
        {
            qcril_free( nas_cached_info.persistent_cached_nitz_op_name_long );
            nas_cached_info.persistent_cached_nitz_op_name_long = NULL;
        }
        nas_cached_info.persistent_cached_nitz_op_name_long = persist_store_name_long;

        if ( nas_cached_info.persistent_cached_nitz_op_name_short )
        {
            qcril_free( nas_cached_info.persistent_cached_nitz_op_name_short );
            nas_cached_info.persistent_cached_nitz_op_name_short = NULL;
        }
        nas_cached_info.persistent_cached_nitz_op_name_short = persist_store_name_short;

        strlcpy(nas_cached_info.persistent_cached_mobile_country_code,op_mcc_str,sizeof(nas_cached_info.persistent_cached_mobile_country_code));
        strlcpy(nas_cached_info.persistent_cached_mobile_network_code,op_mnc_str,sizeof(nas_cached_info.persistent_cached_mobile_network_code));
    }
    else
    {
        if ( persist_store_name_long )
        {
            qcril_free( persist_store_name_long );
        }
        if ( persist_store_name_short )
        {
            qcril_free( persist_store_name_short );
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);

    return res;
} // qcril_qmi_nas_update_presist_nitz_cache_shadow

//===========================================================================
//qcril_qmi_nas_persist_entry_fetch_to_shadow
//===========================================================================
IxErrnoType qcril_qmi_nas_persist_entry_fetch_to_shadow(char * op_name_to_read, size_t op_name_to_read_size, const char ** prop_name_prefix, int prop_name_prefix_domain_size, int prop_name_suffix )
{
    IxErrnoType res;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];

    int idx;

    const char ** prop_name_orefix_cur_ptr;


    QCRIL_LOG_FUNC_ENTRY();

    prop_name_orefix_cur_ptr = prop_name_prefix;
    res = E_SUCCESS;
    *op_name_to_read = 0;

    for ( idx = 0 ; idx < prop_name_prefix_domain_size && E_SUCCESS == res; idx++ )
    {
        snprintf( property_name, sizeof(property_name), "%s%d", *prop_name_orefix_cur_ptr, prop_name_suffix );
        *property_value = 0;
        property_get( property_name, property_value, "" );
        QCRIL_LOG_INFO(".. prop get iter %d prop %s", idx, property_value );
        if ( E_SUCCESS == res )
        {
            strlcat(op_name_to_read, property_value, op_name_to_read_size);
        }
        prop_name_orefix_cur_ptr++;
    }

    QCRIL_LOG_INFO("res: %d, op_name_to_read: %s", (int)res, op_name_to_read);

    return res;
} // qcril_qmi_nas_persist_entry_fetch_to_shadow

//===========================================================================
//qcril_qmi_nas_nitz_persistent_cache_is_shadow_available
//===========================================================================
int qcril_qmi_nas_nitz_persistent_cache_is_shadow_available(void)
{
    int res = FALSE;
    int long_valid;
    int short_valid;

    long_valid  = ( NULL != nas_cached_info.persistent_cached_nitz_op_name_long && NAS_ZERO != *nas_cached_info.persistent_cached_nitz_op_name_long );
    short_valid = ( NULL != nas_cached_info.persistent_cached_nitz_op_name_short && NAS_ZERO != *nas_cached_info.persistent_cached_nitz_op_name_short );
    res = long_valid || short_valid;

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} // qcril_qmi_nas_nitz_persistent_cache_is_shadow_available
//===========================================================================
//qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow
//===========================================================================
void qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow(void)
{
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;
    IxErrnoType prop_req_err;
    char nitz_long_buf[512];
    char nitz_short_buf[512];

    char fetched_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char fetched_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    int sscanf_res;

    QCRIL_LOG_INFO("persistent_cached_nitz_op_name_long: %p, persistent_cached_nitz_op_name_short: %p",
                    nas_cached_info.persistent_cached_nitz_op_name_long,
                    nas_cached_info.persistent_cached_nitz_op_name_short);

    if ( NULL == nas_cached_info.persistent_cached_nitz_op_name_long || NULL == nas_cached_info.persistent_cached_nitz_op_name_short )
    {

        moniker = (int)qmi_ril_get_process_instance_id();
        prop_req_err = E_SUCCESS;

        QCRIL_LOG_INFO( ".. load from prop - %d", (int) moniker );

        do
        {
            // mcc mnc context
            snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_OP_NAME_NITZ_PLMN, moniker );
            prop_req_err = (IxErrnoType)property_get( property_name, property_value, "" );
            QCRIL_LOG_INFO( ".. master mccmnc prop get %d, %s - %s", (int) prop_req_err, property_name, property_value );
            if ( !*property_value )
            {
                prop_req_err = E_FAILURE;
                break;
            }

            memset(fetched_mcc_str,0,sizeof(fetched_mcc_str));
            memset(fetched_mnc_str,0,sizeof(fetched_mnc_str));
            // TBD: use macro pasting so we can use macro here for width as well
            sscanf_res = sscanf(property_value, "%3s %3s", fetched_mcc_str, fetched_mnc_str );
            QCRIL_LOG_INFO( ".. mcc mnc fetch %s-%s, %d", fetched_mcc_str, fetched_mnc_str, sscanf_res );
            if ( sscanf_res != 2 )
            {
                prop_req_err = E_FAILURE;
                break;
            }

            // name long
            prop_req_err = qcril_qmi_nas_persist_entry_fetch_to_shadow( nitz_long_buf,
                                                               sizeof(nitz_long_buf),
                                                               qmi_ril_op_name_persist_store_prop_list_long,
                                                               QCRIL_ARR_SIZE(qmi_ril_op_name_persist_store_prop_list_long),
                                                               moniker  );
            if ( E_SUCCESS != prop_req_err )
                break;

            // name short
            prop_req_err = qcril_qmi_nas_persist_entry_fetch_to_shadow( nitz_short_buf,
                                                               sizeof(nitz_short_buf),
                                                               qmi_ril_op_name_persist_store_prop_list_short,
                                                               QCRIL_ARR_SIZE(qmi_ril_op_name_persist_store_prop_list_short),
                                                               moniker  );
            if ( E_SUCCESS != prop_req_err )
                break;
        } while (FALSE);

        QCRIL_LOG_INFO( ".. prop fetch res %d", (int) prop_req_err );
        if ( E_SUCCESS == prop_req_err  )
        {
            QCRIL_LOG_INFO( ".. long, short fetch %s, %s", nitz_long_buf, nitz_short_buf );
            qcril_qmi_nas_update_presist_nitz_cache_shadow( nitz_long_buf, nitz_short_buf, fetched_mcc_str, fetched_mnc_str );
        }

    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nitz_persistent_cache_fetch_to_dyna_cache

//===========================================================================
//qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow
//===========================================================================
void qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow(void)
{
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;
    IxErrnoType prop_req_err;
    char *end_ptr;
    unsigned long ret_val;

    QCRIL_LOG_INFO( "dsds_is_tune_away = %d, priority_paging = %d, dsds_is_lte_tune_away = %d",
                     nas_common_info.dsds.is_tune_away, nas_common_info.dsds.paging_priority,
                     nas_common_info.dsds.is_lte_tune_away);

    moniker = (int)qmi_ril_get_process_instance_id();
    prop_req_err = E_SUCCESS;

    QCRIL_LOG_INFO( ".. load from prop - %d", (int) moniker );

    // tune away
    snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_TUNE_AWAY, moniker );
    prop_req_err = (IxErrnoType)property_get( property_name, property_value, "" );
    QCRIL_LOG_INFO( ".. master tuneaway prop get %d, %s - %s", (int) prop_req_err, property_name, property_value );
    nas_common_info.dsds.is_tune_away = NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;

    if ( *property_value )
    {
        ret_val = strtoul( property_value, &end_ptr, 0 );
        if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
        {
          QCRIL_LOG_ERROR( "Fail to convert tune away property values %s", property_value );
        }
        else if ( TRUE != ret_val && FALSE != ret_val )
        {
          QCRIL_LOG_ERROR( "Invalid saved tune away %ld", ret_val );
        }
        else
        {
          nas_common_info.dsds.is_tune_away = ( boolean ) ret_val;
        }
    }
    QCRIL_LOG_INFO( "..  tuneaway value after reading from property %d", (int) nas_common_info.dsds.is_tune_away );

    // priority paging
    snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_PAGING_PRIORITY, moniker );
    prop_req_err = (IxErrnoType)property_get( property_name, property_value, "" );
    QCRIL_LOG_INFO( ".. master priority paging prop get %d, %s - %s", (int) prop_req_err, property_name, property_value );

    nas_common_info.dsds.paging_priority = (nas_subs_type_enum_v01) NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;
    if ( *property_value )
    {
        ret_val = strtoul( property_value, &end_ptr, 0 );
        if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to convert paging priorty %s", property_value );
        }
        else if ( ( ret_val > NAS_SECONDARY_SUBSCRIPTION_V01 ) || ( ret_val > NAS_PRIMARY_SUBSCRIPTION_V01 ) )
        {
          QCRIL_LOG_ERROR( "RID %d Invalid saved paging priority %ld", ret_val );
        }
        else
        {
          nas_common_info.dsds.paging_priority = ( nas_subs_type_enum_v01 ) ret_val;
        }
    }
    QCRIL_LOG_INFO( "..  paging priority value after reading from property %d", (int) nas_common_info.dsds.paging_priority );

    // lte tune away
    snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_LTE_TUNE_AWAY, moniker );
    qmi_ril_get_property_value_from_integer(property_name,
                                            &nas_common_info.dsds.is_lte_tune_away,
                                            NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE);

    QCRIL_LOG_INFO( "..  lte tuneaway value after reading from property %d", (int) nas_common_info.dsds.is_lte_tune_away );

    nas_common_info.dsds.default_voice_sub = (nas_subs_type_enum_v01) NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;

    nas_common_info.dsds.default_data_sub = (nas_subs_type_enum_v01) NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;
    nas_common_info.dsds.dds_data_sub_valid = FALSE;
    nas_common_info.dsds.dds_data_sub.dds_sub_id = -1;
    nas_common_info.dsds.dds_data_sub.switch_type = DSD_DDS_DURATION_ENUM_MIN_ENUM_VAL_V01;
} // qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow

//===========================================================================
//qcril_qmi_fetch_system_selection_preference
//===========================================================================
RIL_Errno qcril_qmi_fetch_system_selection_preference(void)
{

    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_error = QMI_ERR_NONE_V01;

    nas_get_system_selection_preference_resp_msg_v01 * qmi_response = NULL;

    qmi_response = (nas_get_system_selection_preference_resp_msg_v01 *)
                        qcril_malloc( sizeof( *qmi_response ) );
    if ( qmi_response )
    {

        qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                 NULL,
                                                 NAS_NIL,  // empty request payload
                                                 (void*) qmi_response,
                                                 sizeof( *qmi_response ));

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, &qmi_response->resp);

        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.emergency_mode, qmi_response->emergency_mode );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.mode_pref, qmi_response->mode_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.band_pref, qmi_response->band_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prl_pref, qmi_response->prl_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_pref, qmi_response->roam_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.net_sel_pref, qmi_response->net_sel_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gw_acq_order_pref, qmi_response->gw_acq_order_pref );
            NAS_CACHE_STORE_ENTRY_ARR ( nas_cached_info.acq_order, qmi_response->acq_order );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_disable_cause, qmi_response->lte_disable_cause );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.rat_disabled_mask, qmi_response->rat_disabled_mask );

            // If srv_domain_pref is invalid, it means no domain/no srv. Reset the cache.
            if ( qmi_response->srv_domain_pref_valid )
            {
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.srv_domain_pref, qmi_response->srv_domain_pref );
            }
            else
            {
                NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.srv_domain_pref );
            }

            if ( qmi_response->voice_domain_pref_valid )
            {
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_domain_pref, qmi_response->voice_domain_pref );
            }
            else
            {
                NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.voice_domain_pref );
            }
            NAS_CACHE_UNLOCK();
        }

        qcril_free( qmi_response );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_fetch_system_selection_preference

//===========================================================================
//qcril_qmi_nas_get_nw_selection_mode
//===========================================================================
RIL_Errno qcril_qmi_nas_get_nw_selection_mode(nas_net_sel_pref_enum_v01 * mode)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;

    if ( mode )
    {
        if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.net_sel_pref) )
        {
            *mode = (nas_net_sel_pref_enum_v01) nas_cached_info.net_sel_pref;
            QCRIL_LOG_INFO("returning pref %d ", (int) *mode);
            res = RIL_E_SUCCESS;
        }
    }

    return res;
} // qcril_qmi_nas_get_nw_selection_mode
//===========================================================================
//selection preference ind
//===========================================================================
int qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril(nas_system_selection_preference_ind_msg_v01 * qmi_msg,
                                                  int * emergency_mode_entered,
                                                  int * emergency_mode_left
                                                )
{
    int is_mode_pref_change = FALSE;
    qmi_ril_nas_attch_state_e_type cur_attch_state = qcril_qmi_nas_get_attch_state();

    is_mode_pref_change = qmi_msg->mode_pref_valid?( nas_cached_info.mode_pref_valid != qmi_msg->mode_pref_valid ):FALSE;
    if( (FALSE == is_mode_pref_change) && qmi_msg->mode_pref_valid )
    {
        is_mode_pref_change = ( nas_cached_info.mode_pref != qmi_msg->mode_pref )? TRUE:FALSE;
    }

    qcril_qmi_nas_embms_send_e911_state_changed_if_needed(qmi_msg->emergency_mode_valid,
            qmi_msg->emergency_mode);

    if ( qmi_msg->emergency_mode_valid )
    {
        if( FALSE == nas_cached_info.emergency_mode_valid || nas_cached_info.emergency_mode != qmi_msg->emergency_mode )
        {
            *emergency_mode_entered = (qmi_msg->emergency_mode == NAS_CMN_EMERGENCY_MODE_ON) ? TRUE : FALSE;
            *emergency_mode_left    = (qmi_msg->emergency_mode == NAS_CMN_EMERGENCY_MODE_OFF) ? TRUE : FALSE;
        }
        else
        {
            *emergency_mode_entered = FALSE;
            *emergency_mode_left    = FALSE;
        }
    }

    NAS_CACHE_LOCK();
    if ( qmi_msg->mode_pref_valid )
    {
        nas_cached_info.is_indication_received = TRUE;
        auto& msgList = getNasModule().getPendingMessageList();
        auto pendingMsg = msgList.find(RilRequestSetPrefNetworkTypeMessage::get_class_message_id());
        if (pendingMsg)
        {
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                RIL_E_SUCCESS, nullptr);
            auto setMsg = std::static_pointer_cast<RilRequestSetPrefNetworkTypeMessage>(pendingMsg);
            setMsg->sendResponse(setMsg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(pendingMsg);
            QCRIL_LOG_INFO( "..Got Entry for setting pref network type in list. Sent response ");

            if( NAS_ZERO != nas_cached_info.sys_sel_pref_tmr )
            {
                qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.sys_sel_pref_tmr);
                nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
            }
        }

        QCRIL_LOG_DEBUG("nas_cached_info.mode_pref_valid: %d, nas_cached_info.mode_pref: %d,"
                " qmi_msg->mode_pref_valid: %d, qmi_msg->mode_pref: %d", nas_cached_info.mode_pref_valid,
                nas_cached_info.mode_pref, qmi_msg->mode_pref_valid, qmi_msg->mode_pref);

        std::shared_ptr<Nas5gStatusIndMessage> five_g_status_ind = nullptr;
        if ( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) )
        {
            if (qmi_msg->mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G)
            {
                // 5G enabled
                five_g_status_ind = std::make_shared<Nas5gStatusIndMessage>(true);
            }
        }
        else
        {
            if ((nas_cached_info.mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G) &&
                    !(qmi_msg->mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G))
            {
                // 5G disabled
                five_g_status_ind = std::make_shared<Nas5gStatusIndMessage>(false);
            }
            else if (!(nas_cached_info.mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G) &&
                    qmi_msg->mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G)
            {
                // 5G enabled
                five_g_status_ind = std::make_shared<Nas5gStatusIndMessage>(true);
            }
        }

        if (five_g_status_ind != nullptr)
        {
            five_g_status_ind->broadcast();
        }
    }

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.emergency_mode, qmi_msg->emergency_mode );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.mode_pref, qmi_msg->mode_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.band_pref, qmi_msg->band_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prl_pref, qmi_msg->prl_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_pref, qmi_msg->roam_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_band_pref, qmi_msg->lte_band_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.net_sel_pref, qmi_msg->net_sel_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gw_acq_order_pref, qmi_msg->gw_acq_order_pref );
    NAS_CACHE_STORE_ENTRY_ARR ( nas_cached_info.acq_order, qmi_msg->acq_order );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_disable_cause, qmi_msg->lte_disable_cause );
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.rat_disabled_mask,
                               qmi_msg->rat_disabled_mask);

    // If srv_domain_pref is invalid, it means no domain/no srv. Reset the cache.
    if ( qmi_msg->srv_domain_pref_valid )
    {
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.srv_domain_pref, qmi_msg->srv_domain_pref );
    }
    else
    {
      NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.srv_domain_pref );
    }

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_domain_pref, qmi_msg->voice_domain_pref );

    QCRIL_LOG_INFO( ".. new lte band pref valid %d, value %llx", (int)qmi_msg->lte_band_pref_valid, qmi_msg->lte_band_pref);
    QCRIL_LOG_INFO( ".. new mode pref valid %d, value %d", (int)qmi_msg->mode_pref_valid, (int) qmi_msg->mode_pref );
    QCRIL_LOG_INFO( ".. new net sel pref valid %d, value %d", (int)qmi_msg->net_sel_pref_valid, (int) qmi_msg->net_sel_pref );
    QCRIL_LOG_INFO( ".. new emergency mode valid %d, value %d", (int)qmi_msg->emergency_mode_valid, (int) qmi_msg->emergency_mode );
    QCRIL_LOG_INFO( ".. new prl pref valid %d, value %d", (int)qmi_msg->prl_pref_valid, (int) qmi_msg->prl_pref );
    QCRIL_LOG_INFO( ".. new gw acq order valid %d, value %d", (int)qmi_msg->gw_acq_order_pref_valid, (int) qmi_msg->gw_acq_order_pref );
    QCRIL_LOG_INFO( ".. new srv domain pref valid %d, value %d", (int)qmi_msg->srv_domain_pref_valid, (int) qmi_msg->srv_domain_pref);
    QCRIL_LOG_INFO( ".. new acq order pref valid %d, len %d", (int)qmi_msg->acq_order_valid, (int) qmi_msg->acq_order_len );
    QCRIL_LOG_INFO( ".. new lte disable cause valid %d, value %d", (int)qmi_msg->lte_disable_cause_valid, (int) qmi_msg->lte_disable_cause );
    QCRIL_LOG_INFO( ".. new rat disables mask valid %d, value %d",
                    (int)qmi_msg->rat_disabled_mask_valid,
                    (int)qmi_msg->rat_disabled_mask);
    QCRIL_LOG_INFO( ".. new voice domain pref valid %d, value %d", (int)qmi_msg->voice_domain_pref_valid, (int) qmi_msg->voice_domain_pref);

    if( (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref)) ||
        ( nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_ONLY_V01 )
      )
    {
        // Clear the snapshot info and cancel timer as DDS changed
        qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
        qcril_qmi_arb_reset_pref_data_snapshot();
    }

    NAS_CACHE_UNLOCK();

    /* broadcast Service Domain Indication */
    /* If srv_domain_pref is invalid, it means no domain/no srv. */
    auto msg = std::make_shared<NasSrvDomainPrefIndMessage>(qmi_msg->srv_domain_pref_valid,
            qmi_msg->srv_domain_pref);
    if (msg) {
      Dispatcher::getInstance().dispatch(msg);
    }

    if ((cur_attch_state == QMI_RIL_NAS_ALLOW_DATA_ATTCH_DETACH) ||
        (cur_attch_state == QMI_RIL_NAS_ALLOW_DATA_ATTCH_ATTACH) ||
        (cur_attch_state == QMI_RIL_NAS_ALLOW_DATA_ATTCH_WAIT_FOR_RAT_EXP))
    {
      qcril_qmi_nas_check_ps_attach_status();
    }

    if ( TRUE == is_mode_pref_change )
    {
        qcril_qmi_nas_initiate_voice_rte_change_propagation();
    }

    return E_SUCCESS;
} // qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril

//===========================================================================
//qcril_qmi_nas_fill_sys_info_details
//===========================================================================
int qcril_qmi_nas_fill_sys_info_details(nas_sys_info_helper_type * sys_info_helper,
                                        nas_service_status_enum_type_v01 * service_status)
{
    int res = E_SUCCESS;
    switch ( nas_cached_info.voice_rte )
    {
      case QMI_RIL_RTE_1x:
      QCRIL_LOG_INFO( " .. cur rte- CDMA" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
      {
        *service_status = nas_cached_info.cdma_srv_status_info->srv_status;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
      {
        sys_info_helper->common_sys_info =
                (nas_common_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.cdma_sys_info->common_sys_info));
        sys_info_helper->cdma_only_sys_info =
                (nas_cdma_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.cdma_sys_info->cdma_specific_sys_info));

        if(sys_info_helper->common_sys_info != NULL && sys_info_helper->cdma_only_sys_info != NULL)
        {
          memcpy(sys_info_helper->common_sys_info,
                &nas_cached_info.cdma_sys_info->common_sys_info, sizeof(nas_cached_info.cdma_sys_info->common_sys_info));
          memcpy(sys_info_helper->cdma_only_sys_info,
                &nas_cached_info.cdma_sys_info->cdma_specific_sys_info, sizeof(nas_cached_info.cdma_sys_info->cdma_specific_sys_info));
        }
        else
        {
          QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
          res = E_FAILURE;
          break;
        }
      }
      break;

      case QMI_RIL_RTE_GSM:
      QCRIL_LOG_INFO( " .. cur rte- GSM" );
      if ( NAS_CACHE_IS_ENTRY_VALID ( nas_cached_info.gsm_srv_status_info ) )
      {
        *service_status = nas_cached_info.gsm_srv_status_info->srv_status;
        sys_info_helper->threegpp_srv_status =
                (nas_3gpp_srv_status_info_type_v01*)qcril_malloc(sizeof(*nas_cached_info.gsm_srv_status_info));
        if(sys_info_helper->threegpp_srv_status != NULL)
        {
            memcpy(sys_info_helper->threegpp_srv_status,
                    nas_cached_info.gsm_srv_status_info, sizeof(*nas_cached_info.gsm_srv_status_info));
        }
        else
        {
            QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
            res = E_FAILURE;
            break;
        }
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
      {
        sys_info_helper->common_sys_info =
                (nas_common_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.gsm_sys_info->common_sys_info));
        sys_info_helper->threegpp_only_sys_info =
                (nas_3gpp_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.gsm_sys_info->threegpp_specific_sys_info));

        if(sys_info_helper->common_sys_info != NULL && sys_info_helper->threegpp_only_sys_info != NULL)
        {
          memcpy(sys_info_helper->common_sys_info,
                &nas_cached_info.gsm_sys_info->common_sys_info, sizeof(nas_cached_info.gsm_sys_info->common_sys_info));
          memcpy(sys_info_helper->threegpp_only_sys_info,
                &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info, sizeof(nas_cached_info.gsm_sys_info->threegpp_specific_sys_info));
        }
        else
        {
          QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
          res = E_FAILURE;
          break;
        }
      }
      break;

      case QMI_RIL_RTE_WCDMA:
      QCRIL_LOG_INFO( " .. cur rte- WCDMA" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
      {
        *service_status = nas_cached_info.wcdma_srv_status_info->srv_status;
        sys_info_helper->threegpp_srv_status =
                (nas_3gpp_srv_status_info_type_v01*)qcril_malloc(sizeof(*nas_cached_info.wcdma_srv_status_info));
        if(sys_info_helper->threegpp_srv_status != NULL)
        {
            memcpy(sys_info_helper->threegpp_srv_status,
                    nas_cached_info.wcdma_srv_status_info, sizeof(*nas_cached_info.wcdma_srv_status_info));
        }
        else
        {
            QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
            res = E_FAILURE;
            break;
        }
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
      {
        sys_info_helper->common_sys_info =
                (nas_common_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.wcdma_sys_info->common_sys_info));
        sys_info_helper->threegpp_only_sys_info =
                (nas_3gpp_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info));

        if(sys_info_helper->common_sys_info != NULL && sys_info_helper->threegpp_only_sys_info != NULL)
        {
          memcpy(sys_info_helper->common_sys_info,
                &nas_cached_info.wcdma_sys_info->common_sys_info, sizeof(nas_cached_info.wcdma_sys_info->common_sys_info));
          memcpy(sys_info_helper->threegpp_only_sys_info,
                &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info, sizeof(nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info));
        }
        else
        {
          QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
          res = E_FAILURE;
          break;
        }
      }
      break;

      case QMI_RIL_RTE_TDSCDMA:
      QCRIL_LOG_INFO( " .. cur rte- TDSCDMA" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
      {
          *service_status = nas_cached_info.tdscdma_srv_status_info->srv_status;
          sys_info_helper->threegpp_srv_status =
                (nas_3gpp_srv_status_info_type_v01*)qcril_malloc(sizeof(*nas_cached_info.tdscdma_srv_status_info));
          if(sys_info_helper->threegpp_srv_status != NULL)
          {
              memcpy(sys_info_helper->threegpp_srv_status,
                    nas_cached_info.tdscdma_srv_status_info, sizeof(*nas_cached_info.tdscdma_srv_status_info));
          }
          else
          {
              QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
              res = E_FAILURE;
              break;
          }
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
      {
        sys_info_helper->common_sys_info =
                (nas_common_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.tdscdma_sys_info->common_sys_info));
        sys_info_helper->threegpp_only_sys_info =
                (nas_3gpp_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info));

        if(sys_info_helper->common_sys_info != NULL && sys_info_helper->threegpp_only_sys_info != NULL)
        {
          memcpy(sys_info_helper->common_sys_info,
                &nas_cached_info.tdscdma_sys_info->common_sys_info, sizeof(nas_cached_info.tdscdma_sys_info->common_sys_info));
          memcpy(sys_info_helper->threegpp_only_sys_info,
                &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info, sizeof(nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info));
        }
        else
        {
          QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
          res = E_FAILURE;
          break;
        }
      }
      break;

      case QMI_RIL_RTE_SUB_LTE:
      QCRIL_LOG_INFO( " .. cur rte- LTE" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
      {
        *service_status = nas_cached_info.lte_srv_status_info->srv_status;
        sys_info_helper->threegpp_srv_status =
                (nas_3gpp_srv_status_info_type_v01*)qcril_malloc(sizeof(*nas_cached_info.lte_srv_status_info));
        if(sys_info_helper->threegpp_srv_status != NULL)
        {
            memcpy(sys_info_helper->threegpp_srv_status,
                    nas_cached_info.lte_srv_status_info, sizeof(*nas_cached_info.lte_srv_status_info));
        }
        else
        {
            QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
            res = E_FAILURE;
            break;
        }
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
      {
        sys_info_helper->common_sys_info =
                (nas_common_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.lte_sys_info->common_sys_info));
        sys_info_helper->threegpp_only_sys_info =
                (nas_3gpp_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.lte_sys_info->threegpp_specific_sys_info));
        sys_info_helper->lte_only_sys_info =
                (nas_lte_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.lte_sys_info->lte_specific_sys_info));

        if(sys_info_helper->common_sys_info != NULL && sys_info_helper->threegpp_only_sys_info != NULL
                                                            && sys_info_helper->lte_only_sys_info != NULL)
        {
          memcpy(sys_info_helper->common_sys_info,
                &nas_cached_info.lte_sys_info->common_sys_info, sizeof(nas_cached_info.lte_sys_info->common_sys_info));
          memcpy(sys_info_helper->threegpp_only_sys_info,
                &nas_cached_info.lte_sys_info->threegpp_specific_sys_info, sizeof(nas_cached_info.lte_sys_info->threegpp_specific_sys_info));
          memcpy(sys_info_helper->lte_only_sys_info,
                &nas_cached_info.lte_sys_info->lte_specific_sys_info, sizeof(nas_cached_info.lte_sys_info->lte_specific_sys_info));
        }
        else
        {
          QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
          res = E_FAILURE;
          break;
        }
      }
      break;

      case QMI_RIL_RTE_SUB_NR5G:
          QCRIL_LOG_INFO(" .. cur rte- 5G");
          if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info))
          {
              *service_status = nas_cached_info.nr5g_srv_status_info->srv_status;
              sys_info_helper->threegpp_srv_status =
                      (nas_3gpp_srv_status_info_type_v01*) qcril_malloc(sizeof(*nas_cached_info.nr5g_srv_status_info));
              if(sys_info_helper->threegpp_srv_status != NULL)
              {
                  memcpy(sys_info_helper->threegpp_srv_status, nas_cached_info.nr5g_srv_status_info,
                          sizeof(*nas_cached_info.nr5g_srv_status_info));
              }
              else
              {
                  QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
                  res = E_FAILURE;
                  break;
              }
          }

          if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info))
          {
              sys_info_helper->common_sys_info =
                      (nas_common_sys_info_type_v01*) qcril_malloc(sizeof(nas_cached_info.nr5g_sys_info->common_sys_info));
              sys_info_helper->threegpp_only_sys_info =
                      (nas_3gpp_only_sys_info_type_v01*) qcril_malloc(sizeof(nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info));
              sys_info_helper->nr5g_only_sys_info =
                      (nas_nr5g_only_sys_info_type_v01*) qcril_malloc(sizeof(nas_cached_info.nr5g_sys_info->nr5g_specific_sys_info));

              if (sys_info_helper->common_sys_info != NULL && sys_info_helper->threegpp_only_sys_info != NULL
                      && sys_info_helper->nr5g_only_sys_info != NULL)
              {
                  memcpy(sys_info_helper->common_sys_info,
                          &nas_cached_info.nr5g_sys_info->common_sys_info, sizeof(nas_cached_info.nr5g_sys_info->common_sys_info));
                  memcpy(sys_info_helper->threegpp_only_sys_info,
                          &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info, sizeof(nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info));
                  memcpy(sys_info_helper->nr5g_only_sys_info,
                          &nas_cached_info.nr5g_sys_info->nr5g_specific_sys_info, sizeof(nas_cached_info.nr5g_sys_info->nr5g_specific_sys_info));
              }
              else
              {
                  QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
                  res = E_FAILURE;
                  break;
              }
          }
          break;

      case QMI_RIL_RTE_SUB_DO:
      QCRIL_LOG_INFO( " .. cur rte- EVDO" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
      {
        *service_status = nas_cached_info.hdr_srv_status_info->srv_status;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
      {
        sys_info_helper->common_sys_info =
                (nas_common_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.hdr_sys_info->common_sys_info));
        sys_info_helper->cdma_hdr_only_sys_info =
                (nas_cdma_hdr_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info));
        sys_info_helper->hdr_only_sys_info =
                (nas_hdr_only_sys_info_type_v01*)qcril_malloc(sizeof(nas_cached_info.hdr_sys_info->hdr_specific_sys_info));

        if(sys_info_helper->common_sys_info != NULL && sys_info_helper->cdma_hdr_only_sys_info != NULL
                                                            && sys_info_helper->hdr_only_sys_info != NULL)
        {
          memcpy(sys_info_helper->common_sys_info,
                &nas_cached_info.hdr_sys_info->common_sys_info, sizeof(nas_cached_info.hdr_sys_info->common_sys_info));
          memcpy(sys_info_helper->cdma_hdr_only_sys_info,
                &nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info, sizeof(nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info));
          memcpy(sys_info_helper->hdr_only_sys_info,
                &nas_cached_info.hdr_sys_info->hdr_specific_sys_info, sizeof(nas_cached_info.hdr_sys_info->hdr_specific_sys_info));
        }
        else
        {
          QCRIL_LOG_INFO("Couldn't allocate memory for sys info helper.");
          res = E_FAILURE;
          break;
        }
      }
      break;

      default:
      QCRIL_LOG_INFO( " .. cur rte- UNKNOWN" );
      res = E_FAILURE;
      break;
    }
    return res;
}

//===========================================================================
//qcril_qmi_nas_fetch_lte_voice_status
//===========================================================================
void qcril_qmi_nas_fetch_lte_voice_status ( uint8_t *lte_voice_status_valid, nas_lte_voice_status_enum_type_v01 *lte_voice_status )
{
    NAS_CACHE_LOCK();
    *lte_voice_status = nas_cached_info.lte_voice_status;
    *lte_voice_status_valid = nas_cached_info.lte_voice_status_valid;
    NAS_CACHE_UNLOCK();
}

//===========================================================================
//qcril_qmi_nas_fetch_lte_sms_status
//===========================================================================
void qcril_qmi_nas_fetch_lte_sms_status ( uint8_t *lte_sms_status_valid, nas_sms_status_enum_type_v01 *lte_sms_status )
{
    NAS_CACHE_LOCK();
    *lte_sms_status = nas_cached_info.lte_sms_status;
    *lte_sms_status_valid = nas_cached_info.lte_sms_status_valid;
    NAS_CACHE_UNLOCK();
}

//===========================================================================
//qcril_qmi_nas_lte_voice_status_compare
//===========================================================================
int qcril_qmi_nas_lte_voice_status_compare( uint8_t prev_lte_voice_status_valid, nas_lte_voice_status_enum_type_v01 prev_lte_voice_status )
{
    int status = FALSE;
    uint8_t new_lte_voice_status_valid;
    nas_lte_voice_status_enum_type_v01 new_lte_voice_status;

    qcril_qmi_nas_fetch_lte_voice_status( &new_lte_voice_status_valid, &new_lte_voice_status);

    status = ( new_lte_voice_status_valid != prev_lte_voice_status_valid )? TRUE:FALSE;

    if( ( FALSE == status ) && new_lte_voice_status_valid )
    {
        status = ( new_lte_voice_status != prev_lte_voice_status )? TRUE:FALSE;
    }

    return status;

}

//===========================================================================
//qcril_qmi_nas_lte_sms_status_compare
//===========================================================================
int qcril_qmi_nas_lte_sms_status_compare( uint8_t prev_lte_sms_status_valid, nas_sms_status_enum_type_v01 prev_lte_sms_status )
{
    int status = FALSE;
    uint8_t new_lte_sms_status_valid;
    nas_sms_status_enum_type_v01 new_lte_sms_status;

    qcril_qmi_nas_fetch_lte_sms_status ( &new_lte_sms_status_valid, &new_lte_sms_status );

    status = ( new_lte_sms_status_valid != prev_lte_sms_status_valid )? TRUE:FALSE;

    if( ( FALSE == status ) && new_lte_sms_status_valid )
    {
        status = ( new_lte_sms_status != prev_lte_sms_status )? TRUE:FALSE;
    }

    return status;
}

void qcril_qmi_nas_report_cell_info_if_needed_cl()
{
    uint64_t current_time;
    if ( INT_MAX != nas_common_info.unsol_cell_info_rate )
    {
      qcril_qmi_nas_cell_location_update_timer_cl(QCRIL_CELL_LOCATION_RESET_PERIOD);
      current_time = ril_nano_time();
      if ( (nas_cached_info.cell_location_info_time +
           nas_common_info.unsol_cell_info_current_rate * 1000000) <= current_time)
      {
        qcril_qmi_nas_queue_cell_info_poll();
      }
    }

}

template<typename NAS_SYS_INFO>
static bool qcril_qmi_nas_is_endc_dcnr_info_changed(NAS_SYS_INFO &sys_info) {
    bool endc_dcnr_info_changed = false;

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available))
    {
        if (sys_info.endc_available_valid)
        {
            endc_dcnr_info_changed = true;
        }
    }
    else if (sys_info.endc_available_valid)
    {
        endc_dcnr_info_changed =
            (nas_cached_info.endc_available != sys_info.endc_available);
    }
    else
    {
        endc_dcnr_info_changed = true;
    }

    if (endc_dcnr_info_changed)
    {
        return endc_dcnr_info_changed;
    }

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.restrict_dcnr))
    {
        if (sys_info.restrict_dcnr_valid)
        {
            endc_dcnr_info_changed = true;
        }
    }
    else if (sys_info.restrict_dcnr_valid)
    {
        endc_dcnr_info_changed =
            (nas_cached_info.restrict_dcnr != sys_info.restrict_dcnr);
    }
    else
    {
        endc_dcnr_info_changed = true;
    }

    return endc_dcnr_info_changed;
}

template<typename NAS_SYS_INFO>
static bool qcril_qmi_nas_is_upper_layer_ind_info_changed(NAS_SYS_INFO &sys_info) {
    bool upli_changed = false;

    QCRIL_LOG_FUNC_ENTRY();

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.plmn_infolist_r15_available))
    {
        if (sys_info.plmn_infolist_r15_available_valid)
        {
            upli_changed = true;
        }
    }
    else if (sys_info.plmn_infolist_r15_available_valid)
    {
        upli_changed =
            (nas_cached_info.plmn_infolist_r15_available != sys_info.plmn_infolist_r15_available);
    }
    else
    {
        upli_changed = true;
    }

    QCRIL_LOG_DEBUG("plmn info list changed - %d", upli_changed);

    if (upli_changed)
    {
        return upli_changed;
    }

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available))
    {
        if (sys_info.endc_available_valid)
        {
            upli_changed = true;
        }
    }
    else if (sys_info.endc_available_valid)
    {
        upli_changed =
            (nas_cached_info.endc_available != sys_info.endc_available);
    }
    else
    {
        upli_changed = true;
    }

    QCRIL_LOG_DEBUG("upper layer indications status changed - %d", upli_changed);
    return upli_changed;
}

template<typename NAS_SYS_INFO>
static bool qcril_qmi_nas_is_5g_config_info_changed(NAS_SYS_INFO &sys_info) {
    bool config_changed = false;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO("nas_cached_info.nr5g_srv_status_info_valid: %d", nas_cached_info.nr5g_srv_status_info_valid);
    QCRIL_LOG_INFO("sys_info.nr5g_srv_status_info_valid: %d", sys_info.nr5g_srv_status_info_valid);

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info))
    {
        if (sys_info.nr5g_srv_status_info_valid &&
            sys_info.nr5g_srv_status_info.srv_status == NAS_SYS_SRV_STATUS_SRV_V01)
        {
            config_changed = true;
        }
    }
    else
    {
        QCRIL_LOG_INFO("nas_cached_info.nr5g_srv_status_info->srv_status: %d", nas_cached_info.nr5g_srv_status_info->srv_status);
        if (sys_info.nr5g_srv_status_info_valid) {
            QCRIL_LOG_INFO("sys_info.nr5g_srv_status_info.srv_status: %d", sys_info.nr5g_srv_status_info.srv_status);
            config_changed = nas_cached_info.nr5g_srv_status_info->srv_status != sys_info.nr5g_srv_status_info.srv_status;
        } else {
            config_changed = true;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(config_changed);
    return config_changed;
}

template<typename NAS_SYS_INFO>
static void qcril_qmi_nas_notify_changes_to_5g_parameters(NAS_SYS_INFO &sys_info)
{
    if (qcril_qmi_nas_is_endc_dcnr_info_changed(sys_info)) {
        std::shared_ptr<NasEndcDcnrIndMessage> endc_dcnr_ind = nullptr;
        endc_dcnr_ind = std::make_shared<NasEndcDcnrIndMessage>(
                sys_info.endc_available_valid && sys_info.endc_available,
                sys_info.restrict_dcnr_valid && sys_info.restrict_dcnr);
        if (endc_dcnr_ind != nullptr)
        {
            endc_dcnr_ind->broadcast();
        }
    }

    if (qcril_qmi_nas_is_upper_layer_ind_info_changed(sys_info)) {
        std::shared_ptr<NasUpperLayerIndInfoIndMessage> upli_ind = nullptr;
        QCRIL_LOG_DEBUG("upper layer ind info changed");
        upli_ind = std::make_shared<NasUpperLayerIndInfoIndMessage>(
                sys_info.plmn_infolist_r15_available_valid && sys_info.plmn_infolist_r15_available,
                sys_info.endc_available_valid && sys_info.endc_available);
        if (upli_ind != nullptr)
        {
            upli_ind->broadcast();
        }
    }

    if (qcril_qmi_nas_is_5g_config_info_changed(sys_info)) {
        std::shared_ptr<Nas5gConfigInfoIndMessage> config_ind = nullptr;
        QCRIL_LOG_DEBUG("nr5g config info changed");
        bool is5gSA = sys_info.nr5g_srv_status_info_valid &&
                      (sys_info.nr5g_srv_status_info.srv_status == NAS_SYS_SRV_STATUS_SRV_V01);
        QCRIL_LOG_DEBUG("is5gSA - %d", is5gSA);
        config_ind = std::make_shared<Nas5gConfigInfoIndMessage>(is5gSA);
        if (config_ind != nullptr)
        {
            config_ind->broadcast();
        }
    }
}

//===========================================================================
//qcril_qmi_nas_free_sys_info_helper
//===========================================================================
void qcril_qmi_nas_free_sys_info_helper(nas_sys_info_helper_type * sys_info_helper)
{
    qcril_free(sys_info_helper->threegpp2_srv_status);
    qcril_free(sys_info_helper->threegpp_srv_status);
    qcril_free(sys_info_helper->common_sys_info);
    qcril_free(sys_info_helper->cdma_hdr_only_sys_info);
    qcril_free(sys_info_helper->cdma_only_sys_info);
    qcril_free(sys_info_helper->hdr_only_sys_info);
    qcril_free(sys_info_helper->threegpp_only_sys_info);
    qcril_free(sys_info_helper->gsm_only_sys_info);
    qcril_free(sys_info_helper->wcdma_only_sys_info);
    qcril_free(sys_info_helper->tdscdma_only_sys_info);
    qcril_free(sys_info_helper->lte_only_sys_info);
    qcril_free(sys_info_helper->nr5g_only_sys_info);
    qcril_free(sys_info_helper->voice_support_on_lte);
    qcril_free(sys_info_helper->extra_results);
}

//===========================================================================
//qcril_qmi_nas_sys_info_ind_conv_qmi2ril
//===========================================================================
int qcril_qmi_nas_sys_info_ind_conv_qmi2ril(nas_sys_info_ind_msg_v01 * qmi_msg,
                                            int * network_state_updated,
                                            int * radio_tech_changed,
                                            int * data_nw_state_changed
                                                )
{
  qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
  qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
  int                              any_rte_change;
  uint8_t                          prev_lte_embms_coverage_valid;
  uint8_t                          prev_lte_embms_coverage;
  uint8_t                          prev_embms_coverage_status_valid;
  nas_lte_rrc_embms_coverage_status_enum_v01  prev_embms_coverage_status;
  uint8_t                          prev_lte_sys_info_valid;
  nas_lte_sys_info_type_v01        prev_lte_sys_info;
  nas_service_status_enum_type_v01  old_service_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
  nas_service_status_enum_type_v01  new_service_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
  nas_sys_info_helper_type prev_sys_info_helper;
  nas_sys_info_helper_type cur_sys_info_helper;
  int limit_sys_info = nas_common_info.limit_sys_info_logic_change; // Default value is 0
  int res = E_SUCCESS;

  uint8_t old_mcc_mnc_valid;
  char old_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char old_mnc_str[NAS_MCC_MNC_MAX_SIZE];
  uint8_t new_mcc_mnc_valid;
  char new_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char new_mnc_str[NAS_MCC_MNC_MAX_SIZE];

  nas_sms_status_enum_type_v01 prev_lte_sms_status;
  uint8_t prev_lte_sms_status_valid;

  nas_lte_voice_status_enum_type_v01 prev_lte_voice_status;
  uint8_t prev_lte_voice_status_valid;

  qcril_arb_pref_data_type pref_data;
  int extrapolation_is_under;
  int extrapolation_is_roaming;
  int data_reg;
  int local_confident_response;

  QCRIL_LOG_FUNC_ENTRY();

  //Memset SYS Info helpers to 0
  memset(&cur_sys_info_helper,0,sizeof(cur_sys_info_helper));
  memset(&prev_sys_info_helper,0,sizeof(prev_sys_info_helper));

  NAS_EMBMS_CACHE_LOCK();
  prev_lte_embms_coverage_valid = nas_cached_info.lte_embms_coverage_valid;
  prev_lte_embms_coverage = nas_cached_info.lte_embms_coverage;
  prev_embms_coverage_status_valid = nas_cached_info.embms_coverage_status_valid;
  prev_embms_coverage_status = nas_cached_info.embms_coverage_status;
  NAS_EMBMS_CACHE_UNLOCK();

  NAS_CACHE_LOCK();
  qcril_qmi_nas_fetch_lte_voice_status( &prev_lte_voice_status_valid, &prev_lte_voice_status );
  qcril_qmi_nas_fetch_lte_sms_status( &prev_lte_sms_status_valid, &prev_lte_sms_status);
  prev_lte_sys_info_valid = nas_cached_info.lte_sys_info_valid;
  if (prev_lte_sys_info_valid)
  {
    if (nas_cached_info.lte_sys_info)
    {
      memcpy(&prev_lte_sys_info, nas_cached_info.lte_sys_info, sizeof(prev_lte_sys_info));
    }
    else
    {
      QCRIL_LOG_DEBUG("nas_cached_info.lte_sys_info_valid is true but nas_cached_info.lte_sys_info is NULL");
      prev_lte_sys_info_valid = FALSE;
    }
  }

  old_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(old_mcc_str, old_mnc_str, TRUE, NULL);
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_DEBUG( "limit_sys_info=%d", limit_sys_info);

  qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
  qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );

  NAS_CACHE_LOCK();

  qcril_qmi_nas_report_cell_info_if_needed_cl();

  // Set network_state_updated initialized to FALSE if limit_sys_info prop is set
  if ( limit_sys_info == TRUE )
  {
    *network_state_updated = FALSE;
  }
  else
  {
    *network_state_updated = TRUE;
  }

  *data_nw_state_changed = qcril_qmi_nas_is_data_nw_state_updated( qmi_msg );

  QCRIL_LOG_DEBUG("... network_state_updated = %d, data_nw_state_changed = %d", *network_state_updated, *data_nw_state_changed);

  // Store the current nas cache info to compare against updated sys info
  if ( limit_sys_info == TRUE )
  {
    // Fill sys info call will allocate memory for corresponding
    // sys info structs based on the RTE. Care must be taken to
    // free this memory by calling qcril_qmi_nas_free_sys_info_helper
    res = qcril_qmi_nas_fill_sys_info_details (&prev_sys_info_helper, &old_service_status );
    if ( res == E_FAILURE)
    {
       *network_state_updated = TRUE;
    }
  }

  qcril_qmi_nas_notify_changes_to_5g_parameters(*qmi_msg);

  qmi_ril_nw_reg_update_sys_info_cache_from_ind( qmi_msg );

  QCRIL_LOG_INFO("Vops Old : %d, New: %d Valid: %d", nas_cached_info.old_lte_ims_voice_avail,
         nas_cached_info.lte_ims_voice_avail, nas_cached_info.lte_ims_voice_avail_valid);

  if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_ims_voice_avail) &&
          nas_cached_info.old_lte_ims_voice_avail != nas_cached_info.lte_ims_voice_avail )
  {
      nas_cached_info.old_lte_ims_voice_avail = nas_cached_info.lte_ims_voice_avail;
      qcril_qmi_nas_vops_info_ind_handler(nas_cached_info.old_lte_ims_voice_avail);
  }

  qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc();

  new_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(new_mcc_str, new_mnc_str, TRUE, NULL);
  if( old_mcc_mnc_valid != new_mcc_mnc_valid || strcmp(old_mcc_str, new_mcc_str) || strcmp(old_mnc_str, new_mnc_str) ) //invalidiating operator name specifics as PLMN has changed
  {
      NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
      NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
      NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
      NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
      NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
      *network_state_updated = TRUE;
      *radio_tech_changed = TRUE;
  }

  if(nas_common_info.is_snapshot_reported_data_reg_state)
  {
      nas_cached_info.is_proper_data_reg_to_report = FALSE;
      QCRIL_LOG_INFO( "is_proper_data_reg_to_report %d",
          nas_cached_info.is_proper_data_reg_to_report);
      if ( NAS_NIL == nas_cached_info.reported_data_reg_expiry )
      {//start timer if not running
          qmi_ril_nwreg_spawn_reported_data_reg_snapshot_timer();
      }
  }

  NAS_CACHE_UNLOCK();

  if( qmi_msg->wcdma_eutra_status_valid )
  {
      qcril_qmi_nas_report_eutra_status( &qmi_msg->wcdma_eutra_status );
  }

  qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
  qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
  qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
  any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
  QCRIL_LOG_INFO( "any rte change %d", any_rte_change);

  if(FALSE == (*radio_tech_changed))
  {
      *radio_tech_changed = ( any_rte_change ) ? TRUE : FALSE;
  }

  QCRIL_LOG_INFO( ".. rte changed %d",
                  (int)*radio_tech_changed );

  if( FALSE == ( *radio_tech_changed ) )
  {
      if( qcril_qmi_nas_lte_sms_status_compare( prev_lte_sms_status_valid, prev_lte_sms_status ) ||
          qcril_qmi_nas_lte_voice_status_compare( prev_lte_voice_status_valid, prev_lte_voice_status )
        )
      {
          *radio_tech_changed = TRUE;
      }
  }

  QCRIL_LOG_INFO( ".. after lte voice and sms status rte changed %d", (int)*radio_tech_changed );
  if( TRUE == any_rte_change )
  {
    NAS_CACHE_LOCK();
    qcril_qmi_nas_drop_nw_info_cache();
    qcril_qmi_nas_fetch_sys_info();

    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);
    qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, &extrapolation_is_under, &extrapolation_is_roaming );
    // Invalidate sig info cache when not extrapolating or extrapolating but VOICE_RTE and DATA_RTE same.
    if ( (!extrapolation_is_under) ||
         ( extrapolation_is_under && ( nas_cached_info.voice_rte == nas_cached_info.data_rte ) ) )
    {
      qcril_qmi_drop_sig_info_cache();
    }

    NAS_CACHE_UNLOCK();

    *network_state_updated = TRUE; //voice and data network state need to be updated as there is a change in rte
    *data_nw_state_changed = TRUE;
  }
  else
  {
      if(qcril_qmi_nas_is_considered_registered(NULL))
      {
          qcril_qmi_nas_report_change_in_rat_rac();
      }
      else
      {
          /* Device is OOS, so clear the cache */
          qcril_qmi_nas_clear_reported_rat_rac_cache();
      }
  }

  qcril_qmi_nas_report_change_in_csg_id();

  NAS_CACHE_LOCK();
  qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );
  memset(&pref_data, 0, sizeof(pref_data));
  qcril_qmi_get_pref_data_tech(&pref_data);
  local_confident_response = qcril_qmi_nas_decide_data_roam_status(pref_data.pref_data_tech, &data_reg);
  if(TRUE == local_confident_response)
  {
    qcril_qmi_nas_reset_extrapolation_ban_expiry();
  }
  NAS_CACHE_UNLOCK();

  qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(prev_lte_embms_coverage_valid, prev_lte_embms_coverage,
                                                           prev_embms_coverage_status_valid, prev_embms_coverage_status);
  qcril_qmi_nas_embms_send_cell_info_changed_if_needed(prev_lte_sys_info_valid, &prev_lte_sys_info);

  QCRIL_LOG_DEBUG("...... network_state_updated = %d, data_nw_state_changed = %d", *network_state_updated, *data_nw_state_changed);

  // In case RTE is not changed check for change in other sys info fields
  if ( ( limit_sys_info == TRUE ) && (! ( *network_state_updated  || *data_nw_state_changed ) ) )
  {
    res = qcril_qmi_nas_fill_sys_info_details (&cur_sys_info_helper, &new_service_status );
    if ( res == E_FAILURE)
    {
       *network_state_updated = TRUE;
    }

    // Basic srv status related checks common to 3gpp and 3gpp2
    if ( !*network_state_updated && ( NULL != prev_sys_info_helper.common_sys_info ) &&
         ( NULL != cur_sys_info_helper.common_sys_info ) )
    {
      *network_state_updated = old_service_status != new_service_status ||
                               ( ( prev_sys_info_helper.common_sys_info->srv_domain_valid && cur_sys_info_helper.common_sys_info->srv_domain_valid ) &&
                                  prev_sys_info_helper.common_sys_info->srv_domain != cur_sys_info_helper.common_sys_info->srv_domain ) ||
                               ( ( prev_sys_info_helper.common_sys_info->srv_capability_valid && cur_sys_info_helper.common_sys_info->srv_capability_valid ) &&
                                  prev_sys_info_helper.common_sys_info->srv_capability != cur_sys_info_helper.common_sys_info->srv_capability ) ||
                               ( ( prev_sys_info_helper.common_sys_info->roam_status_valid && cur_sys_info_helper.common_sys_info->roam_status_valid ) &&
                                  prev_sys_info_helper.common_sys_info->roam_status != cur_sys_info_helper.common_sys_info->roam_status );
      QCRIL_LOG_INFO( "old_service_status %d, new_service_status %d prev srv domain %d cur srv domain %d prev srv capability %d cur srv capability %d prev roam status %d cur roam status %d", old_service_status, new_service_status, prev_sys_info_helper.common_sys_info->srv_domain, cur_sys_info_helper.common_sys_info->srv_domain, prev_sys_info_helper.common_sys_info->srv_capability, cur_sys_info_helper.common_sys_info->srv_capability, prev_sys_info_helper.common_sys_info->roam_status, cur_sys_info_helper.common_sys_info->roam_status);
    }

    // 3gpp checks
    if ((!*network_state_updated) &&
            ((nas_cached_info.voice_rte == QMI_RIL_RTE_GSM) ||
            (nas_cached_info.voice_rte == QMI_RIL_RTE_WCDMA) ||
            (nas_cached_info.voice_rte == QMI_RIL_RTE_TDSCDMA) ||
            (nas_cached_info.voice_rte == QMI_RIL_RTE_SUB_LTE) ||
            (nas_cached_info.voice_rte == QMI_RIL_RTE_SUB_NR5G)) &&
            (NULL != prev_sys_info_helper.threegpp_only_sys_info) &&
            (NULL != cur_sys_info_helper.threegpp_only_sys_info) &&
            (NULL != prev_sys_info_helper.threegpp_srv_status) &&
            (NULL != cur_sys_info_helper.threegpp_srv_status))
    {
      QCRIL_LOG_INFO( " .. 3gpp check");
      *network_state_updated = ( ( prev_sys_info_helper.threegpp_only_sys_info->reg_reject_info_valid && cur_sys_info_helper.threegpp_only_sys_info->reg_reject_info_valid ) &&
                                 (( prev_sys_info_helper.threegpp_only_sys_info->reg_reject_info.reject_srv_domain != cur_sys_info_helper.threegpp_only_sys_info->reg_reject_info.reject_srv_domain ) ||
                                 ( prev_sys_info_helper.threegpp_only_sys_info->reg_reject_info.rej_cause != cur_sys_info_helper.threegpp_only_sys_info->reg_reject_info.rej_cause )) ) ||
                                 prev_sys_info_helper.threegpp_srv_status->true_srv_status != cur_sys_info_helper.threegpp_srv_status->true_srv_status ||
                               ( nas_common_info.location_updates_enabled &&
                                  ( ( ( prev_sys_info_helper.threegpp_only_sys_info->lac_valid && cur_sys_info_helper.threegpp_only_sys_info->lac_valid ) &&
                                    ( prev_sys_info_helper.threegpp_only_sys_info->lac != cur_sys_info_helper.threegpp_only_sys_info->lac )) ||
                                    (( prev_sys_info_helper.threegpp_only_sys_info->cell_id_valid && cur_sys_info_helper.threegpp_only_sys_info->cell_id_valid ) &&
                                    ( prev_sys_info_helper.threegpp_only_sys_info->cell_id != cur_sys_info_helper.threegpp_only_sys_info->cell_id )) ) );
     QCRIL_LOG_INFO( "prev lac %u cur lac %u prev cid %d cur cid %d", prev_sys_info_helper.threegpp_only_sys_info->lac, cur_sys_info_helper.threegpp_only_sys_info->lac, prev_sys_info_helper.threegpp_only_sys_info->cell_id, cur_sys_info_helper.threegpp_only_sys_info->cell_id );

     // Check for TAC change if rte is LTE
     if ( !*network_state_updated && nas_cached_info.voice_rte == QMI_RIL_RTE_SUB_LTE && ( NULL != prev_sys_info_helper.lte_only_sys_info) &&
          ( NULL != cur_sys_info_helper.lte_only_sys_info) )
     {
       *network_state_updated = ( nas_common_info.location_updates_enabled &&
                                ( ( prev_sys_info_helper.lte_only_sys_info->tac_valid && cur_sys_info_helper.lte_only_sys_info->tac_valid ) &&
                                  ( prev_sys_info_helper.lte_only_sys_info->tac != cur_sys_info_helper.lte_only_sys_info->tac ) ) );
     }
   }
   // Check for location update for CDMA
   else if ( !*network_state_updated && nas_cached_info.voice_rte == QMI_RIL_RTE_1x &&
              ( NULL != prev_sys_info_helper.cdma_only_sys_info) && ( NULL != cur_sys_info_helper.cdma_only_sys_info) )
   {
     QCRIL_LOG_INFO( " .. 1x check");
     *network_state_updated =  ( nas_common_info.location_updates_enabled &&
                               ( ( prev_sys_info_helper.cdma_only_sys_info->bs_info_valid && cur_sys_info_helper.cdma_only_sys_info->bs_info_valid ) &&
                                 (( prev_sys_info_helper.cdma_only_sys_info->bs_info.base_id != cur_sys_info_helper.cdma_only_sys_info->bs_info.base_id ) ||
                                 ( prev_sys_info_helper.cdma_only_sys_info->bs_info.base_lat != cur_sys_info_helper.cdma_only_sys_info->bs_info.base_lat ) ||
                                 ( prev_sys_info_helper.cdma_only_sys_info->bs_info.base_long != cur_sys_info_helper.cdma_only_sys_info->bs_info.base_long )) ) );
     QCRIL_LOG_INFO( "prev base_id %u cur base_id %u", prev_sys_info_helper.cdma_only_sys_info->bs_info.base_id, cur_sys_info_helper.cdma_only_sys_info->bs_info.base_id );
   }
   // HDR fields
   else if ( !*network_state_updated && nas_cached_info.voice_rte == QMI_RIL_RTE_SUB_DO &&
             ( NULL != prev_sys_info_helper.hdr_only_sys_info) && ( NULL != cur_sys_info_helper.hdr_only_sys_info) )
   {
     QCRIL_LOG_INFO( " .. hdr check");
     *network_state_updated = ( ( prev_sys_info_helper.hdr_only_sys_info->hdr_personality_valid && cur_sys_info_helper.hdr_only_sys_info->hdr_personality_valid ) ||
                                 prev_sys_info_helper.hdr_only_sys_info->hdr_personality != cur_sys_info_helper.hdr_only_sys_info->hdr_personality ) ||
                              ( ( prev_sys_info_helper.hdr_only_sys_info->hdr_active_prot_valid && cur_sys_info_helper.hdr_only_sys_info->hdr_active_prot_valid ) ||
                                prev_sys_info_helper.hdr_only_sys_info->hdr_active_prot != cur_sys_info_helper.hdr_only_sys_info->hdr_active_prot );
      QCRIL_LOG_INFO( "prev hdr_personality %d cur hdr_personality %d", prev_sys_info_helper.hdr_only_sys_info->hdr_personality, cur_sys_info_helper.hdr_only_sys_info->hdr_personality );
   }
 }

  QCRIL_LOG_DEBUG("......... network_state_updated = %d, data_nw_state_changed = %d", *network_state_updated, *data_nw_state_changed);

  qcril_qmi_nas_free_sys_info_helper(&cur_sys_info_helper);
  qcril_qmi_nas_free_sys_info_helper(&prev_sys_info_helper);

  QCRIL_LOG_FUNC_RETURN();

  return E_SUCCESS;
} // qcril_qmi_nas_sys_info_ind_conv_qmi2ril

//===========================================================================
//qmi_ril_nw_reg_update_sys_info_cache_from_ind
//===========================================================================
void qmi_ril_nw_reg_update_sys_info_cache_from_ind( nas_sys_info_ind_msg_v01 * qmi_msg )
{
    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_srv_status_info, qmi_msg->cdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_srv_status_info, qmi_msg->hdr_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_srv_status_info, qmi_msg->gsm_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_srv_status_info, qmi_msg->wcdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_srv_status_info, qmi_msg->tdscdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_srv_status_info, qmi_msg->lte_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_srv_status_info, qmi_msg->nr5g_srv_status_info );

    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info, qmi_msg->cdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info, qmi_msg->hdr_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info, qmi_msg->gsm_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info, qmi_msg->wcdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_sys_info, qmi_msg->tdscdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info, qmi_msg->lte_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_sys_info, qmi_msg->nr5g_sys_info );

    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info2, qmi_msg->cdma_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info2, qmi_msg->hdr_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info2, qmi_msg->gsm_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info2, qmi_msg->wcdma_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info2, qmi_msg->lte_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info3, qmi_msg->gsm_sys_info3 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info3, qmi_msg->wcdma_sys_info3  );

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_cell_status, qmi_msg->lte_cell_status  );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_support_on_lte, qmi_msg->voice_support_on_lte );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_is_eb_supported, qmi_msg->lte_is_eb_supported );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.emergency_access_barred, qmi_msg->emergency_access_barred );

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_embms_coverage, qmi_msg->lte_embms_coverage );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.embms_coverage_status, qmi_msg->embms_coverage_status );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sim_rej_info, qmi_msg->sim_rej_info );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_ims_voice_avail, qmi_msg->lte_ims_voice_avail );

    NAS_CACHE_STORE_ENTRY(nas_cached_info.nr5g_tac_info, qmi_msg->nr5g_tac_info);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.tracking_area_is_restricted, qmi_msg->tracking_area_is_restricted);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.nr5g_cell_status, qmi_msg->nr5g_cell_status);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.nr5g_voice_domain, qmi_msg->nr5g_voice_domain);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.voice_support_on_nr5g, qmi_msg->voice_support_on_nr5g);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.n1_sms_is_registered, qmi_msg->n1_sms_is_registered);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.nr5g_sms_domain, qmi_msg->nr5g_sms_domain);

    nas_cached_info.is_considered_registered_cached_result_valid = FALSE;
    nas_cached_info.is_in_service_of_technology_cache_result_valid = FALSE;

    NAS_CACHE_STORE_ENTRY(nas_cached_info.wcdma_csg_info, qmi_msg->wcdma_csg_info );

    NAS_CACHE_STORE_ENTRY(nas_cached_info.lte_csg_info, qmi_msg->lte_csg_info );

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_voice_status,qmi_msg->lte_voice_status);

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sms_status,qmi_msg->lte_sms_status);

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.wcdma_rac,qmi_msg->wcdma_rac);

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.gsm_rac,qmi_msg->gsm_rac);

    QCRIL_LOG_DEBUG("endc_available_valid: %d, endc_available: %d, restrict_dcnr_valid: %d,"
            " restrict_dcnr: %d", qmi_msg->endc_available_valid, qmi_msg->endc_available,
            qmi_msg->restrict_dcnr_valid, qmi_msg->restrict_dcnr);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.endc_available);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.endc_available, qmi_msg->endc_available);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.restrict_dcnr);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.restrict_dcnr, qmi_msg->restrict_dcnr);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available, qmi_msg->plmn_infolist_r15_available);

    qcril_qmi_nas_invalidate_data_snapshot_if_applicable();
    qcril_qmi_nas_update_voice_rte();
    qcril_qmi_nas_update_data_rte();
    qcril_qmi_nas_update_ims_rte();
    qcril_qmi_voice_technology_updated();
    qmi_ril_nwr_update_reg_rej_from_sys_info();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_update_sys_info_cache_from_ind

//===========================================================================
//qcril_qmi_nas_is_data_nw_state_updated
//===========================================================================
int qcril_qmi_nas_is_data_nw_state_updated(nas_sys_info_ind_msg_v01 * qmi_msg)
{
  int res = FALSE;
  qcril_arb_pref_data_type pref_data;

  nas_3gpp_only_sys_info_type_v01 *cache_threegpp_specific_sys_info, *ind_threegpp_specific_sys_info;
  nas_common_sys_info_type_v01 *cache_common_sys_info, *ind_common_sys_info;
  nas_lte_only_sys_info_type_v01 *cache_lte_specific_sys_info, *ind_lte_specific_sys_info;

  QCRIL_LOG_FUNC_ENTRY();

  cache_threegpp_specific_sys_info = NULL;
  ind_threegpp_specific_sys_info = NULL;
  cache_lte_specific_sys_info = NULL;
  ind_lte_specific_sys_info = NULL;
  cache_common_sys_info = NULL;
  ind_common_sys_info = NULL;

  if( qmi_msg )
  {
    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);

    if( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data.pref_data_tech &&
        QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data.pref_data_tech &&
        TRUE == pref_data.is_current )
    {
        QCRIL_LOG_INFO("CnE module available with current status - Valid pref data tech %d", pref_data.pref_data_tech);

        switch ( pref_data.pref_data_tech )
        {
            case QCRIL_ARB_PREF_DATA_TECH_GSM:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.gsm_sys_info->common_sys_info;
                }
                if( qmi_msg->gsm_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->gsm_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->gsm_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.wcdma_sys_info->common_sys_info;
                }
                if( qmi_msg->wcdma_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->wcdma_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->wcdma_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.tdscdma_sys_info->common_sys_info;
                }
                if( qmi_msg->tdscdma_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->tdscdma_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->tdscdma_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_LTE:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.lte_sys_info->common_sys_info;
                    cache_lte_specific_sys_info = &nas_cached_info.lte_sys_info->lte_specific_sys_info;
                }
                if( qmi_msg->lte_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->lte_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->lte_sys_info.common_sys_info;
                    ind_lte_specific_sys_info = &qmi_msg->lte_sys_info.lte_specific_sys_info;
                }
                break;

             case QCRIL_ARB_PREF_DATA_TECH_5G:
                if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info))
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.nr5g_sys_info->common_sys_info;
                }

                if (qmi_msg->nr5g_sys_info_valid)
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->nr5g_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->nr5g_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
                {
                    cache_common_sys_info = &nas_cached_info.cdma_sys_info->common_sys_info;
                }
                if( qmi_msg->cdma_sys_info_valid )
                {
                    ind_common_sys_info = &qmi_msg->cdma_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_EVDO:
            case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                {
                    cache_common_sys_info = &nas_cached_info.hdr_sys_info->common_sys_info;
                }
                if( qmi_msg->hdr_sys_info_valid )
                {
                    ind_common_sys_info = &qmi_msg->hdr_sys_info.common_sys_info;
                }
                break;


            default:
                // nothing
                break;
        }

        if( FALSE == res && cache_common_sys_info && ind_common_sys_info )
        {
          if( cache_common_sys_info->roam_status_valid == ind_common_sys_info->roam_status_valid &&
              cache_common_sys_info->roam_status == ind_common_sys_info->roam_status )
          {
            res = FALSE;
          }
          else
          {
            res = TRUE;
          }
        }
        else if( cache_common_sys_info != ind_common_sys_info )
        {
          res = TRUE;
        }

        if( FALSE == res && cache_threegpp_specific_sys_info && ind_threegpp_specific_sys_info )
        {
          if( cache_threegpp_specific_sys_info->cell_id_valid == ind_threegpp_specific_sys_info->cell_id_valid &&
              cache_threegpp_specific_sys_info->cell_id == ind_threegpp_specific_sys_info->cell_id &&
              cache_threegpp_specific_sys_info->lac_valid == ind_threegpp_specific_sys_info->lac_valid &&
              cache_threegpp_specific_sys_info->lac == ind_threegpp_specific_sys_info->lac )
          {
            res = FALSE;
          }
          else
          {
            res = TRUE;
          }
        }
        else if( cache_threegpp_specific_sys_info != ind_threegpp_specific_sys_info )
        {
          res = TRUE;
        }


        if( FALSE == res && cache_lte_specific_sys_info && ind_lte_specific_sys_info )
        {
          if( cache_lte_specific_sys_info->tac_valid == ind_lte_specific_sys_info->tac_valid &&
              cache_lte_specific_sys_info->tac == ind_lte_specific_sys_info->tac )
          {
            res = FALSE;
          }
          else
          {
            res = TRUE;
          }
        }
        else if( cache_lte_specific_sys_info != ind_lte_specific_sys_info )
        {
          res = TRUE;
        }
    }
    else
    {
      res = TRUE;
    }
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} //qcril_qmi_nas_is_data_nw_state_updated

//===========================================================================
//qcril_qmi_nas_report_eutra_status
//===========================================================================
void qcril_qmi_nas_report_eutra_status(nas_eutra_cell_status_enum_type_v01 * eutra_status)
{
    char payload;

    QCRIL_LOG_FUNC_ENTRY();

    if( eutra_status )
    {
        QCRIL_LOG_INFO("eutra status %d", *eutra_status);
        payload = (char) *eutra_status;
        qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_EUTRA_STATUS, &payload, sizeof(payload));
    }
    else
    {
        QCRIL_LOG_INFO("eutra status unspecified");
    }

    QCRIL_LOG_FUNC_RETURN();
}  // qcril_qmi_nas_report_eutra_status

//===========================================================================
//qcril_qmi_nas_send_unsol_max_data_changed
//===========================================================================
void qcril_qmi_nas_send_unsol_max_data_changed()
{
    char payload;
    NAS_CACHE_LOCK();
    payload = nas_dms_cached_info.max_active_data_subs;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO("max_data indication - %d", payload);
    qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_MAX_DATA_CHANGE_IND, &payload, sizeof(payload));
}

//===========================================================================
// QCRIL_EVT_HOOK_GET_MAX_DATA_ALLOWED_REQ
//===========================================================================
void qcril_qmi_nas_get_max_data_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno result = RIL_E_SUCCESS;
    qcril_request_resp_params_type resp;
    uint8_t max_active_data_subs = 1;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    // Max active data subs supported - 1 byte
    if (NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs))
    {
      max_active_data_subs = nas_dms_cached_info.max_active_data_subs;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("get max_data req - %d", max_active_data_subs);

    if (params_ptr != NULL)
    {
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    params_ptr->t,
                                    params_ptr->event_id,
                                    result,
                                    &resp );
        resp.resp_pkt = &max_active_data_subs;
        resp.resp_len = sizeof(max_active_data_subs);
        qcril_send_request_response( &resp );
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// QCRIL_EVT_HOOK_GET_CSG_ID
//===========================================================================
void qcril_qmi_nas_get_csg_id_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno result = RIL_E_SUCCESS;
    qcril_request_resp_params_type resp;
    uint32_t csg_id = QCRIL_CSG_ID_INVALID;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    if ( nas_cached_info.prev_reported_csg_id_valid )
    {
        csg_id = nas_cached_info.prev_reported_csg_id;
    }

    QCRIL_LOG_INFO("csg_id - %d", csg_id);

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    params_ptr->t,
                                    params_ptr->event_id,
                                    result,
                                    &resp );

    resp.resp_pkt = &csg_id;
    resp.resp_len = sizeof(csg_id);
    qcril_send_request_response( &resp );

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_send_unsol_csg_id_changed
//===========================================================================
void qcril_qmi_nas_send_unsol_csg_id_changed(uint32_t csg_id)
{
    int payload;
    payload = csg_id;
    qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_CSG_ID_CHANGE_IND, (char *)&payload, sizeof(payload));
    NAS_CACHE_LOCK();
    nas_cached_info.prev_reported_csg_id_valid = TRUE;
    nas_cached_info.prev_reported_csg_id = csg_id;
    NAS_CACHE_UNLOCK();
}

//===========================================================================
//qcril_qmi_nas_report_change_in_csg_id
//===========================================================================
void qcril_qmi_nas_report_change_in_csg_id()
{
    uint8_t csg_id_changed = FALSE;
    uint8_t prev_csg_valid = FALSE;
    uint32_t prev_csg_id = QCRIL_CSG_ID_INVALID;
    uint8_t new_csg_valid = FALSE;
    uint32_t new_csg_id = QCRIL_CSG_ID_INVALID;

    QCRIL_LOG_FUNC_ENTRY();

    prev_csg_valid = nas_cached_info.prev_reported_csg_id_valid;
    prev_csg_id = nas_cached_info.prev_reported_csg_id;

    if (  NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_csg_info) )
    {
        new_csg_valid = TRUE;
        new_csg_id = nas_cached_info.wcdma_csg_info->id;
    }
    else if (  NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_csg_info) )
    {
        new_csg_valid = TRUE;
        new_csg_id = nas_cached_info.lte_csg_info->id;
    }

    do
    {
        if ( new_csg_valid == TRUE && prev_csg_valid == TRUE )
        {
            if ( prev_csg_id != new_csg_id )
            {
                csg_id_changed = TRUE;
                break;
            }
        }
        else if ( new_csg_valid || prev_csg_valid )
        {
            csg_id_changed = TRUE;
            break;
        }

    } while ( FALSE );


    if ( csg_id_changed == TRUE )
    {
        QCRIL_LOG_INFO("old csg_id - %d new csg_id - %d", prev_csg_id, new_csg_id);
        qcril_qmi_nas_send_unsol_csg_id_changed(new_csg_id);
    }
    else
    {
        QCRIL_LOG_INFO("No change in csg_id - %d", new_csg_id);
    }

    QCRIL_LOG_FUNC_RETURN();
}  // qcril_qmi_nas_report_change_in_csg_id


//===========================================================================
// qcril_qmi_nas_calculate_restricted_details
//===========================================================================
void qcril_qmi_nas_calculate_restricted_details(int * restricted_details)
{
    nas_gw_sys_info3_type_v01 * cs_restriction_related_sys_info3;
    nas_gw_sys_info3_type_v01 * ps_restriction_related_sys_info3;
    nas_gw_sys_info3_type_v01 lte_restricted_details;
    nas_gw_sys_info3_type_v01 tdscdma_restricted_details;


    QCRIL_LOG_FUNC_ENTRY();

    if( restricted_details )
    {
      cs_restriction_related_sys_info3 = NULL;
      ps_restriction_related_sys_info3 = NULL;
      memset(&lte_restricted_details, 0, sizeof(lte_restricted_details));
      memset(&tdscdma_restricted_details, 0, sizeof(tdscdma_restricted_details));

      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
         cs_restriction_related_sys_info3 = nas_cached_info.wcdma_sys_info3;
      }
      else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
          if( nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.cs_bar_status_valid )
          {
              tdscdma_restricted_details.cs_bar_status = nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.cs_bar_status;
              cs_restriction_related_sys_info3 = &tdscdma_restricted_details;
          }
      }
      else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
          cs_restriction_related_sys_info3 = nas_cached_info.gsm_sys_info3;
      }
      else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
          lte_restricted_details.cs_bar_status = nas_cached_info.lte_cell_status;
          cs_restriction_related_sys_info3 = &lte_restricted_details;
      }

      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
          lte_restricted_details.ps_bar_status = nas_cached_info.lte_cell_status;
          ps_restriction_related_sys_info3 = &lte_restricted_details;
      }
      else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
          ps_restriction_related_sys_info3 = nas_cached_info.wcdma_sys_info3;
      }
      else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
          if( nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.ps_bar_status_valid )
          {
              tdscdma_restricted_details.ps_bar_status = nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.ps_bar_status;
              ps_restriction_related_sys_info3 = &tdscdma_restricted_details;
          }
      }
      else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 ) &&
           (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
          )
      {
          ps_restriction_related_sys_info3 = nas_cached_info.gsm_sys_info3;
      }

      qcril_qmi_nas_fill_up_restricted_state_details( cs_restriction_related_sys_info3, ps_restriction_related_sys_info3, restricted_details );
    }
    else
    {
      QCRIL_LOG_FATAL("Null Pointer");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_calculate_restricted_details

//===========================================================================
// qcril_qmi_nas_report_restricted_details
//===========================================================================
void qcril_qmi_nas_report_restricted_details(int restricted_details)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_FATAL(".. reporting %d", restricted_details);

    auto msg = std::make_shared<RilUnsolRestrictedStateChangedMessage>(restricted_details);
    Dispatcher::getInstance().dispatchSync(msg);

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_report_restricted_details

//===========================================================================
//qcril_qmi_nas_restricted_state_handle_event
//===========================================================================
void qcril_qmi_nas_restricted_state_handle_event( qmi_ril_nas_restricted_details_event_e_type event )
{
    int                                                     fresh_details;
    qmi_ril_nas_restricted_details_state_e_type             new_state;
    int                                                     state_changed;
    qcril_arb_pref_data_type                                pref_data;

    QCRIL_LOG_FUNC_ENTRY();

    state_changed = FALSE;
    new_state     = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE;

    QCRIL_LOG_INFO( "event %d under state %d, cached details %d", (int)event, (int)nas_cached_info.restricted_details_state, (int)nas_cached_info.cached_restricted_details );

    switch ( event )
    {
        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_RESET:
            new_state                                 = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE;
            state_changed                             = TRUE;
            nas_cached_info.cached_restricted_details = NAS_NIL;
            break;

        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE:
            fresh_details = NAS_NIL;

            memset(&pref_data, 0, sizeof(pref_data));
            qcril_qmi_get_pref_data_tech(&pref_data);
            qcril_qmi_nas_calculate_restricted_details( &fresh_details );

            if ((RADIO_TECH_IWLAN == pref_data.radio_technology) &&
                (fresh_details & RIL_RESTRICTED_STATE_PS_ALL))
            {
                fresh_details = fresh_details & (~RIL_RESTRICTED_STATE_PS_ALL);
            }

            if ( fresh_details != nas_cached_info.cached_restricted_details )
            {
                nas_cached_info.cached_restricted_details = fresh_details;
                qcril_qmi_nas_report_restricted_details( nas_cached_info.cached_restricted_details );

                switch ( nas_cached_info.restricted_details_state )
                {
                    case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING:
                        // no change
                        break;

                    case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE:
                        new_state     = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING;
                        state_changed = TRUE;
                        break;

                    default:
                        // nothing
                        break;
                }
            }
            break;

        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_REPOST:
            switch ( nas_cached_info.restricted_details_state )
            {
                case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING:
                    qcril_setup_timed_callback(
                                              QCRIL_DEFAULT_INSTANCE_ID,
                                              QCRIL_DEFAULT_MODEM_ID,
                                              qcril_qmi_nas_retranslate_cs_ps_bar_info_handler,
                                              NULL,   // immediate
                                              NULL
                                              );
                    break;

                default:
                    break;
            }
            break;
            break;

        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHANGE_REPOST:
            switch ( nas_cached_info.restricted_details_state )
            {
                case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING:
                    qcril_qmi_nas_report_restricted_details( nas_cached_info.cached_restricted_details );

                    new_state                                 = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE;
                    state_changed                             = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default: // nothing
            break;
    }

    if ( state_changed )
    {
        nas_cached_info.restricted_details_state = new_state;
        QCRIL_LOG_INFO( "state changed to %d", (int)nas_cached_info.restricted_details_state );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_restricted_state_handle_event

//===========================================================================
//qcril_qmi_nas_fill_up_restricted_state_details
//===========================================================================
void qcril_qmi_nas_fill_up_restricted_state_details(nas_gw_sys_info3_type_v01 * cs_gw_sys_info3,
                                                    nas_gw_sys_info3_type_v01 * ps_gw_sys_info3,
                                                    int * restricted_state_details)
{
    int restricted_state_details_local;

    restricted_state_details_local = NAS_NIL;
    if ( NULL != cs_gw_sys_info3 )
    {
        QCRIL_LOG_INFO(  "cs_bar_status %d", (int)cs_gw_sys_info3->cs_bar_status );
        switch ( cs_gw_sys_info3->cs_bar_status )
        {
            case NAS_CELL_ACCESS_NORMAL_ONLY_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_CS_EMERGENCY;
                break;

            case NAS_CELL_ACCESS_EMERGENCY_ONLY_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_CS_NORMAL;
                break;

            case NAS_CELL_ACCESS_NO_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_CS_ALL;
                break;

            case NAS_CELL_ACCESS_ALL_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_NONE;
                break;

            case NAS_CELL_ACCESS_UNKNOWN_V01:
            default: // nothing
                break;
        }
    }

    if ( NULL != ps_gw_sys_info3 )
    {
        QCRIL_LOG_INFO(  "ps_bar_status %d", (int)ps_gw_sys_info3->ps_bar_status );
        switch ( ps_gw_sys_info3->ps_bar_status )
        {
            case NAS_CELL_ACCESS_EMERGENCY_ONLY_V01:    // fallthrough
            case NAS_CELL_ACCESS_NO_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_PS_ALL;
                break;

            case NAS_CELL_ACCESS_NORMAL_ONLY_V01:       // fallthrough
            case NAS_CELL_ACCESS_ALL_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_NONE;
                break;

            case NAS_CELL_ACCESS_UNKNOWN_V01:
            default: // nothing
                break;
        }

    }

    QCRIL_LOG_INFO(  " .. restricted_state_details_local %d", (int)restricted_state_details_local );
    *restricted_state_details = restricted_state_details_local;
} // qcril_qmi_nas_fill_up_restricted_state_details

//===========================================================================
//event report and signal strength ind
//===========================================================================
int qcril_qmi_nas_event_report_ind_conv_qmi2ril(nas_event_report_ind_msg_v01* qmi_msg, int * network_state_updated, int * data_nw_state_updated)
{
    int cs_reg_rej;
    int ps_reg_rej;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    if (qmi_msg)
    {
        // dbm
        if ( qmi_msg->rssi_valid )
        {
            NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.rssi );
        }

        // error rate
        if ( qmi_msg->error_rate_valid )
        {
            NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.error_rate );
        }


        // ecio
        if ( qmi_msg->ecio_valid )
        {
            NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.ecio );
        }

        // ** update cache
        NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.io, qmi_msg->io );
        NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sinr, qmi_msg->sinr );
        NAS_CACHE_STORE_ENTRY( nas_cached_info.rsrq , qmi_msg->rsrq );

        NAS_CACHE_STORE_ENTRY( nas_cached_info.registration_reject_reason , qmi_msg->registration_reject_reason );
        QCRIL_LOG_INFO( ".. reg reject valid %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason ) );
        if ( qmi_msg->registration_reject_reason_valid &&
             nas_cached_info.registration_reject_reason &&
             NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason )
           )
        {
            QCRIL_LOG_INFO( ".. evt_rep reg reject cause %d", (int)nas_cached_info.registration_reject_reason->reject_cause );
            QCRIL_LOG_INFO( ".. evt_rep reg reject dmn %d", (int)nas_cached_info.registration_reject_reason->service_domain );
            switch (nas_cached_info.registration_reject_reason->service_domain)
            {
                case NAS_CIRCUIT_SWITCHED_V01:
                    cs_reg_rej = TRUE;
                    ps_reg_rej = FALSE;
                    break;

                case NAS_PACKET_SWITCHED_V01:
                    cs_reg_rej = FALSE;
                    ps_reg_rej = TRUE;
                    break;

                case NAS_CIRCUIT_AND_PACKET_SWITCHED_V01:
                    cs_reg_rej = TRUE;
                    ps_reg_rej = TRUE;
                    break;

                default:
                    // no action
                    cs_reg_rej = FALSE;
                    ps_reg_rej = FALSE;
                    break;
            }

                if ( cs_reg_rej )
                {
                  *network_state_updated = TRUE;

                  // workaround for sys_info not delivering reg reject, using QMI_RIL_RTE_WCDMA but any 3gpp rte would do
                  if ( !nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected )
                  {
                      QCRIL_LOG_INFO( ".. applying cs reg rej workaround, cause %d", (int)nas_cached_info.registration_reject_reason->reject_cause );
                      qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                      nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_reject_cause           = nas_cached_info.registration_reject_reason->reject_cause;
                      nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected_assumed       = TRUE;
                  }
                }
                if ( ps_reg_rej )
                {
                *data_nw_state_updated = TRUE;
                }
        }

        NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.rf_band_info_list , qmi_msg->rf_band_info_list );
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
} // qcril_qmi_nas_event_report_ind_conv_qmi2ril

//===========================================================================
//handling sig info ind
//===========================================================================
int qcril_qmi_nas_sig_info_ind_conv_qmi2ril(nas_sig_info_ind_msg_v01* qmi_msg)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    if (qmi_msg)
    {
      NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sig_info, qmi_msg->cdma_sig_info );
      NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sig_info, qmi_msg->hdr_sig_info );
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gsm_sig_info, qmi_msg->gsm_sig_info );
      NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sig_info, qmi_msg->wcdma_sig_info );
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.rscp, qmi_msg->rscp );
      NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sig_info, qmi_msg->lte_sig_info );
      NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_sig_info, qmi_msg->nr5g_sig_info );
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.nr5g_rsrq, qmi_msg->nr5g_rsrq );
    }

    QCRIL_LOG_INFO("validity sign info GSM %d, WCDMA %d, TDSCDMA %d, 1x %d, HRPD %d, LTE %d, NR5G_SIG_INFO %d, NR5G_RSRQ %d",
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_rsrq)
                       );

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sig_info))
    {
        std::shared_ptr<Nas5gSignalStrengthIndMessage> five_g_signal_strength_ind =
            std::make_shared<Nas5gSignalStrengthIndMessage>(nas_cached_info.nr5g_sig_info->rsrp,
                    nas_cached_info.nr5g_sig_info->snr);
        if (five_g_signal_strength_ind != nullptr)
        {
            five_g_signal_strength_ind->broadcast();
        }
    }

    qcril_qmi_nas_report_cell_info_if_needed_cl();

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
} // qcril_qmi_nas_sig_info_ind_conv_qmi2ril

//===========================================================================
//handling err rate ind
//===========================================================================
int qcril_qmi_nas_err_rate_ind_conv_qmi2ril(nas_err_rate_ind_msg_v01* qmi_msg)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    if (qmi_msg)
    {
        //gsm
        if( qmi_msg->gsm_bit_err_rate_valid )
        {
            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.gsm_bit_err_rate );
        }

        // wcdma
        if ( qmi_msg->wcdma_block_err_rate_valid )
        {
            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.wcdma_block_err_rate );
        }

        // tdscdma
        if ( qmi_msg->tdscdma_block_err_rate_valid )
        {
            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.tdscdma_block_err_rate );
        }
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
} // qcril_qmi_nas_err_rate_ind_conv_qmi2ril

//===========================================================================
//qcril_qmi_nas_dump_sign_strength_report
//===========================================================================
void qcril_qmi_nas_dump_sign_strength_report(RIL_SignalStrength* ril_signal_strength)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO( "..GW");
    QCRIL_LOG_INFO( ".. signalStrength %d, bitErrorRate %d", ril_signal_strength->GW_SignalStrength.signalStrength,
                                                             ril_signal_strength->GW_SignalStrength.bitErrorRate );

    QCRIL_LOG_INFO( "..WCDMA");
    QCRIL_LOG_INFO( ".. %s valid", ril_signal_strength->WCDMA_SignalStrength.valid ? "" : "NOT");
    QCRIL_LOG_INFO( ".. signalStrength %d, bitErrorRate %d rscp %u ecio %u", ril_signal_strength->WCDMA_SignalStrength.signalStrength,
                                                             ril_signal_strength->WCDMA_SignalStrength.bitErrorRate,
                                                             ril_signal_strength->WCDMA_SignalStrength.rscp,
                                                             ril_signal_strength->WCDMA_SignalStrength.ecio);

    QCRIL_LOG_INFO( "..TDSCDMA");
#ifndef QMI_RIL_UTF
    QCRIL_LOG_INFO( ".. signalStrength %d", ril_signal_strength->TD_SCDMA_SignalStrength.rscp );
#endif

    QCRIL_LOG_INFO( "..CDMA");
    QCRIL_LOG_INFO( ".. dbm %d, ecio %d ", ril_signal_strength->CDMA_SignalStrength.dbm,
                                                             ril_signal_strength->CDMA_SignalStrength.ecio );

    QCRIL_LOG_INFO( "..EVDO");
    QCRIL_LOG_INFO( ".. dbm %d, ecio %d, signalNoiseRatio %d", ril_signal_strength->EVDO_SignalStrength.dbm,
                                                             ril_signal_strength->EVDO_SignalStrength.ecio,
                                                             ril_signal_strength->EVDO_SignalStrength.signalNoiseRatio );

    QCRIL_LOG_INFO( "..LTE");
    QCRIL_LOG_INFO( ".. signalStrength %d, rsrp %d, rsrq %d, rsnnr %d", ril_signal_strength->LTE_SignalStrength.signalStrength,
                                                              ril_signal_strength->LTE_SignalStrength.rsrp,
                                                              ril_signal_strength->LTE_SignalStrength.rsrq,
                                                              ril_signal_strength->LTE_SignalStrength.rssnr );

    QCRIL_LOG_INFO("..5G");
    QCRIL_LOG_INFO(".. ssRsrp %d, ssRsrq %d, ssSinr %d, csiRsrp %d, csiRsrq %d, csiSinr %d",
                   ril_signal_strength->NR_SignalStrength.ssRsrp,
                   ril_signal_strength->NR_SignalStrength.ssRsrq,
                   ril_signal_strength->NR_SignalStrength.ssSinr,
                   ril_signal_strength->NR_SignalStrength.csiRsrp,
                   ril_signal_strength->NR_SignalStrength.csiRsrq,
                   ril_signal_strength->NR_SignalStrength.csiSinr);

    QCRIL_LOG_FUNC_RETURN();
}

void convertWcdmaRssiFromQmi(int &out, int8_t in)
{
    if (in > -125) {
        out = static_cast<int>( (113 + in)/2 );
        if (out > 31) out = 31;
        if (out < 0) out = 0;
    } else {
        out = 99;
    }
    QCRIL_LOG_DEBUG("input: %d, output: %u", (int) in, out);
}

void convertWcdmaRscpFromQmi(uint32_t &out, int16_t in)
{
    int16_t rscp = 120+in;
    if (rscp > 96) {
      rscp = 96;
    }
    if (rscp < 0) {
      rscp = 0;
    }
    out = static_cast<uint16_t>(rscp);
    QCRIL_LOG_DEBUG("input: %d, output: %u", (int)in, out);
}

void convertWcdmaEcioFromQmi(uint32_t &out, int16_t in)
{
    int16_t ecio = 48 - in;
    if (ecio < 0) ecio = 0;
    if (ecio > 49) ecio = 49;
    out = static_cast<uint16_t>(ecio);
    QCRIL_LOG_DEBUG("input: %d, output: %u", (int) in, out);
}

void convertTdscdmaRscpFromQmi(int &out, int8_t in)
{
    out = 120+in;
    if (out < 0) out = 0;
    if (out > 96) out = 96;
    QCRIL_LOG_DEBUG("input: %d, output: %u", (int)in, out);
}

//===========================================================================
//signal strength
//===========================================================================
int qcril_qmi_nas_signal_strength_con_conv_cache2ril(RIL_SignalStrength* ril_msg)
{

    NAS_CACHE_LOCK();
    if (ril_msg)
    {
        memset( ril_msg, 0, sizeof( *ril_msg ) );

        ril_msg->GW_SignalStrength.signalStrength   = NAS_SIGNAL_STRENGTH_UNK_GW;
        ril_msg->WCDMA_SignalStrength.valid   = FALSE;
        ril_msg->WCDMA_SignalStrength.signalStrength   = NAS_SIGNAL_STRENGTH_UNK_GW;
        ril_msg->WCDMA_SignalStrength.bitErrorRate   = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->WCDMA_SignalStrength.rscp   = NAS_SIGNAL_STRENGTH_UNK_RSCP;
        ril_msg->WCDMA_SignalStrength.ecio   = NAS_SIGNAL_STRENGTH_UNK_ECIO;
        ril_msg->LTE_SignalStrength.signalStrength  = NAS_SIGNAL_STRENGTH_UNK_GW;
        ril_msg->CDMA_SignalStrength.dbm            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->EVDO_SignalStrength.dbm            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->CDMA_SignalStrength.ecio            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->EVDO_SignalStrength.ecio            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->EVDO_SignalStrength.signalNoiseRatio = NAS_SIGNAL_STRENGTH_UNK;

        ril_msg->LTE_SignalStrength.rsrp    = INT_MAX;
        ril_msg->LTE_SignalStrength.rsrq    = INT_MAX;
        ril_msg->LTE_SignalStrength.rssnr   = INT_MAX;
        ril_msg->LTE_SignalStrength.cqi     = INT_MAX;

#if (QCRIL_RIL_VERSION >= 9)
        ril_msg->LTE_SignalStrength.timingAdvance = INT_MAX;
#endif

#ifndef QMI_RIL_UTF
        ril_msg->TD_SCDMA_SignalStrength.rscp = INT_MAX;
#endif
        ril_msg->NR_SignalStrength.ssRsrp = std::numeric_limits<int32_t>::max();
        ril_msg->NR_SignalStrength.ssRsrq = std::numeric_limits<int32_t>::max();
        ril_msg->NR_SignalStrength.ssSinr = std::numeric_limits<int32_t>::max();
        ril_msg->NR_SignalStrength.csiRsrp = std::numeric_limits<int32_t>::max();
        ril_msg->NR_SignalStrength.csiRsrq = std::numeric_limits<int32_t>::max();
        ril_msg->NR_SignalStrength.csiSinr = std::numeric_limits<int32_t>::max();

        // ??? ril_msg->CDMA_SignalStrength.signalNoiseRatio
        //TODO Initialization of bit err rate
        if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM))
        {
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info) )
            {
                qcril_cm_util_rssi_to_gw_signal_strength((nas_cached_info.gsm_sig_info * -1),&ril_msg->GW_SignalStrength.signalStrength);
            }
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_bit_err_rate) )
            {
                //TODO translating QMI NAS value to Telephony value
            }
        }

        if( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS)){
            ril_msg->WCDMA_SignalStrength.valid = TRUE;
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info) )
            {
                convertWcdmaRssiFromQmi(ril_msg->WCDMA_SignalStrength.signalStrength, nas_cached_info.wcdma_sig_info->rssi);
                convertWcdmaEcioFromQmi(ril_msg->WCDMA_SignalStrength.ecio, nas_cached_info.wcdma_sig_info->ecio);
            }
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_block_err_rate) )
            {
                //TODO translating QMI NAS value to Telephony value
            }
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_rscp) )
            {
                convertWcdmaRscpFromQmi(ril_msg->WCDMA_SignalStrength.rscp, nas_cached_info.wcdma_rscp);
            }
        }

        if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_TDSCDMA))
        {
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp) )
            {
#ifndef QMI_RIL_UTF
                convertTdscdmaRscpFromQmi(ril_msg->TD_SCDMA_SignalStrength.rscp, nas_cached_info.rscp);
#endif
            }
        }

        if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000))
        {
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info) )
            {
                ril_msg->CDMA_SignalStrength.dbm = nas_cached_info.cdma_sig_info->rssi * -1;
                ril_msg->CDMA_SignalStrength.ecio = nas_cached_info.cdma_sig_info->ecio * 5;
            }
        }

        if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000_HRPD))
        {
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info) )
            {
                ril_msg->EVDO_SignalStrength.dbm = nas_cached_info.hdr_sig_info->common_sig_str.rssi * -1;
                ril_msg->EVDO_SignalStrength.ecio = nas_cached_info.hdr_sig_info->common_sig_str.ecio * 5;
                ril_msg->EVDO_SignalStrength.signalNoiseRatio = nas_cached_info.hdr_sig_info->sinr;
            }
        }

        if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE))
        {
            if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info) )
            {
                qcril_cm_util_rssi_to_gw_signal_strength((nas_cached_info.lte_sig_info->rssi * -1),&ril_msg->LTE_SignalStrength.signalStrength);
                ril_msg->LTE_SignalStrength.rssnr = nas_cached_info.lte_sig_info->snr;
                ril_msg->LTE_SignalStrength.rsrp = nas_cached_info.lte_sig_info->rsrp * -1;
                ril_msg->LTE_SignalStrength.rsrq = nas_cached_info.lte_sig_info->rsrq * -1;
            }
        }

        if (qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_NR5G) || qcril_qmi_is_5g_data_connected())
        {
            if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sig_info))
            {
                if (nas_cached_info.nr5g_sig_info->rsrp != -32768)
                {
                    ril_msg->NR_SignalStrength.ssRsrp = nas_cached_info.nr5g_sig_info->rsrp;
                }

                if (nas_cached_info.nr5g_sig_info->snr != -32768)
                {
                    ril_msg->NR_SignalStrength.ssSinr = nas_cached_info.nr5g_sig_info->snr;
                }
            }

            if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_rsrq))
            {
                ril_msg->NR_SignalStrength.ssRsrq = nas_cached_info.nr5g_rsrq;
            }
        }
        qcril_qmi_nas_dump_sign_strength_report( ril_msg );
    }

    NAS_CACHE_UNLOCK();
    return E_SUCCESS;
}

//===========================================================================
// RIL_REQUEST_SIGNAL_STRENGTH
//===========================================================================
void qcril_qmi_nas_request_signal_strength
(
  std::shared_ptr<RilRequestGetSignalStrengthMessage> msg
)
{
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  auto payload = new qcril::interfaces::RilGetSignalStrengthResult_t();
  if (payload == nullptr) {
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_NO_MEMORY, nullptr));
    return;
  }
  auto& ril_response_payload = payload->respData;

  // let's see if any info needs to be fetched
  NAS_CACHE_LOCK();
  memset( &ril_response_payload, 0, sizeof( ril_response_payload ) );

  NAS_CACHE_LOCK();
  auto is_registered = qcril_qmi_nas_is_considered_registered(NULL);
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO(".. is registered %d", (int) is_registered);

  if ( is_registered  || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
  {
      ril_req_res = qcril_qmi_nas_fetch_signal_strength_observations();

      QCRIL_LOG_INFO(".. subfetch sig strength info %d", (int) ril_req_res);
      if ( RIL_E_SUCCESS == ril_req_res )
      {
          //by default the below function is returning success.
          ril_req_res = ( E_SUCCESS == qcril_qmi_nas_signal_strength_con_conv_cache2ril( &ril_response_payload ) ) ? RIL_E_SUCCESS : RIL_E_INTERNAL_ERR;
      }
  }
  else
  {  // no registered
      ril_req_res = RIL_E_SUCCESS; // we will retun 0 data
  }

  NAS_CACHE_UNLOCK();

  // ** respond
  if (RIL_E_SUCCESS == ril_req_res) {
    QCRIL_LOG_INFO( "responsed with payload");
    std::shared_ptr<qcril::interfaces::RilGetSignalStrengthResult_t> shared_resp(payload);
    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, shared_resp);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  } else {
    delete payload;
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);
} // qcril_qmi_nas_request_signal_strength

//===========================================================================
// QCRIL_EVT_QMI_NAS_SIG_STRENGTH_UPDATE
//===========================================================================
void qcril_qmi_trigger_propagate_known_signal_strength_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(params_ptr);
    QCRIL_NOTUSED(ret_ptr);
    qcril_qmi_nas_propagate_known_signal_strength_ind();
}
//===========================================================================
// qcril_qmi_nas_propagate_known_signal_strength_ind
//===========================================================================
RIL_Errno qcril_qmi_nas_propagate_known_signal_strength_ind(void)
{
    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    RIL_SignalStrength ril_response_payload;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &ril_response_payload, 0, sizeof(ril_response_payload) );
    ril_req_res = qcril_qmi_nas_fetch_signal_strength_observations();
    QCRIL_LOG_INFO(".. subfetch sig strength info %d", (int) ril_req_res);
    if ( RIL_E_SUCCESS == ril_req_res )
    {
        ril_req_res = ( E_SUCCESS == qcril_qmi_nas_signal_strength_con_conv_cache2ril( &ril_response_payload ) ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
        QCRIL_LOG_INFO(".. conf res %d", (int) ril_req_res);
        if ( RIL_E_SUCCESS == ril_req_res )
        {
            auto msg = std::make_shared<RilUnsolSignalStrengthMessage>(ril_response_payload);
            Dispatcher::getInstance().dispatchSync(msg);
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);
    return ril_req_res;
} // qcril_qmi_nas_propagate_known_signal_strength_ind
//===========================================================================
// qcril_qmi_nas_fetch_signal_strength_observations
//===========================================================================
RIL_Errno qcril_qmi_nas_fetch_signal_strength_observations(void)
{
    int qmi_request_need_sig_info = 0, qmi_request_need_err_rate = 0;

    nas_get_sig_info_resp_msg_v01 qmi_response_sig_info;
    nas_get_err_rate_resp_msg_v01 qmi_response_err_rate;
    nas_get_cell_location_info_resp_msg_v01 qmi_response_location_info;

    qmi_client_error_type qmi_client_error;

    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    QCRIL_LOG_INFO("validity sign info GSM %d, WCDMA %d, TDSCDMA %d, 1x %d, HRPD %d, LTE %d, NR5G_SIG_INFO %d, NR5G_RSRQ %d",
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info),
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info),
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp),
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info),
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info),
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info),
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sig_info),
                   (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_rsrq)
                   );

    QCRIL_LOG_INFO("validity err rate GSM %d, WCDMA %d, TDSCDMA %d",
                   (int)NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_bit_err_rate),
                   (int)NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_block_err_rate),
                   (int)NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_block_err_rate)
                   );

    memset( &qmi_response_err_rate, 0, sizeof( qmi_response_err_rate ) );
    qmi_request_need_sig_info = FALSE;
    qmi_request_need_err_rate = FALSE;
    if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM) )
    {
        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info) )
        {
            qmi_request_need_sig_info = TRUE;
        }
        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_bit_err_rate) )
        {
            qmi_request_need_err_rate = TRUE;
        }
    }

    if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS) )
    {
        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info) )
        {
            qmi_request_need_sig_info = TRUE;
        }
        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_block_err_rate) )
        {
            qmi_request_need_err_rate = TRUE;
        }
    }

    if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_TDSCDMA) )
    {
        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp) )
        {
            qmi_request_need_sig_info = TRUE;
        }
        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_block_err_rate) )
        {
            qmi_request_need_err_rate = TRUE;
        }
    }

    if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000) )
    {
        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info) )
        {
            qmi_request_need_sig_info = TRUE;
        }
    }

    if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000_HRPD) )
    {
        if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info))
        {
            qmi_request_need_sig_info = TRUE;
        }
    }

    if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE) )
    {
        if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info) )
        {
            qmi_request_need_sig_info = TRUE;
        }
    }

    if (qcril_qmi_is_5g_data_connected())
    {
        if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sig_info) || !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_rsrq))
        {
            qmi_request_need_sig_info = TRUE;
        }
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("..qmi_request_need_sig_info-%d, qmi_request_need_err_rate-%d", qmi_request_need_sig_info,qmi_request_need_err_rate);

    if ( qmi_request_need_sig_info )
    {
        memset( &qmi_response_sig_info, 0, sizeof( qmi_response_sig_info ) );
        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SIG_INFO_REQ_MSG_V01,
                                                      NULL,
                                                      NAS_NIL,
                                                      &qmi_response_sig_info,
                                                      sizeof( qmi_response_sig_info ),
                                                      ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response_sig_info.resp );
        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sig_info, qmi_response_sig_info.cdma_sig_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sig_info, qmi_response_sig_info.hdr_sig_info );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gsm_sig_info, qmi_response_sig_info.gsm_sig_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sig_info, qmi_response_sig_info.wcdma_sig_info );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.rscp, qmi_response_sig_info.rscp );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sig_info, qmi_response_sig_info.lte_sig_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_sig_info, qmi_response_sig_info.nr5g_sig_info );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.nr5g_rsrq, qmi_response_sig_info.nr5g_rsrq );
            NAS_CACHE_UNLOCK();
        }
        QCRIL_LOG_INFO("..sign info fetch res %d, %d, %d", (int) ril_req_res, (int) qmi_client_error, (int)qmi_response_sig_info.resp.error );
    }

    if ( (RIL_E_SUCCESS == ril_req_res) && qmi_request_need_err_rate )
    {
        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_ERR_RATE_REQ_MSG_V01,
                                                      NULL,
                                                      NAS_NIL,
                                                      &qmi_response_err_rate,
                                                      sizeof( qmi_response_err_rate ),
                                                      ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response_err_rate.resp );
        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gsm_bit_err_rate, qmi_response_err_rate.gsm_bit_err_rate );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.wcdma_block_err_rate, qmi_response_err_rate.wcdma_block_err_rate );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.tdscdma_block_err_rate, qmi_response_err_rate.tdscdma_block_err_rate );
            NAS_CACHE_UNLOCK();
        }
        QCRIL_LOG_INFO("..err rate fetch res %d, %d, %d", (int) ril_req_res, (int) qmi_client_error, (int)qmi_response_err_rate.resp.error );
    }
#ifndef QMI_RIL_UTF
    if ( (RIL_E_SUCCESS == ril_req_res))
    {
        memset( &qmi_response_location_info, 0, sizeof(qmi_response_location_info));
        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                NULL,
                NAS_NIL,
                &qmi_response_location_info,
                sizeof( qmi_response_location_info ));
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error,
                &qmi_response_location_info.resp,
                QCRIL_QMI_ERR_CTX_CELL_LOCATION_TXN,
                nullptr);
        if (RIL_E_SUCCESS == ril_req_res)
        {
            NAS_CACHE_LOCK();
            nas_cached_info.wcdma_rscp_valid = qmi_response_location_info.umts_info_valid;
            nas_cached_info.wcdma_rscp = qmi_response_location_info.umts_info.rscp;
            NAS_CACHE_UNLOCK();
        }
        QCRIL_LOG_INFO("..rscp fetch res %d, %d, %d", (int) ril_req_res, (int) qmi_client_error, (int)qmi_response_err_rate.resp.error );
        QCRIL_LOG_DEBUG("..wcdma rscp %s valid wcdma rscp %d", nas_cached_info.wcdma_rscp_valid ? "" : "NOT", nas_cached_info.wcdma_rscp );
    }
#endif
    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_fetch_signal_strength_observations

//===========================================================================^M
// qcril_qmi_nas_send_known_signal_strength
//===========================================================================
void qcril_qmi_nas_send_known_signal_strength(void)
{
    QCRIL_LOG_FUNC_ENTRY();

    RIL_SignalStrength ril_signal_strength;
    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    memset( &ril_signal_strength, 0, sizeof(ril_signal_strength) );

    ril_req_res = qcril_qmi_nas_fetch_signal_strength_observations();

    QCRIL_LOG_INFO(".. Fetch sig strength info %d", (int) ril_req_res);
    if ( RIL_E_SUCCESS == ril_req_res )
    {
      ril_req_res = (RIL_Errno) qcril_qmi_nas_signal_strength_con_conv_cache2ril( &ril_signal_strength );

      if ( RIL_E_SUCCESS == ril_req_res )
      {
        auto msg = std::make_shared<RilUnsolSignalStrengthMessage>(ril_signal_strength);
        Dispatcher::getInstance().dispatchSync(msg);
      }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_send_known_signal_strength

//===========================================================================
// qcril_qmi_nas_get_cell_location_data_sync
//===========================================================================
RIL_Errno qcril_qmi_nas_get_cell_location_data_sync
(
    nas_get_cell_location_info_resp_msg_v01 *get_cell_location_info_resp,
    uint64_t *timestamp,
    qmi_ril_err_context_e_type context
)
{
    qmi_client_error_type qmi_client_error = QMI_ERR_INTERNAL_V01;
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

    if ( NULL != get_cell_location_info_resp )
    {
        memset (get_cell_location_info_resp, 0, sizeof( *get_cell_location_info_resp));

        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                      NULL,
                                                      NAS_NIL,
                                                      (void *) get_cell_location_info_resp,
                                                      sizeof( *get_cell_location_info_resp ),
                                                      ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        if (timestamp)
        {
          *timestamp = ril_nano_time();
        }
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(
                                    qmi_client_error, &get_cell_location_info_resp->resp,
                                    context, nullptr);
    }
    else
    {
      QCRIL_LOG_ERROR("Internal err..response structure is null");
      ril_req_res = RIL_E_INTERNAL_ERR;
    }

    return ril_req_res;
}

//===========================================================================
// qcril_qmi_nas_fetch_sys_info
//===========================================================================
RIL_Errno qcril_qmi_nas_fetch_sys_info()
{
    qmi_client_error_type qmi_client_error;
    uint8_t prev_lte_embms_coverage_valid;
    uint8_t prev_lte_embms_coverage;
    uint8_t prev_lte_embms_coverage_status_valid;
    nas_lte_rrc_embms_coverage_status_enum_v01 prev_lte_embms_coverage_status;
    uint8_t                          prev_lte_sys_info_valid;
    nas_lte_sys_info_type_v01        prev_lte_sys_info;
    nas_sms_status_enum_type_v01 prev_lte_sms_status;
    uint8_t prev_lte_sms_status_valid = FALSE;
    nas_lte_voice_status_enum_type_v01 prev_lte_voice_status;
    uint8_t prev_lte_voice_status_valid = FALSE;
    qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
    qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
    int radio_tech_changed = FALSE;

    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

    nas_get_sys_info_resp_msg_v01 * qmi_response = NULL;

    uint8_t old_mcc_mnc_valid;
    char old_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char old_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    uint8_t new_mcc_mnc_valid;
    char new_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char new_mnc_str[NAS_MCC_MNC_MAX_SIZE];

    QCRIL_LOG_FUNC_ENTRY();

    qmi_response = (nas_get_sys_info_resp_msg_v01 *)qcril_malloc( sizeof( *qmi_response ) );
    qmi_ril_nw_reg_snapshot_init(&old_rte_snapshot);
    qmi_ril_nw_reg_snapshot_init(&new_rte_snapshot);
    if ( qmi_response )
    {
        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                       NULL,
                                                       NAS_NIL,  // empty request payload
                                                       (void*) qmi_response,
                                                       sizeof( *qmi_response ),
                                                       ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);


        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response->resp );


        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();
            // Get the old info/status
            qcril_qmi_nas_fetch_lte_voice_status( &prev_lte_voice_status_valid, &prev_lte_voice_status);
            qcril_qmi_nas_fetch_lte_sms_status( &prev_lte_sms_status_valid, &prev_lte_sms_status );
            qmi_ril_nw_reg_snapshot_cur_rte(&old_rte_snapshot);
            old_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(old_mcc_str, old_mnc_str, TRUE, NULL);

            qcril_qmi_nas_notify_changes_to_5g_parameters(*qmi_response);

            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_srv_status_info, qmi_response->cdma_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_srv_status_info, qmi_response->hdr_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_srv_status_info, qmi_response->gsm_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_srv_status_info, qmi_response->wcdma_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_srv_status_info, qmi_response->tdscdma_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_srv_status_info, qmi_response->lte_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_srv_status_info, qmi_response->nr5g_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info, qmi_response->cdma_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info, qmi_response->hdr_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info, qmi_response->gsm_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info, qmi_response->wcdma_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_sys_info, qmi_response->tdscdma_sys_info );

            prev_lte_sys_info_valid = nas_cached_info.lte_sys_info_valid;
            if (prev_lte_sys_info_valid)
            {
               if (nas_cached_info.lte_sys_info)
               {
                  memcpy(&prev_lte_sys_info, nas_cached_info.lte_sys_info, sizeof(prev_lte_sys_info));
               }
               else
               {
                  QCRIL_LOG_DEBUG("nas_cached_info.lte_sys_info_valid is true but nas_cached_info.lte_sys_info is NULL");
                  prev_lte_sys_info_valid = FALSE;
               }
            }

            NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info, qmi_response->lte_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_sys_info, qmi_response->nr5g_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info2, qmi_response->cdma_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info2, qmi_response->hdr_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info2, qmi_response->gsm_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info2, qmi_response->wcdma_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info2, qmi_response->lte_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info3, qmi_response->gsm_sys_info3 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info3, qmi_response->wcdma_sys_info3 );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_cell_status, qmi_response->lte_cell_status );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_support_on_lte, qmi_response->voice_support_on_lte );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_is_eb_supported, qmi_response->lte_is_eb_supported );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.emergency_access_barred, qmi_response->emergency_access_barred );

            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sim_rej_info, qmi_response->sim_rej_info );

            nas_cached_info.is_considered_registered_cached_result_valid = FALSE;
            nas_cached_info.is_in_service_of_technology_cache_result_valid = FALSE;

            NAS_CACHE_STORE_ENTRY(nas_cached_info.wcdma_csg_info, qmi_response->wcdma_csg_info );

            NAS_CACHE_STORE_ENTRY(nas_cached_info.lte_csg_info, qmi_response->lte_csg_info );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_ims_voice_avail, qmi_response->lte_ims_voice_avail );

            QCRIL_LOG_DEBUG("endc_available_valid: %d, endc_available: %d, restrict_dcnr_valid: %d,"
                    " restrict_dcnr: %d", qmi_response->endc_available_valid, qmi_response->endc_available,
                    qmi_response->restrict_dcnr_valid, qmi_response->restrict_dcnr);

            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.endc_available);
            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.endc_available, qmi_response->endc_available);

            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.restrict_dcnr);
            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.restrict_dcnr, qmi_response->restrict_dcnr);

            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available);
            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available, qmi_response->plmn_infolist_r15_available);

            qcril_qmi_nas_invalidate_data_snapshot_if_applicable();
            qcril_qmi_nas_update_voice_rte();
            qcril_qmi_nas_update_data_rte();
            qcril_qmi_nas_update_ims_rte();
            qcril_qmi_voice_technology_updated();
            qmi_ril_nwr_update_reg_rej_from_sys_info();

            qcril_qmi_nas_report_change_in_csg_id();
            // get the new info/status
            qmi_ril_nw_reg_snapshot_cur_rte(&new_rte_snapshot);

            new_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(new_mcc_str, new_mnc_str, TRUE, NULL);
            if( old_mcc_mnc_valid != new_mcc_mnc_valid || strcmp(old_mcc_str, new_mcc_str) || strcmp(old_mnc_str, new_mnc_str) )  //invalidiating operator name specifics as PLMN has changed
            {
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
                radio_tech_changed = TRUE;
            }

            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_voice_status,qmi_response->lte_voice_status);

            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sms_status,qmi_response->lte_sms_status);

            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.wcdma_rac,qmi_response->wcdma_rac);

            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.gsm_rac,qmi_response->gsm_rac);

            if(qcril_qmi_nas_is_considered_registered(NULL))
            {
                qcril_qmi_nas_report_change_in_rat_rac();
            }
            else
            {
                /* Device is OOS, so clear the cache */
                qcril_qmi_nas_clear_reported_rat_rac_cache();
            }

            NAS_CACHE_UNLOCK();

            NAS_EMBMS_CACHE_LOCK();
            prev_lte_embms_coverage_valid = nas_cached_info.lte_embms_coverage_valid;
            prev_lte_embms_coverage = nas_cached_info.lte_embms_coverage;
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_embms_coverage, qmi_response->lte_embms_coverage );

            prev_lte_embms_coverage_status_valid = nas_cached_info.embms_coverage_status_valid;
            prev_lte_embms_coverage_status = nas_cached_info.embms_coverage_status;
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.embms_coverage_status, qmi_response->embms_coverage_status );
            NAS_EMBMS_CACHE_UNLOCK();

            if ( radio_tech_changed == FALSE )
            {
                if (!qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ) ||
                    qcril_qmi_nas_lte_sms_status_compare( prev_lte_sms_status_valid, prev_lte_sms_status) ||
                    qcril_qmi_nas_lte_voice_status_compare( prev_lte_voice_status_valid, prev_lte_voice_status ))
                {
                    radio_tech_changed = TRUE;
                }
            }

            if ( radio_tech_changed == TRUE )
            {
#ifndef QMI_RIL_UTF
                qcril_qmi_nas_initiate_voice_rte_change_propagation();
#endif
            }

            qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(
                    prev_lte_embms_coverage_valid,
                    prev_lte_embms_coverage,
                    prev_lte_embms_coverage_status_valid,
                    prev_lte_embms_coverage_status);
            qcril_qmi_nas_embms_send_cell_info_changed_if_needed(prev_lte_sys_info_valid, &prev_lte_sys_info);
        }

        qcril_free( qmi_response );
    }
    else
    {
      QCRIL_LOG_ERROR("Memory allocation failed..");
      ril_req_res = RIL_E_NO_MEMORY;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_fetch_sys_info

void qcril_qmi_nas_dump_ril_cell_identity_v16
(
  RIL_CellIdentity_v16* cell
)
{
  if (!cell)
    return;

  QCRIL_LOG_INFO("RIL Cell Identity V16 dump:");
  switch (cell->cellInfoType) {
  case RIL_CELL_INFO_TYPE_NONE:
    QCRIL_LOG_INFO(" - No Cell Information");
    break;
  case RIL_CELL_INFO_TYPE_GSM:
    QCRIL_LOG_INFO(" - GSM Cell info");
    QCRIL_LOG_INFO(" mcc: %s, mnc: %s, lac: %d, cid: %d",
        cell->cellIdentityGsm.mcc, cell->cellIdentityGsm.mnc,
        cell->cellIdentityGsm.lac, cell->cellIdentityGsm.cid);
    break;
  case RIL_CELL_INFO_TYPE_CDMA:
    QCRIL_LOG_INFO(" - CDMA Cell info");
    QCRIL_LOG_INFO(" networkId: %d, systemId: %d, basestationId: %d, "
        "longitude: %d, latitude: %d", cell->cellIdentityCdma.networkId,
        cell->cellIdentityCdma.systemId, cell->cellIdentityCdma.basestationId,
        cell->cellIdentityCdma.longitude, cell->cellIdentityCdma.latitude);
    break;
  case RIL_CELL_INFO_TYPE_LTE:
    QCRIL_LOG_INFO(" - LTE Cell info");
    QCRIL_LOG_INFO(" mcc: %s, mnc: %s, ci: %d, pci: %d, tac: %d, earfcn: %d",
        cell->cellIdentityLte.mcc, cell->cellIdentityLte.mnc,
        cell->cellIdentityLte.ci, cell->cellIdentityLte.pci,
        cell->cellIdentityLte.tac, cell->cellIdentityLte.earfcn);
    break;
  case RIL_CELL_INFO_TYPE_WCDMA:
    QCRIL_LOG_INFO(" - WCDMA Cell info");
    QCRIL_LOG_INFO(" mcc: %s, mnc: %s, lac: %d, cid: %d, psc: %d, uarfcn: %d",
        cell->cellIdentityWcdma.mcc, cell->cellIdentityWcdma.mnc,
        cell->cellIdentityWcdma.lac, cell->cellIdentityWcdma.cid,
        cell->cellIdentityWcdma.psc, cell->cellIdentityWcdma.uarfcn);
    break;
  case RIL_CELL_INFO_TYPE_TD_SCDMA:
    QCRIL_LOG_INFO(" - TDSCDMA Cell info");
    QCRIL_LOG_INFO(" mcc: %s, mnc: %s, lac: %d, cid: %d, cpid: %d",
        cell->cellIdentityTdscdma.mcc, cell->cellIdentityTdscdma.mnc,
        cell->cellIdentityTdscdma.lac, cell->cellIdentityTdscdma.cid,
        cell->cellIdentityTdscdma.cpid);
    break;
  default:
    QCRIL_LOG_INFO(" - Invalid Cell Type");
  }
}

void qcril_qmi_nas_dump_voice_registration_state
(
  RIL_VoiceRegistrationStateResponse *voice_reg
)
{
  if (!voice_reg)
    return;

  QCRIL_LOG_INFO("RIL VOICE REGISTRATION: %s in %s",
                 qcril_qmi_util_retrieve_regstate_name(voice_reg->regState),
                 qcril_qmi_util_retrieve_technology_name(voice_reg->rat));
  QCRIL_LOG_INFO("CCS supported: %d", voice_reg->cssSupported);
  QCRIL_LOG_INFO("Roaming Indicator: %d", voice_reg->roamingIndicator);
  QCRIL_LOG_INFO("System is in PRL: %d", voice_reg->systemIsInPrl);
  QCRIL_LOG_INFO("default Roaming Indicator: %d", voice_reg->defaultRoamingIndicator);
  QCRIL_LOG_INFO("Denial reason: %d", voice_reg->reasonForDenial);
#ifndef QMI_RIL_UTF
  qcril_qmi_nas_dump_ril_cell_identity_v16(&voice_reg->cellIdentity);
#endif
}

void qcril_qmi_nas_dump_data_registration_state
(
  RIL_DataRegistrationStateResponse *data_reg
)
{
  if (!data_reg)
    return;

  QCRIL_LOG_INFO("RIL DATA REGISTRATION: %s in %s",
                qcril_qmi_util_retrieve_regstate_name(data_reg->regState),
                qcril_qmi_util_retrieve_technology_name(data_reg->rat));
  QCRIL_LOG_INFO("Data Denied reason: %d", data_reg->reasonDataDenied);
  QCRIL_LOG_INFO("Max data calls: %d", data_reg->maxDataCalls);
#ifndef QMI_RIL_UTF
  qcril_qmi_nas_dump_ril_cell_identity_v16(&data_reg->cellIdentity);
#endif
}

void qcril_qmi_nas_fill_3gpp2_cell_identity
(
  qmi_ril_nw_reg_rte_type           rte,
  RIL_CellIdentity_v16              *cell,
  nas_cdma_only_sys_info_type_v01   *cdma_only_sys_info
)
{
  QCRIL_NOTUSED(rte);

  if (!cell)
    return;

  // initialize the value
  int32_t *array = (int32_t*)cell;
  size_t idx;
  for (idx = 0; idx < sizeof(RIL_CellIdentity_v16)/sizeof(int32_t); idx++)
    array[idx] = -1;
  memset(&cell->cellIdentityCdma.operatorNames, 0, sizeof(cell->cellIdentityCdma.operatorNames));

  if (!cdma_only_sys_info)
  {
    cell->cellInfoType = RIL_CELL_INFO_TYPE_NONE; /* indicates no cell information */
    return;
  }

  cell->cellInfoType = RIL_CELL_INFO_TYPE_CDMA;
  if (cdma_only_sys_info->bs_info_valid)
  {
    cell->cellIdentityCdma.basestationId = cdma_only_sys_info->bs_info.base_id;
    cell->cellIdentityCdma.longitude = cdma_only_sys_info->bs_info.base_long;
    cell->cellIdentityCdma.latitude = cdma_only_sys_info->bs_info.base_lat;
  }

  if (cdma_only_sys_info->cdma_sys_id_valid)
  {
    cell->cellIdentityCdma.networkId = cdma_only_sys_info->cdma_sys_id.nid;
    cell->cellIdentityCdma.systemId = cdma_only_sys_info->cdma_sys_id.sid;
  }
}

void qcril_qmi_nas_fill_3gpp_cell_identity
(
  qmi_ril_nw_reg_rte_type                    rte,
  RIL_CellIdentity_v16                       *cell,
  nas_sys_info_helper_type                   *sys_info_helper,
  qmi_ril_nw_reg_data_reg_snapshot_info_type *snapshot
)
{
  QCRIL_LOG_FUNC_ENTRY();
  if (!cell)
    return;

  // initialize the value
  int32_t *array = (int32_t*)cell;
  nas_radio_if_enum_v01 if_rat = NAS_RADIO_IF_NO_SVC_V01;
  RIL_CellIdentityOperatorNames *operatorNames = nullptr;
  size_t idx;
  for (idx = 0; idx < sizeof(RIL_CellIdentity_v16)/sizeof(int32_t); idx++)
    array[idx] = -1;

  /* Initialize the MCC, MNC, oprts with 0s as they are strings */
  memset(cell->cellIdentityGsm.mcc, 0, sizeof(cell->cellIdentityGsm.mcc));
  memset(cell->cellIdentityGsm.mnc, 0, sizeof(cell->cellIdentityGsm.mnc));

  if (!sys_info_helper)
  {
    cell->cellInfoType = RIL_CELL_INFO_TYPE_NONE;  /* indicates no cell information */
    return;
  }
  // fill cell info type
  switch (rte) {
  case QMI_RIL_RTE_GSM:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_GSM;
    operatorNames = &cell->cellIdentityGsm.operatorNames;
    if_rat = NAS_RADIO_IF_GSM_V01;
    break;
  case QMI_RIL_RTE_WCDMA:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
    operatorNames = &cell->cellIdentityWcdma.operatorNames;
    if_rat = NAS_RADIO_IF_UMTS_V01;
    break;
  case QMI_RIL_RTE_TDSCDMA:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_TD_SCDMA;
    operatorNames = &cell->cellIdentityTdscdma.operatorNames;
    if_rat = NAS_RADIO_IF_TDSCDMA_V01;
    break;
  case QMI_RIL_RTE_SUB_LTE:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_LTE;
    operatorNames = &cell->cellIdentityLte.operatorNames;
    if_rat = NAS_RADIO_IF_LTE_V01;
    break;
  default:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_NONE;
    return;
  }

  /* Memset Operator Names structure */
  if (operatorNames)
  {
    memset(operatorNames, 0, sizeof(RIL_CellIdentityOperatorNames));
  }

  // fill the MCC/MNC. Since MCC/MNC is always present in the first two ints
  // for different RIL_CellIdentityXXX), just fill for Gsm in union.
  if (sys_info_helper->threegpp_only_sys_info &&
        sys_info_helper->threegpp_only_sys_info->network_id_valid)
  {
    // format: 0x35 0x31 0xFF (Unused byte is set to 0xFF) -> 51
    qcril_qmi_nas_fillup_mcc_mnc_helper(sys_info_helper->threegpp_only_sys_info->network_id.mcc, cell->cellIdentityGsm.mcc);
    qcril_qmi_nas_fillup_mcc_mnc_helper(sys_info_helper->threegpp_only_sys_info->network_id.mnc, cell->cellIdentityGsm.mnc);
#ifndef QMI_RIL_UTF
    if (operatorNames) {
        qcril_qmi_util_handle_centralized_short_long_eons(
                cell->cellIdentityGsm.mcc,
                cell->cellIdentityGsm.mnc,
                operatorNames->alphaShort,
                sizeof(operatorNames->alphaShort),
                operatorNames->alphaLong,
                sizeof(operatorNames->alphaLong),
                FALSE,
                if_rat,
                FALSE,
                0);
    }
#endif
  }

  // fill PSC specific for WCDMA:
  if (rte == QMI_RIL_RTE_WCDMA &&
      sys_info_helper->wcdma_only_sys_info &&
        sys_info_helper->wcdma_only_sys_info->psc_valid)
  {
    // convert uint16_t to int
    cell->cellIdentityWcdma.psc = (int)sys_info_helper->wcdma_only_sys_info->psc;
  }

  // fill TAC specific for LTE
  if (rte == QMI_RIL_RTE_SUB_LTE &&
        sys_info_helper->lte_only_sys_info &&
        sys_info_helper->lte_only_sys_info->tac_valid) {
    // convert uint16_t to int
    cell->cellIdentityLte.tac = (int)sys_info_helper->lte_only_sys_info->tac;
    cell->cellIdentityLte.bandwidth = getNasModule().getLteBw();
    QCRIL_LOG_DEBUG("Set bandwidth to %d", cell->cellIdentityLte.bandwidth);
    if (snapshot)
    {
      snapshot->tac_valid = TRUE;
      snapshot->tac = (int)sys_info_helper->lte_only_sys_info->tac;
      // XXX: do we need to overwrite the lac using tac if it is not the case for
      // QMI_RIL_FEATURE_PLAIN_ANDROID (legacy behavior)
    }
  }

  // get LAC and CID for (WCDMA, GSM and TDSCDMA Cell Identity)
  if (rte == QMI_RIL_RTE_WCDMA || rte == QMI_RIL_RTE_GSM ||
            rte == QMI_RIL_RTE_TDSCDMA)
  {
    int lac = INT_MAX;
    int cid = INT_MAX;
    if (sys_info_helper->threegpp_only_sys_info)
    {
      if (sys_info_helper->threegpp_only_sys_info->cell_id_valid)
      {
        cid = (sys_info_helper->threegpp_only_sys_info->cell_id > (uint32_t)0x7FFFFFFF) ?
          (uint32_t) 0x7FFFFFFF : sys_info_helper->threegpp_only_sys_info->cell_id;
        if (snapshot)
        {
          snapshot->cid_valid = TRUE;
          snapshot->cid = cid;
        }
      }

      if (sys_info_helper->threegpp_only_sys_info->lac_valid)
      {
        lac = sys_info_helper->threegpp_only_sys_info->lac;
        if (snapshot)
        {
          snapshot->lac_valid = TRUE;
          snapshot->lac = lac;
        }
      }
    }
    cell->cellIdentityGsm.lac = lac;
    cell->cellIdentityGsm.cid = cid;
  }

  // *LAST step*: fill the item that could not be fetched by sys_info
  // - GSM: arfcn, bsic
  // - WCDMA: uarfcn
  // - LTE: ci, pci, earfcn
  // - TDSCDMA: cpid
  // for now, DO NOT snapshot it
  nas_get_cell_location_info_resp_msg_v01 get_cell_location_info_resp;
  if (RIL_E_SUCCESS == qcril_qmi_nas_get_cell_location_data_sync(
        &get_cell_location_info_resp, NULL, QCRIL_QMI_ERR_CTX_NONE))
  {
    if (rte == QMI_RIL_RTE_GSM)
    {
      if (get_cell_location_info_resp.geran_info_valid)
      {
        // Absolute RF channel number
        cell->cellIdentityGsm.arfcn = get_cell_location_info_resp.geran_info.arfcn;
        // Base station identity code
        cell->cellIdentityGsm.bsic = get_cell_location_info_resp.geran_info.bsic;
      }
    }

    if (rte == QMI_RIL_RTE_WCDMA)
    {
      if (get_cell_location_info_resp.umts_info_valid)
      {
        // UTRA absolute RF channel number
        cell->cellIdentityWcdma.uarfcn = get_cell_location_info_resp.umts_info.uarfcn;
      }
    }

    if (rte == QMI_RIL_RTE_SUB_LTE)
    {
      if (get_cell_location_info_resp.lte_intra_valid )
      {
        // Global Cell ID
        cell->cellIdentityLte.ci = get_cell_location_info_resp.lte_intra.global_cell_id;
        // Physical Cell ID
        cell->cellIdentityLte.pci = get_cell_location_info_resp.lte_intra.serving_cell_id;
        // LTE Absolute RC Channel Number
        if(get_cell_location_info_resp.lte_intra_earfcn_valid)
        {
            cell->cellIdentityLte.earfcn = get_cell_location_info_resp.lte_intra_earfcn;
        }
        else
        {
            cell->cellIdentityLte.earfcn = get_cell_location_info_resp.lte_intra.earfcn;
        }

        if (snapshot)
        {
          snapshot->cid_valid = TRUE;
          snapshot->cid = get_cell_location_info_resp.lte_intra.global_cell_id;
        }
      }
    }

    if (rte == QMI_RIL_RTE_TDSCDMA)
    {
      // TODO: how to get cpid
    }
  }
}

void qcril_qmi_nas_restore_cell_indentity_from_snapshot
(
  qmi_ril_nw_reg_rte_type                    rte,
  RIL_CellIdentity_v16                       *cell,
  qmi_ril_nw_reg_data_reg_snapshot_info_type *snapshot
)
{
  QCRIL_LOG_FUNC_ENTRY();
  if (!cell)
    return;

  if (!snapshot) {
    cell->cellInfoType = RIL_CELL_INFO_TYPE_NONE;  /* indicates no cell information */
    return;
  }

  // fill cell info type
  switch (rte) {
  case QMI_RIL_RTE_GSM:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_GSM;
    break;
  case QMI_RIL_RTE_WCDMA:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
    break;
  case QMI_RIL_RTE_TDSCDMA:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_TD_SCDMA;
    break;
  case QMI_RIL_RTE_SUB_LTE:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_LTE;
    break;
  case QMI_RIL_RTE_1x: // fall through
  case QMI_RIL_RTE_SUB_DO:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_CDMA;
    break;
  default:
    cell->cellInfoType = RIL_CELL_INFO_TYPE_NONE;
    return;
  }

  if (rte == QMI_RIL_RTE_WCDMA || rte == QMI_RIL_RTE_GSM ||
        rte == QMI_RIL_RTE_TDSCDMA)
  {
    if (snapshot->cid_valid)
      cell->cellIdentityGsm.cid = snapshot->cid;
    if (snapshot->lac_valid)
      cell->cellIdentityGsm.lac = snapshot->lac;
  }

  if (rte == QMI_RIL_RTE_SUB_LTE)
  {
    if (snapshot->cid_valid)
      cell->cellIdentityLte.ci = snapshot->cid;
    if (snapshot->tac_valid)
      cell->cellIdentityLte.tac = snapshot->tac;
  }

}

//===========================================================================
// RIL_REQUEST_VOICE_REGISTRATION_STATE
//===========================================================================
void qcril_qmi_nas_request_registration_state
(
  std::shared_ptr<RilRequestGetVoiceRegistrationMessage> msg
)
{
  int           qmi_request_need1;

  qmi_ril_nw_reg_rte_type           vrte;
  qmi_ril_nw_reg_rte_type           irte;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  int   val_int;

  int in_service;

  boolean hdr_in_service = FALSE;

  int reg_state = 0;

  nas_service_status_enum_type_v01  sys_info_common_service_status;
  RIL_RadioTechnology               voice_rte;
  int                               is_rte_3gpp;
  int                               is_rte_lte;
  nas_sys_info_helper_type sys_info_helper;

  int                                must_rerender_reg_report;
  int                                in_transfer_cs_reg_reject;

  int                                post_adjustment_val;

  int                                ccs_is_present;

  int                                cdma_ccs_supported;

  uint8_t is_ims_registered = FALSE;
  int current_data_tech = RADIO_TECH_UNKNOWN;

  QCRIL_LOG_FUNC_ENTRY();

  // allocate the internal response data
  auto respPayload = new qcril::interfaces::RilGetVoiceRegResult_t();
  if (!respPayload) {
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_NO_MEMORY, nullptr));
    return;
  }

  is_rte_lte = FALSE;
  cdma_ccs_supported = FALSE;
  must_rerender_reg_report  = FALSE;
  in_transfer_cs_reg_reject = FALSE;
  is_ims_registered = qcril_qmi_nas_ims_is_ims_registered_for_voip_vt_service();

  // ** response holder init
  auto& ril_resp_helper = respPayload->respData;
  memset( &ril_resp_helper, 0, sizeof( ril_resp_helper ) );
  ril_resp_helper.roamingIndicator = -1;
  ril_resp_helper.systemIsInPrl = -1;
  ril_resp_helper.defaultRoamingIndicator = -1;

  qcril_suppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_suppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());

  NAS_CACHE_LOCK();

  NAS_CACHE_LOCK();

  vrte = nas_cached_info.voice_rte;
  irte = nas_cached_info.ims_rte;

  if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
  {
      qmi_request_need1 = FALSE; // response for IMS is entirely simulated
  }
  else
  {
      switch ( nas_cached_info.voice_rte )
      {
          case QMI_RIL_RTE_1x:
              qmi_request_need1 =
                  (
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info )
                  ) ? FALSE : TRUE;
              break;

          case QMI_RIL_RTE_GSM:
              qmi_request_need1 =
                  (
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 )
                  ) ? FALSE : TRUE;
              break;

          case QMI_RIL_RTE_WCDMA:
              qmi_request_need1 =
                  (
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 )
                  ) ? FALSE : TRUE;
              break;

          case QMI_RIL_RTE_TDSCDMA:
              qmi_request_need1 =
                  (
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info )
                  ) ? FALSE : TRUE;
              break;

          case QMI_RIL_RTE_SUB_LTE:
              qmi_request_need1 =
                  (
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_is_eb_supported ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_access_barred )
                  ) ? FALSE : TRUE;
              break;

        case QMI_RIL_RTE_SUB_NR5G:
              qmi_request_need1 =
                  (
                  NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info) &&
                  NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info)
                  ) ? FALSE : TRUE;
              break;

          case QMI_RIL_RTE_SUB_DO:
              qmi_request_need1 =
                  (
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) &&
                  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info )
                  ) ? FALSE : TRUE;
              break;

          default:
              qmi_request_need1 = TRUE; // if vrte unknown, refresh
              break;
      }
  }
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO(".. request need %d, vrte %d, irte %d", (int) qmi_request_need1, (int) vrte, (int) irte );
  if ( qmi_request_need1 )
  {
      ril_req_res = qcril_qmi_nas_fetch_sys_info();
  }
  else
  {
      ril_req_res = RIL_E_SUCCESS;
  }

  if ( RIL_E_SUCCESS == ril_req_res )
  {
      NAS_CACHE_LOCK();

      QCRIL_LOG_INFO(" ... cdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) );
      QCRIL_LOG_INFO(" ... hdr_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) );
      QCRIL_LOG_INFO(" ... gsm_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) );
      QCRIL_LOG_INFO(" ... wcdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) );
      QCRIL_LOG_INFO(" ... tdscdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) );
      QCRIL_LOG_INFO(" ... lte_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) );
      QCRIL_LOG_INFO(" ... nr5g_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_srv_status_info ) );
      QCRIL_LOG_INFO(" ... cdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) );
      QCRIL_LOG_INFO(" ... hdr_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) );
      QCRIL_LOG_INFO(" ... gsm_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) );
      QCRIL_LOG_INFO(" ... wcdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) );
      QCRIL_LOG_INFO(" ... tdscdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) );
      QCRIL_LOG_INFO(" ... lte_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) );
      QCRIL_LOG_INFO(" ... voice_support_on_lte val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) );
      QCRIL_LOG_INFO(" ... lte_is_eb_supported val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_is_eb_supported ) );
      QCRIL_LOG_INFO(" ... emergency_access_barred val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_access_barred ) );

      // first run - full service check
      QCRIL_LOG_INFO(" ... nas_cached_info.voice_rte %d", (int) nas_cached_info.voice_rte );
      sys_info_common_service_status= NAS_SYS_SRV_STATUS_NO_SRV_V01;
      memset(&sys_info_helper,0,sizeof(sys_info_helper));


      QCRIL_LOG_INFO(" ... nas_cached_info.ims_rte %d", (int) nas_cached_info.ims_rte );
      if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
      {
          voice_rte   = RADIO_TECH_UMTS;
          is_rte_3gpp = FALSE;
      }
      else
      {
          switch ( nas_cached_info.voice_rte )
          {
              case QMI_RIL_RTE_1x:
                  QCRIL_LOG_INFO( " .. prep CDMA" );
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
                  {
                      sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
                      sys_info_common_service_status = nas_cached_info.cdma_srv_status_info->srv_status;
                  }
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
                  {
                      sys_info_helper.common_sys_info = &nas_cached_info.cdma_sys_info->common_sys_info;
                      sys_info_helper.cdma_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_specific_sys_info;
                      sys_info_helper.cdma_hdr_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_hdr_only_sys_info;
                  }
                  voice_rte                      = (RIL_RadioTechnology) qcril_qmi_nas_util_determine_cdma_rev( sys_info_helper.cdma_only_sys_info );
                  is_rte_3gpp                    = FALSE;
                  val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_EMPTY,
                                                                                        &sys_info_helper);

                  break;

              case QMI_RIL_RTE_GSM:
                  QCRIL_LOG_INFO( " .. prep GSM" );
                  if ( NAS_CACHE_IS_ENTRY_VALID ( nas_cached_info.gsm_srv_status_info ) )
                  {
                      sys_info_helper.threegpp_srv_status  = nas_cached_info.gsm_srv_status_info;
                      sys_info_common_service_status = nas_cached_info.gsm_srv_status_info->srv_status;
                  }
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                  {
                      sys_info_helper.common_sys_info = &nas_cached_info.gsm_sys_info->common_sys_info;
                      sys_info_helper.threegpp_only_sys_info = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                  }

                  voice_rte = RADIO_TECH_GSM;

                  is_rte_3gpp                    = TRUE;
                  val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                        &sys_info_helper);
                  break;

              case QMI_RIL_RTE_WCDMA:
                  QCRIL_LOG_INFO( " .. prep WCDMA" );
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
                  {
                      sys_info_helper.threegpp_srv_status  = nas_cached_info.wcdma_srv_status_info;
                      sys_info_common_service_status = nas_cached_info.wcdma_srv_status_info->srv_status;
                  }
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                  {
                      sys_info_helper.common_sys_info = &nas_cached_info.wcdma_sys_info->common_sys_info;
                      sys_info_helper.threegpp_only_sys_info = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                      sys_info_helper.wcdma_only_sys_info = &nas_cached_info.wcdma_sys_info->wcdma_specific_sys_info;
                  }
                  voice_rte                      = RADIO_TECH_UMTS;
                  is_rte_3gpp                    = TRUE;
                  val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                        &sys_info_helper);
                  break;

              case QMI_RIL_RTE_TDSCDMA:
                  QCRIL_LOG_INFO( " .. prep TDSCDMA" );
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
                  {
                      sys_info_helper.threegpp_srv_status  = nas_cached_info.tdscdma_srv_status_info;
                      sys_info_common_service_status = nas_cached_info.tdscdma_srv_status_info->srv_status;
                  }
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                  {
                      sys_info_helper.common_sys_info = &nas_cached_info.tdscdma_sys_info->common_sys_info;
                      sys_info_helper.threegpp_only_sys_info = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                      sys_info_helper.tdscdma_only_sys_info = &nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info;
                  }
                  voice_rte                      = RADIO_TECH_TD_SCDMA;
                  is_rte_3gpp                    = TRUE;
                  val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                        &sys_info_helper);
                  break;


              case QMI_RIL_RTE_SUB_LTE:
                  QCRIL_LOG_INFO( " .. prep LTE" );
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
                  {
                      sys_info_helper.threegpp_srv_status  = nas_cached_info.lte_srv_status_info;
                      sys_info_common_service_status = nas_cached_info.lte_srv_status_info->srv_status;
                  }
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                  {
                      sys_info_helper.common_sys_info  = &nas_cached_info.lte_sys_info->common_sys_info;
                      sys_info_helper.threegpp_only_sys_info = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                      sys_info_helper.lte_only_sys_info = &nas_cached_info.lte_sys_info->lte_specific_sys_info;
                  }
                  voice_rte                      = RADIO_TECH_LTE;
                  is_rte_3gpp                    = TRUE;
                  is_rte_lte                     = TRUE;
                  if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.voice_support_on_lte) )
                  {
                      sys_info_helper.voice_support_on_lte = &nas_cached_info.voice_support_on_lte;
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_is_eb_supported) )
                  {
                      sys_info_helper.lte_is_eb_supported = &nas_cached_info.lte_is_eb_supported;
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.emergency_access_barred) )
                  {
                      sys_info_helper.emergency_access_barred = &nas_cached_info.emergency_access_barred;
                  }
                  val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                                        &sys_info_helper);
                  break;

              case QMI_RIL_RTE_SUB_NR5G:
                  QCRIL_LOG_INFO( " .. prep 5G" );
                  if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info))
                  {
                      sys_info_helper.threegpp_srv_status  = nas_cached_info.nr5g_srv_status_info;
                      sys_info_common_service_status = nas_cached_info.nr5g_srv_status_info->srv_status;
                  }

                  if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info))
                  {
                      sys_info_helper.common_sys_info  = &nas_cached_info.nr5g_sys_info->common_sys_info;
                      sys_info_helper.threegpp_only_sys_info = &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info;
                      sys_info_helper.nr5g_only_sys_info = &nas_cached_info.nr5g_sys_info->nr5g_specific_sys_info;
                  }

                  voice_rte = RADIO_TECH_5G;
                  is_rte_3gpp = TRUE;
                  val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_5G, &sys_info_helper);
                  break;

              case QMI_RIL_RTE_SUB_DO:
              {
                  int hdr_srv_status = RIL_VAL_REG_UNKNOWN;
                  QCRIL_LOG_INFO( " .. prep EVDO" );
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
                  {
                      sys_info_helper.threegpp2_srv_status  = nas_cached_info.hdr_srv_status_info;
                      sys_info_common_service_status = nas_cached_info.hdr_srv_status_info->srv_status;
                  }
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                  {
                      sys_info_helper.common_sys_info = &nas_cached_info.hdr_sys_info->common_sys_info;
                      sys_info_helper.cdma_hdr_only_sys_info = &nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info;
                      sys_info_helper.hdr_only_sys_info = &nas_cached_info.hdr_sys_info->hdr_specific_sys_info;
                  }
                  voice_rte                      = RADIO_TECH_UNKNOWN;
                  is_rte_3gpp                    = FALSE;
                  val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_HDR,
                                                                                        &sys_info_helper);
                      if ( sys_info_helper.common_sys_info && sys_info_helper.threegpp2_srv_status )
                      {
                          hdr_srv_status =
                              qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status_direct(
                                      sys_info_helper.threegpp2_srv_status->srv_status,
                                      sys_info_helper.common_sys_info, FALSE);
                      }
                      if (hdr_srv_status == RIL_VAL_REG_REGISTERED_HOME_NET ||
                              hdr_srv_status == RIL_VAL_REG_REGISTERED_ROAMING)
                      {
                          hdr_in_service = TRUE;
                      }
                      QCRIL_LOG_INFO( " .. hdr_in_service: %s", hdr_in_service ? "true": "false" );
                  break;
              }

              default:
                  val_int                        = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
                  voice_rte                      = RADIO_TECH_UNKNOWN;
                  is_rte_3gpp                    = TRUE;
                  break;
          }
      }
      QCRIL_LOG_INFO(" ... so far ss, vrte %d, %d", (int) nas_cached_info.voice_rte, (int) voice_rte );

      // * registartion state
      if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
      {
          val_int = RIL_VAL_REG_REGISTERED_HOME_NET;
      }
      else
      {
          // reg reject adjust
          switch ( val_int )
          {
              case RIL_VAL_REG_REGISTERED_HOME_NET:
              case RIL_VAL_REG_REGISTERED_ROAMING:
                if ( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected &&
                     !nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause_relayed )
                {
                    val_int                   = RIL_VAL_REG_REGISTRATION_DENIED;
                    must_rerender_reg_report  = TRUE;
                    in_transfer_cs_reg_reject = TRUE;
                }
                break;

              case RIL_VAL_REG_UNKNOWN:                         // fallthough
              case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:        // fallthough
              case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:    // fallthough
              case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                  if ( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected )
                  {
                    switch ( val_int )
                    {
                      case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                        if ( ( QMI_NAS_REJ_CAUSE_PLMN_NOT_ALLOWED    == nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause ||
                             QMI_NAS_REJ_CAUSE_NO_SUITABLE_CELL_LA == nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause
                             ) && ( TRUE == nas_common_info.is_reg_denied_on_rej_cause ) ) //Has to set the property for QMI RIL to report RIL_VAL_REG_REGISTRATION_DENIED when reject cause is QMI_NAS_REJ_CAUSE_PLMN_NOT_ALLOWED or QMI_NAS_REJ_CAUSE_NO_SUITABLE_CELL_LA
                        {
                          post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED;
                        }
                        else
                        {
                          post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV;
                        }
                        break;

                      default:
                        post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED;
                        break;
                    }
                    val_int = post_adjustment_val;
                  }
                  QCRIL_LOG_INFO(".. adjusting for reg reject %d, status %d", (int) nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected, val_int );
                  break;

              default:
                  break;
          }
      }

      // RIL resp filling: registration state
      ril_resp_helper.regState = (RIL_RegState)val_int;
      reg_state = val_int;
      QCRIL_LOG_INFO("cur reg state %d", val_int);

      // is in service
      if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
      {
          in_service = TRUE;
      }
      else
      {
          if ( (NAS_SYS_SRV_STATUS_SRV_V01 == sys_info_common_service_status && !in_transfer_cs_reg_reject) ||
               RIL_VAL_REG_REGISTERED_HOME_NET == val_int ||
               RIL_VAL_REG_REGISTERED_ROAMING == val_int ||
               RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == val_int ||
               RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == val_int )
          {
              in_service = TRUE;
          }
          else
          {
              in_service = FALSE;
          }
      }
      QCRIL_LOG_INFO(" ... so far in_service %d", (int) in_service );

      if ( in_service || hdr_in_service)
      {
          // RIL resp filling: radio tech
          ril_resp_helper.rat = voice_rte;

          if ( QMI_RIL_RTE_NONE == nas_cached_info.ims_rte )
          {
              // *lac
              if ( is_rte_3gpp )
              {
                  // RIL resp filling: cell identity structure
                  qcril_qmi_nas_fill_3gpp_cell_identity(nas_cached_info.voice_rte,
                        &ril_resp_helper.cellIdentity, &sys_info_helper, NULL);
              }

              // *base_id, base_latitude, base_longitude, sid, nid, roaming status, def roam indicator
              if ( !is_rte_3gpp  )
              {
                  // RIL resp filling: cell identity structure
                  qcril_qmi_nas_fill_3gpp2_cell_identity(nas_cached_info.voice_rte,
                        &ril_resp_helper.cellIdentity, sys_info_helper.cdma_only_sys_info);

                  if ( NULL != sys_info_helper.cdma_only_sys_info && sys_info_helper.cdma_only_sys_info->ccs_supported_valid )
                  {
                      cdma_ccs_supported = sys_info_helper.cdma_only_sys_info->ccs_supported;
                  }

                  if ( NULL != sys_info_helper.cdma_only_sys_info && sys_info_helper.cdma_only_sys_info->cdma_sys_id_valid  )
                  {
                      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cdma_sys_id, sys_info_helper.cdma_only_sys_info->cdma_sys_id );
                  }
                  else
                  {
                      NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
                  }

                  if ( NULL != sys_info_helper.common_sys_info && sys_info_helper.common_sys_info->roam_status_valid )
                  {
                      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_status, sys_info_helper.common_sys_info->roam_status );
                      nas_cached_info.voice_roam_status_reported = TRUE;
                  }
                  else
                  {
                      NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
                  }

                  if ( NULL != sys_info_helper.cdma_hdr_only_sys_info && sys_info_helper.cdma_hdr_only_sys_info->is_sys_prl_match_valid )
                  {
                      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.is_sys_prl_match, sys_info_helper.cdma_hdr_only_sys_info->is_sys_prl_match );
                  }
                  else
                  {
                      NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
                  }

              }
          }

      }
      else
      {   // RIL resp filling: radio tech
          ril_resp_helper.rat = RADIO_TECH_UNKNOWN;
      }

      // CCS
      QCRIL_LOG_INFO("ccs_supported %d", cdma_ccs_supported);
      QCRIL_LOG_DEBUG("simul_voice_and_data_capability valid %d, value %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ), nas_cached_info.simul_voice_and_data_capability);
      QCRIL_LOG_DEBUG("reported data technology %d", nas_cached_info.reported_data_technology);

      current_data_tech = qcril_qmi_nas_evaluate_data_rat_to_decide_ccs();
      QCRIL_LOG_DEBUG("current data technology %d", current_data_tech);

      ccs_is_present = FALSE;
      nas_cached_info.ccs_status = FALSE;
      switch( current_data_tech )
      {
          case RADIO_TECH_LTE:
#ifndef NOT_SUPPORTED_LTE_CA
          case RADIO_TECH_LTE_CA:
#endif
              // TODO: Evaluate if CCS is needed for 5G
              if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ) &&
                  (QMI_DMS_MASK_SVLTE_CAPABLE_V01 & nas_cached_info.simul_voice_and_data_capability) )    //checking svlte
              {
                  ccs_is_present = TRUE;
              }
              else if(is_ims_registered) //If IMS regitered for VOIP or VT service, set CCS=TRUE
              {
                  ccs_is_present = TRUE;
              }
              break;

          case RADIO_TECH_EVDO_0:
          case RADIO_TECH_EVDO_A:
          case RADIO_TECH_EVDO_B:
          case RADIO_TECH_EHRPD:
              if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ) &&
                  (QMI_DMS_MASK_SVDO_CAPABLE_V01 & nas_cached_info.simul_voice_and_data_capability) )    //checking svdo
              {
                  ccs_is_present = TRUE;
                  nas_cached_info.ccs_status = TRUE;
              }
              break;

          case RADIO_TECH_IS95A:
          case RADIO_TECH_IS95B:
          case RADIO_TECH_1xRTT:
              if( TRUE == cdma_ccs_supported )
              {
                  ccs_is_present = TRUE;
                  nas_cached_info.ccs_status = TRUE;
              }
              break;

          case RADIO_TECH_GPRS:
          case RADIO_TECH_EDGE:
          case RADIO_TECH_GSM:
              if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
              {
                  QCRIL_LOG_INFO("dtm_supp_valid, dtm_supp %d, %d",
                                 (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp_valid,
                                 (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp );
                  if ( nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp_valid &&
                       NAS_SYS_DTM_SUPPORT_AVAIL == nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp )
                  {
                      ccs_is_present = TRUE;
                      nas_cached_info.ccs_status = TRUE;
                  }
              }
              break;

          case RADIO_TECH_IWLAN:
              ccs_is_present = TRUE;
              nas_cached_info.ccs_status = TRUE;
              break;

          default:  //SV is Not Applicable to other technologies
              break;
      }
      nas_cached_info.considered_data_technology_valid = TRUE;
      nas_cached_info.considered_data_technology = nas_cached_info.reported_data_technology;

      // RIL resp filling: css, roaming indicator, PRL, default roaming indicator
      ril_resp_helper.cssSupported = ccs_is_present;
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roam_status ) )
      {
          ril_resp_helper.roamingIndicator = qmi_ril_nwr_map_roam_status_from_qmi_to_android ( nas_cached_info.roam_status );
      }

      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.is_sys_prl_match ) )
      {
          ril_resp_helper.systemIsInPrl = (int32_t)nas_cached_info.is_sys_prl_match;
          if( FALSE == nas_cached_info.is_sys_prl_match && TRUE == NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roam_status ) )
          {
            ril_resp_helper.defaultRoamingIndicator = qmi_ril_nwr_map_roam_status_from_qmi_to_android ( nas_cached_info.roam_status );
          }
      }


      // * registration reject reason
      switch ( reg_state )
      {
          case RIL_VAL_REG_REGISTRATION_DENIED:
          case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
              if (! nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected )
              {
                  val_int = NAS_NIL;
                  break;
              }
              if ((nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected_managed_roaming)
               && (nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause_relayed == TRUE ))
              {
                  val_int = NAS_NIL;
                  break;
              }
              val_int = qmi_ril_nwr_conv_reg_reject_cause_voice( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause,
                                          nas_cached_info.voice_rte );
              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, nas_cached_info.voice_rte, QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED );
              break;

          default:
              val_int = NAS_NIL;
              break;
      }
      // RIL resp filling: reason for denial
      ril_resp_helper.reasonForDenial = val_int;

      // reset display for managed roaming
      if ( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected &&
           nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected_managed_roaming &&
           nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause_relayed
         )
      {
          qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, nas_cached_info.voice_rte, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED );
      }

      // follow up transfer reg reject while in service
      QCRIL_LOG_INFO(".. in transfer reg reject %d", (int) in_transfer_cs_reg_reject );
      if ( in_transfer_cs_reg_reject )
      {
        qmi_ril_nwr_update_reg_rej_from_sys_info();
      }

      // done with reg reporting
      NAS_CACHE_UNLOCK();
  }

  NAS_CACHE_UNLOCK();
  // ** respond
  if (RIL_E_SUCCESS == ril_req_res) {
      qcril_qmi_nas_dump_voice_registration_state(&ril_resp_helper);
      std::shared_ptr<qcril::interfaces::RilGetVoiceRegResult_t> shared_resp(respPayload);
      auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, shared_resp);
      msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  } else {
      delete respPayload;
      msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
            std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
  }

  // NOTE: current implementation ensures that all responses are sent back in ONE thread
  // after calling qcril_send_request_response()
  qcril_unsuppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_unsuppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());

  NAS_CACHE_LOCK();
  qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_REPOST );
  NAS_CACHE_UNLOCK();

  // check need for rerendering report
  if ( must_rerender_reg_report )
  {
    QCRIL_LOG_INFO(".. will rerender voice reg report");

    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                            QCRIL_DEFAULT_MODEM_ID,
                            qmi_ril_nw_reg_redo_reg_report,
                            NULL,  // immediate
                            NULL );
  }

  // done
  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

} // qcril_qmi_nas_request_registration_state

//===========================================================================
// qcril_qmi_nas_retranslate_cs_ps_bar_info_handler
//===========================================================================
void qcril_qmi_nas_retranslate_cs_ps_bar_info_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(param);

    NAS_CACHE_LOCK();
    qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHANGE_REPOST );
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_retranslate_cs_ps_bar_info_handler


//===========================================================================
// qmi_ril_nw_reg_redo_reg_report
//===========================================================================
void qmi_ril_nw_reg_redo_reg_report(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    qcril_qmi_nas_wave_voice_data_status();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_redo_reg_report

//===========================================================================
// qmi_ril_nwr_map_roam_status_from_qmi_to_android
//===========================================================================
int qmi_ril_nwr_map_roam_status_from_qmi_to_android( nas_roam_status_enum_type_v01 qmi_roam_status )
{
    int res;

    switch ( qmi_roam_status ) // ref: 3GPP2 C.R1001-G, Table 8.1-1. Enhanced Roaming Indicator Number Assignments
    {
        case NAS_SYS_ROAM_STATUS_OFF_V01:
            res = 1; // Roaming Indicator Off
            break;

        case NAS_SYS_ROAM_STATUS_ON_V01:
            res = 0; // Roaming Indicator On
            break;

        case NAS_SYS_ROAM_STATUS_BLINK_V01:
            res = 2; // Roaming Indicator Flashing
            break;

        case NAS_SYS_ROAM_STATUS_OUT_OF_NEIGHBORHOOD_V01:
            res = 3; // Out of Neighborhood
            break;

        case NAS_SYS_ROAM_STATUS_OUT_OF_BLDG_V01:
            res = 4; // Out of Building
            break;

        case NAS_SYS_ROAM_STATUS_PREF_SYS_V01:
            res = 5; // Out of Building
            break;

        case NAS_SYS_ROAM_STATUS_AVAIL_SYS_V01:
            res = 6; // Roaming - Available System
            break;

        case NAS_SYS_ROAM_STATUS_ALLIANCE_PARTNER_V01:
            res = 7; // Roaming - Alliance Partner
            break;

        case NAS_SYS_ROAM_STATUS_PREMIUM_PARTNER_V01:
            res = 8; // Roaming - Premium Partner
            break;

        case NAS_SYS_ROAM_STATUS_FULL_SVC_V01:
            res = 9; // Roaming - Full Service Functionality
            break;

        case NAS_SYS_ROAM_STATUS_PARTIAL_SVC_V01:
            res = 10; // Roaming - Partial Service Functionality
            break;

        case NAS_SYS_ROAM_STATUS_BANNER_ON_V01:
            res = 11; // Roaming Banner On
            break;

        case NAS_SYS_ROAM_STATUS_BANNER_OFF_V01:
            res = 12; // Roaming Banner Off
            break;

        default:
            res = (int) qmi_roam_status;
            break;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) res);

    return res;
} // qmi_ril_nwr_map_roam_status_from_qmi_to_android

//===========================================================================
// qmi_ril_nwr_conv_reg_reject_cause_voice
//===========================================================================
int qmi_ril_nwr_conv_reg_reject_cause_voice(uint8_t org_cause, uint8_t radio_if)
{
    int res;

    if( QMI_RIL_RTE_SUB_LTE == radio_if )
    {
        res = qmi_ril_nwr_conv_reg_reject_cause_lte( org_cause );
    }
    else
    {
        switch ( org_cause )
        {
            case 255 : // Authentication rejected
            case 2 :   // IMSI unknown in HLR
            case 3 :   // Illegal MS
            case 4 :   // IMSI unknown in VLR
            case 5 :   // IMEI not accepted
            case 6:    // Illegal ME
            case 8:
            case 11:   // PLMN not allowed
            case 12:   // Location Area not allowed
            case 13:   // Roaming not allowed in this location area
            case 15:   // No Suitable Cells in this Location Area
            case 17:   // Network failure
            case 20:   // MAC Failure
            case 21:   // Sync Failure */
            case 22:   // Congestion
            case 23:   // GSM Authentication unacceptable
            case 25:   // Not Authorized for this CSG
            case 32:   // Service option not supported
            case 33:   // Requested service option not subscribed
            case 34:   // Service option temporarily out of order
            case 38:   // Call cannot be identified
            case 95:   // Semantically incorrect message
            case 96:   // Network failure
            case 97:   // Network failure
            case 98:   // Network failure
            case 99:   // Network failure
            case 100:  // Network failure
            case 101:  // Message not compatible with protocol state
            case 111:  // Protocol error, unspecified
                res = (int) org_cause;
                break;

            case RIL_VAL_REG_MANAGED_ROAMING_CAUSE: // managed roaming
                res = (int) RIL_VAL_REG_MANAGED_ROAMING_CAUSE;
                break;

            case 48 ... 63: // Retry upon entry into a new cell
                res = 48;
                break;

            default:   // Unspecified failure
                res = 0;
                break;
        }
    }

    return res;
} // qmi_ril_nwr_conv_reg_reject_cause_voice
//===========================================================================
// qcril_qmi_nas_is_in_service_of_technology
//===========================================================================
int qcril_qmi_nas_is_in_service_of_technology(int technology)
{
    int res = FALSE;
    int rte_reg_status[ QMI_RIL_RTE_CAP ];

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_LOG_INFO( ".. param %d", (int) technology );

    if ( nas_cached_info.ims_rte )
    {
        res = (NAS_SELECTED_NETWORK_3GPP_V01 == technology) ? TRUE : FALSE;
    }
    else
    {
        QCRIL_LOG_INFO( ".. cache valid %d", (int) nas_cached_info.is_in_service_of_technology_cache_result_valid );

        if ( !nas_cached_info.is_in_service_of_technology_cache_result_valid )
        {
            nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] = FALSE;
            nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] = FALSE;

            // voice first
            memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
            qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );
            QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
            QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
            QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
            QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
            QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
            QCRIL_LOG_INFO(".. 5G reg %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);
            QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );
            if (
                RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_GSM ] ||
                RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_WCDMA ] ||
                RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] ||
                RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] ||
                RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[QMI_RIL_RTE_SUB_NR5G] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[QMI_RIL_RTE_SUB_NR5G]
                 )
            {
                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] = TRUE;
            }
            if (
                RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_1x ] ||
                RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_DO ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_DO ]
                 )
            {
                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] = TRUE;
            }
            QCRIL_LOG_INFO( ".. prelim res 3ggp %d, 3gpp2 %d",
                            nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ],
                            nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] );

            // data if needed
            if ( !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] ||
                 !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ]  )
            {
                memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
                qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );

                QCRIL_LOG_INFO( ".. 1x reg data %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
                QCRIL_LOG_INFO( ".. gsm reg data %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
                QCRIL_LOG_INFO( ".. wcdma reg data %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
                QCRIL_LOG_INFO( ".. tdscdma reg data %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
                QCRIL_LOG_INFO( ".. lte reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
                QCRIL_LOG_INFO(".. 5G reg data %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);
                QCRIL_LOG_INFO( ".. hdr reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

                if ( !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ]  &&
                     (
                      RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_GSM ] ||
                      RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_WCDMA ] ||
                      RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] ||
                      RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] ||
                      RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_NR5G ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_NR5G ]
                      )
                   )
                {
                    nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] = TRUE;
                }

                if ( !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] &&
                     (
                      RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_1x ] ||
                      RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_DO ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_DO ]
                     )
                   )
                {
                    nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] = TRUE;
                }

            }

            QCRIL_LOG_INFO( ".. final cached res 3ggp %d, 3gpp2 %d",
                            nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ],
                            nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] );

            nas_cached_info.is_in_service_of_technology_cache_result_valid = TRUE;
        }
        res = nas_cached_info.is_in_service_of_technology_cache_result[ technology ];
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) res);
    return res;
} // qcril_qmi_nas_is_in_service_of_technology

//===========================================================================
//qcril_qmi_nas_is_using_rte_helper
//===========================================================================
int qcril_qmi_nas_is_using_rte_helper(qmi_ril_nw_reg_rte_type rte,
                                      qmi_ril_nw_reg_rte_kind_type rte_kind)
{
    int ret;

    QCRIL_LOG_FUNC_ENTRY();

    ret= FALSE;

    NAS_CACHE_LOCK();
    ret = qcril_qmi_nas_is_using_rte(rte, rte_kind);
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_using_rte_helper

//===========================================================================
// qcril_qmi_nas_is_using_rte
//===========================================================================
int qcril_qmi_nas_is_using_rte(qmi_ril_nw_reg_rte_type rte, qmi_ril_nw_reg_rte_kind_type rte_kind)
{
    int ret;
    int err;
    qmi_ril_nw_reg_rte_type current_rte;
    qmi_ril_nw_reg_rat_confidence_tag_type current_rte_confidence;

    ret = FALSE;
    err = FALSE;
    current_rte = QMI_RIL_RTE_NONE;
    current_rte_confidence = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;

    switch( rte_kind )
    {
        case QMI_RIL_RTE_KIND_VOICE:
            current_rte            = nas_cached_info.voice_rte;
            current_rte_confidence = nas_cached_info.voice_rte_confidence_tag;
            QCRIL_LOG_INFO("questioned rte %d, voice rte %d confd %d", (int)rte, (int)current_rte, (int)current_rte_confidence);
            break;

        case QMI_RIL_RTE_KIND_DATA:
            current_rte            = nas_cached_info.data_rte;
            current_rte_confidence = nas_cached_info.data_rte_confidence_tag;
            QCRIL_LOG_INFO("questioned rte %d, data rte %d confd %d", (int)rte, (int)current_rte, (int)current_rte_confidence);
            break;

        case QMI_RIL_RTE_KIND_IMS:
            current_rte            = nas_cached_info.ims_rte;
            current_rte_confidence = nas_cached_info.ims_rte_confidence_tag;
            QCRIL_LOG_INFO("questioned rte %d, ims rte %d confd %d", (int)rte, (int)current_rte, (int)current_rte_confidence);
            break;

        default:
            err = TRUE;
            QCRIL_LOG_INFO("invalid rte kind %d", rte_kind);
            break;
    }

    if( FALSE == err )
    {
        if( rte == current_rte && ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == current_rte_confidence || QMI_RIL_RAT_CONFIDENCE_LTD_SVC == current_rte_confidence ) )
        {
            ret = TRUE;
        }
    }

    return ret;
} //qcril_qmi_nas_is_using_rte

//===========================================================================
// qcril_qmi_nas_is_using_radio_if
//===========================================================================
int qcril_qmi_nas_is_using_radio_if(uint8_t radio_if)
{
    int res = FALSE;

    QCRIL_LOG_INFO(" isn on tech whereabouts - questioned tech %d", (int)radio_if);

    if ( NAS_RADIO_IF_GSM == radio_if &&
         (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_VOICE) ||
             qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_DATA)  ||
             qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_IMS)
                                         )
       )
    {
        res = TRUE;
    }
    else if ( NAS_RADIO_IF_UMTS == radio_if &&
              (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_VOICE) ||
                  qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_DATA)  ||
                  qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_IMS)
                                         )
       )
    {
        res = TRUE;
    }
    else if ( NAS_RADIO_IF_TDSCDMA == radio_if &&
              (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_VOICE) ||
                  qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_DATA)  ||
                  qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_IMS)
                                         )
       )
    {
        res = TRUE;
    }
    else if ( NAS_RADIO_IF_CDMA2000 == radio_if &&
              (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_VOICE) ||
                  qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_DATA)
                           )
            )
    {
        res = TRUE;
    }
    else if ( NAS_RADIO_IF_LTE== radio_if &&
              (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_VOICE) ||
                  qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_DATA)  ||
                  qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_IMS)
                                         )
       )
    {
        res = TRUE;
    }
    else if (NAS_RADIO_IF_NR5G == radio_if &&
            (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_NR5G, QMI_RIL_RTE_KIND_VOICE) ||
             qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_NR5G, QMI_RIL_RTE_KIND_DATA)  ||
             qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_NR5G, QMI_RIL_RTE_KIND_IMS)))
    {
        res = TRUE;
    }
    else if ( NAS_RADIO_IF_CDMA2000_HRPD == radio_if &&
              (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_DO, QMI_RIL_RTE_KIND_DATA) )
            )
    {
        res = TRUE;
    }
    else
    {
        res = FALSE;
    }
    return res;
} // qcril_qmi_nas_is_using_radio_if


//===========================================================================
// qcril_qmi_nas_is_rte_registered
//===========================================================================
int qcril_qmi_nas_is_rte_registered(qmi_ril_nw_reg_rte_type rte)
{
    int ret;
    qmi_ril_nw_reg_rte_type current_rte;
    qmi_ril_nw_reg_rat_confidence_tag_type current_rte_confidence;

    ret = FALSE;
    current_rte = QMI_RIL_RTE_NONE;
    current_rte_confidence = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;

    NAS_CACHE_LOCK();

    do
    {
        // voice rte
        current_rte            = nas_cached_info.voice_rte;
        current_rte_confidence = nas_cached_info.voice_rte_confidence_tag;

        // TRUE only if full svc
        if( ( current_rte == rte && QMI_RIL_RAT_CONFIDENCE_FULL_SVC == current_rte_confidence ) )
        {
            ret = TRUE;
            break;
        }

        // data rte
        current_rte            = nas_cached_info.data_rte;
        current_rte_confidence = nas_cached_info.data_rte_confidence_tag;

        // TRUE only if full svc
        if( ( current_rte == rte && QMI_RIL_RAT_CONFIDENCE_FULL_SVC == current_rte_confidence ) )
        {
            ret = TRUE;
            break;
        }

    }while(0);

    NAS_CACHE_UNLOCK();

    return ret;
} //qcril_qmi_nas_is_rte_registered


//===========================================================================
// qcril_qmi_nas_find_current_mcc_mnc
//===========================================================================
int qcril_qmi_nas_find_current_mcc_mnc
(
    char                  *mcc_str_ptr,
    char                  *mnc_str_ptr,
    int                    is_full_service_required,
    nas_radio_if_enum_v01 *plmn_rat
)
{
    int res = FALSE;
    qmi_ril_nw_reg_rte_type registered_rtes[QMI_RIL_RTE_LAST] = {QMI_RIL_RTE_NONE};
    qmi_ril_nw_reg_rte_type chosen_registered_rte             = QMI_RIL_RTE_NONE;

    if( NULL != mcc_str_ptr && NULL != mnc_str_ptr)
    {
        memset(mcc_str_ptr,0,NAS_MCC_MNC_MAX_SIZE);
        memset(mnc_str_ptr,0,NAS_MCC_MNC_MAX_SIZE);

        if(FALSE == is_full_service_required ||
           qcril_qmi_nas_is_considered_registered(registered_rtes))
        {
            chosen_registered_rte =
                qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name_info(registered_rtes);

            QCRIL_LOG_INFO("chosen rte - %d", chosen_registered_rte);

            if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_GSM) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sys_info)
                && nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id_valid &&
                (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_GSM) : TRUE))
            {
                QCRIL_LOG_INFO("using sys_info_ind - GSM");
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                if (plmn_rat)
                {
                    *plmn_rat = NAS_RADIO_IF_GSM_V01;
                }
                res = TRUE;
            }
            else if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_UMTS) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sys_info)
                && nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id_valid &&
                (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_WCDMA) : TRUE))
            {
                QCRIL_LOG_INFO("using sys_info_ind - WCDMA");
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                if (plmn_rat)
                {
                    *plmn_rat = NAS_RADIO_IF_UMTS_V01;
                }
                res = TRUE;
            }
            else if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_TDSCDMA) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_sys_info)
                && nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id_valid &&
                (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_TDSCDMA) : TRUE))
            {
                QCRIL_LOG_INFO("using sys_info_ind - TDSCDMA");
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                if (plmn_rat)
                {
                    *plmn_rat = NAS_RADIO_IF_TDSCDMA_V01;
                }
                res = TRUE;
            }
            else if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_LTE) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sys_info)
                && nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id_valid &&
                (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_SUB_LTE) : TRUE))
            {
                QCRIL_LOG_INFO("using sys_info_ind - LTE");
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                if (plmn_rat)
                {
                    *plmn_rat = NAS_RADIO_IF_LTE_V01;
                }
                res = TRUE;
            }
            else if (qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_NR5G) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info)
                && nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info.network_id_valid &&
                (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_SUB_NR5G) : TRUE))
            {
                QCRIL_LOG_INFO("using sys_info_ind - NR5G");
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                if (plmn_rat)
                {
                    *plmn_rat = NAS_RADIO_IF_NR5G_V01;
                }
                res = TRUE;
            }
            else if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_CDMA2000) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sys_info)
                && nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id_valid)
            {
                QCRIL_LOG_INFO("using sys_info_ind - CDMA");
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mcc, mcc_str_ptr);
                qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mnc, mnc_str_ptr);
                if (plmn_rat)
                {
                    *plmn_rat = NAS_RADIO_IF_CDMA_1X_V01;
                }
                res = TRUE;
            }
        }

        if( TRUE == res )
        {
            QCRIL_LOG_INFO("mcc %s mnc %s",mcc_str_ptr,mnc_str_ptr);
        }
    }
    QCRIL_LOG_INFO("completed with %d",res);

    return res;
} //qcril_qmi_nas_find_current_mcc_mnc

//===========================================================================
// qcril_qmi_nas_fillup_mcc_mnc_helper
//===========================================================================
void qcril_qmi_nas_fillup_mcc_mnc_helper(char *src_arr, char *dest_str)
{
    int iter_i=0,len=0;

    if( NULL != src_arr && NULL != dest_str )
    {
        memset(dest_str, 0, NAS_MCC_MNC_MAX_V01);
        for( iter_i=0; iter_i<NAS_MCC_MNC_MAX_V01; iter_i++ )
        {
            if( isdigit(src_arr[iter_i]) )
            {
                dest_str[iter_i] = src_arr[iter_i];
                len++;
            }
        }
        dest_str[len] = '\0';
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }

} //qcril_qmi_nas_fillup_mcc_mnc_helper

//===========================================================================
// qcril_qmi_nas_is_mcc_mnc_wildcard_entry
//===========================================================================
int qcril_qmi_nas_is_mcc_mnc_wildcard_entry(char *mcc, char *mnc)
{
    int ret = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    if( (NAS_MCC_WILDCARD_ENTRY == mcc[0] && NAS_MCC_MNC_WILDCARD_ENTRY == mcc[1] && NAS_MCC_MNC_WILDCARD_ENTRY == mcc[2]) &&
        (NAS_MNC_WILDCARD_ENTRY == mnc[0] && NAS_MCC_MNC_WILDCARD_ENTRY == mnc[1] && NAS_MCC_MNC_WILDCARD_ENTRY == mnc[2]) )
    {
        ret = TRUE;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_mcc_mnc_wildcard_entry

//===========================================================================
// qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper
//===========================================================================
void qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper(char *mcc, char *mnc)
{
    QCRIL_LOG_FUNC_ENTRY();

    strlcpy(mcc,NAS_PLACEHOLDER_MCC_STR,NAS_MCC_MNC_MAX_SIZE);
    strlcpy(mnc,NAS_PLACEHOLDER_MNC_STR,NAS_MCC_MNC_MAX_SIZE);
    QCRIL_LOG_INFO("mcc %s mnc %s", mcc, mnc);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper

//===========================================================================
// qcril_qmi_nas_evaluate_sglte_current_eons_rte
//===========================================================================
void qcril_qmi_nas_evaluate_sglte_current_eons_rte()
{
    qmi_ril_nw_reg_rte_type sglte_current_eons_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rte_type sglte_cs_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rte_type sglte_ps_rte = QMI_RIL_RTE_NONE;
    int is_cs_registered = FALSE;
    int is_cs_roaming = FALSE;
    int is_ps_registered = FALSE;
    int is_ps_roaming = FALSE;
    int rte_reg_status[ QMI_RIL_RTE_CAP ];
    int idx_rte;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );   //evaluating sglte cs rte
    qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );
    QCRIL_LOG_INFO( ".. gsm cs reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma cs reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma cs reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte cs reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO(".. 5G cs reg %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);

    for (idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST && !is_cs_registered; idx_rte++)
    {
        // skip 3GPP2 RATs
        if (idx_rte == QMI_RIL_RTE_1x || idx_rte == QMI_RIL_RTE_SUB_DO)
        {
            continue;
        }

        switch( rte_reg_status[ idx_rte ] )
        {
            case RIL_VAL_REG_REGISTERED_ROAMING: //fallthrough
                is_cs_roaming = TRUE;
                [[clang::fallthrough]];

            case RIL_VAL_REG_REGISTERED_HOME_NET:
                is_cs_registered = TRUE;
                sglte_cs_rte = (qmi_ril_nw_reg_rte_type) idx_rte;
                break;

            default: //no action
                break;
        }
    }

    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) ); //evaluating sglte ps rte
    qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );
    QCRIL_LOG_INFO( ".. gsm ps reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma ps reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma ps reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte ps reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO(".. 5G ps reg %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);

    for (idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST && !is_ps_registered; idx_rte++)
    {
        // skip 3GPP2 RATs
        if (idx_rte == QMI_RIL_RTE_1x || idx_rte == QMI_RIL_RTE_SUB_DO)
        {
            continue;
        }

        switch( rte_reg_status[ idx_rte ] )
        {
            case RIL_VAL_REG_REGISTERED_ROAMING: //fallthrough
                is_ps_roaming = TRUE;
                [[clang::fallthrough]];

            case RIL_VAL_REG_REGISTERED_HOME_NET:
                is_ps_registered = TRUE;
                sglte_ps_rte = (qmi_ril_nw_reg_rte_type) idx_rte;
                break;

            default: //no action
                break;
        }
    }

    do
    {
      /* if only one modem is online continue with the same. */
      if (sglte_cs_rte == sglte_ps_rte)
      {
        sglte_current_eons_rte = sglte_cs_rte;
        break;
      }

      /* if only one domain is registered continue with corresponding modem. */
      if (!is_ps_registered && is_cs_registered)
      {
        sglte_current_eons_rte = sglte_cs_rte;
        break;
      }
      else if (!is_cs_registered && is_ps_registered)
      {
        sglte_current_eons_rte = sglte_ps_rte;
        break;
      }
      else if (is_cs_registered && is_ps_registered)
      {
        /* if roaming preference is enabled then continue with the one which is
           roaming */
        if(nas_common_info.sglte_eons_is_roam_enabled)
        {
          if (!is_cs_roaming && is_ps_roaming)
          {
            sglte_current_eons_rte = sglte_ps_rte;
            break;
          }
          else if (!is_ps_roaming && is_cs_roaming)
          {
            sglte_current_eons_rte = sglte_cs_rte;
            break;
          }
        }

        /* if domain preference has been set then continue with the one which is
           cs */
        if(nas_common_info.sglte_eons_is_domain_cs)
        {
          sglte_current_eons_rte = sglte_cs_rte;
          break;
        }
        else
        {
          sglte_current_eons_rte = sglte_ps_rte;
          break;
        }
      }
      else
      {
          QCRIL_LOG_INFO("Not registered on either CS or PS");
          sglte_current_eons_rte = QMI_RIL_RTE_NONE;
      }
    } while (0);

    nas_cached_info.sglte_current_eons_rte = sglte_current_eons_rte;
    QCRIL_LOG_INFO("completed, sglte current eons rte %d", nas_cached_info.sglte_current_eons_rte);
} //qcril_qmi_nas_evaluate_sglte_current_eons_rte

//===========================================================================
// qcril_qmi_nas_is_radio_if_plmn_available
//===========================================================================
int qcril_qmi_nas_is_radio_if_plmn_available(uint8_t radio_if)
{
    int ret = FALSE;

    if( (qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) ||
        qcril_qmi_nas_is_sglte3()) &&
        !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ))
    {
        switch( radio_if )
        {
            case NAS_RADIO_IF_GSM:
                if( QMI_RIL_RTE_GSM == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            case NAS_RADIO_IF_UMTS:
                if( QMI_RIL_RTE_WCDMA == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            case NAS_RADIO_IF_TDSCDMA:
                if( QMI_RIL_RTE_TDSCDMA == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            case NAS_RADIO_IF_LTE:
                if( QMI_RIL_RTE_SUB_LTE == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            case NAS_RADIO_IF_NR5G:
                if(QMI_RIL_RTE_SUB_NR5G == nas_cached_info.sglte_current_eons_rte)
                {
                    ret = TRUE;
                }
                break;

            default: //no action
                break;
        }
    }
    else
    {
        ret = qcril_qmi_nas_is_using_radio_if(radio_if);
        if(FALSE == ret)
        {
            ret = qcril_qmi_nas_is_using_radio_based_on_data_rat_sys_info(radio_if);
        }
    }

    return ret;
} //qcril_qmi_nas_is_radio_if_plmn_available

//===========================================================================
// qcril_qmi_nas_reset_data_snapshot_cache_and_timer
//===========================================================================
void qcril_qmi_nas_reset_data_snapshot_cache_and_timer()
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    QCRIL_LOG_ESSENTIAL("Resetting snapshot timer");

    if( TRUE == nas_cached_info.data_reg_report_snapshot.valid ) //reset cache
    {
        memset(&nas_cached_info.data_reg_report_snapshot, 0, sizeof(nas_cached_info.data_reg_report_snapshot));
        nas_cached_info.data_reg_report_snapshot.valid = FALSE;
    }
    if ( NAS_NIL != nas_cached_info.data_reg_report_expiry ) //cancel timer
    {
        qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
        nas_cached_info.data_reg_report_expiry = NAS_NIL;
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_reset_data_snapshot_cache_and_timer

//===========================================================================
//qcril_qmi_nas_evaluate_data_rte_on_pref_data_tech_change
//===========================================================================
void qcril_qmi_nas_evaluate_data_rte_on_pref_data_tech_change()
{
  qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
  qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
  int                              any_rte_change;

  QCRIL_LOG_FUNC_ENTRY();

  qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
  qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );

  qcril_qmi_nas_wave_data_reg_in_case_of_csfb(FALSE);
  NAS_CACHE_LOCK();
  qcril_qmi_nas_invalidate_data_snapshot_if_applicable();
  qcril_qmi_nas_update_data_rte();
  qcril_qmi_voice_technology_updated();
  qmi_ril_nwr_update_reg_rej_from_sys_info();
  qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );

  if(nas_common_info.is_snapshot_reported_data_reg_state)
  {
      nas_cached_info.is_proper_data_reg_to_report = TRUE;
      QCRIL_LOG_INFO( "is_proper_data_reg_to_report %d",
          nas_cached_info.is_proper_data_reg_to_report);
      if ( NAS_NIL != nas_cached_info.reported_data_reg_expiry ) //cancel timer
      {
          qcril_cancel_timed_callback((void*)(uintptr_t)nas_cached_info.reported_data_reg_expiry);
          nas_cached_info.reported_data_reg_expiry = NAS_NIL;
      }
  }
  NAS_CACHE_UNLOCK();

  qcril_qmi_nas_send_known_signal_strength();

  qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
  qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
  qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
  any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
  QCRIL_LOG_INFO( "any rte change %d", any_rte_change);
  if( any_rte_change )
  {
    qcril_qmi_nas_initiate_voice_rte_change_propagation();
  }

  if ((qcril_qmi_nas_get_attch_state() ==
          QMI_RIL_NAS_ALLOW_DATA_ATTCH_ATTACH) ||
      (qcril_qmi_nas_get_attch_state() ==
          QMI_RIL_NAS_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH))
  {
    qcril_qmi_nas_check_ps_attach_status();
  }

  QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_evaluate_data_rte_on_pref_data_tech_change

//===========================================================================
// RIL_REQUEST_SETUP_DATA_CALL suppress handler
//===========================================================================
void qcril_qmi_nas_request_setup_data_call_suppress_handler
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    QCRIL_NOTUSED(ret_ptr);

#define QCRIL_SUGGESTED_RETRY_TIMER (5*1000)

    qcril_instance_id_e_type  instance_id;

#if (QCRIL_RIL_VERSION >= 11)

    RIL_Data_Call_Response_v11 setup_rsp;

#elif (QCRIL_RIL_VERSION == 10)

    /* Response to setup data call request */
    RIL_Data_Call_Response_v9  setup_rsp;

#else

    /* Response to setup data call request */
    RIL_Data_Call_Response_v6  setup_rsp;

#endif /* (QCRIL_RIL_VERSION >= 11)  */

    qcril_request_resp_params_type resp;

    instance_id = QCRIL_DEFAULT_INSTANCE_ID;

    memset( &setup_rsp, 0x0, sizeof(setup_rsp) );
    setup_rsp.status             = PDP_FAIL_ERROR_UNSPECIFIED;
    setup_rsp.suggestedRetryTime = QCRIL_SUGGESTED_RETRY_TIMER;

    if (NULL != params_ptr)
    {
        qcril_default_request_resp_params( instance_id,
                                           params_ptr->t,
                                           QCRIL_EVT_RIL_REQUEST_SETUP_DATA_CALL,
                                           RIL_E_GENERIC_FAILURE,
                                           &resp );
        resp.resp_pkt = (void *)&(setup_rsp);
        resp.resp_len = sizeof(setup_rsp);
        qcril_send_request_response( &resp );
    }
}

//===========================================================================
// RIL_REQUEST_DATA_REGISTRATION_STATE
//===========================================================================
void qcril_qmi_nas_request_data_registration_state
(
  std::shared_ptr<RilRequestGetDataRegistrationMessage> msg
)
{
  int           qmi_request_need1;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  int idx;

  int is_registered = FALSE;

  int   val_int;

  int is_under_post_mode_pref_ban;

  qcril_arb_pref_data_type pref_data;
  qcril_arb_pref_data_tech_e_type pref_data_tech_implied;
  qcril_arb_pref_data_tech_e_type data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_UNKNOWN;
  qcril_arb_pref_data_tech_e_type data_tech_iter;

  int data_tech_idx;

  nas_sys_info_helper_type sys_info_helper;
  nas_3gpp_only_sys_info_type_v01* threegpp_sys_info;
  nas_cdma_only_sys_info_type_v01* sys_info_cdma;
  nas_common_sys_info_type_v01* common_sys_info;
  nas_cdma_hdr_only_sys_info_type_v01 * cdma_hdr_only_sys_info;

  nas_wcdma_only_sys_info_type_v01* sys_info_wcdma;
  nas_tdscdma_only_sys_info_type_v01* sys_info_tdscdma;


  int tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_MAX ];
  int pref_data_tech_reg_state;

  int do_varations_reg_status;

  int vrte_mapper;

  uint8_t current_roam_status_valid;
  nas_roam_status_enum_type_v01 current_roam_status;

  qmi_ril_nw_reg_data_reg_snapshot_info_type local_reg_snapshot;

  int must_rerender_data_reg_report;

  qmi_ril_nw_reg_rte_type drte;

  int extrapolation_is_under;
  int extrapolation_is_roaming;
  int need_reset_roaming_tmr;
  int need_spawn_roaming_tmr;

  int          data_reg_roaming_confident_resp;
  int          data_reg_roaming_determined;

  nas_hs_support_enum_type_v01 loc_hs_ser = NAS_HS_SUPPORT_ENUM_TYPE_MIN_ENUM_VAL_V01;

  uint8_t prev_reported_state_valid;
  int prev_reported_state;
  uint8_t prev_reported_tech_valid;
  int prev_reported_tech;

  QCRIL_LOG_FUNC_ENTRY();

  // allocate the internal response data
  auto respPayload = new qcril::interfaces::RilGetDataRegResult_t();
  if (!respPayload) {
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_NO_MEMORY, nullptr));
    return;
  }

  must_rerender_data_reg_report = FALSE;

  extrapolation_is_roaming = FALSE;
  extrapolation_is_under   = FALSE;
  prev_reported_state_valid = FALSE;
  prev_reported_state = RIL_VAL_REG_UNKNOWN;
  prev_reported_tech_valid = FALSE;
  prev_reported_tech = RADIO_TECH_UNKNOWN;


  // ** response holder init
  auto& ril_resp_helper = respPayload->respData;
  memset( &ril_resp_helper, 0, sizeof( ril_resp_helper ) );

  memset( &local_reg_snapshot, 0, sizeof( local_reg_snapshot ) );

  memset( &pref_data, 0, sizeof(pref_data) );

  qcril_suppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_suppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());

  qcril_qmi_nas_wave_data_reg_in_case_of_csfb(FALSE);

  NAS_CACHE_LOCK();
  if(nas_common_info.is_snapshot_reported_data_reg_state &&
      !nas_cached_info.is_proper_data_reg_to_report)
  {
    memcpy(&ril_resp_helper, &nas_cached_info.reported_data_reg_state_snapshot,
        sizeof(RIL_DataRegistrationStateResponse));
    ril_req_res = RIL_E_SUCCESS;
  }
  else
  { // sys info supported

      qcril_qmi_get_pref_data_tech(&pref_data);

      NAS_CACHE_LOCK();
      prev_reported_state_valid = nas_cached_info.reported_data_reg_status_valid;
      prev_reported_state = nas_cached_info.reported_data_reg_status;
      prev_reported_tech_valid = nas_cached_info.reported_data_technology_valid;
      prev_reported_tech = nas_cached_info.reported_data_technology;

      qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, &extrapolation_is_under, &extrapolation_is_roaming );

      drte = nas_cached_info.data_rte;
      qmi_request_need1 = qcril_qmi_nas_util_check_request_need(pref_data.pref_data_tech, drte);

      is_under_post_mode_pref_ban = (NAS_NIL != nas_cached_info.extrapolation_ban_expiry);
      NAS_CACHE_UNLOCK();

      QCRIL_LOG_INFO(".. request need %d, drte %d, pref data tech %s, post mpref ban %d",
                            (int) qmi_request_need1,
                            (int) drte,
                            qcril_qmi_util_retrieve_pref_data_tech_name(pref_data.pref_data_tech),
                            is_under_post_mode_pref_ban );

      if ( qmi_request_need1 )
      {
          ril_req_res = qcril_qmi_nas_fetch_sys_info();
      }
      else
      {
          ril_req_res = RIL_E_SUCCESS;
      }

      if ( RIL_E_SUCCESS == ril_req_res )
      {

          NAS_CACHE_LOCK();

          QCRIL_LOG_INFO(" ... cdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... hdr_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) );
          QCRIL_LOG_INFO(" ... gsm_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) );
          QCRIL_LOG_INFO(" ... wcdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... tdscdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... lte_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) );
          QCRIL_LOG_INFO(" ... cdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) );
          QCRIL_LOG_INFO(" ... hdr_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) );
          QCRIL_LOG_INFO(" ... gsm_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) );
          QCRIL_LOG_INFO(" ... wcdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) );
          QCRIL_LOG_INFO(" ... tdscdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) );
          QCRIL_LOG_INFO(" ... lte_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) );
          QCRIL_LOG_INFO(" ... nr5g_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) );

          memset(&tech_data_reg, 0, sizeof(tech_data_reg) );

          // CDMA
          QCRIL_LOG_INFO( " .. prep CDMA" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_CDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA,
                                                                    &sys_info_helper);
          }

          // DO & EHRPD
          QCRIL_LOG_INFO( " .. prep EVDO" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp2_srv_status = nas_cached_info.hdr_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
              sys_info_helper.hdr_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->hdr_specific_sys_info : NULL;
              do_varations_reg_status = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_HDR,
                                                                    &sys_info_helper);
              QCRIL_LOG_INFO(" ... do/ehrpd detection %d", do_varations_reg_status );
              QCRIL_LOG_INFO(" ... hdr_sys_info valid %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) );

              switch ( do_varations_reg_status )
              {
                  case RIL_VAL_REG_REGISTERED_HOME_NET:     // fallthrough
                  case RIL_VAL_REG_REGISTERED_ROAMING:
                      if ( sys_info_helper.hdr_only_sys_info )
                      {
                          QCRIL_LOG_INFO(" ... hdr_active valid %d, hdr_personality valid %d", (int)sys_info_helper.hdr_only_sys_info->hdr_active_prot_valid,
                                         (int)sys_info_helper.hdr_only_sys_info->hdr_personality_valid );
                      }
                      if ( sys_info_helper.hdr_only_sys_info && sys_info_helper.hdr_only_sys_info->hdr_personality_valid )
                      {
                          QCRIL_LOG_INFO(" ... hdr_personality %d", (int)sys_info_helper.hdr_only_sys_info->hdr_personality );
                          switch ( sys_info_helper.hdr_only_sys_info->hdr_personality )
                              {
                              case NAS_SYS_PERSONALITY_EHRPD_V01: // EHRPD
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = do_varations_reg_status;
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                                  break;

                              default: // DO
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = do_varations_reg_status;
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                                  break;
                          }
                      }
                      else
                      { // DO by default
                          tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = do_varations_reg_status;
                          tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                      }
                      break;

                  default:
                      tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = do_varations_reg_status;
                      tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = do_varations_reg_status;
                      break;
              }

          }

          // GSM
          QCRIL_LOG_INFO( " .. prep GSM" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
              sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP,
                                                                    &sys_info_helper);
          }

          // WCDMA
          QCRIL_LOG_INFO( " .. prep WCDMA" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
              sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_UMTS ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP,
                                                                    &sys_info_helper);
          }

          // TDSCDMA
          QCRIL_LOG_INFO( " .. prep TDSCDMA" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
              sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP,
                                                                    &sys_info_helper);
          }

      // LTE
      QCRIL_LOG_INFO( " .. prep LTE" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
      {
          memset(&sys_info_helper, 0, sizeof(sys_info_helper));
          sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
          sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
          sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
          sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
          sys_info_helper.lte_is_eb_supported = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_is_eb_supported ) ? &nas_cached_info.lte_is_eb_supported : NULL;
          sys_info_helper.emergency_access_barred = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_access_barred ) ? &nas_cached_info.emergency_access_barred : NULL;
          tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                &sys_info_helper);
      }

      // 5G
      QCRIL_LOG_INFO( " .. prep 5G" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_srv_status_info ) )
      {
          memset(&sys_info_helper, 0, sizeof(sys_info_helper));
          sys_info_helper.threegpp_srv_status = nas_cached_info.nr5g_srv_status_info;
          sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->common_sys_info : NULL;
          sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info : NULL;
          tech_data_reg[QCRIL_ARB_PREF_DATA_TECH_5G] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(
                  NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_5G, &sys_info_helper);
      }
          // overview
          for ( data_tech_idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; data_tech_idx < QCRIL_ARB_PREF_DATA_TECH_MAX; data_tech_idx++  )
          {
              QCRIL_LOG_INFO(" ... tech %s, reg %d", qcril_qmi_util_retrieve_pref_data_tech_name( (qcril_arb_pref_data_tech_e_type) data_tech_idx), (int) tech_data_reg[ data_tech_idx ]  );
          }

          // CDMA details
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
          {
              sys_info_cdma = &nas_cached_info.cdma_sys_info->cdma_specific_sys_info;
          }
          else
          {
              sys_info_cdma = NULL;
          }

          QCRIL_LOG_INFO(" ..* tech detection" );
          switch ( pref_data.pref_data_tech )
          {
              case QCRIL_ARB_PREF_DATA_TECH_EVDO:
                  pref_data_tech_implied = QCRIL_ARB_PREF_DATA_TECH_EHRPD;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                  pref_data_tech_implied = QCRIL_ARB_PREF_DATA_TECH_EVDO;
                  break;

              default:
                  pref_data_tech_implied = pref_data.pref_data_tech;
                  break;
          }

          QCRIL_LOG_INFO(" ... data_tech_to_report_implied %s", qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech_implied) );

          is_registered = FALSE;
          if (  QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data.pref_data_tech  )
          {
            QCRIL_LOG_INFO("CnE module available, is current %d, pref data tech %s", (int)pref_data.is_current, qcril_qmi_util_retrieve_pref_data_tech_name(pref_data.pref_data_tech) );
            if( TRUE == pref_data.is_current )
            {
              QCRIL_LOG_INFO("with current status");
              if( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data.pref_data_tech )
              {
                data_tech_to_report = pref_data.pref_data_tech;
                is_registered = TRUE;
                QCRIL_LOG_INFO("data in service on %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));

                // determine roaming status
                need_reset_roaming_tmr = FALSE;
                need_spawn_roaming_tmr = FALSE;

                QCRIL_LOG_INFO("data roam status latest %d / %d under tmr 0x%x, is extrap %d, extrap_roaming %d, a/m nw sel %d",
                               nas_cached_info.data_reg_roaming_status_latest_val,
                               nas_cached_info.data_reg_roaming_status_latest,
                               nas_cached_info.data_reg_roaming_status_latest_expiry,
                               extrapolation_is_under,
                               extrapolation_is_roaming,
                               (int)nas_cached_info.nw_select_state );
                if ( extrapolation_is_under )
                { // extrapolation - reuse what's known
                    pref_data_tech_reg_state = extrapolation_is_roaming ? RIL_VAL_REG_REGISTERED_ROAMING : RIL_VAL_REG_REGISTERED_HOME_NET;
                    need_reset_roaming_tmr = TRUE;
                }
                else
                {
                    data_reg_roaming_determined = FALSE;
                    if ( !( nas_cached_info.data_reg_roaming_status_latest_val &&
                            ( is_under_post_mode_pref_ban || QMI_RIL_NAS_NW_SELECT_NONE != nas_cached_info.nw_select_state )
                          ) || ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.reported_pref_data_technology) &&
                                 ( pref_data.pref_data_tech != nas_cached_info.reported_pref_data_technology ))
                         )
                    { // normal case: not extrapolating and not "right after" mode pref change
                        data_reg_roaming_confident_resp = FALSE;

                        if( RADIO_TECH_IWLAN != pref_data.radio_technology )
                        {
                        //Do not check roaming status on pref data tech if radio tech is IWLAN
                           pref_data_tech_reg_state = qcril_qmi_nas_util_check_roaming_status(
                                                              pref_data.pref_data_tech,
                                                              tech_data_reg,
                                                              &data_reg_roaming_confident_resp );
                        }

                        if ( data_reg_roaming_confident_resp )
                        {
                           nas_cached_info.data_reg_roaming_status_latest     = pref_data_tech_reg_state;
                           nas_cached_info.data_reg_roaming_status_latest_val = TRUE;
                           data_reg_roaming_determined = TRUE;
                        }
                        else
                        {
                           if ( !nas_cached_info.data_reg_roaming_status_latest_val )
                           { // not matching roaming TLV at this time or roaming never known-set to no roaming
                              pref_data_tech_reg_state    = RIL_VAL_REG_REGISTERED_HOME_NET;
                              data_reg_roaming_determined = TRUE;

                              nas_cached_info.data_reg_roaming_status_latest     = RIL_VAL_REG_REGISTERED_HOME_NET;
                              nas_cached_info.data_reg_roaming_status_latest_val = TRUE;
                           }
                        }

                        need_reset_roaming_tmr = TRUE;
                        need_spawn_roaming_tmr = TRUE;
                    }
                    else
                    { // "right after" mode pref change - apply cached roaming status
                        pref_data_tech_reg_state = nas_cached_info.data_reg_roaming_status_latest;
                        data_reg_roaming_determined = TRUE;
                    }

                    if ( !data_reg_roaming_determined &&
                         (pref_data.radio_technology == RADIO_TECH_IWLAN))
                    {
                        pref_data_tech_reg_state = RIL_VAL_REG_REGISTERED_HOME_NET;
                        data_reg_roaming_determined = TRUE;
                        QCRIL_LOG_INFO("default to HOME for IWLAN");
                    }

                    if ( !data_reg_roaming_determined && nas_cached_info.data_reg_roaming_status_latest_val )
                    {
                        pref_data_tech_reg_state = nas_cached_info.data_reg_roaming_status_latest;
                    }
                }
                QCRIL_LOG_INFO("need reset roaming tmr %d, need spawn roaming tmr %d", need_reset_roaming_tmr, need_spawn_roaming_tmr );
                if ( need_reset_roaming_tmr )
                {
                    if ( nas_cached_info.data_reg_roaming_status_latest_expiry )
                    {
                        qcril_cancel_timed_callback( (void*)(uintptr_t)nas_cached_info.data_reg_roaming_status_latest_expiry );
                        nas_cached_info.data_reg_roaming_status_latest_expiry = NAS_NIL;
                    }
                }
              }
            }
          } // if (  QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data.pref_data_tech  )
          else
          {
            QCRIL_LOG_INFO("CnE module UNavailable");
          }

          if( FALSE == is_registered )
          { // determine technology
              QCRIL_LOG_INFO("Using QMI NAS indication info");
              data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_UNKNOWN;

              // what's registered : Only in case of Invalid pref_data_tech (preferred data system indication unavailability)

              if( QCRIL_ARB_PREF_DATA_TECH_INVALID == pref_data.pref_data_tech )
              {
                  for ( idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; idx < QCRIL_ARB_PREF_DATA_TECH_MAX && QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report; idx++ )
                  {
                      data_tech_iter = qmi_ril_data_reg_tech_priorities[ idx ];
                      if ( RIL_VAL_REG_REGISTERED_HOME_NET == tech_data_reg[ data_tech_iter ] || RIL_VAL_REG_REGISTERED_ROAMING == tech_data_reg[ data_tech_iter ] )
                      {
                          data_tech_to_report = data_tech_iter;
                          is_registered = TRUE;
                          QCRIL_LOG_INFO("no CnE, picking %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
                      }
                  }
              }
              // what's reg rejected
              if ( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report )
              {
                  for ( idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; idx < QCRIL_ARB_PREF_DATA_TECH_MAX && QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report; idx++ )
                  {
                      data_tech_iter = qmi_ril_data_reg_tech_priorities[ idx ];
                      switch ( tech_data_reg[ data_tech_iter ] )
                      {
                          case RIL_VAL_REG_REGISTRATION_DENIED:
                          case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                              data_tech_to_report = data_tech_iter;
                              break;

                          default:
                              // skip
                              break;
                      }
                  }
              }
              // what's reg rejected 2
              if ( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report )
              {
                for ( vrte_mapper = QMI_RIL_RTE_NONE;  (vrte_mapper < QMI_RIL_RTE_CAP) && (QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report) ; vrte_mapper++ )
                {
                    if ( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_rejected )
                    {
                        QCRIL_LOG_INFO("... reje reg data adjust to vrte %d", vrte_mapper );

                        switch ( vrte_mapper )
                        {
                            case QMI_RIL_RTE_GSM:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_GSM;
                                break;

                            case QMI_RIL_RTE_WCDMA:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_UMTS;
                                break;

                            case QMI_RIL_RTE_TDSCDMA:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_TDSCDMA;
                                break;

                            case QMI_RIL_RTE_SUB_LTE:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_LTE;
                                break;

                            case QMI_RIL_RTE_SUB_NR5G:
                                data_tech_to_report =  QCRIL_ARB_PREF_DATA_TECH_5G;
                                break;

                            default:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_UNKNOWN;
                                break;
                        }
                    }
                }
              }
              // what's in search
              if ( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report )
              {
                  for ( idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; idx < QCRIL_ARB_PREF_DATA_TECH_MAX && QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report; idx++ )
                  {
                      data_tech_iter = qmi_ril_data_reg_tech_priorities[ idx ];
                      switch ( tech_data_reg[ data_tech_iter ] )
                      {
                          case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:
                          case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:
                          case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                              data_tech_to_report = data_tech_iter;
                              QCRIL_LOG_INFO("... in search RAT %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
                              break;

                          default:
                              // skip
                              break;
                      }
                  }
              }
              QCRIL_LOG_INFO(" ... matched tech %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));

          // map
          switch ( data_tech_to_report )
          {
              case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                  vrte_mapper = QMI_RIL_RTE_1x;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_EVDO:           // fallthrough
              case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                  vrte_mapper = QMI_RIL_RTE_SUB_DO;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_GSM:
                  vrte_mapper = QMI_RIL_RTE_GSM;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                  vrte_mapper = QMI_RIL_RTE_WCDMA;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                  vrte_mapper = QMI_RIL_RTE_TDSCDMA;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_LTE:
                  vrte_mapper = QMI_RIL_RTE_SUB_LTE;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_5G:
                  vrte_mapper = QMI_RIL_RTE_SUB_NR5G;
                  break;

              default:
                  vrte_mapper = QMI_RIL_RTE_NONE;
                  break;
          }
          QCRIL_LOG_INFO("... vrte_mapper %d", (int) vrte_mapper );

          // reg reject adjust
          QCRIL_LOG_INFO("... pre cur reg state %d", (int) tech_data_reg[ data_tech_to_report ] );
          switch ( tech_data_reg[ data_tech_to_report ] )
          {
              case RIL_VAL_REG_REGISTERED_HOME_NET:
              case RIL_VAL_REG_REGISTERED_ROAMING:
                  // nothing for reg reject
                  break;

              default:
                  if ( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_rejected )
                  {
                      QCRIL_LOG_INFO("... adjusted to reje reg data for data rte %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
                      tech_data_reg [ data_tech_to_report ] = RIL_VAL_REG_REGISTRATION_DENIED;
                  }
                  break;
          }
          pref_data_tech_reg_state = tech_data_reg [ data_tech_to_report ];
       }

       // * response
       QCRIL_LOG_INFO(" ..* response build" );

       local_reg_snapshot.registration_state = pref_data_tech_reg_state;
       NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_reg_status, pref_data_tech_reg_state);
       // RIL resp filling: registration state
       ril_resp_helper.regState = ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV != pref_data_tech_reg_state ) ?
             (RIL_RegState)pref_data_tech_reg_state : RIL_NOT_REG_AND_NOT_SEARCHING;

       QCRIL_LOG_INFO("... cur reg state %d %d", (int) pref_data_tech_reg_state, ril_resp_helper.regState );

       if ( is_registered )
       {
           threegpp_sys_info = NULL;
           sys_info_wcdma    = NULL;
           sys_info_tdscdma  = NULL;
           common_sys_info   = NULL;
           cdma_hdr_only_sys_info = NULL;
           switch ( data_tech_to_report )
           {
               case QCRIL_ARB_PREF_DATA_TECH_GSM:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                   {
                       threegpp_sys_info = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                       common_sys_info = &nas_cached_info.gsm_sys_info->common_sys_info;
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                   {
                       threegpp_sys_info = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                       sys_info_wcdma    = &nas_cached_info.wcdma_sys_info->wcdma_specific_sys_info;
                       common_sys_info = &nas_cached_info.wcdma_sys_info->common_sys_info;
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                   {
                       threegpp_sys_info = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                       sys_info_tdscdma    = &nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info;
                       common_sys_info = &nas_cached_info.tdscdma_sys_info->common_sys_info;
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_LTE:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                   {
                       threegpp_sys_info = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                       common_sys_info = &nas_cached_info.lte_sys_info->common_sys_info;
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
                   {
                       common_sys_info = &nas_cached_info.cdma_sys_info->common_sys_info;
                       cdma_hdr_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_hdr_only_sys_info;
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_EVDO:
               case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                   {
                       common_sys_info = &nas_cached_info.hdr_sys_info->common_sys_info;
                       cdma_hdr_only_sys_info = &nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info;
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_5G:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) )
                   {
                       threegpp_sys_info = &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info;
                       common_sys_info = &nas_cached_info.nr5g_sys_info->common_sys_info;
                   }
                   break;

               default:
                   // nothing
                   break;
           }

           // XXX: rebuild sys_info_helper to fill 3gpp cell indentity
           memset(&sys_info_helper, 0, sizeof(sys_info_helper));
           sys_info_helper.common_sys_info = common_sys_info;
           sys_info_helper.threegpp_only_sys_info = threegpp_sys_info;
           sys_info_helper.wcdma_only_sys_info = sys_info_wcdma;
           sys_info_helper.tdscdma_only_sys_info = sys_info_tdscdma;

           if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sys_info))
             sys_info_helper.lte_only_sys_info = &nas_cached_info.lte_sys_info->lte_specific_sys_info;

           // RIL resp filling: cell identity
           if (data_tech_to_report == QCRIL_ARB_PREF_DATA_TECH_CDMA ||
                 data_tech_to_report == QCRIL_ARB_PREF_DATA_TECH_EVDO ||
                 data_tech_to_report == QCRIL_ARB_PREF_DATA_TECH_EHRPD)
           {
             qcril_qmi_nas_fill_3gpp2_cell_identity(QMI_RIL_RTE_NONE, &ril_resp_helper.cellIdentity, sys_info_cdma);
           }
           else
           {
             qcril_qmi_nas_fill_3gpp_cell_identity(qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(
                     data_tech_to_report), &ril_resp_helper.cellIdentity, &sys_info_helper, &local_reg_snapshot);
           }

           if ( NULL != sys_info_cdma && sys_info_cdma->cdma_sys_id_valid )
           {
               NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cdma_sys_id, sys_info_cdma->cdma_sys_id );
           }
           else
           {
               NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
           }

           if ( NULL != common_sys_info && common_sys_info->roam_status_valid )
           {
               current_roam_status_valid = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roam_status );
               current_roam_status = nas_cached_info.roam_status;

               if ( FALSE == nas_cached_info.voice_roam_status_reported &&
                 (FALSE == current_roam_status_valid || current_roam_status != common_sys_info->roam_status) )
               {
                   NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_status, common_sys_info->roam_status );

                   must_rerender_data_reg_report = TRUE;
               }
           }
           else
           {
               NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
           }

           if ( NULL != cdma_hdr_only_sys_info && cdma_hdr_only_sys_info->is_sys_prl_match_valid )
           {
               NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.is_sys_prl_match, cdma_hdr_only_sys_info->is_sys_prl_match );
           }
           else
           {
               NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
           }

           // * radio tech
           val_int = RADIO_TECH_UNKNOWN;

           QCRIL_LOG_DEBUG("pref_data.is_current = %d", pref_data.is_current);
           if( (TRUE == pref_data.is_current) )
           {
               val_int = pref_data.radio_technology;
           }
           else
           {
           switch ( data_tech_to_report )
           {
               case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                   val_int = qcril_qmi_nas_util_determine_cdma_rev( sys_info_cdma );
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_EVDO:
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                   {
                       QCRIL_LOG_INFO("... hdr_active_prot_valid %d", (int)nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot_valid );
                   }
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) && nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot_valid )
                   {
                       QCRIL_LOG_INFO("... hdr_active_prot %d", (int)nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot  );
                       switch ( nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot )
                       {
                           case NAS_SYS_ACTIVE_PROT_HDR_REL0_V01:
                               val_int = RADIO_TECH_EVDO_0;
                               break;

                           case NAS_SYS_ACTIVE_PROT_HDR_RELA_V01:
                               val_int = RADIO_TECH_EVDO_A;
                               break;

                           case NAS_SYS_ACTIVE_PROT_HDR_RELB_V01:
                               val_int = RADIO_TECH_EVDO_B;
                               break;

                           case NAS_SYS_ACTIVE_PROT_NONE_V01:
                           default:
                               break;
                       }
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_GSM:
                   QCRIL_LOG_INFO("... gsm_sys_info valid %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ));
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                   {
                       QCRIL_LOG_INFO("... egprs_supp_valid, egprs_supp %d, %d",
                                      (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp_valid,
                                      (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp );
                   }
                   if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                        nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp_valid &&
                        NAS_SYS_EGPRS_SUPPORT_AVAIL == nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp )
                   {
                       val_int = RADIO_TECH_EDGE;
                   }
                   else
                   {
                       val_int = RADIO_TECH_GPRS; // safe to assume GPRS as serving_status is "in service" and srv_domain is either cs_ps or ps_only
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                   val_int = RADIO_TECH_UMTS; // by default
                   QCRIL_LOG_INFO("... sys_info_wcdma %p", sys_info_wcdma);
                   if ( NULL != sys_info_wcdma )
                   {
                       QCRIL_LOG_INFO( "... hs_ind_valid, hs_ind %d, %d", (int)sys_info_wcdma->hs_ind_valid, (int)sys_info_wcdma->hs_ind );
                       QCRIL_LOG_INFO( "... hs_call_status_valid, hs_call_status %d, %d", (int)sys_info_wcdma->hs_call_status_valid, (int)sys_info_wcdma->hs_call_status );
                       if ( sys_info_wcdma->hs_ind_valid && sys_info_wcdma->hs_call_status_valid )
                       {
                         if( sys_info_wcdma->hs_ind > sys_info_wcdma->hs_call_status )
                         {
                           loc_hs_ser = sys_info_wcdma->hs_ind;
                         }
                         else
                         {
                           loc_hs_ser = sys_info_wcdma->hs_call_status;
                         }
                       }
                       else if ( sys_info_wcdma->hs_ind_valid )
                       {
                         loc_hs_ser = sys_info_wcdma->hs_ind;
                       }
                       else if ( sys_info_wcdma->hs_call_status_valid )
                       {
                         loc_hs_ser = sys_info_wcdma->hs_call_status;
                       }

                       switch ( loc_hs_ser )
                       {
                         case SYS_HS_IND_HSDPA_SUPP_CELL_V01:          // fallthrough
                             val_int = RADIO_TECH_HSDPA;
                             break;

                         case SYS_HS_IND_HSUPA_SUPP_CELL_V01:
                             val_int = RADIO_TECH_HSUPA;
                             break;

                         case SYS_HS_IND_HSDPA_HSUPA_SUPP_CELL_V01:
                             val_int = RADIO_TECH_HSPA;
                             break;

                         case SYS_HS_IND_HSDPAPLUS_SUPP_CELL_V01:      // fallthrough
                         case SYS_HS_IND_HSDPAPLUS_64QAM_SUPP_CELL_V01:// fallthrough
                         case SYS_HS_IND_DC_HSDPAPLUS_SUPP_CELL_V01:   // fallthrough
                         case SYS_HS_IND_HSDPAPLUS_HSUPA_SUPP_CELL_V01:    // fallthrough
                         case SYS_HS_IND_DC_HSDPAPLUS_HSUPA_SUPP_CELL_V01: // fallthrough
                         case SYS_HS_IND_HSDPAPLUS_64QAM_HSUPA_SUPP_CELL_V01:
                             val_int = RADIO_TECH_HSPAP;
                             break;

                         default:
                             // no change, RADIO_TECH_UMTS by default
                             break;
                       }
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                   val_int = RADIO_TECH_EHRPD;
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_LTE:
                   val_int = RADIO_TECH_LTE;
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                   val_int = RADIO_TECH_TD_SCDMA; // by default
                   QCRIL_LOG_INFO("... sys_info_tdscdma %p", sys_info_tdscdma);
                   if ( NULL != sys_info_tdscdma )
                   {
                       QCRIL_LOG_INFO( "... hs_ind_valid, hs_ind %d, %d", (int)sys_info_tdscdma->hs_ind_valid, (int)sys_info_tdscdma->hs_ind );
                       QCRIL_LOG_INFO( "... hs_call_status_valid, hs_call_status %d, %d", (int)sys_info_tdscdma->hs_call_status_valid, (int)sys_info_tdscdma->hs_call_status );
                       if ( sys_info_tdscdma->hs_ind_valid && sys_info_tdscdma->hs_call_status_valid )
                       {
                         if( sys_info_tdscdma->hs_ind > sys_info_tdscdma->hs_call_status )
                         {
                           loc_hs_ser = sys_info_tdscdma->hs_ind;
                         }
                         else
                         {
                           loc_hs_ser = sys_info_tdscdma->hs_call_status;
                         }
                       }
                       else if ( sys_info_tdscdma->hs_ind_valid )
                       {
                         loc_hs_ser = sys_info_tdscdma->hs_ind;
                       }
                       else if ( sys_info_tdscdma->hs_call_status_valid )
                       {
                         loc_hs_ser = sys_info_tdscdma->hs_call_status;
                       }

                       switch ( loc_hs_ser )
                       {
                         case SYS_HS_IND_HSDPA_SUPP_CELL_V01:          // fallthrough
                             val_int = RADIO_TECH_HSDPA;
                             break;

                         case SYS_HS_IND_HSUPA_SUPP_CELL_V01:
                             val_int = RADIO_TECH_HSUPA;
                             break;

                         case SYS_HS_IND_HSDPA_HSUPA_SUPP_CELL_V01:
                             val_int = RADIO_TECH_HSPA;
                             break;

                         case SYS_HS_IND_HSDPAPLUS_SUPP_CELL_V01:      // fallthrough
                         case SYS_HS_IND_HSDPAPLUS_64QAM_SUPP_CELL_V01:// fallthrough
                         case SYS_HS_IND_DC_HSDPAPLUS_SUPP_CELL_V01:   // fallthrough
                         case SYS_HS_IND_HSDPAPLUS_HSUPA_SUPP_CELL_V01:    // fallthrough
                         case SYS_HS_IND_DC_HSDPAPLUS_HSUPA_SUPP_CELL_V01: // fallthrough
                         case SYS_HS_IND_HSDPAPLUS_64QAM_HSUPA_SUPP_CELL_V01:
                             val_int = RADIO_TECH_HSPAP;
                             break;

                         default:
                             // no change, RADIO_TECH_TD_SCDMA by default
                             break;
                       }
                   }
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_5G:
                   val_int = RADIO_TECH_5G;
                   break;

               case QCRIL_ARB_PREF_DATA_TECH_UNKNOWN:    // fallthrough
               default:
                   val_int = RADIO_TECH_UNKNOWN;
                   break;
           }
           }
           QCRIL_LOG_INFO("... cur tech %d", (int) val_int );
           // RIL resp filling: data radio technology
           ril_resp_helper.rat = (RIL_RadioTechnology)val_int;
           NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_technology, val_int);
           local_reg_snapshot.data_radio_tech = val_int;
       } // if is_registered
       else
       {
         // * reg reject
         if ( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_rejected )
         {
           val_int = qmi_ril_nwr_conv_reg_reject_cause_data( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_reject_cause, vrte_mapper );
           qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, (qmi_ril_nw_reg_rte_type) vrte_mapper, QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED );
         }
         else
         {
           val_int = NAS_NIL;
         }
         // RIL resp filling: data denied reason
         ril_resp_helper.reasonDataDenied = val_int;
       }

       // data reg snapshot work out
       QCRIL_LOG_INFO(".. prestored reg snapshot valid %d while cur reg %d", (int) nas_cached_info.data_reg_report_snapshot.valid, is_registered );

       if ( is_registered )
       { // refer to prestored snapshot on next occasions
           local_reg_snapshot.valid = TRUE;
       }
       else if ( nas_cached_info.data_reg_report_snapshot.valid && nas_common_info.data_snapshot_feature_enabled )
       { // report prestored snapshot vector
           ril_resp_helper.regState = (RIL_RegState)nas_cached_info.data_reg_report_snapshot.registration_state;
           ril_resp_helper.rat = (RIL_RadioTechnology)nas_cached_info.data_reg_report_snapshot.data_radio_tech;
           qcril_qmi_nas_restore_cell_indentity_from_snapshot(qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(
                 data_tech_to_report), &ril_resp_helper.cellIdentity, &nas_cached_info.data_reg_report_snapshot);

           NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_technology, nas_cached_info.data_reg_report_snapshot.data_radio_tech);
           NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_reg_status, nas_cached_info.data_reg_report_snapshot.registration_state);
       }

       if ( !is_registered )
       {
           nas_cached_info.data_reg_roaming_status_latest_val = FALSE;
       }

       // Populate LTE VoPS indicators
       if (ril_resp_helper.rat == RADIO_TECH_LTE && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_ims_voice_avail)) {
           ril_resp_helper.lteVopsInfoValid = 1;
           ril_resp_helper.lteVopsInfo.isVopsSupported = nas_cached_info.lte_ims_voice_avail;
       }

       if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_is_eb_supported)) {
           ril_resp_helper.lteVopsInfoValid = 1;
           switch (nas_cached_info.lte_is_eb_supported) {
               case NAS_TRI_TRUE_V01:
                   ril_resp_helper.lteVopsInfo.isEmcBearerSupported = 1;
                   break;
               default:
                   ril_resp_helper.lteVopsInfo.isEmcBearerSupported = 0;
                   break;
           }
       }

       if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.plmn_infolist_r15_available) ||
               NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available) ||
               NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.restrict_dcnr))
       {
           ril_resp_helper.nrIndicatorsValid = 1;

           if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.plmn_infolist_r15_available))
           {
               ril_resp_helper.nrIndicators.plmnInfoListR15Available = nas_cached_info.plmn_infolist_r15_available;
           }

           if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available))
           {
               ril_resp_helper.nrIndicators.isEndcAvailable = nas_cached_info.endc_available;
           }

           if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.restrict_dcnr))
           {
               ril_resp_helper.nrIndicators.isDcNrRestricted = nas_cached_info.restrict_dcnr;
           }
       }

       QCRIL_LOG_INFO("considered data technology valid %d, value %d", NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.considered_data_technology), nas_cached_info.considered_data_technology);
       QCRIL_LOG_INFO("reported data technology %d", nas_cached_info.reported_data_technology);
       qcril_qmi_nas_data_update_mtu_size_if_needed(prev_reported_state_valid,
                                                    prev_reported_state,
                                                    prev_reported_tech_valid,
                                                    prev_reported_tech);
       NAS_CACHE_UNLOCK();
   }

   // RIL resp filling: maximum data calls
   ril_resp_helper.maxDataCalls = NAS_REG_DATA_MAX_DATA_CALLS;

   // save snapshot if applicable
   QCRIL_LOG_INFO("snapshot valid %d", (int) local_reg_snapshot.valid  );
   QCRIL_LOG_INFO("is snapshot feature enabled %d", (int) nas_common_info.data_snapshot_feature_enabled  );
   if ( local_reg_snapshot.valid )
   {
       NAS_CACHE_LOCK();

       if ( !pref_data.is_extrapolation || NAS_NIL == nas_cached_info.data_reg_report_expiry )
       {
           QCRIL_LOG_INFO("launching extrapolation expry tmr" );
           if ( NAS_NIL != nas_cached_info.data_reg_report_expiry )
           {
               QCRIL_LOG_INFO("stopping outdated tmr" );
               qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
               nas_cached_info.data_reg_report_expiry = NAS_NIL;
           }

           if ( pref_data.is_current && qmi_ril_nwreg_spawn_snapshot_timer_cl( FALSE ) )
           {
               nas_cached_info.data_reg_report_snapshot = local_reg_snapshot;
           }

       }
       else
       {
           QCRIL_LOG_INFO("extrapolation expry tmr already oustanding or inapplicable, no recursing" );
       }

       NAS_CACHE_UNLOCK();
   }

   if (nas_common_info.data_snapshot_feature_enabled)
   {
       if (pref_data.is_extrapolation &&
           nas_cached_info.data_reg_report_snapshot.valid)
       {
           /* reporting snapshot rat to Telephony. Don't let
            * Setup Data Call to come down */
           if (!qcril_request_check_if_suppressed(RIL_REQUEST_SETUP_DATA_CALL, NULL))
           {
               qcril_request_suppress_request(
                         RIL_REQUEST_SETUP_DATA_CALL,
                         qcril_qmi_nas_request_setup_data_call_suppress_handler);
           }
       }
       else
       {
           /* stopped reporting snapshot rat to Telephony. Let
            * Setup Data Call to come down */
           qcril_request_unsuppress_request(
                         RIL_REQUEST_SETUP_DATA_CALL,
                         qcril_qmi_nas_request_setup_data_call_suppress_handler);
       }
   }
  }

  NAS_CACHE_UNLOCK();

  // ** snapshot processing
  if (RIL_E_SUCCESS == ril_req_res) {
    qcril_qmi_nas_dump_data_registration_state(&ril_resp_helper);
    if(nas_common_info.is_snapshot_reported_data_reg_state &&
            nas_cached_info.is_proper_data_reg_to_report) {
        memcpy(&nas_cached_info.reported_data_reg_state_snapshot, &ril_resp_helper,
            sizeof(RIL_DataRegistrationStateResponse));
    }
  } else if (nas_common_info.is_snapshot_reported_data_reg_state) {
      memset(&nas_cached_info.reported_data_reg_state_snapshot, 0,
          sizeof(RIL_DataRegistrationStateResponse));
  }

  if(!nas_common_info.is_snapshot_reported_data_reg_state ||
      nas_cached_info.is_proper_data_reg_to_report)
  {
    QCRIL_LOG_INFO("reported pref data tech %s", qcril_qmi_util_retrieve_pref_data_tech_name(
        pref_data.pref_data_tech));
    NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_pref_data_technology,
        pref_data.pref_data_tech);
  }

  // ** respond
  QCRIL_LOG_INFO("complete with %d", (int) ril_req_res  );
  if (RIL_E_SUCCESS == ril_req_res) {
      std::shared_ptr<qcril::interfaces::RilGetDataRegResult_t> shared_resp(respPayload);
      auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, shared_resp);
      msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  } else {
      delete respPayload;
      msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
            std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
  }

  // NOTE: current implementation ensures that all responses are sent back in ONE thread
  // after calling qcril_send_request_response()
  qcril_unsuppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_unsuppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());

  if(!nas_common_info.is_snapshot_reported_data_reg_state ||
      nas_cached_info.is_proper_data_reg_to_report)
  {
    if ( must_rerender_data_reg_report )
    {
      QCRIL_LOG_INFO("will arrange rerender data reg report" );

      qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                            QCRIL_DEFAULT_MODEM_ID,
                            qmi_ril_nw_reg_redo_data_reg_report,
                            NULL,  // immediate
                            NULL );

    }
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_request_data_registration_state

//===========================================================================
// qcril_qmi_nas_retrieve_reported_data_technology
//===========================================================================
int qcril_qmi_nas_retrieve_reported_data_technology()
{
    int reported_data_technology;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    reported_data_technology = nas_cached_info.reported_data_technology;
    NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN_WITH_RET(reported_data_technology);
   return reported_data_technology;
} //qcril_qmi_nas_retrieve_reported_data_technology

//===========================================================================
// qmi_ril_nwreg_spawn_snapshot_timer_cl
//===========================================================================
int qmi_ril_nwreg_spawn_snapshot_timer_cl( int is_maintanance )
{
    uint32              snapshot_validity_window_tmr = 0;
    struct timeval      snapshot_validity_window_frame;
    int                 spawn_snapshot_timer;

    if( nas_common_info.data_snapshot_timer_value_valid )
    {
        if ( nas_common_info.data_snapshot_timer_value > NAS_NIL )
        {
            snapshot_validity_window_frame.tv_sec  = nas_common_info.data_snapshot_timer_value;
            snapshot_validity_window_frame.tv_usec = NAS_NIL;
            spawn_snapshot_timer                   = TRUE;
        }
        else
        { // zero effectively disables snapshot timer
            spawn_snapshot_timer = FALSE;
        }
    }
    else
    {
        snapshot_validity_window_frame.tv_sec  = 22; //default value - 22 seconds
        snapshot_validity_window_frame.tv_usec = NAS_NIL;
        spawn_snapshot_timer                   = TRUE;
    }

    if ( spawn_snapshot_timer && is_maintanance )
    { // maintanance mode - not user's setting, not default setting but a large time window
        snapshot_validity_window_frame.tv_sec  = 24 * 60 * 60; // 24 hours
        snapshot_validity_window_frame.tv_usec = NAS_NIL;
    }

    QCRIL_LOG_INFO("snapshot tmr action %d", spawn_snapshot_timer );

    if ( spawn_snapshot_timer )
    {
        qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_DEFAULT_MODEM_ID,
                                      qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler,
                                      &snapshot_validity_window_frame,
                                      &snapshot_validity_window_tmr );

        nas_cached_info.data_reg_report_expiry   = snapshot_validity_window_tmr;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET( spawn_snapshot_timer );
    return spawn_snapshot_timer;
} // qmi_ril_nwreg_spawn_snapshot_timer_cl

//===========================================================================
// qmi_ril_nw_reg_data_sys_update_pre_update_action
//===========================================================================
void qmi_ril_nw_reg_data_sys_update_pre_update_action( void )
{
    NAS_CACHE_LOCK();

    QCRIL_LOG_INFO("snapshot tmr 0x%x, snapshot valid %d", nas_cached_info.data_reg_report_expiry, nas_cached_info.data_reg_report_snapshot.valid );
    if ( NAS_NIL != nas_cached_info.data_reg_report_expiry && nas_cached_info.data_reg_report_snapshot.valid )
    {
          qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
          nas_cached_info.data_reg_report_expiry = NAS_NIL;

          (void)qmi_ril_nwreg_spawn_snapshot_timer_cl( FALSE );
    }

    NAS_CACHE_UNLOCK();

} // qmi_ril_nw_reg_data_sys_update_pre_update_action

//===========================================================================
// qmi_ril_nw_reg_extend_pref_data_tech_cl
//===========================================================================
void qmi_ril_nw_reg_extend_pref_data_tech_cl( qcril_arb_pref_data_type * pref_data, int * is_extrapolation, int * extrapolation_is_roaming )
{
  int                       need_reset;
  qcril_uim_card_status_e_type  card_status;
  int                       card_ever_present;
  int                       local_is_extrapolation;
  int                       local_extrapolation_is_roaming;
  uint32_t                  slot = 0;

  QCRIL_LOG_FUNC_ENTRY();

  local_is_extrapolation         = FALSE;
  local_extrapolation_is_roaming = FALSE;

  if ( pref_data )
  {
    need_reset = FALSE;

    slot = qmi_ril_get_sim_slot();
    card_status        = nas_common_info.card_info[slot].status;
    card_ever_present  = nas_common_info.card_info[slot].card_ever_present;

    QCRIL_LOG_INFO( "is extrapolation %d, cache is valid %d, cache rat %d, oprt valid %d, oprt %d, card status %d, card ever present %d, ban %d, mpv %d, mp %d",
                    (int)pref_data->is_extrapolation,
                    (int)nas_cached_info.data_reg_report_snapshot.valid,
                    (int)nas_cached_info.data_reg_report_snapshot.data_radio_tech,
                    NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ),
                    (int)nas_dms_cached_info.operating_mode,
                    (int)card_status,
                    card_ever_present,
                    (int)nas_cached_info.extrapolation_ban_expiry,
                    NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref),
                    (int)nas_cached_info.mode_pref );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) &&
         DMS_OP_MODE_ONLINE_V01 != nas_dms_cached_info.operating_mode &&
         RADIO_TECH_IWLAN != pref_data->radio_technology )
    { // reset when not ONLINE
      need_reset = TRUE;
    }
    if ( pref_data->is_extrapolation )
    { // extrapolation behavior

      local_is_extrapolation = TRUE;

      if ( nas_cached_info.data_reg_report_snapshot.valid && RIL_VAL_REG_REGISTERED_ROAMING == nas_cached_info.data_reg_report_snapshot.registration_state )
      {
          local_extrapolation_is_roaming = TRUE;
      }

      // reset if snapshot and expired
      if ( !nas_cached_info.data_reg_report_snapshot.valid || (int)nas_cached_info.data_reg_report_snapshot.data_radio_tech != (int)pref_data->radio_technology )
      {
        need_reset = TRUE;
      }
      // reset if card absent
      if ( card_ever_present && (QCRIL_CARD_STATUS_UP != card_status) )
      {
          need_reset = TRUE;
      }
      // reset if GLW or its subset
      if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) && ( NAS_NIL == ( QMI_NAS_RAT_MODE_PREF_CDMA_HRPD & nas_cached_info.mode_pref ) ) )
      {
          need_reset = TRUE;
      }
      // reset if extrapolation banned
      if ( NAS_NIL != nas_cached_info.extrapolation_ban_expiry )
      {
          need_reset = TRUE;
      }
      // reset if subscription is deactivated
      if (nas_cached_info.dsds_is_active_valid && !nas_cached_info.dsds_is_active)
      {
          need_reset = TRUE;
      }
      // reset if DDS changed
      if( (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref)) ||
          ( nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_ONLY_V01 )
        )
      {
          need_reset = TRUE;
      }
    }

    QCRIL_LOG_INFO( "need reset %d", need_reset );
    if ( need_reset )
    {
      pref_data->radio_technology = RADIO_TECH_UNKNOWN;
      pref_data->is_current       = FALSE;  // this will force to use QMI NAS info for previously camped CnE RAT

      local_is_extrapolation            = FALSE;
      local_extrapolation_is_roaming    = FALSE;

      // Clear the snapshot info and cancel timer as DDS changed
      qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
      qcril_qmi_arb_reset_pref_data_snapshot();
    }

    QCRIL_LOG_INFO( "RAT %d, is current %d, is_extrapolation %d, is_extrap_roaming %d",
                    (int)pref_data->radio_technology,
                    (int)pref_data->is_current,
                    local_is_extrapolation,
                    local_extrapolation_is_roaming
                     );

    if ( NULL != is_extrapolation )
    {
        *is_extrapolation = local_is_extrapolation;
    }
    if ( NULL != extrapolation_is_roaming )
    {
        *extrapolation_is_roaming = local_extrapolation_is_roaming;
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_extend_pref_data_tech_cl

//===========================================================================
// qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation
//===========================================================================
void qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation_ncl()
{
    const struct timeval ban_timeout = {10 , 0}; // 10 seconds
    uint32 timeout_watch;
    int    timeout_set_res;

    QCRIL_LOG_FUNC_ENTRY();

    timeout_watch = 0;
    NAS_CACHE_LOCK();
    if ( NAS_NIL != nas_cached_info.extrapolation_ban_expiry )
    {
        qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.extrapolation_ban_expiry );
        nas_cached_info.extrapolation_ban_expiry = NAS_NIL;
    }
    NAS_CACHE_UNLOCK();

    timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                  QCRIL_DEFAULT_MODEM_ID,
                                                  qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired,
                                                  &ban_timeout,
                                                  &timeout_watch );
    if ( E_SUCCESS == timeout_set_res && NAS_NIL != timeout_watch )
    {
        NAS_CACHE_LOCK();
        nas_cached_info.extrapolation_ban_expiry = timeout_watch;
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation
//===========================================================================
// qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired
//===========================================================================
void qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.extrapolation_ban_expiry = NAS_NIL;
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_wave_voice_data_status();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired

//===========================================================================
// qmi_ril_nw_reg_redo_data_reg_report
//===========================================================================
void qmi_ril_nw_reg_redo_data_reg_report(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    qcril_qmi_nas_wave_voice_data_status();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_redo_data_reg_report


//===========================================================================
// qcril_qmi_nas_util_check_request_need
//===========================================================================
int qcril_qmi_nas_util_check_request_need(qcril_arb_pref_data_tech_e_type pref_data_tech, qmi_ril_nw_reg_rte_type drte)
{
  int qmi_request_need;

  QCRIL_LOG_FUNC_ENTRY();

  if( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data_tech )
  {
    switch ( pref_data_tech )
    {
        case QCRIL_ARB_PREF_DATA_TECH_CDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_GSM:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_UMTS:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_LTE:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_is_eb_supported ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_access_barred )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_5G:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info) &&
                NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info)
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_EVDO:
        case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info )
                ) ? FALSE : TRUE;
            break;

        default:
            qmi_request_need = FALSE; // if unknown
            break;
    }
  }
  else
  {
    switch ( drte )
    {
        case QMI_RIL_RTE_1x:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_GSM:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_WCDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_TDSCDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_SUB_LTE:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_is_eb_supported ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_access_barred )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_SUB_NR5G:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info) &&
                NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info)
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_SUB_DO:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info )
                ) ? FALSE : TRUE;
            break;

        default:
            qmi_request_need = TRUE; // data rte is unknown, let's refetch QMI NAS info and reevaluate that
            break;
    }
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(qmi_request_need);
  return qmi_request_need;
} //qcril_qmi_nas_util_check_request_need

//===========================================================================
// qcril_qmi_nas_util_check_roaming_status
//===========================================================================
int qcril_qmi_nas_util_check_roaming_status(qcril_arb_pref_data_tech_e_type pref_data_tech, int * data_reg_status, int *confident_response )
{
  int                            res;
  nas_common_sys_info_type_v01 * common_sys_info = NULL;
  int                            local_confident_response;

  QCRIL_LOG_FUNC_ENTRY();

  local_confident_response = FALSE;

  if ( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data_tech &&
       QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data_tech &&
       NULL != data_reg_status &&
       (RIL_VAL_REG_REGISTERED_HOME_NET == data_reg_status [ pref_data_tech ] || RIL_VAL_REG_REGISTERED_ROAMING == data_reg_status [ pref_data_tech ] ) )
  {
    switch ( pref_data_tech )
    {
        case QCRIL_ARB_PREF_DATA_TECH_CDMA:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_GSM:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_UMTS:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_LTE:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_EVDO:
        case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_5G:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->common_sys_info : NULL;
            break;

        default:
            common_sys_info = NULL;
            break;
    }

    if ( NULL != common_sys_info &&
         common_sys_info->roam_status_valid )
    {
        if ( ( NAS_SYS_ROAM_STATUS_OFF_V01 == common_sys_info->roam_status ) ||
             ( ( ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_64 == common_sys_info->roam_status ) ||
                 ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_65 == common_sys_info->roam_status ) ||
                 ( (common_sys_info->roam_status >= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_76 ) &&
                   (common_sys_info->roam_status <= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_83 )
                 ) ) && nas_common_info.eri_64_home )
           )
        {
             res = RIL_VAL_REG_REGISTERED_HOME_NET;
        }
        else
        {
            res = RIL_VAL_REG_REGISTERED_ROAMING;
        }
        local_confident_response = TRUE;
    }
    else
    {
        res = RIL_VAL_REG_REGISTERED_HOME_NET;
    }
  }
  else if ( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data_tech &&
            QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data_tech )
  {
    local_confident_response = qcril_qmi_nas_decide_data_roam_status(pref_data_tech, &res);
  }
  else
  {
    res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
  }

  QCRIL_LOG_INFO( ".. data roam determination confidence %d", local_confident_response );
  if ( NULL != confident_response )
  {
      *confident_response = local_confident_response;
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} //qcril_qmi_nas_util_check_roaming_status

//===========================================================================
// qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler
//===========================================================================
void qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler(void * param)
{
    int                             need_update;
    int                             need_keep_guard;
    qcril_arb_pref_data_type        pref_data;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    qcril_qmi_get_pref_data_tech( &pref_data );

    NAS_CACHE_LOCK();

    nas_cached_info.data_reg_report_expiry = NAS_NIL;

    need_update         = nas_cached_info.data_reg_report_snapshot.valid && pref_data.is_extrapolation;

    need_keep_guard     = // snapshot is still valid
                          nas_cached_info.data_reg_report_snapshot.valid &&
                         // not extrapolated as if extrapolated we do not extended timer
                         !pref_data.is_extrapolation &&
                         // radio technology is known
                         ( RADIO_TECH_UNKNOWN != pref_data.radio_technology ) &&
                         // not subset of GWL so extrapolation is of use
                         ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) && ( NAS_NIL != ( QMI_NAS_RAT_MODE_PREF_CDMA_HRPD & nas_cached_info.mode_pref ) ) );

    QCRIL_LOG_INFO("is cache still valid %d, pref data tech is extrap %d, need upd %d, need peep guard %d",
                   (int) nas_cached_info.data_reg_report_snapshot.valid,
                   (int) pref_data.is_extrapolation,
                   need_update,
                   need_keep_guard );

    if ( need_keep_guard )
    {
        (void)qmi_ril_nwreg_spawn_snapshot_timer_cl( TRUE );
    }
    else
    {
        nas_cached_info.data_reg_report_snapshot.valid = FALSE;
    }

    NAS_CACHE_UNLOCK();

    if ( need_update )
    {
        qcril_qmi_nas_wave_voice_data_status();
        qcril_qmi_drop_sig_info_cache();
        qcril_qmi_nas_send_known_signal_strength();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler

//===========================================================================
// qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler
//===========================================================================
void qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestSetPrefNetworkTypeMessage::get_class_message_id());

    if ((pendingMsg != nullptr ) && (FALSE == nas_cached_info.is_indication_received))
    {
      auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            RIL_E_MODEM_ERR, nullptr);
      auto setMsg = std::static_pointer_cast<RilRequestSetPrefNetworkTypeMessage>(pendingMsg);
      setMsg->sendResponse(setMsg, Message::Callback::Status::SUCCESS, respData);
      msgList.erase(pendingMsg);
    }

    nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
}//qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler

//===========================================================================
// qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler
//===========================================================================
void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler(void * param)
{
    int                             nof_data_calls;
    int                             need_invalidate;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    need_invalidate = FALSE;

    nof_data_calls = NasDataCache::getInstance().getNumDataCalls();
    QCRIL_LOG_INFO("nof data calls %d", (int) nof_data_calls );

    if ( NAS_NIL == nof_data_calls )
    {
        NAS_CACHE_LOCK();
        if ( nas_cached_info.data_reg_report_snapshot.valid )
        {
            if ( NAS_NIL != nas_cached_info.data_reg_report_expiry )
            {
                qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
                nas_cached_info.data_reg_report_expiry = NAS_NIL;
            }
            nas_cached_info.data_reg_report_snapshot.valid = FALSE;

            need_invalidate = TRUE;
        }
        NAS_CACHE_UNLOCK();
    }

    if ( need_invalidate )
    {
        qcril_qmi_nas_wave_voice_data_status();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler

//===========================================================================
// qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler
//===========================================================================
void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler(void * param)
{
    int                             nof_data_calls;
    int                             need_revalidate;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    need_revalidate = FALSE;

    nof_data_calls = NasDataCache::getInstance().getNumDataCalls();
    QCRIL_LOG_INFO("nof data calls %d", (int) nof_data_calls );

    if ( nof_data_calls > NAS_NIL )
    {
        NAS_CACHE_LOCK();
        if ( !nas_cached_info.data_reg_report_snapshot.valid )
        {
            need_revalidate = TRUE;
        }
        NAS_CACHE_UNLOCK();
    }

    if ( need_revalidate )
    {
        qcril_qmi_nas_wave_voice_data_status();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler
//===========================================================================
// qcril_qmi_util_retrieve_technology_name
//===========================================================================
const char* qcril_qmi_util_retrieve_technology_name(int technology)
{
  // TODO: Use a map for this translation instead of an array to make element
  // TODO: accesses less prone to crash.
  if( technology >= RADIO_TECH_UNKNOWN && technology <= RADIO_TECH_MAX )
  {
    return radio_tech_name[technology];
  }
  else
  {
    return radio_tech_name[sizeof(radio_tech_name) / sizeof(*radio_tech_name) - 1];
  }
} //qcril_qmi_util_retrieve_technology_name

//===========================================================================
// qcril_qmi_util_retrieve_regstate_name
//===========================================================================
const char* qcril_qmi_util_retrieve_regstate_name(RIL_RegState reg)
{
  switch (reg) {
  case RIL_NOT_REG_AND_NOT_SEARCHING:
    return "Not Registered, Not Searching";
  case RIL_REG_HOME:
    return "Home Service";
  case RIL_NOT_REG_AND_SEARCHING:
    return "Not Registered, Searching";
  case RIL_REG_DENIED:
    return "Registration Denied";
  case RIL_UNKNOWN:
    return "Unknown";
  case RIL_REG_ROAMING:
    return "Roaming Service";
  case RIL_NOT_REG_AND_EMERGENCY_AVAILABLE_AND_NOT_SEARCHING:
    return "Not Registered, Not Searching, Emergency Available";
  case RIL_NOT_REG_AND_EMERGENCY_AVAILABLE_AND_SEARCHING:
    return "Not Registered, Searching, Emergency Available";
  case RIL_REG_DENIED_AND_EMERGENCY_AVAILABLE:
    return "Registration Denied, Emergency Available";
  case RIL_UNKNOWN_AND_EMERGENCY_AVAILABLE:
    return "Unknown, Emergency Available";
  default:
    return "Unknown";
  }
}

//===========================================================================
// qcril_qmi_util_retrieve_pref_data_tech_name
//===========================================================================
const char* qcril_qmi_util_retrieve_pref_data_tech_name(int pref_data_tech)
{
  if( pref_data_tech >= QCRIL_ARB_PREF_DATA_TECH_INVALID && pref_data_tech <= QCRIL_ARB_PREF_DATA_TECH_5G )
  {
    return pref_data_tech_name[pref_data_tech + 1];
  }
  else
  {
    return pref_data_tech_name[QCRIL_ARB_PREF_DATA_TECH_MAX + 1];
  }
} //qcril_qmi_util_retrieve_pref_data_tech_name

//===========================================================================
// qmi_ril_nwr_conv_reg_reject_cause_lte
//===========================================================================
int qmi_ril_nwr_conv_reg_reject_cause_lte(uint8_t org_cause)
{
    int res;

    switch( org_cause )
    {
        case 2:   //IMSI unknown in HSS
        case 3:   //Illegal UE
        case 6:   //Illegal ME
        case 9:   //UE identity cannot be derived by the network
        case 10:  //Implicitly detached
        case 5:   //IMEI not accepted
        case 7:   //EPS services not allowed
        case 8:   //EPS services and non-EPS services not allowed
        case 11:  //PLMN not allowed
        case 12:  //Tracking area not allowed
        case 13:  //Roaming not allowed in this tracking area
        case 14:  //EPS services not allowed in this PLMN
        case 15:  //No suitable cells in tracking area
        case 25:  //Not authorized for this CSG
        case 35:  //Requested service option not authorized
        case 40:  //No EPS bearer context activated
        case 16:  //MSC temporarily not reachable
        case 17:  //Network failure
        case 18:  //CS domain not available
        case 19:  //ESM failure
        case 20:  //MAC failure
        case 21:  //Synch failure
        case 22:  //Congestion
        case 23:  //UE security capabilities mismatch
        case 24:  //Security mode rejected, unspecified
        case 26:  //Non-EPS authentication unacceptable
        case 39:  //CS service temporarily not available
        case 95:  //Semantically incorrect message
        case 96:  //Invalid mandatory information
        case 97:  //Message type non-existent or not implemented
        case 98:  //Message type not compatible with protocol state
        case 99:  //Information element non-existent or not implemented
        case 100: //Conditional IE error
        case 101: //Message not compatible with protocol state
        case 111: //Protocol error, unspecified
            res = (int) org_cause;
            break;

        default: // Unspecified failure
            res = 0;
            break;
    }

    return res;
} // qmi_ril_nwr_conv_reg_reject_cause_lte

//===========================================================================
// qmi_ril_nwr_conv_reg_reject_cause_data
//===========================================================================
int qmi_ril_nwr_conv_reg_reject_cause_data(uint8_t org_cause, uint8_t radio_if)
{
    int res;

    if( QMI_RIL_RTE_SUB_LTE == radio_if )
    {
        res = qmi_ril_nwr_conv_reg_reject_cause_lte( org_cause );
    }
    else
    {
        switch ( org_cause )
        {
          case 2 :  // IMSI Unknown
          case 7 :  // GPRS services not allowed
          case 8 :  // GPRS services and non-GPRS services not allowed
          case 9 :  // MS identity cannot be derived by the network
          case 10:  // Implicitly detached
          case 14:  // GPRS services not allowed in this PLMN
          case 16:  // MSC temporarily not reachable
          case 40:  // No PDP context activated
              res = (int) org_cause;
              break;

          default: // Unspecified failure
              res = 0;
              break;
        }
    }

    return res;
} // qmi_ril_nwr_conv_reg_reject_cause_data


//===========================================================================
// qcril_qmi_nas_util_determine_hdr_rev
//===========================================================================
int qcril_qmi_nas_util_determine_hdr_rev(nas_hdr_only_sys_info_type_v01 * hdr_details_info)
{
    int res = RADIO_TECH_EVDO_0;

    QCRIL_LOG_INFO("hdr_details_info %p", hdr_details_info);
    if ( hdr_details_info )
    {
        QCRIL_LOG_INFO("hdr_personality_valid, hdr_personality %d, %d",
                                 (int) hdr_details_info->hdr_personality_valid,
                                 (int) hdr_details_info->hdr_personality );
        QCRIL_LOG_INFO("hdr_active_prot_valid, hdr_active_prot %d, %d",
                                 (int) hdr_details_info->hdr_active_prot_valid,
                                 (int) hdr_details_info->hdr_active_prot);

        if (( hdr_details_info->hdr_personality_valid ) &&
            (hdr_details_info->hdr_personality == NAS_SYS_PERSONALITY_EHRPD_V01))
        {
            res = RADIO_TECH_EHRPD;
        }
        else if ( hdr_details_info->hdr_active_prot_valid )
        {
            switch (hdr_details_info->hdr_active_prot)
            {
                case NAS_SYS_ACTIVE_PROT_HDR_RELA_V01:
                    res = RADIO_TECH_EVDO_A;
                    break;

                case NAS_SYS_ACTIVE_PROT_HDR_RELB_V01:
                    res = RADIO_TECH_EVDO_B;
                    break;

                default:
                    /* No Action, as default value is already taken care
                       as part of initialization */
                    break;
            }
        }
    }

    return res;
} // qcril_qmi_nas_util_determine_hdr_rev

//===========================================================================
// qcril_qmi_nas_util_determine_cdma_rev
//===========================================================================
int qcril_qmi_nas_util_determine_cdma_rev(nas_cdma_only_sys_info_type_v01 * cdma_details_info)
{
    int res;

    QCRIL_LOG_INFO("cdma_details_info %p", cdma_details_info );
    if ( cdma_details_info )
    {
        QCRIL_LOG_INFO("bs_p_rev_valid, bs_p_rev %d, %d", (int) cdma_details_info->bs_p_rev_valid, (int) cdma_details_info->bs_p_rev  );
        QCRIL_LOG_INFO("p_rev_in_use_valid, p_rev_in_use %d, %d", (int) cdma_details_info->p_rev_in_use_valid, (int) cdma_details_info->p_rev_in_use  );
    }
    if ( cdma_details_info && cdma_details_info->p_rev_in_use_valid )
    {
        res = qcril_qmi_util_determine_cdma_rev_direct( cdma_details_info->p_rev_in_use );
    }
    else
    {
        res = RADIO_TECH_IS95A; // by default
    }

    return res;
} // qcril_qmi_nas_util_determine_cdma_rev
//===========================================================================
// qcril_qmi_util_determine_cdma_rev_direct
//===========================================================================
int qcril_qmi_util_determine_cdma_rev_direct( uint8_t p_rev )
{
    int res;
    if ( p_rev >= 6 )
    {
        res = RADIO_TECH_1xRTT;
    }
    else if ( p_rev >= 4  )
    {
        res = RADIO_TECH_IS95B;
    }
    else
    {
        res = RADIO_TECH_IS95A;
    }
    return res;
} // qcril_qmi_util_determine_cdma_rev_direct

//===========================================================================
// qcril_qmi_util_retrieve_srv_status
//===========================================================================
nas_service_status_enum_type_v01 qcril_qmi_util_retrieve_srv_status(nas_sys_info_helper_type * nas_sys_info_helper, int is_3gpp)
{
    nas_service_status_enum_type_v01 nas_srv_status;

    nas_srv_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    if( NULL != nas_sys_info_helper )
    {
        if( is_3gpp )
        {
            if( nas_sys_info_helper->threegpp_srv_status )
            {
                nas_srv_status = nas_sys_info_helper->threegpp_srv_status->srv_status;
            }
            else
            {
                QCRIL_LOG_DEBUG("3gpp srv status info absent");
            }
        }
        else
        {
            if( nas_sys_info_helper->threegpp2_srv_status )
            {
                nas_srv_status = nas_sys_info_helper->threegpp2_srv_status->srv_status;
            }
            else
            {
                QCRIL_LOG_DEBUG("3gpp2 srv status info absent");
            }
        }
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED - nas_sys_info_helper is NULL");
    }

    QCRIL_LOG_DEBUG("completed with %d",(int) nas_srv_status);

    return nas_srv_status;
} //qcril_qmi_util_retrieve_srv_status

//===========================================================================
// qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info
//===========================================================================
void qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info( int is_data,
                                                             int * res,
                                                             nas_reg_reject_info_type_v01 * reg_reject_info,
                                                             qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results )
{

    QCRIL_LOG_FUNC_ENTRY();
    if( reg_reject_info )
    {
        if ( is_data )
        { // data
            switch ( reg_reject_info->reject_srv_domain )
            {
                case SYS_SRV_DOMAIN_PS_ONLY_V01:    // fallthrough
                case SYS_SRV_DOMAIN_CS_PS_V01:
                    switch ( reg_reject_info->rej_cause)
                    {
                        case IMSI_UNKNOWN_IN_HLR:
                        case ILLEGAL_MS:
                        case ILLEGAL_ME:
                        case GPRS_SERVICES_NOT_ALLOWED:
                        case GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED:
                        case PLMN_NOT_ALLOWED:
                        case LA_NOT_ALLOWED:
                        case NATIONAL_ROAMING_NOT_ALLOWED:
                        case GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN:
                        case NO_SUITABLE_CELLS_IN_LA:
                        case CSG_NOT_AUTHORIZED:
                            *res = RIL_VAL_REG_REGISTRATION_DENIED;
                            break;

                        case QCRIL_REJECT_CAUSE_NETWORK_FAIL:
                            // Force no service on reject cause 17 only when property is set to true.
                            // If no service is sent this is failing 3GPP TS51.010-1 26.7.4.3.4.
                            if (nas_common_info.force_no_srv_on_rej_reject_17 == TRUE)
                            {
                                *res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
                            }

                            break;

                        default:
                             //no action
                            break;
                    }

                    if ( extra_results )
                    {
                        extra_results->is_reject_case      = TRUE;
                        extra_results->is_managed_roaming  = FALSE;
                        extra_results->reject_cause        = reg_reject_info->rej_cause;
                    }
                    break;

                case SYS_SRV_DOMAIN_NO_SRV_V01:
                case SYS_SRV_DOMAIN_CAMPED_V01:
                    // skip for data
                    break;

                default:
                    // no action
                    break;
            }
        }
        else
        { // voice
            switch ( reg_reject_info->reject_srv_domain )
            {
                case SYS_SRV_DOMAIN_CS_ONLY_V01:    // fallthrough
                case SYS_SRV_DOMAIN_CS_PS_V01:
                case SYS_SRV_DOMAIN_NO_SRV_V01:
                case SYS_SRV_DOMAIN_CAMPED_V01:
                    switch ( reg_reject_info->rej_cause)
                    {
                        case IMSI_UNKNOWN_IN_HLR:
                        case ILLEGAL_MS:
                        case ILLEGAL_ME:
                        case GPRS_SERVICES_NOT_ALLOWED:
                        case GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED:
                        case PLMN_NOT_ALLOWED:
                        case LA_NOT_ALLOWED:
                        case NATIONAL_ROAMING_NOT_ALLOWED:
                        case GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN:
                        case NO_SUITABLE_CELLS_IN_LA:
                        case CSG_NOT_AUTHORIZED:
                            if (RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == *res || RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == *res)
                            {
                                *res = RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV;
                            }
                            else
                            {
                                *res = RIL_VAL_REG_REGISTRATION_DENIED;
                            }
                            break;

                        case QCRIL_REJECT_CAUSE_NETWORK_FAIL:
                            // Force no service on reject cause 17 only when property is set to true.
                            // If no service is sent this is failing 3GPP TS51.010-1 26.7.4.3.4.
                            if (nas_common_info.force_no_srv_on_rej_reject_17 == TRUE)
                            {
                                *res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
                            }
                            break;

                        default:
                             //no action
                            break;

                    }
                    if ( extra_results )
                    {
                        extra_results->is_reject_case      = TRUE;
                        extra_results->is_managed_roaming  = FALSE;
                        extra_results->reject_cause        = reg_reject_info->rej_cause;
                    }
                    break;

                default:
                    // no action
                    break;
            }
        }
    }
    else
    {
        QCRIL_LOG_INFO("reg_reject_info is NULL");
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET( *res );

} // qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info

static inline bool is_emergency_voice_service_possible_on_lte
(
 bool lte_is_eb_supported,
 bool emergency_access_barred
)
{
    return lte_is_eb_supported && !emergency_access_barred;
} // is_emergency_voice_service_possible_on_lte

static inline bool is_voice_supported_on_5g()
{
    return NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.voice_support_on_nr5g)
            && nas_cached_info.voice_support_on_nr5g;
}

static inline bool is_capability_allows_normal_call
(
 bool srv_capability_valid,
 int srv_capability,
 bool is_lte,
 bool is_voice_supported_on_lte,
 bool cfg_voice_support_on_lte,
 bool is_5g
)
{
    return
      srv_capability_valid &&
      (
        SYS_SRV_DOMAIN_CS_ONLY_V01 == srv_capability ||
        SYS_SRV_DOMAIN_CS_PS_V01 == srv_capability ||
        (
           SYS_SRV_DOMAIN_PS_ONLY_V01 == srv_capability &&
           (
             (is_lte && (is_voice_supported_on_lte || cfg_voice_support_on_lte)) ||
             (is_5g && is_voice_supported_on_5g())
           )
        )
      );
} // is_capability_allows_normal_call

static inline bool is_srv_domain_allows_normal_call
(
 bool srv_domain_valid,
 int srv_domain,
 bool is_lte,
 bool is_voice_supported_on_lte,
 bool cfg_voice_support_on_lte,
 bool is_5g
)
{
    return
      srv_domain_valid &&
      (
        SYS_SRV_DOMAIN_CS_ONLY_V01 == srv_domain ||
        SYS_SRV_DOMAIN_CS_PS_V01 == srv_domain ||
        (
          SYS_SRV_DOMAIN_PS_ONLY_V01 == srv_domain &&
          (
            (is_lte && (is_voice_supported_on_lte || cfg_voice_support_on_lte)) ||
            (is_5g && is_voice_supported_on_5g())
          )
        )
      );
} // is_srv_domain_allows_normal_call



//===========================================================================
// qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status_direct
//===========================================================================
int qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status_direct
(
 nas_service_status_enum_type_v01 nas_srv_status,
 nas_common_sys_info_type_v01 *common_sys_info,
 boolean ignore_srv_domain
)
{
    int res = RIL_VAL_REG_UNKNOWN;
    switch ( nas_srv_status )
    {
        case NAS_SYS_SRV_STATUS_NO_SRV_V01:
            res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
            break;

        case NAS_SYS_SRV_STATUS_LIMITED_V01:            // fallthrough
        case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
            res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV;
            break;

        case NAS_SYS_SRV_STATUS_SRV_V01:
            if ( NULL == common_sys_info ||
                 ( common_sys_info->roam_status_valid &&
                   ( ( NAS_SYS_ROAM_STATUS_OFF_V01 == common_sys_info->roam_status ) ||
                     ( ( ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_64 == common_sys_info->roam_status ) ||
                         ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_65 == common_sys_info->roam_status ) ||
                         ( (common_sys_info->roam_status >= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_76 ) &&
                           (common_sys_info->roam_status <= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_83 )
                          ) ) && nas_common_info.eri_64_home )
                   )
                 ) || (ignore_srv_domain && !common_sys_info->roam_status_valid)
               )
            {
                res = RIL_VAL_REG_REGISTERED_HOME_NET;
            }
            else
            {
                res = RIL_VAL_REG_REGISTERED_ROAMING;
            }
            break;

        case NAS_SYS_SRV_STATUS_PWR_SAVE_V01:
            res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                        break;

        default:
            res = RIL_VAL_REG_UNKNOWN;
            break;
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} // qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status_direct

//===========================================================================
// qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status
//===========================================================================
int qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status( uint32_t nas_sys_info_flag, nas_sys_info_helper_type * nas_sys_info_helper )
{
    int res,is_data,is_3gpp,is_hdr;
    int ignore_srv_domain;

    nas_net_sel_pref_enum_v01 nw_sel_pref;
    nas_service_status_enum_type_v01 nas_srv_status;
    nas_common_sys_info_type_v01 * common_sys_info;
    nas_3gpp_only_sys_info_type_v01 * threegpp_sys_info;
    uint8_t * is_voice_supported_on_lte;
    nas_tri_state_boolean_type_v01 *lte_is_eb_supported;
    nas_tri_state_boolean_type_v01 *emergency_access_barred;
    nas_3gpp_srv_status_info_type_v01 * threegpp_status_info;
    nas_hdr_only_sys_info_type_v01 * hdr_only_sys_info;
    qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results;

    QCRIL_LOG_FUNC_ENTRY();

    res = RIL_VAL_REG_UNKNOWN;
    ignore_srv_domain = FALSE;

    if( NULL != nas_sys_info_helper )
    {
        is_data = NAS_IS_BIT_SET(nas_sys_info_flag, NAS_SYS_INFO_IS_DATA);
        is_3gpp = NAS_IS_BIT_SET(nas_sys_info_flag, NAS_SYS_INFO_IS_3GPP);
        is_hdr = NAS_IS_BIT_SET(nas_sys_info_flag, NAS_SYS_INFO_IS_HDR);

        nas_srv_status = qcril_qmi_util_retrieve_srv_status(nas_sys_info_helper, is_3gpp);
        common_sys_info = nas_sys_info_helper->common_sys_info;
        threegpp_sys_info = nas_sys_info_helper->threegpp_only_sys_info;
        is_voice_supported_on_lte = nas_sys_info_helper->voice_support_on_lte;
        lte_is_eb_supported = nas_sys_info_helper->lte_is_eb_supported;
        emergency_access_barred = nas_sys_info_helper->emergency_access_barred;
        threegpp_status_info = nas_sys_info_helper->threegpp_srv_status;
        hdr_only_sys_info = nas_sys_info_helper->hdr_only_sys_info;
        extra_results = nas_sys_info_helper->extra_results;

        QCRIL_LOG_INFO("... nas_srv_status %d, is_data %d, is_3gpp %d, is_hdr %d", (int) nas_srv_status, is_data, is_3gpp, is_hdr );

        if ( NULL != common_sys_info )
        {
            ignore_srv_domain = qcril_qmi_nas_is_ignore_nas_srv_domain(nas_srv_status,
                    common_sys_info->srv_domain_valid, common_sys_info->srv_domain,
                    nas_sys_info_flag & NAS_SYS_INFO_IS_LTE, is_voice_supported_on_lte,
                    nas_sys_info_flag & NAS_SYS_INFO_IS_5G);
            QCRIL_LOG_INFO("ignore_srv_domain %d", ignore_srv_domain);
        }

        // 1st run
        res = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status_direct(
                nas_srv_status,
                common_sys_info,
                ignore_srv_domain);

        QCRIL_LOG_INFO("... intermediate res 1 %d, ... common_sys_info %p", (int) res, common_sys_info  );

        // caps check
        if ( NULL != common_sys_info )
        {
            QCRIL_LOG_INFO("... srv_capability_valid, srv_capability %d, %d ... srv_domain_valid, srv_domain %d, %d",
                           (int) common_sys_info->srv_capability_valid,
                           (int) common_sys_info->srv_capability,
                           (int) common_sys_info->srv_domain_valid,
                           (int) common_sys_info->srv_domain );

            if ( RIL_VAL_REG_REGISTERED_HOME_NET == res || RIL_VAL_REG_REGISTERED_ROAMING == res || RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res )
            {
                if ( !is_data )
                { // voice
                    if ( NULL != is_voice_supported_on_lte )
                    {
                        QCRIL_LOG_INFO("... is voice supported on lte dyn %d, setting %d",
                                (int) *is_voice_supported_on_lte,
                                (int)nas_common_info.voice_support_on_lte  );
                    }
                    if ( NULL != lte_is_eb_supported )
                    {
                        QCRIL_LOG_INFO("... is eb supported on lte %d", (int) *lte_is_eb_supported);
                    }
                    if ( NULL != emergency_access_barred )
                    {
                        QCRIL_LOG_INFO("... emergency access barred on lte %d", (int) *emergency_access_barred);
                    }
                    if ( (FALSE == ignore_srv_domain) &&
                         (
                          (
                           common_sys_info->srv_capability_valid
                           &&
                           !is_capability_allows_normal_call(
                               common_sys_info->srv_capability_valid,
                               common_sys_info->srv_capability,
                               nas_sys_info_flag & NAS_SYS_INFO_IS_LTE,
                               is_voice_supported_on_lte ? *is_voice_supported_on_lte : false,
                               nas_common_info.voice_support_on_lte,
                               nas_sys_info_flag & NAS_SYS_INFO_IS_5G)
                           &&
                           !is_emergency_voice_service_possible_on_lte(
                               lte_is_eb_supported ?
                               *lte_is_eb_supported == NAS_TRI_TRUE_V01 : false,
                               emergency_access_barred ?
                               *emergency_access_barred == NAS_TRI_TRUE_V01 : false)
                          )
                          || (
                              common_sys_info->srv_domain_valid
                              && RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV != res
                              && !is_srv_domain_allows_normal_call(
                                      common_sys_info->srv_domain_valid,
                                      common_sys_info->srv_domain,
                                      nas_sys_info_flag & NAS_SYS_INFO_IS_LTE,
                                      is_voice_supported_on_lte ?  *is_voice_supported_on_lte : false,
                                      nas_common_info.voice_support_on_lte,
                                      nas_sys_info_flag & NAS_SYS_INFO_IS_5G)
                             )
                          || (
                              RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res
                              && ( nas_sys_info_flag & NAS_SYS_INFO_IS_LTE ) != 0
                              && !is_emergency_voice_service_possible_on_lte(
                                  lte_is_eb_supported ?
                                  *lte_is_eb_supported == NAS_TRI_TRUE_V01 : false,
                                  emergency_access_barred ?
                                  *emergency_access_barred == NAS_TRI_TRUE_V01 : false)
                             )
                         )
                       )
                    {
                        res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                    }
                }
                else
                { // data
                    if ( is_3gpp )
                    {
                        if ( (common_sys_info->srv_capability_valid && common_sys_info->srv_capability != SYS_SRV_DOMAIN_PS_ONLY_V01 && common_sys_info->srv_capability != SYS_SRV_DOMAIN_CS_PS_V01)
                             ||
                             (common_sys_info->srv_domain_valid && common_sys_info->srv_domain != SYS_SRV_DOMAIN_PS_ONLY_V01 && common_sys_info->srv_domain != SYS_SRV_DOMAIN_CS_PS_V01 && RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV != res)
                             )
                        {
                            res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
                        }
                    }
                }
            }
        }
        QCRIL_LOG_INFO("... intermediate res 2 %d, ... hdr_only_sys_info %p", (int) res, hdr_only_sys_info  );

        if( is_hdr )
        {
            res = qcril_qmi_nas_util_adjust_hdr_ril_reg_state(res, hdr_only_sys_info);
        }
        QCRIL_LOG_INFO("... intermediate res 3 %d", (int) res  );

        // reg reject check
        if ( NULL != common_sys_info )
        {
            QCRIL_LOG_INFO("... is_sys_forbidden_valid, is_sys_forbidden %d, %d", (int) common_sys_info->is_sys_forbidden_valid, (int) common_sys_info->is_sys_forbidden );
        }
        if ( NULL != threegpp_sys_info )
        {
            QCRIL_LOG_INFO("... reg_reject_info_valid, reg_reject_info.dmn, reg_reject_info.cause %d, %d, %d",
                                (int) threegpp_sys_info->reg_reject_info_valid,
                                (int) threegpp_sys_info->reg_reject_info.reject_srv_domain,
                                (int) threegpp_sys_info->reg_reject_info.rej_cause );
        }
        if ( threegpp_status_info != NULL )
        {
            QCRIL_LOG_INFO("... true srv status %d", (int) threegpp_status_info->true_srv_status);
        }

        QCRIL_LOG_INFO("is_blocking_valid %d, is_blocking %d", nas_cached_info.is_blocked_valid, nas_cached_info.is_blocked);

        if ( is_3gpp )
        {
            if( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == res || RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == res || RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res )
            {
                if ( !is_data &&
                     ( RIL_E_SUCCESS == qcril_qmi_nas_get_nw_selection_mode( &nw_sel_pref ) && NAS_NET_SEL_PREF_MANUAL_V01 == nw_sel_pref && nas_cached_info.nw_select_state == QMI_RIL_NAS_NW_SELECT_NONE ) // manual selection
                     &&
                     NULL != threegpp_status_info // sanity check
                     &&
                     (  // either limited service
                        ( SYS_SRV_STATUS_LIMITED_V01 == threegpp_status_info->true_srv_status )
                        ||
                        ( // or full service on ps only
                         ( SYS_SRV_STATUS_SRV_V01 == threegpp_status_info->true_srv_status || SYS_SRV_STATUS_PWR_SAVE_V01 == threegpp_status_info->true_srv_status )
                         &&
                         ( NULL != common_sys_info &&  SYS_SRV_DOMAIN_PS_ONLY_V01 == common_sys_info->srv_domain )
                        )
                     )
                     &&
                     (TRUE != nas_common_info.do_not_consider_managed_roam)
                    )
                {   // managed roaming
                    res = RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV;
                    if ( extra_results )
                    {
                        extra_results->is_reject_case      = TRUE;
                        if(nas_cached_info.is_blocked_valid && nas_cached_info.is_blocked)
                        {
                            extra_results->is_managed_roaming  = FALSE;
                            extra_results->reject_cause        = ILLEGAL_ME;
                        }
                        else
                        {
                            extra_results->is_managed_roaming  = TRUE;
                            extra_results->reject_cause        = RIL_VAL_REG_MANAGED_ROAMING_CAUSE; // dedicated cause for managed roaming
                        }
                    }
                }
                else
                {   // common reg reject
                    if ( NULL != common_sys_info && common_sys_info->is_sys_forbidden_valid && common_sys_info->is_sys_forbidden )
                    {
                        res = (RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res) ? RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV : RIL_VAL_REG_REGISTRATION_DENIED;
                        if ( extra_results )
                        {
                            extra_results->is_reject_case      = TRUE;
                            extra_results->is_managed_roaming  = FALSE;
                            extra_results->reject_cause        = NAS_NIL;
                        }
                    }
                    if(nas_cached_info.is_blocked_valid && nas_cached_info.is_blocked)
                    {
                        res = (RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res) ? RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV : RIL_VAL_REG_REGISTRATION_DENIED;
                        if ( extra_results )
                        {
                            extra_results->is_reject_case      = TRUE;
                            extra_results->is_managed_roaming  = FALSE;
                            extra_results->reject_cause        = ILLEGAL_ME;
                        }
                    }
                    else if ( NULL != threegpp_sys_info && threegpp_sys_info->reg_reject_info_valid )
                    {
                        qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info(is_data, &res, &threegpp_sys_info->reg_reject_info, extra_results);
                    }
                }
            }
            else if( RIL_VAL_REG_REGISTERED_HOME_NET == res || RIL_VAL_REG_REGISTERED_ROAMING == res )
            {
                if(nas_cached_info.is_blocked_valid && nas_cached_info.is_blocked)
                {
                    res = RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV;
                    if ( extra_results )
                    {
                        extra_results->is_reject_case      = TRUE;
                        extra_results->is_managed_roaming  = FALSE;
                        extra_results->reject_cause        = ILLEGAL_ME;
                    }
                }
                else if ( NULL != threegpp_sys_info && threegpp_sys_info->reg_reject_info_valid &&
                     (
                       ( !is_data &&
                          (SYS_SRV_DOMAIN_CS_ONLY_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain ||
                           SYS_SRV_DOMAIN_CS_PS_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain )
                       ) ||
                       ( is_data &&
                          ( SYS_SRV_DOMAIN_CS_PS_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain ||
                            SYS_SRV_DOMAIN_PS_ONLY_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain )
                       )
                     )
                   )
                {
                    qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info(is_data, &res, &threegpp_sys_info->reg_reject_info, extra_results);
                }
            }
        }
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED - nas_sys_info_helper is NULL");
    }

    QCRIL_LOG_INFO("complete with %d", (int) res  );

    return res;
} // qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status

//===========================================================================
// qcril_qmi_nas_is_ignore_nas_srv_domain
//===========================================================================
int qcril_qmi_nas_is_ignore_nas_srv_domain(nas_service_status_enum_type_v01 nas_srv_status,
                                           uint8_t srv_domain_valid,
                                           nas_service_domain_enum_type_v01 srv_domain,
                                           bool is_lte,
                                           uint8_t *is_voice_supported_on_lte,
                                           bool is_5g)
{
    int res;
    int cache_srv_domain;
    int start_srv_domain_camped_timer;
    int cancel_srv_domain_camped_timer;

    QCRIL_LOG_FUNC_ENTRY();

    res = FALSE;
    cache_srv_domain = FALSE;
    start_srv_domain_camped_timer = FALSE;
    cancel_srv_domain_camped_timer = FALSE;

    if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer)
    {
        if(TRUE == srv_domain_valid)
        {
            switch(srv_domain)
            {
                case SYS_SRV_DOMAIN_CAMPED_V01:
                    if(NAS_SYS_SRV_STATUS_SRV_V01 == nas_srv_status &&
                       TRUE == nas_common_info.prev_srv_domain_valid &&
                       (SYS_SRV_DOMAIN_CS_ONLY_V01 == nas_common_info.prev_srv_domain ||
                        SYS_SRV_DOMAIN_CS_PS_V01 == nas_common_info.prev_srv_domain)
                       )
                    {
                        start_srv_domain_camped_timer = TRUE;
                        res = TRUE;
                    }
                    break;

                case SYS_SRV_DOMAIN_CS_ONLY_V01:
                case SYS_SRV_DOMAIN_CS_PS_V01:
                    cache_srv_domain = TRUE;
                    cancel_srv_domain_camped_timer = TRUE;
                    break;

                case SYS_SRV_DOMAIN_PS_ONLY_V01:
                    if ((is_lte && NULL != is_voice_supported_on_lte && TRUE == *is_voice_supported_on_lte) ||
                       (is_5g && is_voice_supported_on_5g()))
                    {
                        srv_domain = SYS_SRV_DOMAIN_CS_PS_V01;
                        cache_srv_domain = TRUE;
                        cancel_srv_domain_camped_timer = TRUE;
                    }
                    break;

                default: //no action
                    break;
            }
        }

        if(TRUE == cache_srv_domain)
        {
            nas_common_info.prev_srv_domain_valid = TRUE;
            nas_common_info.prev_srv_domain = srv_domain;
        }

        if (TRUE == start_srv_domain_camped_timer)
        {
            qcril_qmi_nas_start_srv_domain_camped_timer();
        }

        if(TRUE == cancel_srv_domain_camped_timer)
        {
            qcril_qmi_nas_cancel_srv_domain_camped_timer();
        }
    }

    QCRIL_LOG_INFO("completed with %d",res);
    return res;
} //qcril_qmi_nas_is_ignore_nas_srv_domain

//===========================================================================
// qcril_qmi_nas_start_srv_domain_camped_timer
//===========================================================================
void qcril_qmi_nas_start_srv_domain_camped_timer()
{
   struct timeval ignore_srv_domain_camped_timeout;

   QCRIL_LOG_FUNC_ENTRY();

   ignore_srv_domain_camped_timeout.tv_sec = nas_common_info.ignore_srv_domain_camped_timer;
   ignore_srv_domain_camped_timeout.tv_usec = NAS_NIL;

   if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer &&
      FALSE == nas_common_info.ignore_srv_domain_camped_timer_id_valid)
   {
       qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb,
                                   &ignore_srv_domain_camped_timeout,
                                   &nas_common_info.ignore_srv_domain_camped_timer_id);
       nas_common_info.ignore_srv_domain_camped_timer_id_valid = TRUE;
       QCRIL_LOG_INFO("ignore_srv_domain_camped_timer started");
   }

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_start_srv_domain_camped_timer


//===========================================================================
// qcril_qmi_nas_cancel_srv_domain_camped_timer
//===========================================================================
void qcril_qmi_nas_cancel_srv_domain_camped_timer()
{
   QCRIL_LOG_FUNC_ENTRY();

   if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer &&
      TRUE == nas_common_info.ignore_srv_domain_camped_timer_id_valid)
   {
       qcril_cancel_timed_callback((void *)(uintptr_t)nas_common_info.ignore_srv_domain_camped_timer_id);
       nas_common_info.ignore_srv_domain_camped_timer_id_valid = FALSE;
       nas_common_info.ignore_srv_domain_camped_timer_id = NAS_NIL;
       QCRIL_LOG_INFO("ignore_srv_domain_camped_timer cancelled");
   }

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_cancel_srv_domain_camped_timer

//===========================================================================
// qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb
//===========================================================================
void qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb(void * params)
{
   int action_needed;
   QCRIL_LOG_FUNC_ENTRY();

   QCRIL_NOTUSED(params);

   action_needed = FALSE;

   NAS_CACHE_LOCK();
   if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer)
   {
       QCRIL_LOG_INFO("ignore_srv_domain_camped_timer timed out, prev srv domain valid %d, value %d",
                      nas_common_info.prev_srv_domain_valid,
                      nas_common_info.prev_srv_domain);
       nas_common_info.ignore_srv_domain_camped_timer_id_valid = FALSE;
       nas_common_info.ignore_srv_domain_camped_timer_id = NAS_NIL;
       nas_common_info.prev_srv_domain_valid = FALSE;
       nas_common_info.prev_srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;
       action_needed = TRUE;
   }
   NAS_CACHE_UNLOCK();

   if(TRUE == action_needed)
   {
       qcril_qmi_nas_wave_voice_data_status();
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb

//===========================================================================
// qcril_qmi_nas_cancel_srv_domain_camped_timer_helper
//===========================================================================
void qcril_qmi_nas_cancel_srv_domain_camped_timer_helper()
{
   QCRIL_LOG_FUNC_ENTRY();

   NAS_CACHE_LOCK();
   qcril_qmi_nas_cancel_srv_domain_camped_timer();
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_cancel_srv_domain_camped_timer_helper

//===========================================================================
// qcril_qmi_nas_is_mcc_mnc_info_available
//===========================================================================
static int qcril_qmi_nas_is_mcc_mnc_info_available()
{
    int res = FALSE;
    int is_now_registered;

    QCRIL_LOG_FUNC_ENTRY();

    is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
    QCRIL_LOG_INFO( ".. is registered %d", is_now_registered );
    if( is_now_registered )
    {
        if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sys_info))
            && (TRUE == nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id_valid)))
        {
            QCRIL_LOG_INFO("checking sys_info_ind - GSM");
            res = TRUE;
        }
        else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sys_info))
            && (TRUE == nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id_valid)))
        {
            QCRIL_LOG_INFO("checking sys_info_ind - WCDMA");
            res = TRUE;
        }
        else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_TDSCDMA) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_sys_info))
            && (TRUE == nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id_valid)))
        {
            QCRIL_LOG_INFO("checking sys_info_ind - TDSCDMA");
            res = TRUE;
        }
        else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sys_info))
            && (TRUE == nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id_valid)))
        {
            QCRIL_LOG_INFO("checking sys_info_ind - LTE");
            res = TRUE;
        }
        else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_NR5G) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info))
            && (TRUE == nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info.network_id_valid)))
        {
            QCRIL_LOG_INFO("checking sys_info_ind - NR5G");
            res = TRUE;
        }
    }

    QCRIL_LOG_INFO("completed with %d",res);

    return res;
} //qcril_qmi_nas_is_mcc_mnc_info_available

//===========================================================================
// qcril_qmi_nas_fetch_system_info_helper
//===========================================================================
static RIL_Errno qcril_qmi_nas_fetch_system_info_helper()
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();

    res = qcril_qmi_nas_fetch_sys_info();

    QCRIL_LOG_INFO("completed with %d",res);

    return res;
} //qcril_qmi_nas_fetch_system_info_helper


//===========================================================================
// qcril_qmi_nas_fetch_mcc_mnc_of_current_system
//===========================================================================
int qcril_qmi_nas_fetch_mcc_mnc_of_current_system
(
    char current_mcc_str[NAS_MCC_MNC_MAX_SIZE],
    char current_mnc_str[NAS_MCC_MNC_MAX_SIZE],
    uint8_t is_3gpp,
    uint8_t is_3gpp2
)
{
    int res = FALSE;
    int is_service_in_3gpp;
    int is_service_in_3gpp2;

    NAS_CACHE_LOCK();

    do {

        if (!current_mcc_str || !current_mnc_str)
        {
            break;
        }

        is_service_in_3gpp  =
            qcril_qmi_nas_is_in_service_of_technology(NAS_SELECTED_NETWORK_3GPP_V01);
        is_service_in_3gpp2 =
            qcril_qmi_nas_is_in_service_of_technology(NAS_SELECTED_NETWORK_3GPP2_V01);

        if (is_service_in_3gpp && is_3gpp)
        {
            if (qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str,
                                                   current_mnc_str,
                                                   TRUE, NULL))
            {
                res = TRUE;
            }
        }
        else if (is_service_in_3gpp2 && is_3gpp2)
        {
            if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sys_info) &&
                nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id_valid)
            {
                if(!qcril_qmi_nas_is_mcc_mnc_wildcard_entry(
                            nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mcc,
                            nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mnc))
                {
                    qcril_qmi_nas_fillup_mcc_mnc_helper(
                            nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mcc,
                            current_mcc_str);
                    qcril_qmi_nas_fillup_mcc_mnc_helper(
                            nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mnc,
                            current_mnc_str);
                    res = TRUE;
                }
            }
        }

    } while(0);

    NAS_CACHE_UNLOCK();

    return res;

}

void qcril_qmi_nas_get_meta_build_id_from_file(char *ap_sw_version, size_t len)
{
    std::ifstream input(QCRIL_META_BUILD_VER_INFO, std::ifstream::in);
    size_t pos;
    string line;
    string meta;
    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if((NULL == ap_sw_version) || (0 == len))
        {
            QCRIL_LOG_INFO("ap_sw_version is NULL or len is zero");
            break;
        }

        if (!input)
        {
            QCRIL_LOG_INFO("Could not open file ver_info.txt");
            break;
        }

        if(!input.eof())
        {
            while(getline(input,line))
            {
                pos = line.find("Meta_Build_ID");
                if(pos != string::npos) // string::npos is returned if string is not found
                {
                    Log::getInstance().d("Found meta line: " + line);
/*
        "Meta_Build_ID": "SDM845.LA.2.0-00145-STD.INT.MD-1",
*/
                    pos = line.find(":");
                    meta = line.substr (pos);
                    pos = meta.find("\"");
                    meta = meta.substr (pos+1);
                    pos = meta.find("\"");
                    meta = meta.substr(0, pos);
                    Log::getInstance().d("meta: " + meta);
                    strlcpy(ap_sw_version, meta.c_str(), len);
                    QCRIL_LOG_INFO( "ap_sw_version %s", ap_sw_version);
                    break;
                }
            }
        }
    }while(0);

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// RIL_REQUEST_OPERATOR
//===========================================================================
void qcril_qmi_nas_request_operator
(
  std::shared_ptr<RilRequestOperatorMessage> msg
)
{
  qcril_qmi_operator_resp_helper_type ril_resp_helper;

  int           everything_cached;

  qmi_client_error_type qmi_client_error = QMI_NO_ERR;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  const char * op_name_short = NULL;
  const char * op_name_long = NULL;

  char log_buf[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];

  char mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char mnc_str[NAS_MCC_MNC_MAX_SIZE];
  char mcc_3gpp2_str[NAS_3GPP2_MCC_MAX_SIZE];
  char mnc_3gpp2_str[NAS_MCC_MNC_MAX_SIZE];
  uint16_t sid_3gpp2,nid_3gpp2;
  int used_nam_name_len;

  nas_radio_if_enum_v01 plmn_rat = NAS_RADIO_IF_NO_SVC_V01;

  nas_get_3gpp2_subscription_info_req_msg_v01 cdma_subscription_info_req;
  nas_get_3gpp2_subscription_info_resp_msg_v01 cdma_subscription_info_resp;
  int res;

  int is_now_registered;
  int is_service_in_3gpp;
  int is_service_in_3gpp2;

  int is_spn_present;
  int is_plmn_name_present;
  int prefer_spn;

  uint8_t slot;

  boolean use_cc_names = FALSE;
  char sim_mcc_str[NAS_MCC_MNC_MAX_SIZE];

  uint8_t csg_id_valid;
  uint32_t csg_id;

  // ** response holder init

  QCRIL_LOG_FUNC_ENTRY();
  qcril_suppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_suppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());
  NAS_CACHE_LOCK();

  memset( &ril_resp_helper, 0, sizeof( ril_resp_helper ) );
  memset( mcc_str, 0, sizeof( mcc_str ) );
  memset( mnc_str, 0, sizeof( mnc_str ) );
  memset( mcc_3gpp2_str, 0, sizeof( mcc_3gpp2_str ) );
  memset( mnc_3gpp2_str, 0, sizeof( mnc_3gpp2_str ) );
  memset( log_buf, 0, sizeof( log_buf ) );

  NAS_CACHE_LOCK();
  is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
  NAS_CACHE_UNLOCK();
  QCRIL_LOG_INFO("now registered %d", (int)is_now_registered);

  if ( is_now_registered )
  {
      ril_resp_helper.operator_info_array[ 0 ] = ril_resp_helper.long_eons;
      ril_resp_helper.operator_info_array[ 1 ] = ril_resp_helper.short_eons;
      ril_resp_helper.operator_info_array[ 2 ] = ril_resp_helper.mcc_mnc_ascii;

      NAS_CACHE_LOCK();
      use_cc_names = nas_common_info.use_cc_names;
      slot = qmi_ril_get_process_instance_id();
      if (nas_common_info.card_info[slot].mcc_from_iccid)
      {
        strlcpy(sim_mcc_str, nas_common_info.card_info[slot].mcc_from_iccid, NAS_MCC_MNC_MAX_SIZE);
      }
      qcril_qmi_nas_find_current_mcc_mnc(mcc_str, mnc_str, TRUE, NULL);

      is_service_in_3gpp = qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01);
      is_service_in_3gpp2 = qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP2_V01);
      NAS_CACHE_UNLOCK();

      if ( is_service_in_3gpp )
      {
          if(use_cc_names)
          {
              qcril_qmi_nas2_find_static_cc_operator_name(sim_mcc_str, mcc_str, mnc_str, &op_name_short, &op_name_long);
          }

          if ((op_name_short != NULL && op_name_short[0] != 0) ||
              (op_name_long != NULL && op_name_long[0] != 0))
          {
              if (op_name_long != NULL)
              {
                memcpy(ril_resp_helper.long_eons, op_name_long, sizeof(ril_resp_helper.long_eons));
              }
              if (op_name_short != NULL)
              {
                memcpy(ril_resp_helper.short_eons, op_name_short, sizeof(ril_resp_helper.short_eons));
              }
              snprintf(ril_resp_helper.mcc_mnc_ascii, NAS_OPERATOR_RESP_MAX_MCC_MNC_LEN, "%s%s", mcc_str, mnc_str);
          }
          else
          {
              *ril_resp_helper.long_eons        = NAS_NIL;
              *ril_resp_helper.short_eons       = NAS_NIL;
              *ril_resp_helper.mcc_mnc_ascii    = NAS_NIL;

              NAS_CACHE_LOCK();
              QCRIL_LOG_INFO( "plmn_id cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id ) );
              QCRIL_LOG_INFO( "spn cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn ) );
              QCRIL_LOG_INFO( "short_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) );
              QCRIL_LOG_INFO( "long_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) );

              everything_cached = (
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id )    &&
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn )        &&
                 !is_operator_name_empty_or_white_space( (char *) nas_cached_info.spn->spn, NAS_SPN_LEN_MAX_V01 )&&
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) &&
                 !is_operator_name_empty_or_white_space( (char *) nas_cached_info.short_name->plmn_name, NAS_PLMN_NAME_MAX_V01 ) &&
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name )  &&
                 !is_operator_name_empty_or_white_space( (char *) nas_cached_info.long_name->plmn_name, NAS_PLMN_NAME_MAX_V01 )
                                   );
              NAS_CACHE_UNLOCK();


              if( TRUE == everything_cached &&
                         !nas_common_info.unicode_operator_names_support && /*query op name always from modem if enabled*/
                         ((!qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) &&
                         !qcril_qmi_nas_is_sglte3()) ||
                          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ))) //On SGLTE we can have CURRENT_PLMN_NAME_IND from both msm and qsc
              {                                                                                         //thus restricting us from running the logic of choosing the right plmn based
                  NAS_CACHE_LOCK();                                                                     //on persist.vendor.radio.sglte.eons_domain and persist.vendor.radio.sglte.eons_roam
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id ) )
                  {
                      snprintf( mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", nas_cached_info.plmn_id->mcc );
                      if ( nas_cached_info.plmn_id->mnc > 99 || TRUE == nas_cached_info.plmn_id->mnc_includes_pcs_digit )
                      {
                          snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int) nas_cached_info.plmn_id->mnc );
                      }
                      else
                      {
                          snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int) nas_cached_info.plmn_id->mnc );
                      }
                  }
                  snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );

                  is_spn_present = (NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn ) && nas_cached_info.spn->spn_len > NAS_NIL);
                  is_plmn_name_present = ((NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) && nas_cached_info.short_name->plmn_name_len > NAS_NIL) || (NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) && nas_cached_info.long_name->plmn_name_len > NAS_NIL));
                  prefer_spn = qcril_qmi_util_prefer_spn_over_plmn_name(is_spn_present, is_plmn_name_present, FALSE, NULL, NULL);
                  if( TRUE == prefer_spn )
                  {
                      if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == nas_cached_info.spn->spn_enc )
                      {
                          qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)nas_cached_info.spn->spn,
                                                                            nas_cached_info.spn->spn_len,
                                                                            ril_resp_helper.short_eons,
                                                                            sizeof(ril_resp_helper.short_eons));
                          qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char *)nas_cached_info.spn->spn,
                                                                            nas_cached_info.spn->spn_len,
                                                                            ril_resp_helper.long_eons,
                                                                            sizeof(ril_resp_helper.long_eons));
                          QCRIL_LOG_INFO("spn is 7-bit Unpacked data");
                      }
                      else
                      {
                          qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.short_eons,
                                                              NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                              nas_cached_info.spn->spn_enc,
                                                              nas_cached_info.spn->spn,
                                                              nas_cached_info.spn->spn_len);

                          qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.long_eons,
                                                              NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                              nas_cached_info.spn->spn_enc,
                                                              nas_cached_info.spn->spn,
                                                              nas_cached_info.spn->spn_len);
                      }
                      QCRIL_LOG_INFO("short eons derived from spn %s",ril_resp_helper.short_eons);
                      QCRIL_LOG_INFO("long eons derived from spn %s",ril_resp_helper.long_eons);
                  }
                  else
                  {
                    if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) )
                    {
                        if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == nas_cached_info.short_name->plmn_name_enc )
                        {
                            qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)nas_cached_info.short_name->plmn_name,
                                                                              nas_cached_info.short_name->plmn_name_len,
                                                                              ril_resp_helper.short_eons,
                                                                              sizeof(ril_resp_helper.short_eons));
                            QCRIL_LOG_INFO("plmn short name is 7-bit Unpacked data");
                        }
                        else
                        {
                            qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.short_eons,
                                                                NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                                nas_cached_info.short_name->plmn_name_enc,
                                                                nas_cached_info.short_name->plmn_name,
                                                                nas_cached_info.short_name->plmn_name_len);
                        }
                        QCRIL_LOG_INFO("short eons derived from plmn %s",ril_resp_helper.short_eons);
                    }

                    if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) )
                    {
                        if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == nas_cached_info.long_name->plmn_name_enc )
                        {
                            qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)nas_cached_info.long_name->plmn_name,
                                                                              nas_cached_info.long_name->plmn_name_len,
                                                                              ril_resp_helper.long_eons,
                                                                              sizeof(ril_resp_helper.long_eons));
                            QCRIL_LOG_INFO("plmn long name is 7-bit Unpacked data");
                        }
                        else
                        {
                            qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.long_eons,
                                                                NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                                nas_cached_info.long_name->plmn_name_enc,
                                                                nas_cached_info.long_name->plmn_name,
                                                                nas_cached_info.long_name->plmn_name_len);
                        }
                        QCRIL_LOG_INFO("long eons derived from plmn %s",ril_resp_helper.long_eons);
                    }
                  }
                  NAS_CACHE_UNLOCK();
              }
              else
              {
                  NAS_CACHE_LOCK();
                  everything_cached =   ( TRUE == qcril_qmi_nas_is_mcc_mnc_info_available() );
                  NAS_CACHE_UNLOCK();
                  if( FALSE == everything_cached )
                  {
                      qcril_qmi_nas_fetch_sys_info();
                  }

                  NAS_CACHE_LOCK();
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..gsm network id valid %d", nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..wcdma network id valid %d", nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..tdscdma network id valid %d", nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..lte network id valid %d", nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }

                  res = qcril_qmi_nas_find_current_mcc_mnc(mcc_str, mnc_str, TRUE, &plmn_rat);

                  csg_id_valid = FALSE;
                  csg_id = 0;

                  if(nas_common_info.csg_info_available)
                  {
                      if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_csg_info ) )
                      {
                          csg_id_valid = nas_cached_info.wcdma_csg_info_valid;
                          csg_id = nas_cached_info.wcdma_csg_info->id;
                      }
                      else if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_csg_info ) )
                      {
                          csg_id_valid = nas_cached_info.lte_csg_info_valid;
                          csg_id = nas_cached_info.lte_csg_info->id;
                      }
                  }

                  NAS_CACHE_UNLOCK();

                  if( res )
                  {
                      snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );
                      qcril_qmi_util_handle_centralized_short_long_eons(mcc_str,
                                                                        mnc_str,
                                                                        ril_resp_helper.short_eons,
                                                                        sizeof(ril_resp_helper.short_eons),
                                                                        ril_resp_helper.long_eons,
                                                                        sizeof(ril_resp_helper.long_eons),
                                                                        FALSE, plmn_rat,
                                                                        csg_id_valid, csg_id );
                  }
                  else
                  {
                      ril_req_res = RIL_E_GENERIC_FAILURE;
                  }
              }
          }

          if ( *ril_resp_helper.long_eons && !*ril_resp_helper.short_eons && TRUE == nas_common_info.fill_eons)
          {
              QCRIL_LOG_INFO("Filling short eons with long eons");
              strlcpy( ril_resp_helper.short_eons, ril_resp_helper.long_eons , sizeof(ril_resp_helper.short_eons));
          }

          if ( *ril_resp_helper.short_eons && !*ril_resp_helper.long_eons && TRUE == nas_common_info.fill_eons)
          {
              QCRIL_LOG_INFO("Filling long eons with short eons");
              strlcpy( ril_resp_helper.long_eons, ril_resp_helper.short_eons , sizeof(ril_resp_helper.long_eons));
          }
      }
      else if ( is_service_in_3gpp2 )
      { // 3gpp2
            // get MCC / MNC
            memset(mcc_3gpp2_str,0,sizeof(mcc_3gpp2_str));
            memset(mnc_3gpp2_str,0,sizeof(mnc_3gpp2_str));
            sid_3gpp2 = 0;
            nid_3gpp2 = 0;

            ril_req_res = qcril_qmi_nas_fetch_sys_info();
            if ( RIL_E_SUCCESS == ril_req_res )
            {
              NAS_CACHE_LOCK();
              if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) && nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id_valid )
              {
                if( TRUE == qcril_qmi_nas_is_mcc_mnc_wildcard_entry(nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mcc,
                                                                    nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mnc) )
                {
                    qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper(mcc_3gpp2_str, mnc_3gpp2_str);
                }
                else
                {
                  qcril_qmi_nas_fillup_mcc_mnc_helper( nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mcc, mcc_3gpp2_str);
                  qcril_qmi_nas_fillup_mcc_mnc_helper( nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mnc, mnc_3gpp2_str);
                }
                snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_3gpp2_str, mnc_3gpp2_str );
                QCRIL_LOG_INFO("..mcc_mnc_ascii %s", ril_resp_helper.mcc_mnc_ascii);
              }

              if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) && nas_cached_info.cdma_sys_info->cdma_specific_sys_info.cdma_sys_id_valid )
              {
                  sid_3gpp2 = nas_cached_info.cdma_sys_info->cdma_specific_sys_info.cdma_sys_id.sid;
                  nid_3gpp2 = nas_cached_info.cdma_sys_info->cdma_specific_sys_info.cdma_sys_id.nid;
              }
              NAS_CACHE_UNLOCK();
            }

            res = qcril_qmi_nas_fill_up_3gpp2_operator_name(mcc_3gpp2_str,
                                                            mnc_3gpp2_str,
                                                            sid_3gpp2,
                                                            nid_3gpp2,
                                                            ril_resp_helper.long_eons,
                                                            sizeof(ril_resp_helper.long_eons),
                                                            ril_resp_helper.short_eons,
                                                            sizeof(ril_resp_helper.short_eons) );

            if( RIL_E_SUCCESS != ril_req_res || FALSE == res )
            {

                //fetch nam_name (for filling the long_eons) by sending QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_REQ_MSG_V01
                ril_req_res = RIL_E_GENERIC_FAILURE;
                memset(&cdma_subscription_info_req,0,sizeof(cdma_subscription_info_req));

                cdma_subscription_info_req.nam_id = 0xFF; // current NAM
                cdma_subscription_info_req.get_3gpp2_info_mask_valid = TRUE;
                cdma_subscription_info_req.get_3gpp2_info_mask = QMI_NAS_GET_3GPP2_SUBS_INFO_NAM_NAME_V01;

                //TODO **TIMER** use correct timer value
                qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_REQ_MSG_V01,
                                                              (void*) &cdma_subscription_info_req,
                                                              sizeof( cdma_subscription_info_req ),
                                                              (void*) &cdma_subscription_info_resp,
                                                              sizeof( cdma_subscription_info_resp ));

                ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error, &cdma_subscription_info_resp.resp, QCRIL_QMI_ERR_TOLERATE_NOT_FOUND, NULL );

                QCRIL_LOG_INFO("qmi_client_error: %d, ril_req_res: %d, cdma_subscription_info_resp.resp.error: %d",
                                 (int)qmi_client_error, (int) ril_req_res, cdma_subscription_info_resp.resp.error );


                if( RIL_E_SUCCESS == ril_req_res )
                {
                    QCRIL_LOG_INFO("nam name valid %d, len %d", (int)cdma_subscription_info_resp.nam_name_valid, (int) cdma_subscription_info_resp.nam_name_len);
                    if ( cdma_subscription_info_resp.nam_name_valid )
                    {
                      used_nam_name_len = MIN(cdma_subscription_info_resp.nam_name_len,
                                              MIN(NAS_MAX_NAM_NAME_LEN_V01,
                                                  (NAS_OPERATOR_RESP_MAX_EONS_LEN-1) )
                                             );
                      QCRIL_LOG_INFO(".. used_nam_name_len %d", (int)cdma_subscription_info_resp.nam_name_len );
                      memcpy(ril_resp_helper.long_eons, cdma_subscription_info_resp.nam_name, used_nam_name_len );
                      ril_resp_helper.long_eons[ used_nam_name_len ]  = 0;
                      QCRIL_LOG_INFO(".. nam %s", ril_resp_helper.long_eons );
                    }
                }

                if ( *ril_resp_helper.long_eons && !*ril_resp_helper.short_eons && TRUE == nas_common_info.fill_eons)
                {
                    QCRIL_LOG_INFO("Filling short eons with long eons");
                    strlcpy( ril_resp_helper.short_eons, ril_resp_helper.long_eons , sizeof(ril_resp_helper.short_eons));
                }

                if ( *ril_resp_helper.short_eons && !*ril_resp_helper.long_eons && TRUE == nas_common_info.fill_eons)
                {
                    QCRIL_LOG_INFO("Filling long eons with short eons");
                    strlcpy( ril_resp_helper.long_eons, ril_resp_helper.short_eons , sizeof(ril_resp_helper.long_eons));
                }

                if ( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_CDMA2000 ) &&  (!*ril_resp_helper.long_eons) )
                {
                    strlcpy(ril_resp_helper.long_eons, ril_resp_helper.mcc_mnc_ascii , sizeof(ril_resp_helper.long_eons));
                }
            }
      }
      else
      { // No Service
          ril_resp_helper.operator_info_array[ 0 ] = NULL;
          ril_resp_helper.operator_info_array[ 1 ] = NULL;
          ril_resp_helper.operator_info_array[ 2 ] = NULL;
      }

      QCRIL_LOG_INFO(".. res long %s", ril_resp_helper.long_eons);
      QCRIL_LOG_INFO(".. res short %s", ril_resp_helper.short_eons);
      QCRIL_LOG_INFO(".. res mcc_mnc %s", ril_resp_helper.mcc_mnc_ascii);
  }
  else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
              (nas_cached_info.gsm_srv_status_info->srv_status == NAS_SYS_SRV_STATUS_LIMITED_V01) &&
              NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
              NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id ) &&
              (nas_common_info.ct_operator_name ))
  {
    ril_resp_helper.operator_info_array[ 0 ] = ril_resp_helper.long_eons;
    ril_resp_helper.operator_info_array[ 1 ] = ril_resp_helper.short_eons;
    ril_resp_helper.operator_info_array[ 2 ] = ril_resp_helper.mcc_mnc_ascii;
    *ril_resp_helper.long_eons        = NAS_NIL;
    *ril_resp_helper.short_eons       = NAS_NIL;
    *ril_resp_helper.mcc_mnc_ascii    = NAS_NIL;
    snprintf( mcc_str, NAS_MCC_MNC_MAX_SIZE, "%c%c%c",
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc[0],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc[1],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc[2] );

    if ( nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[2] != 0xFF )
    {
      snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%c%c%c",
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[0],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[1],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[2] );
    }
    else
    {
      snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%c%c",
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[0],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[1]);
    }
    snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );
    QCRIL_LOG_INFO("..mcc_mnc_ascii %s", ril_resp_helper.mcc_mnc_ascii);
    qcril_qmi_nas_fill_up_operator_name(TRUE,
                                        mcc_str,
                                        mnc_str,
                                        ril_resp_helper.mcc_mnc_ascii,
                                        ril_resp_helper.long_eons,
                                        sizeof(ril_resp_helper.long_eons),
                                        ril_resp_helper.short_eons,
                                        sizeof(ril_resp_helper.short_eons) );
    QCRIL_LOG_INFO(".. long_eons %s, short_eons %s", ril_resp_helper.long_eons, ril_resp_helper.short_eons);
  }
  else if (qcril_qmi_nas_ims_registered_wlan_status())
  {
      QCRIL_LOG_INFO("retrieve pnn or spn");
      ril_resp_helper.operator_info_array[ 0 ] = ril_resp_helper.long_eons;
      ril_resp_helper.operator_info_array[ 1 ] = ril_resp_helper.short_eons;
      ril_resp_helper.operator_info_array[ 2 ] = ril_resp_helper.mcc_mnc_ascii;

      *ril_resp_helper.long_eons        = NAS_NIL;
      *ril_resp_helper.short_eons       = NAS_NIL;
      *ril_resp_helper.mcc_mnc_ascii    = NAS_NIL;

      ril_req_res = qcril_qmi_nas_retrieve_opl_pnn_or_spn(ril_resp_helper.short_eons,
                                                          sizeof(ril_resp_helper.short_eons),
                                                          ril_resp_helper.long_eons,
                                                          sizeof(ril_resp_helper.long_eons),
                                                          mcc_str,
                                                          mnc_str);
      snprintf( ril_resp_helper.mcc_mnc_ascii,
                sizeof(ril_resp_helper.mcc_mnc_ascii),
                "%s%s", mcc_str, mnc_str );
  }
  else
  {
      QCRIL_LOG_INFO(".. res empty as not in full service");
  }

  NAS_CACHE_UNLOCK();
  // ** respond
  ril_req_res = RIL_E_SUCCESS;  // should always return success for request_operator
  std::string longName(ril_resp_helper.long_eons);
  std::string shortName(ril_resp_helper.short_eons);
  std::string numeric(ril_resp_helper.mcc_mnc_ascii);
  auto payload = std::make_shared<qcril::interfaces::RilGetOperatorResult_t>(
        std::move(longName), std::move(shortName), std::move(numeric));
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

  qcril_unsuppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_unsuppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());
  QCRIL_LOG_INFO("complete with %d", (int) ril_req_res  );
} // qcril_qmi_nas_request_operator

//==========================================================================================
// qcril_qmi_util_is_plmn_already_added_to_nw_scan_results

// returns TRUE if passed plmn (mcc_str-mnc_str) is already part of nw scan results
//============================================================================================
int qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(char *mcc_str, char *mnc_str, char *short_eons, char *long_eons, qcril_qmi_nw_scan_resp_helper_type  * unique_network_scan_plmns_table, int no_of_unique_network_scan_plmns)
{
    int ret = FALSE;
    int iter_i;
    char plmn_str[NAS_NW_SCAN_RESP_MCCMNC_SIZE];
    QCRIL_NOTUSED(short_eons);
    QCRIL_NOTUSED(long_eons);

    QCRIL_LOG_FUNC_ENTRY();

    if( mcc_str && mnc_str && unique_network_scan_plmns_table )
    {
        snprintf( plmn_str, sizeof(plmn_str), "%s%s", mcc_str,mnc_str);
        QCRIL_LOG_INFO("checking plmn %s is unique or not",plmn_str);

        for( iter_i = 0; iter_i < no_of_unique_network_scan_plmns; iter_i++ )
        {
            // Compare plmn, short and long eons to identify same plmn with different RAT
            if( (!strcmp(plmn_str, (char*) unique_network_scan_plmns_table->mccmnc_info[iter_i])) )
                // identical plmn is already present in the network scan results
                // (RAT might be different)
            {
                ret = TRUE;
                break;
            }

        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_util_is_plmn_already_added_to_nw_scan_results

//==========================================================================================
// qcril_qmi_util_is_plmn_already_added_to_nw_scan_results

// returns TRUE if passed plmn (mcc_str-mnc_str) is already part of nw scan results
//============================================================================================
int qcril_qmi_util_is_plmn_already_added_to_nw_scan_results
(
    char *mcc_str,
    char *mnc_str,
    char *short_eons,
    char *long_eons,
    std::vector<qcril::interfaces::NetworkInfo>& list
)
{
    int ret = FALSE;
    QCRIL_NOTUSED(short_eons);
    QCRIL_NOTUSED(long_eons);

    QCRIL_LOG_FUNC_ENTRY();

    if (mcc_str && mnc_str)
    {
        std::string plmn = mcc_str;
        plmn.append(mnc_str);

        QCRIL_LOG_INFO("checking plmn %s is unique or not", plmn.c_str());

        for (size_t iter_i = 0; iter_i < list.size(); iter_i++ )
        {
            // Compare plmn, short and long eons to identify same plmn with different RAT
            if (!plmn.compare(list[iter_i].operatorNumeric))
                // identical plmn is already present in the network scan results
                // (RAT might be different)
            {
                ret = TRUE;
                break;
            }

        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_util_is_plmn_already_added_to_nw_scan_results

//=========================================================================
// qcril_qmi_nas_is_registered_plmn
//===========================================================================
int qcril_qmi_nas_is_registered_plmn(char *mcc, char *mnc)
{
    int res = FALSE;
    int is_reg_plmn = FALSE;
    char reg_mcc[QCRIL_MCC_MNC_MAX_SIZE];
    char reg_mnc[QCRIL_MCC_MNC_MAX_SIZE];

    QCRIL_LOG_FUNC_ENTRY();

    memset(reg_mcc, 0, sizeof(reg_mcc));
    memset(reg_mnc, 0, sizeof(reg_mnc));

    res = qcril_qmi_nas_find_current_mcc_mnc(reg_mcc,
                                             reg_mnc,
                                             TRUE,
                                             NULL);
    if ( res && mcc && mnc )
    {
        if ( !strncmp(mcc,reg_mcc,QCRIL_MCC_MNC_MAX_SIZE) &&
             !strncmp(mnc,reg_mnc,QCRIL_MCC_MNC_MAX_SIZE) )
        {
            is_reg_plmn = TRUE;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(is_reg_plmn);
    return is_reg_plmn;
}

//=========================================================================
// qcril_qmi_util_prefer_spn_over_plmn_name
//===========================================================================
int qcril_qmi_util_prefer_spn_over_plmn_name
(
    int is_spn_present,
    int is_plmn_name_present,
    int is_nw_scan,
    char *mcc,
    char *mnc
)
{
    int ret = FALSE;
    int is_reg_plmn = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO("is_nw_scan %d", is_nw_scan);
    QCRIL_LOG_INFO("spn_plmn_name_preference %d", nas_common_info.prefer_spn_over_plmn_name);

    if( is_spn_present )
    {
        QCRIL_LOG_INFO("spn is present");
        ret = TRUE;
    }

    if( is_plmn_name_present )
    {
        QCRIL_LOG_INFO("plmn_name is present");
        switch( nas_common_info.prefer_spn_over_plmn_name )
        {
            case QMI_RIL_NAS_DO_NOT_PREFER_SPN: //when both spn and plmn_name are present, prefer plmn_name over spn by default
                ret = FALSE;
                break;

            case QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_NAME_ONLY: //prefer spn for operator process only
                if( TRUE == is_nw_scan )
                {
                    ret = FALSE;
                }
                break;

            case QMI_RIL_NAS_PREFER_SPN_FOR_NW_SCAN_ONLY:
                /* For network scan prefer SPN only for registered
                   plmn.For all other plmn, need to consider plmn name.
                */
                if ( mcc && mnc )
                {
                    is_reg_plmn = qcril_qmi_nas_is_registered_plmn(mcc, mnc);
                }
                if( is_nw_scan && is_reg_plmn )
                {
                    ret = TRUE;
                }
                else
                {
                    ret = FALSE;
                }
                break;

            case QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_AND_NW_SCAN: //prefer spn for both nw_scan and operator processes If spn is present
            default:
                break;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);

    return ret;
} //qcril_qmi_util_prefer_spn_over_plmn_name

/*===========================================================================

 qcril_qmi_nas_retrieve_opl_pnn_or_spn

============================================================================*/
/*!
    @brief
    Retrieve Operator PLMN List and PLMN Network Name
    or Service Prvider Name

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_retrieve_opl_pnn_or_spn
(
    char *short_eons,
    size_t short_eons_sz,
    char *long_eons,
    size_t long_eons_sz,
    char *card_mcc_str,
    char *card_mnc_str
)
{
    RIL_Errno res  = RIL_E_GENERIC_FAILURE;

    do {

        if (!(short_eons && long_eons && card_mcc_str && card_mnc_str))
        {
            break;
        }

        /* Retrieve Card MCC and MNC */
        if (qcril_qmi_nas_get_sim_mcc_mnc(card_mcc_str, card_mnc_str))
        {
            break;
        }

        /* Query the plmn without any rat,
         * NV 67211 must be set in order to receive OPL_PNN else
         * SPN will be retrieved */
        qcril_qmi_nas_get_plmn_name_from_modem(card_mcc_str,
                                               card_mnc_str,
                                               short_eons,
                                               short_eons_sz,
                                               long_eons,
                                               long_eons_sz,
                                               FALSE,
                                               FALSE,
                                               FALSE,
                                               NAS_RADIO_IF_NO_SVC_V01,
                                               FALSE, 0);

        QCRIL_LOG_DEBUG("short_eons %s, long eons %s", short_eons, long_eons);
        res = RIL_E_SUCCESS;
    } while (0);

    return res;
}

//=========================================================================
// qcril_qmi_util_handle_centralized_short_long_eons
//===========================================================================
void qcril_qmi_util_handle_centralized_short_long_eons(char *mcc_str, char *mnc_str, char *short_eons, size_t short_eons_sz, char *long_eons, size_t long_eons_sz, int is_nw_scan, nas_radio_if_enum_v01 plmn_rat, uint8_t csg_id_valid, uint32_t csg_id)
{
  char mcc_mnc_ascii[NAS_OPERATOR_RESP_MAX_EONS_LEN];

  const char * internal_long_name;
  const char * internal_short_name;
  char loc_long_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
  char loc_short_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
  uint8_t status = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  memset( mcc_mnc_ascii,0, sizeof(mcc_mnc_ascii));
  snprintf( mcc_mnc_ascii, sizeof(mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );

  if( mcc_str && mnc_str && short_eons && long_eons )
  {
    // Legacy customer specifc scenario
    if( TRUE == is_nw_scan && TRUE == nas_common_info.use_se_table_only)
    {
      QCRIL_LOG_INFO("Special scenario: get op name from SE 13 only for perform network scan");
      qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, short_eons_sz, long_eons, long_eons_sz, TRUE, FALSE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
    }
    else
    {
      if (!(nas_common_info.always_send_plmn_name && is_nw_scan))
      {
        // Use EONS algorithm as is, to obtain operator name
        QCRIL_LOG_INFO("Query modem for EONS op name default.");
        qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, short_eons_sz, long_eons, long_eons_sz, FALSE, FALSE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
      }

      if( is_operator_name_empty_or_white_space( long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN ) &&
          is_operator_name_empty_or_white_space( short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN))
      {
        QCRIL_LOG_INFO("Query modem for EONS. Always send PLMN name.");
        // Fall back: Request modem to send PLMN name regardless of SPN
        qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, short_eons_sz, long_eons, long_eons_sz, FALSE, TRUE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
      }

      if( is_operator_name_empty_or_white_space( long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN ) &&
          is_operator_name_empty_or_white_space( short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN))
      {
        QCRIL_LOG_INFO("Query modem for EONS op name from SE.13 only");
        // Fall back on SE.13 table only (from modem)
        qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, short_eons_sz, long_eons, long_eons_sz, TRUE, FALSE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
      }
    }

    status = qcril_qmi_nas_check_long_short_name_as_mcc_mnc(mcc_str, mnc_str, long_eons, loc_long_eons);

    if(status || !strlen(long_eons))
    {
        status = qcril_qmi_nas_check_long_short_name_as_mcc_mnc(mcc_str, mnc_str, short_eons, loc_short_eons);
        if(!status && strlen(loc_long_eons) && !strlen(short_eons))
        {
            status = TRUE;
        }
        else
        {
            strlcpy(long_eons, loc_long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN);
        }
    }

    // If all attempts to retrieve operator name from modem fails, reply on QMI RIL's SE.13
    if(status || ( is_operator_name_empty_or_white_space( long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN ) &&
        is_operator_name_empty_or_white_space( short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN)) )
    {
      QCRIL_LOG_INFO("EONS long and short names returned are both empty or white space");
      internal_long_name  = NULL;
      internal_short_name = NULL;
      if(nas_common_info.use_ril_3gpp_operator_table)
      {
        qcril_qmi_nas2_find_static_operator_name(
                                                mcc_str,
                                                mnc_str,
                                                mcc_mnc_ascii,
                                                &internal_long_name,
                                                &internal_short_name
                                                );
      }
      QCRIL_LOG_INFO("static table: long eons %s, short eons: %s",
                        ( NULL != internal_long_name ) ? internal_long_name : "<empty>" ,
                        ( NULL != internal_short_name )  ? internal_short_name : "<empty>"
                     );

      if(!internal_long_name && !internal_short_name && status)
      {
        strlcpy( long_eons, loc_long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN );
        strlcpy( short_eons, loc_short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN );
      }
      else
      {
        if(!internal_long_name && !internal_short_name)
        {
            internal_long_name = mcc_mnc_ascii;
            internal_short_name = "";
        }

        if ( NULL != internal_long_name )
        {
          strlcpy( long_eons, internal_long_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
        }
        else
        {
          snprintf( long_eons, long_eons_sz, "%s-%s", mcc_str, mnc_str );
        }

        if ( NULL != internal_short_name )
        {
          strlcpy( short_eons, internal_short_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
        }
        else
        {
          snprintf( short_eons, short_eons_sz, "%s-%s", mcc_str, mnc_str );
        }
      }
    } // fallback to RIL internal table case
  }
  else
  {
    QCRIL_LOG_FATAL("Null pointer passed");
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_util_handle_centralized_short_long_eons

//=========================================================================
// qcril_qmi_nas_get_plmn_name_from_modem
//===========================================================================
static void qcril_qmi_nas_get_plmn_name_from_modem
(
  char *mcc_str,
  char *mnc_str,
  char *short_eons,
  size_t short_eons_sz,
  char *long_eons,
  size_t long_eons_sz,
  boolean use_static_table_only,
  boolean is_always_send_plmn_name,
  int  is_nw_scan,
  nas_radio_if_enum_v01 plmn_rat,
  uint8_t csg_id_valid,
  uint32_t csg_id
)
{
  int mcc,mnc;
  nas_get_plmn_name_req_msg_v01  get_plmn_req;
  nas_get_plmn_name_resp_msg_v01 get_plmn_resp;
  qmi_client_error_type qmi_client_error = QMI_NO_ERR;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  int is_spn_present = 0;
  int is_plmn_name_present = 0;
  int is_unicode_name_present = 0;
  int prefer_spn;
  uint32_t name_len;

  QCRIL_LOG_FUNC_ENTRY();

  if( !mcc_str || !mnc_str || !short_eons || !short_eons_sz || !long_eons || !long_eons_sz )
  {
    QCRIL_LOG_ERROR( "Invalid args. NULL ptr passed.");
    QCRIL_LOG_FUNC_RETURN();
    return;
  }

  memset(&get_plmn_req,0,sizeof(get_plmn_req));
  memset(&get_plmn_resp,0,sizeof(get_plmn_resp));
  memset(short_eons, 0, short_eons_sz);
  memset(long_eons, 0, long_eons_sz);

  mcc = atoi(mcc_str);
  mnc = atoi(mnc_str);
  get_plmn_req.plmn.mcc = mcc;
  get_plmn_req.plmn.mnc = mnc;

  if( '0' == mnc_str[0] && NAS_MCC_MNC_MAX_V01 == strlen(mnc_str) )
  {
    get_plmn_req.mnc_includes_pcs_digit_valid = TRUE;
    get_plmn_req.mnc_includes_pcs_digit = TRUE;
  }
  get_plmn_req.suppress_sim_error_valid = TRUE;
  get_plmn_req.suppress_sim_error = TRUE;

  if( use_static_table_only )
  {
    get_plmn_req.use_static_table_only_valid = TRUE;
    get_plmn_req.use_static_table_only = TRUE;
  }

    NAS_CACHE_LOCK();

    // Pass the RAT from network scan response if found valid.
    if ( is_nw_scan )
    {
      if(plmn_rat != NAS_RADIO_IF_NO_SVC_V01)
      {
        get_plmn_req.rat_valid = TRUE;
        get_plmn_req.rat = plmn_rat;
      }
      else
      {
        QCRIL_LOG_INFO("Unknown RAT passed by QMI NAS!");
        get_plmn_req.rat_valid = FALSE;
      }
    }
    else
    {
        if(plmn_rat != NAS_RADIO_IF_NO_SVC_V01)
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = plmn_rat;
        }
        else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE))
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = NAS_RADIO_IF_LTE_V01;
        }
        else if (qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM))
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = NAS_RADIO_IF_GSM_V01;
        }
        else if (qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS))
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = NAS_RADIO_IF_UMTS_V01;
        }
        else
        {
          //TODO for TDSCDMA.
          get_plmn_req.rat_valid = FALSE;
        }
    }

    if( is_always_send_plmn_name )
    {
      get_plmn_req.always_send_plmn_name_valid = TRUE;
      get_plmn_req.always_send_plmn_name = TRUE;
    }

    if( TRUE == csg_id_valid )
    {
        get_plmn_req.csg_id_valid = csg_id_valid;
        get_plmn_req.csg_id = csg_id;
    }

    NAS_CACHE_UNLOCK();

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_PLMN_NAME_REQ_MSG_V01,
                                                  (void*) &get_plmn_req,
                                                  sizeof( get_plmn_req ),
                                                  (void*) &get_plmn_resp,
                                                  sizeof( get_plmn_resp ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error, &get_plmn_resp.resp, QCRIL_QMI_ERR_TOLERATE_NOT_FOUND, NULL );

  QCRIL_LOG_INFO("qmi_client_error: %d, ril_req_res: %d, get_plmn_resp.resp.error: %d",
                   (int)qmi_client_error, (int) ril_req_res, get_plmn_resp.resp.error );

  if( RIL_E_SUCCESS == ril_req_res )
  {
      /*using (OR) condition to handle case where op. name is present only in unicoded SE13 table
       * and not present in mmgsdi_network_table */
      if(TRUE == get_plmn_resp.lang_plmn_names_valid || TRUE == get_plmn_resp.eons_plmn_name_3gpp_valid )
      {
        if(get_plmn_resp.eons_plmn_name_3gpp_valid) {
          is_spn_present = (get_plmn_resp.eons_plmn_name_3gpp.spn_len > NAS_NIL);
          is_plmn_name_present = ((get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_len > NAS_NIL) || (get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_len > NAS_NIL));
        }

        if(get_plmn_resp.lang_plmn_names_valid) {
          char temp_long_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
          char temp_short_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
          memset(temp_long_eons, 0, sizeof(temp_long_eons));
          memset(temp_short_eons, 0, sizeof(temp_short_eons));
          bool opname_result = qcril_qmi_nas_read_unicode_operator_names(&get_plmn_resp,
                                                        temp_short_eons, sizeof(temp_short_eons),
                                                        temp_long_eons, sizeof(temp_long_eons));

          is_unicode_name_present = (opname_result &&
                                    (!is_operator_name_empty_or_white_space((char *)temp_short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN)) &&
                                    (!is_operator_name_empty_or_white_space((char *)temp_long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN)));

          //combine result with eons_plmn_name result
          is_plmn_name_present = is_plmn_name_present || is_unicode_name_present;
        }

        prefer_spn = qcril_qmi_util_prefer_spn_over_plmn_name(is_spn_present, is_plmn_name_present, is_nw_scan, mcc_str, mnc_str);

        if( TRUE == prefer_spn )
        {
          name_len = ( get_plmn_resp.eons_plmn_name_3gpp.spn_len > NAS_SPN_LEN_MAX_V01 ) ?
                    NAS_SPN_LEN_MAX_V01 : get_plmn_resp.eons_plmn_name_3gpp.spn_len;
          if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == get_plmn_resp.eons_plmn_name_3gpp.spn_enc )
          {
              qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                                name_len,
                                                                short_eons,
                                                                short_eons_sz );
              qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                                name_len,
                                                                long_eons,
                                                                short_eons_sz );
              QCRIL_LOG_INFO("spn is 7-bit Unpacked data");
          }
          else
          {
              qcril_qmi_util_decode_operator_name_in_little_endian(short_eons,
                                                      short_eons_sz,
                                                      get_plmn_resp.eons_plmn_name_3gpp.spn_enc,
                                                      (uint8*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                      name_len);

              qcril_qmi_util_decode_operator_name_in_little_endian(long_eons,
                                                      long_eons_sz,
                                                      get_plmn_resp.eons_plmn_name_3gpp.spn_enc,
                                                      (uint8*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                      name_len);

         }
         QCRIL_LOG_INFO("short eons derived from spn %s",short_eons);
         QCRIL_LOG_INFO("long eons derived from spn %s",long_eons);
       }
       else
       {
         boolean read_ucs2_name_status = FALSE;
         if(get_plmn_resp.lang_plmn_names_valid) {
           read_ucs2_name_status = qcril_qmi_nas_read_unicode_operator_names(&get_plmn_resp, short_eons, short_eons_sz, long_eons, long_eons_sz);
         }
         QCRIL_LOG_DEBUG("op_name reading from lang_table status %d ",read_ucs2_name_status);

         if (!read_ucs2_name_status) {
           name_len = ( get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_len > NAS_PLMN_NAME_MAX_V01 ) ?
                     NAS_PLMN_NAME_MAX_V01 : get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_len;
           if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_enc )
           {
             qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name,
                                                                name_len,
                                                                short_eons,
                                                                short_eons_sz );
             QCRIL_LOG_INFO("plmn short name is 7-bit Unpacked data");
           }
           else
           {
             qcril_qmi_util_decode_operator_name_in_little_endian(short_eons,
                                                        short_eons_sz,
                                                        get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_enc,
                                                        (uint8*)get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name,
                                                        name_len);
             QCRIL_LOG_INFO("short eons derived from plmn %s",short_eons);
           }

           name_len = ( get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_len > NAS_PLMN_NAME_MAX_V01 ) ?
                     NAS_PLMN_NAME_MAX_V01 : get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_len;
           if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_enc )
           {
             qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name,
                                                                name_len,
                                                                long_eons,
                                                                long_eons_sz );
             QCRIL_LOG_INFO("plmn long name is 7-bit Unpacked data");
           }
           else
           {
             qcril_qmi_util_decode_operator_name_in_little_endian(long_eons,
                                                       long_eons_sz,
                                                       get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_enc,
                                                       (uint8*)get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name,
                                                       name_len);
             QCRIL_LOG_INFO("long eons derived from plmn %s",long_eons);
           }
         }
       }
      }
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_plmn_name_from_modem
//=========================================================================
//  FUNCTION: qcril_qmi_util_decode_operator_name
//===========================================================================
void qcril_qmi_util_decode_operator_name
(
  char *dest,
  uint16 max_dest_length,
  int coding_scheme,
  const uint8 *src,
  uint16 src_length
)
{
  size_t data_length;
  char *temp_buf;
  size_t i;

  if ( dest!= NULL && src != NULL && src_length > NAS_NIL )
  {
      data_length = ( src_length > max_dest_length ) ? max_dest_length : src_length;

      switch ( coding_scheme )
      {
        case QMI_CODING_SCHEME_CELL_BROADCAST_DATA:
          QCRIL_LOG_INFO( "7-bit coding scheme for NITZ ONS" );
          qcril_cm_ons_decode_packed_7bit_gsm_string( src, src_length, dest, max_dest_length );
          QCRIL_LOG_DEBUG( "NITZ 7-bit GSM str: %s", dest );
          break;

        case QMI_CODING_SCHEME_UCS2:
          QCRIL_LOG_INFO( "UC2 coding scheme for NITZ ONS, len %d", data_length );
          if ( ( data_length % 2 ) != 0 )
          {
            QCRIL_LOG_ERROR( "Invalid UCS length %d", data_length );
            break;
          }

          temp_buf = (char *) qcril_malloc( data_length );
          if ( temp_buf == NULL )
          {
            QCRIL_LOG_ERROR( "Fail to allocate buffer for decoding UCS2" );
            break;
          }

          for ( i = 0; i < data_length; i = i + 2 )
          {
            temp_buf[ i ] = src[ i + 1 ];
            temp_buf[ i + 1 ] = src[ i ];
          }

          (void) qcril_cm_ss_convert_ucs2_to_utf8( temp_buf, data_length, dest, max_dest_length );
          QCRIL_LOG_DEBUG( "NITZ UCS str: %s", dest );

          qcril_free( temp_buf );
          break;

        default:
          QCRIL_LOG_INFO( "Unknown coding scheme %d for NITZ ONS", coding_scheme );
          break;
      }
  }
  else
  {
      QCRIL_LOG_FATAL("CHECK FAILED");
  }

} // qcril_cm_ons_decode_nitz_operator_name

//=========================================================================
//  FUNCTION: qcril_qmi_util_decode_operator_name_in_little_endian
//===========================================================================
void qcril_qmi_util_decode_operator_name_in_little_endian
(
  char *dest,
  size_t max_dest_length,
  int coding_scheme,
  const uint8 *src,
  uint16 src_length
)
{
  size_t data_length;

  QCRIL_LOG_FUNC_ENTRY();

  if ( dest!= NULL && src != NULL && src_length > NAS_NIL )
  {
      data_length = ( src_length > max_dest_length ) ? max_dest_length : src_length;

      switch ( coding_scheme )
      {
        case QMI_CODING_SCHEME_CELL_BROADCAST_DATA:
          QCRIL_LOG_INFO( "7-bit coding scheme for NITZ ONS" );
          qcril_cm_ons_decode_packed_7bit_gsm_string(  src, data_length, dest, max_dest_length );
          QCRIL_LOG_DEBUG( "NITZ 7-bit GSM str: %s", dest );
          break;

        case QMI_CODING_SCHEME_UCS2:
          QCRIL_LOG_INFO( "UC2 coding scheme for NITZ ONS, len %d", data_length );
          if ( ( data_length % 2 ) != 0 )
          {
            QCRIL_LOG_ERROR( "Invalid UCS length %d", data_length );
            break;
          }
          (void) qcril_cm_ss_convert_ucs2_to_utf8( (char *)src, data_length, dest, max_dest_length );
           QCRIL_LOG_DEBUG( "NITZ UCS str: %s", dest );

          break;

        default:
          QCRIL_LOG_INFO( "Unknown coding scheme %d for NITZ ONS", coding_scheme );
          break;
      }
  }
  else
  {
      QCRIL_LOG_FATAL("CHECK FAILED");
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_util_decode_operator_name_in_little_endian

//===========================================================================
// RIL_REQUEST_RADIO_POWER
//===========================================================================
void qcril_qmi_nas_request_power
(
  std::shared_ptr<RilRequestRadioPowerMessage> msg
)
{
  int requested_telephony_power_state;
  RIL_Errno res                                            = RIL_E_GENERIC_FAILURE;
  dms_operating_mode_enum_v01 requested_dms_operating_mode;
  IxErrnoType internal_err;

  QCRIL_LOG_FUNC_ENTRY();

  if (msg != nullptr)
  {
      qcril_qmi_nas_update_radio_power_request_info();

      requested_telephony_power_state =
          msg->getRadioState() ? RIL_VAL_RADIO_POWER_MODE_ONLINE : RIL_VAL_RADIO_POWER_MODE_LPM;
      switch ( requested_telephony_power_state )
      {
          case RIL_VAL_RADIO_POWER_MODE_ONLINE:
              requested_dms_operating_mode = DMS_OP_MODE_ONLINE_V01;
              res = RIL_E_SUCCESS;
              if(qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm())
              {
                  RADIO_POWER_LOCK();
                  if (TRUE == nas_common_info.modem_power_info.is_not_bootup_radio_power_on)
                  {
                      RADIO_POWER_UNLOCK();
                      if (0 == qcril_qmi_modem_power_voting_state_primary_modem())
                      {
                          RADIO_POWER_LOCK();
                          nas_common_info.modem_power_info.radio_power_process_pending = TRUE;
                          RADIO_POWER_UNLOCK();
                          qcril_qmi_register_for_up_event();
                          qcril_qmi_modem_power_process_apm_off();
                          RADIO_POWER_LOCK();
                          if (TRUE == nas_common_info.modem_power_info.radio_power_process_pending)
                          {
                              internal_err = RADIO_POWER_WAIT();
                              if(internal_err == E_SUCCESS)
                              {
                                res = RIL_E_SUCCESS;
                              }
                              else
                              {
                                QCRIL_LOG_ERROR("RADIO_POWER_WAIT returned error %d", internal_err);
                                res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(internal_err);
                              }
                              RADIO_POWER_UNLOCK();
                          }
                          else
                          {
                              RADIO_POWER_UNLOCK();
                              QCRIL_LOG_INFO("Already received signal");
                          }
                      }
                  }
                  else
                  {
                      nas_common_info.modem_power_info.is_not_bootup_radio_power_on = TRUE;
                      RADIO_POWER_UNLOCK();
                  }
              }
              break;

          case RIL_VAL_RADIO_POWER_MODE_LPM:
              requested_dms_operating_mode = DMS_OP_MODE_LOW_POWER_V01;
              res = RIL_E_SUCCESS;
              break;

          default: // invalid (or unsupported) value
              QCRIL_LOG_ERROR("Invalid arguments..Invalid/Unsupported value");
              res = RIL_E_INVALID_ARGUMENTS;
              break;
      }

      if( RIL_E_SUCCESS == res )
      {
          auto ret = getDmsModule().getPendingMessageList().insert(msg);
          if (ret.second)
          {
              // after reqlist is added, check the early radio power
              qcril_qmi_nas_start_timer_if_early_radio_power_req_came();
              qcril_qmi_nas_radio_power_transaction_handler( requested_telephony_power_state );
              res = RIL_E_SUCCESS;
          }
          else
          {
              QCRIL_LOG_ERROR("failed to add to pending list");
              res = RIL_E_INTERNAL_ERR;
          }

      }

      if ( RIL_E_SUCCESS != res )
      {
          auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
              res, nullptr);
          msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
          // To make sure we don't end up having msg in list
          getDmsModule().getPendingMessageList().erase(msg);
       }

  }
  else
  {
    QCRIL_LOG_ERROR("msg ptr is null..");
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_request_power

//===========================================================================
//qcril_qmi_nas_initiate_radio_power_process
//===========================================================================
void qcril_qmi_nas_initiate_radio_power_process()
{
    QCRIL_LOG_FUNC_ENTRY();

    struct timeval tp;

    NAS_CACHE_LOCK();
    gettimeofday(&tp, NULL);
    nas_common_info.is_radio_power_check_enabled = FALSE;
    nas_common_info.radio_power_request_type = QMI_RIL_DMS_RADIO_PWR_REQUEST_NONE;
    nas_common_info.radio_power_cancel_type = QMI_RIL_DMS_RADIO_PWR_CANCEL_NONE;
    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
    nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN;
    nas_common_info.radio_power_multiple_rild_process_complete_num = NAS_NIL;
    nas_common_info.radio_power_multiple_rild_process_timer_valid = FALSE;
    nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE;

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_initiate_radio_power_process

//===========================================================================
//qcril_qmi_nas_voice_move_device_to_online_for_emer_call_conditionally
//===========================================================================
RIL_Errno qcril_qmi_nas_voice_move_device_to_online_for_emer_call_conditionally()
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type current_state;

    QCRIL_LOG_FUNC_ENTRY();

    if( nas_common_info.prov_emer_call_in_lpm )
    {
        RADIO_POWER_LOCK();
        current_state = nas_common_info.radio_pwr_prov_emer_call_lpm_state;
        RADIO_POWER_UNLOCK();

        QCRIL_LOG_INFO("current state %d", current_state);
        if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE == current_state )
        {
            RADIO_POWER_LOCK();
            nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE;
            nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode = DMS_OP_MODE_ONLINE_V01;
            RADIO_POWER_UNLOCK();
            res = qcril_qmi_nas_radio_power_handle_modem_transition(RIL_VAL_RADIO_POWER_MODE_ONLINE, nullptr );

            RADIO_POWER_LOCK();
            if( RIL_E_SUCCESS == res )
            {
                if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE != nas_common_info.radio_pwr_prov_emer_call_lpm_state ) //modem was already ONLINE, no action needed
                {
                    nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NO_ACTION;
                }
            }
            else
            {
                nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE;
            }
            RADIO_POWER_UNLOCK();
        }
        else if ( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE !=
                  nas_common_info.radio_pwr_prov_emer_call_lpm_state ) {
            res = RIL_E_SUCCESS;
        }
    }
    else
    {
        res = RIL_E_SUCCESS;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} //qcril_qmi_nas_voice_move_device_to_online_for_emer_call_conditionally

//===========================================================================
//qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally
//===========================================================================
RIL_Errno qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally(void *param)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type current_state;
    QCRIL_NOTUSED(param);

    QCRIL_LOG_FUNC_ENTRY();

    if( nas_common_info.prov_emer_call_in_lpm )
    {
        RADIO_POWER_LOCK();
        current_state = nas_common_info.radio_pwr_prov_emer_call_lpm_state;
        RADIO_POWER_UNLOCK();

        QCRIL_LOG_INFO("current state %d", current_state);
        if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE == current_state ) //modem was moved to ONLINE for emergency call, so need to move it back to LPM once call is ended
        {
            RADIO_POWER_LOCK();
            nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE;
            nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode = DMS_OP_MODE_LOW_POWER_V01;
            RADIO_POWER_UNLOCK();
            res = qcril_qmi_nas_radio_power_handle_modem_transition(RIL_VAL_RADIO_POWER_MODE_LPM, nullptr);
        }
        else if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NO_ACTION == current_state ) //modem was already ONLINE before emergency call was made, so need not put it back to LPM
        {
            res = RIL_E_SUCCESS;
        }

        RADIO_POWER_LOCK();
        nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE;
        RADIO_POWER_UNLOCK();
    }
    else
    {
        res = RIL_E_SUCCESS;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} //qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally

static inline void qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally_cb(void *param)
{
  RIL_Errno res = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();
  if ( (res = qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally(param)) )
  {
    QCRIL_LOG_ERROR("Return from qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally: %d", res);
  }
  QCRIL_LOG_FUNC_RETURN();
}

RIL_Errno qcril_qmi_nas_register_for_5g_modem_vote_indication(void)
{
    nas_indication_register_req_msg_v01 request;
    nas_indication_register_resp_msg_v01 response;

    memset(&request, 0, sizeof(request));
    request.reg_5g_modem_vote_ind_valid = TRUE;
    request.reg_5g_modem_vote_ind = TRUE;

    qmi_client_error_type qmi_transport_error = qmi_client_nas_send_sync(
            QMI_NAS_INDICATION_REGISTER_REQ_MSG_V01,
            (void*) &request,
            sizeof(request),
            (void*) &response,
            sizeof(response));

    RIL_Errno ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
            qmi_transport_error, &response.resp);

    if ( ril_err == RIL_E_SUCCESS )
    {
        QCRIL_LOG_INFO("Successfully registered for 5G modem vote indication.");
    }
    else
    {
        QCRIL_LOG_INFO("Failed to register for 5G modem vote indication. "
                       "[qmi_transport_error: %d] [ril_err: %d]",
                       (int) qmi_transport_error, (int) ril_err);
    }

    return ril_err;
}

//===========================================================================
//qcril_qmi_nas_cancel_radio_power_process
//===========================================================================
void qcril_qmi_nas_cancel_radio_power_process(qmi_ril_dms_radio_pwr_cancel_e_type cancel_reason)
{
    QCRIL_LOG_FUNC_ENTRY();

    RADIO_POWER_LOCK();

    nas_common_info.radio_power_cancel_type = cancel_reason;
    QCRIL_LOG_INFO("Updated radio power process cancel reason to %s",radio_power_cancel_name[nas_common_info.radio_power_cancel_type]);
    RADIO_POWER_SIGNAL();

    RADIO_POWER_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_cancel_radio_power_process

//===========================================================================
//qcril_qmi_nas_radio_power_process_condition_wait_helper
//===========================================================================
IxErrnoType qcril_qmi_nas_radio_power_process_condition_wait_helper()
{
    IxErrnoType res = E_SUCCESS;
    std::chrono::seconds timeout(74);

    if( QMI_RIL_DMS_RADIO_PWR_CANCEL_NONE != nas_common_info.radio_power_cancel_type )
    {
        QCRIL_LOG_INFO("radio power process cancelled due to %s",radio_power_cancel_name[nas_common_info.radio_power_cancel_type]);
        switch( nas_common_info.radio_power_cancel_type )
        {
            case QMI_RIL_DMS_RADIO_PWR_CANCEL_SSR:
                res = E_RADIO_NOT_AVAILABLE;
                break;

            default: //no action
                res = E_FAILURE;
                break;
        }
    }
    else
    {
        QCRIL_LOG_INFO ("Starting to wait for signal");
        res = (IxErrnoType) nas_common_info.radio_pwr_cond_var.wait_for(nas_common_info.radio_pwr_mutex, timeout);
        if( QMI_RIL_DMS_RADIO_PWR_CANCEL_NONE != nas_common_info.radio_power_cancel_type )
        {
            QCRIL_LOG_INFO("radio power process cancelled due to %s",radio_power_cancel_name[nas_common_info.radio_power_cancel_type]);
            switch( nas_common_info.radio_power_cancel_type )
            {
                case QMI_RIL_DMS_RADIO_PWR_CANCEL_SSR:
                    res = E_RADIO_NOT_AVAILABLE;
                    break;

                default: //no action
                    res = E_FAILURE;
                    break;
            }
        }
    }

    return res;
} //qcril_qmi_nas_radio_power_process_condition_wait_helper

//===========================================================================
//qcril_qmi_nas_log_radio_power_process_state
//===========================================================================
void qcril_qmi_nas_log_radio_power_process_state(int requested_telephony_power_state,qmi_ril_dms_radio_pwr_state_e_type cur_state)
{
    qcril_uim_card_status_e_type                    cur_card_state;
    dms_operating_mode_enum_v01                     cur_operating_mode;
    uint32_t slot = qmi_ril_get_sim_slot();

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    cur_card_state = nas_common_info.card_info[ slot ].status;
    cur_operating_mode = nas_dms_cached_info.operating_mode;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_DEBUG("telephony %s | ril %s | card %s | modem %s",radio_power_telephony_request_name[requested_telephony_power_state+1],
                                                            radio_power_state_name[cur_state],
                                                            card_status_name[cur_card_state],
                                                            dms_op_mode_name[cur_operating_mode]);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_log_radio_power_process_state

//===========================================================================
//qcril_qmi_nas_radio_power_handle_card_transition
//===========================================================================
RIL_Errno qcril_qmi_nas_radio_power_handle_card_transition( int requested_telephony_power_state )
{
    RIL_Errno transaction_res = RIL_E_SUCCESS;
    qcril_evt_e_type requested_card_state;
    qcril_uim_card_status_e_type cur_card_state;
    int card_state_transition_needed = TRUE;
    int wait_res;
    uint32_t slot = qmi_ril_get_sim_slot();

    QCRIL_LOG_FUNC_ENTRY();

    RADIO_POWER_LOCK();
    NAS_CACHE_LOCK();
    cur_card_state = nas_common_info.card_info[ slot ].status;
    NAS_CACHE_UNLOCK();

    switch ( cur_card_state )
    {
        case QCRIL_CARD_STATUS_UP:
            if( RIL_VAL_RADIO_POWER_MODE_ONLINE != requested_telephony_power_state )
            {
                if( TRUE == qcril_qmi_nas_is_apm_enabled() ||                    // Telephony sends RADIO_POWER OFF at bootup from JB
                    FALSE == qcril_qmi_nas_is_bootup_radio_power_off_request() )
                {
                  requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN;
                }
                else
                {
                  card_state_transition_needed = FALSE;
                }
            }
            else
            {
              card_state_transition_needed = FALSE;
            }
            break;

      case QCRIL_CARD_STATUS_DOWN:
            if( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
            {
              requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP;
            }
            else
            {
              card_state_transition_needed = FALSE;
            }
            break;

        case QCRIL_CARD_STATUS_ABSENT:
            if( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
            {
                requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP;
            }
            else
            {
                if (qcril_qmi_nas_is_bootup_radio_power_off_request())
                {
                    card_state_transition_needed = FALSE;
                }
                else
                {
                    requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN;
                }
            }
            break;

        default:
            card_state_transition_needed = FALSE;
            break;
    }

    if( QCRIL_CARD_STATUS_UNKNOWN == cur_card_state && FALSE == nas_common_info.no_wait_for_card )
    {
        qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_CARD_STATUS);
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD;
        wait_res = RADIO_POWER_WAIT();

        if( ETIMEDOUT == wait_res )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            QCRIL_LOG_DEBUG("Radio power wait - ETIMEDOUT.. tranlate to INTERNAL_ERR");
            transaction_res = RIL_E_INTERNAL_ERR;
        }
        else
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            NAS_CACHE_LOCK();
            cur_card_state = nas_common_info.card_info[ slot ].status;
            NAS_CACHE_UNLOCK();
            if( QCRIL_CARD_STATUS_UP == cur_card_state && //Need to power down the card when device bootsup in APM
                TRUE == qcril_qmi_nas_is_apm_enabled() &&
                TRUE == qcril_qmi_nas_is_bootup_radio_power_off_request())
            {
                card_state_transition_needed = TRUE;
                requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN;
            }
            /*During RADIO_POWER OFF if service down event/SSR happen then card_state
              will be UNKNOWN at the time of ONLINE request, so RIL should wait for
              card_state change to DOWN. Then RIL should process CARD_POWER_UP event to UIM.*/
            else if ( ( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state ) &&
                      ( QCRIL_CARD_STATUS_UP != cur_card_state ) &&
                      ( QCRIL_CARD_STATUS_UNKNOWN != cur_card_state )
                    )
            {
                QCRIL_LOG_DEBUG("card status %s", card_status_name[cur_card_state]);
                card_state_transition_needed = TRUE;
                requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP;
            }
        }
    }

    if ( NAS_NIL == nas_common_info.apm_sim_not_pwdn && TRUE == card_state_transition_needed )
    {
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD;
        RADIO_POWER_UNLOCK();

        transaction_res = qcril_qmi_nas_dms_handle_card_status(requested_card_state);

        RADIO_POWER_LOCK();
        if( RIL_E_SUCCESS != transaction_res )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
        }
        else
        {
            NAS_CACHE_LOCK();
            cur_card_state = nas_common_info.card_info[ slot ].status;
            NAS_CACHE_UNLOCK();

            if (( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD == nas_common_info.radio_pwr_signal_cond ) &&
                (cur_card_state != QCRIL_CARD_STATUS_ABSENT))
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_CARD_STATUS);
                wait_res = RADIO_POWER_WAIT();
                if( ETIMEDOUT == wait_res )
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                    QCRIL_LOG_DEBUG("Radio power wait - ETIMEDOUT.. tranlate to INTERNAL_ERR");
                    transaction_res = RIL_E_INTERNAL_ERR;
                }
                else
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                }
            }
            else
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET);
                nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            }
        }
    }
    RADIO_POWER_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(transaction_res);
    return transaction_res;
} //qcril_qmi_nas_radio_power_handle_card_transition

//===========================================================================
// qcril_qmi_nas_radio_power_handle_modem_transition
// p_operating_mode_changed is only filled when SUCCESS
//===========================================================================
RIL_Errno qcril_qmi_nas_radio_power_handle_modem_transition( int requested_telephony_power_state, int* p_op_mode_change_needed )
{
    RIL_Errno transaction_res = RIL_E_SUCCESS;
    dms_operating_mode_enum_v01 requested_dms_operating_mode;
    int is_operating_mode_change_needed = TRUE;
    int wait_res;

    QCRIL_LOG_FUNC_ENTRY();

    switch ( requested_telephony_power_state )
    {
        case RIL_VAL_RADIO_POWER_MODE_ONLINE:
            requested_dms_operating_mode = DMS_OP_MODE_ONLINE_V01;
            break;

        case RIL_VAL_RADIO_POWER_MODE_LPM:
            requested_dms_operating_mode = DMS_OP_MODE_LOW_POWER_V01;
            break;

        default: // invalid (or unsupported) value
            QCRIL_LOG_ERROR("Invalid arguments..invalid/unsupported params");
            transaction_res = RIL_E_INVALID_ARGUMENTS;
            break;
    }

    if( RIL_E_SUCCESS == transaction_res )
    {
        RADIO_POWER_LOCK();
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM;
        RADIO_POWER_UNLOCK();

        transaction_res = qcril_qmi_nas_dms_handle_modem_operating_mode(requested_dms_operating_mode, &is_operating_mode_change_needed);

        RADIO_POWER_LOCK();
        if( RIL_E_SUCCESS != transaction_res )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
        }
        else if( FALSE == is_operating_mode_change_needed )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
        }
        else
        {
            if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM == nas_common_info.radio_pwr_signal_cond )
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_OP_MODE);
                wait_res = RADIO_POWER_WAIT();
                if( ETIMEDOUT == wait_res )
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                    QCRIL_LOG_DEBUG("Radio power wait - ETIMEDOUT.. tranlate to INTERNAL_ERR");
                    transaction_res = RIL_E_INTERNAL_ERR;
                }
                else
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                }
            }
            else
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET);
                nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            }
        }
        RADIO_POWER_UNLOCK();
        if (p_op_mode_change_needed)
            *p_op_mode_change_needed = is_operating_mode_change_needed;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(transaction_res);
    return transaction_res;
} //qcril_qmi_nas_radio_power_handle_modem_transition

static RIL_Errno qcril_qmi_nas_radio_power_wait_for_dms_service() {
    QCRIL_LOG_FUNC_ENTRY();

    RIL_Errno res = RIL_E_SUCCESS;
    if (!getNasModule().isDmsEndpointReady()) {
        QCRIL_LOG_DEBUG("Waiting for DMS service to be up.");

        RADIO_POWER_LOCK();
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_WAITING_FOR_DMS_SERVICE;
        if (RADIO_POWER_WAIT() == ETIMEDOUT) {
            res = RIL_E_INTERNAL_ERR;
        }
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
        RADIO_POWER_UNLOCK();

        if (res == RIL_E_INTERNAL_ERR) {
            QCRIL_LOG_DEBUG("Timedout waiting for DMS service to be up.");
        } else {
            QCRIL_LOG_DEBUG("DMS service is up now.");
        }
    } else {
        QCRIL_LOG_DEBUG("DMS service is already up.");
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

void qcril_qmi_nas_notify_radio_power_handler_dms_service_is_up() {
    if (nas_common_info.radio_pwr_signal_cond == QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_WAITING_FOR_DMS_SERVICE) {
        RADIO_POWER_SIGNAL();
    }
}

//===========================================================================
//qcril_qmi_nas_radio_power_transaction_handler
//===========================================================================
void qcril_qmi_nas_radio_power_transaction_handler( int requested_telephony_power_state )
{
    RIL_Errno                       transaction_res = RIL_E_SUCCESS;
    errno_enum_type                 found_qcril_request;
    uint32_t                        vsid;
    uint8_t                         status = FALSE;
    int                             op_mode_chg_needed_for_lpm = TRUE;

    QCRIL_LOG_FUNC_ENTRY();
    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_NONE);

    if (( RIL_VAL_RADIO_POWER_MODE_ONLINE != requested_telephony_power_state ) &&
          qcril_qmi_nas_is_bootup_radio_power_off_request())
    {
        qcril_qmi_dms_save_prl_info(FALSE, NAS_NIL);
    }

    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_INITIALIZED);
    if( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
    { // * to online
        transaction_res = qcril_qmi_nas_radio_power_wait_for_dms_service();

        // Respond with INVALID_STATE if the device is in FTM
        if (RIL_E_SUCCESS == transaction_res && TRUE == qcril_qmi_nas_dms_is_in_ftm_mode()) {
            QCRIL_LOG_ERROR("Device is in Factory test mode..sending INVALID_STATE");
            transaction_res = RIL_E_INVALID_STATE;
        }

        if (RIL_E_SUCCESS == transaction_res) {
            transaction_res = qcril_qmi_nas_radio_power_handle_card_transition(requested_telephony_power_state);
        }

        if( RIL_E_SUCCESS == transaction_res )
        {
            transaction_res = qcril_qmi_nas_radio_power_handle_modem_transition(requested_telephony_power_state, nullptr);
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
        }
    }
    else
    { // * to LPM
        NAS_CACHE_LOCK();
        if(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_LPM == qcril_qmi_nas_get_bootup_power_optimization_state())
        {
            QCRIL_LOG_INFO("Setting bootup optimization state to TRIGGER_COMPLETE.");
            qcril_qmi_nas_set_bootup_power_optimization_state(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_COMPLETE);
            status = TRUE;
        }
        NAS_CACHE_UNLOCK();

        if( !qmi_ril_is_feature_supported(QMI_RIL_FEATURE_POWER_ON_OPTIMIZATION) ||
            !qcril_qmi_nas_is_bootup_radio_power_off_request() ||
            (TRUE == status) ||
            qcril_qmi_nas_is_apm_enabled() )
        {
            transaction_res = qcril_qmi_nas_radio_power_wait_for_dms_service();

            // Respond with INVALID_STATE if the device is in FTM
            if (RIL_E_SUCCESS == transaction_res && TRUE == qcril_qmi_nas_dms_is_in_ftm_mode()) {
                QCRIL_LOG_ERROR("Device is in Factory test mode..sending INVALID_STATE");
                transaction_res = RIL_E_INVALID_STATE;
            }

            if (RIL_E_SUCCESS == transaction_res) {
                transaction_res = qcril_qmi_nas_radio_power_handle_modem_transition(
                    requested_telephony_power_state, &op_mode_chg_needed_for_lpm);
            }

            if( RIL_E_SUCCESS == transaction_res )
            {
                transaction_res = qcril_qmi_nas_radio_power_handle_card_transition(requested_telephony_power_state);
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
            }
        }
    }

    NAS_CACHE_LOCK();
    nas_common_info.is_radio_power_check_enabled = TRUE;
    NAS_CACHE_UNLOCK();

    auto& msgList = getDmsModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestRadioPowerMessage::get_class_message_id());
    found_qcril_request = pendingMsg ? E_SUCCESS : E_FAILURE;
    if ( E_SUCCESS == found_qcril_request )
    {
        /* send response for RADIO_POWER request right away */
        if ( qmi_ril_is_multi_sim_feature_supported() )
        {
            qcril_qmi_nas_handle_multiple_rild_radio_power_sync(requested_telephony_power_state);
        }

        if (RIL_E_SUCCESS == transaction_res &&
            qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm() &&
            RIL_VAL_RADIO_POWER_MODE_ONLINE != requested_telephony_power_state)
        {
            if (!qcril_qmi_nas_is_bootup_radio_power_off_request())
            {
                qcril_qmi_modem_power_set_voting_state_primary_modem(0);
                qcril_qmi_release_services();
                qcril_qmi_vote_down_primary_modem();
            }
            else
            {
                if (qcril_qmi_nas_is_apm_enabled())
                {
                    RADIO_POWER_LOCK();
                    nas_common_info.modem_power_info.is_not_bootup_radio_power_on = TRUE;
                    RADIO_POWER_UNLOCK();
                    QCRIL_LOG_INFO("Bootup in APM");
                    qcril_qmi_modem_power_set_voting_state_primary_modem(0);
                    qcril_qmi_release_services();
                    qcril_qmi_vote_down_primary_modem();
                }
            }
        }

        NAS_CACHE_LOCK();
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(transaction_res, nullptr);
        auto msg = std::static_pointer_cast<RilRequestRadioPowerMessage>(pendingMsg);
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
        msgList.erase(pendingMsg);
        NAS_CACHE_UNLOCK();

        // Sometimes modem may send voice system id before telephony is UP.
        // So, send unsol VSID first time after radio on. This is sent here to
        // ensure VSID is available to telephony when it is UP and to enable
        // emergency calls in no SIM scenario as well. It is not applicable to
        // non-dsds as voice_system_id will not be valid.
        if ( nas_cached_info.voice_system_id_valid && RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
        {
          NAS_CACHE_LOCK();
          vsid = nas_cached_info.voice_system_id;
          // Send QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID response
          QCRIL_LOG_DEBUG("..Sending VSID %d", vsid);
          qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID,
                                     QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID,
                                     (char*)&vsid, sizeof(vsid));
          qcril_am_set_vsid(QCRIL_AM_VS_VOICE, vsid);
          NAS_CACHE_UNLOCK();
        }

        if( RIL_E_SUCCESS == transaction_res )
        {
            qcril_qmi_nas_initiate_radio_state_changed_ind();
            if (RIL_VAL_RADIO_POWER_MODE_LPM == requested_telephony_power_state)
            {
                qcril_qmi_nas_embms_send_radio_state(RADIO_STATE_OFF_V01);
            }
            else if (RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state)
            {
                qcril_qmi_nas_embms_send_radio_state(RADIO_STATE_ON_V01);
            }
            // in case of phone process crash in APM mode, send unsol network_state_changed
            // too in case IWLAN is available
            if (RIL_VAL_RADIO_POWER_MODE_LPM == requested_telephony_power_state &&
                    op_mode_chg_needed_for_lpm == FALSE && qcril_qmi_nas_is_apm_enabled())
            {
                qcril_qmi_nas_wave_voice_data_status();
            }
        }
    }
    else
    {
        QCRIL_LOG_ERROR( "pending event not found %d", (int) found_qcril_request );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_radio_power_transaction_handler

//===========================================================================
// qcril_qmi_nas_dms_handle_modem_operating_mode
//===========================================================================
RIL_Errno qcril_qmi_nas_dms_handle_modem_operating_mode(dms_operating_mode_enum_v01 requested_operating_mode,int * is_operating_mode_change_needed)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    dms_set_operating_mode_req_msg_v01   qmi_request;
    dms_set_operating_mode_resp_msg_v01  qmi_response;
    dms_operating_mode_enum_v01 current_dms_operating_mode   = DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
    int current_dms_operating_mode_valid                     = FALSE;
    qmi_client_error_type qmi_transport_error;


    QCRIL_LOG_FUNC_ENTRY();
    qcril_qmi_nas_query_cur_power_state(&current_dms_operating_mode_valid, &current_dms_operating_mode);
    if( TRUE == current_dms_operating_mode_valid && requested_operating_mode == current_dms_operating_mode )
    {
        *is_operating_mode_change_needed = FALSE;
        res = RIL_E_SUCCESS;
        QCRIL_LOG_INFO("modem's current operating mode matches the requested operating mode");
    }
    else
    {
        *is_operating_mode_change_needed = TRUE;
        memset(&qmi_request, 0, sizeof(qmi_request));
        qmi_request.operating_mode = requested_operating_mode;

        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                           QMI_DMS_SET_OPERATING_MODE_REQ_V01,
                                                           &qmi_request,
                                                           sizeof( qmi_request ),
                                                           &qmi_response,
                                                           sizeof( qmi_response ),
                                                           QCRIL_QMI_DMS_SET_OPERATING_MODE_SYNC_TIMEOUT );

        /* Device not ready, is reported to SET_OPERATING_MODE only when
           there is a temporary failure.
           In this case, CM will retry to set operating mode.
           Hence passed QCRIL_QMI_ERR_TOLERATE_NOT_READY to tolerate device
           not ready error. */
        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(qmi_transport_error,
                                                                         &qmi_response.resp,
                                                                         QCRIL_QMI_ERR_TOLERATE_NOT_READY,
                                                                         NULL);
        QCRIL_LOG_INFO("modem's operating mode needs to be changed");
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);

    return res;
} // qcril_qmi_nas_dms_handle_modem_operating_mode

//===========================================================================
// qcril_qmi_nas_dms_handle_card_status
//===========================================================================
RIL_Errno qcril_qmi_nas_dms_handle_card_status(qcril_evt_e_type uim_evt)
{
    RIL_Errno res = RIL_E_SUCCESS;
    int slot = qmi_ril_get_sim_slot();

    QCRIL_LOG_FUNC_ENTRY();

    if(uim_evt == QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN)
    {
        std::shared_ptr<UimCardPowerReqMsg> req =
            std::make_shared<UimCardPowerReqMsg>(slot, RIL_UIM_CARD_POWER_DOWN);
        if(req)
        {
            req->dispatch();
        }
    }
    else if (uim_evt == QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP)
    {
        std::shared_ptr<UimCardPowerReqMsg> req =
            std::make_shared<UimCardPowerReqMsg>(slot, RIL_UIM_CARD_POWER_UP);
        if(req)
        {
            req->dispatch();
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} // qcril_qmi_nas_dms_handle_card_status

/*===========================================================================

    qcril_qmi_nas_get_sim_mcc_mnc

============================================================================*/
/*!
    @brief
    Get sim card mcc and mnc

    @return
    None
*/
/*=========================================================================*/
int qcril_qmi_nas_get_sim_mcc_mnc
(
    char mcc[QCRIL_MCC_MNC_MAX_SIZE],
    char mnc[QCRIL_MCC_MNC_MAX_SIZE]
)
{
    int res  = E_FAILURE;
    int slot = qmi_ril_get_sim_slot();

    if (mcc && mnc)
    {
        NAS_CACHE_LOCK();

        if (nas_common_info.card_info[slot].valid)
        {
            strlcpy(mcc, nas_common_info.card_info[slot].mcc, QCRIL_MCC_MNC_MAX_SIZE);
            strlcpy(mnc, nas_common_info.card_info[slot].mnc, QCRIL_MCC_MNC_MAX_SIZE);
            res = E_SUCCESS;
        }

        NAS_CACHE_UNLOCK();

        if (res == E_SUCCESS)
        {
            QCRIL_LOG_DEBUG("card mcc %s", mcc);
            QCRIL_LOG_DEBUG("card mnc %s", mnc);
        }
        else
        {
            QCRIL_LOG_DEBUG("card_info is not valid");
        }
    }

    return res;
}
/*===========================================================================

    qcril_qmi_nas_update_sim_mcc_mnc

============================================================================*/
/*!
    @brief
    Update sim card mcc and mnc

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_update_sim_mcc_mnc
(
    boolean valid,
    char    mcc[QCRIL_MCC_MNC_MAX_SIZE],
    char    mnc[QCRIL_MCC_MNC_MAX_SIZE]
)
{
    int slot = qmi_ril_get_sim_slot();
    bool changed = false;

    if (mcc && mnc)
    {
        NAS_CACHE_LOCK();

        changed = (nas_common_info.card_info[slot].valid != valid) ||
                strncmp(mcc, nas_common_info.card_info[slot].mcc, QCRIL_MCC_MNC_MAX_SIZE) ||
                strncmp(mnc, nas_common_info.card_info[slot].mnc, QCRIL_MCC_MNC_MAX_SIZE);

        nas_common_info.card_info[slot].valid = valid;
        if (valid)
        {
            memcpy(nas_common_info.card_info[slot].mcc, mcc, QCRIL_MCC_MNC_MAX_SIZE);
            memcpy(nas_common_info.card_info[slot].mnc, mnc, QCRIL_MCC_MNC_MAX_SIZE);
        }

        NAS_CACHE_UNLOCK();

        QCRIL_LOG_DEBUG("card mcc %s", mcc);
        QCRIL_LOG_DEBUG("card mnc %s", mnc);

        qcril_qmi_nas_update_iccid_from_uim(slot);

        NAS_CACHE_LOCK();
        if(nas_common_info.card_info[slot].iccid_len_from_uim)
        {
            qcril_qmi_pdc_set_sim_info(nas_common_info.card_info[slot].iccid_from_uim,
                                       mcc, mnc);
        }
        else
        {
            qcril_qmi_pdc_set_sim_info(NULL, mcc, mnc);
        }
        NAS_CACHE_UNLOCK();
    }
    else
    {
        qcril_qmi_pdc_set_sim_info(NULL, NULL, NULL);
    }
    /* If mcc/mnc has changed and we are registered on WLAN
       send unsol nw state changed for telephony to query
       for operator name */
    if (changed && qcril_qmi_nas_ims_registered_wlan_status())
    {
        qmi_ril_nw_reg_redo_reg_report(NULL);
    }

}

/*===========================================================================

    qcril_qmi_nas_retrieve_aid_from_app_info

============================================================================*/
/*!
    @brief
    Retrieve aid buffer application info

    @return
    None
*/
/*=========================================================================*/
int qcril_qmi_nas_retrieve_aid_from_app_info
(
    RIL_UIM_AppStatus *application,
    string            &aid_buffer,
    RIL_UIM_AppType   *app_type
)
{
    int res = E_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();
    if (application && app_type)
    {

        QCRIL_LOG_DEBUG("app type %d", application->app_type);
        QCRIL_LOG_DEBUG("app state %d", application->app_state);

        if (application->app_state == RIL_UIM_APPSTATE_READY)
        {
            aid_buffer = application->aid_ptr;
            *app_type = application->app_type;
            res = E_SUCCESS;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

/*===========================================================================

    qcril_qmi_nas_retrieve_aid_from_card_status

============================================================================*/
/*!
    @brief
    Retrieve aid buffer card status info

    @return
    None
*/
/*=========================================================================*/
int qcril_qmi_nas_retrieve_aid_from_card_status
(
    std::shared_ptr<RIL_UIM_CardStatus> ril_card_status,
    string          &aid_buffer,
    RIL_UIM_AppType *app_type
)
{
    int               res = E_FAILURE;
    int               index;

    QCRIL_LOG_FUNC_ENTRY();

    if (ril_card_status)
    {
        if (ril_card_status->card_state == RIL_UIM_CARDSTATE_PRESENT)
        {
            if (ril_card_status->gsm_umts_subscription_app_index != -1)
            {
                index = ril_card_status->gsm_umts_subscription_app_index;

                /* retrieve aid from gsm umts subscription app info */
                res = qcril_qmi_nas_retrieve_aid_from_app_info(
                                                &ril_card_status->applications[index],
                                                aid_buffer, app_type);
            }

            if ((res == E_FAILURE) &&
                (ril_card_status->cdma_subscription_app_index != -1))
            {
                index = ril_card_status->cdma_subscription_app_index;

                /* retrieve aid from cdma subscription app info */
                res = qcril_qmi_nas_retrieve_aid_from_app_info(
                                                &ril_card_status->applications[index],
                                                aid_buffer, app_type);
            }

            if ((res == E_FAILURE) &&
                (ril_card_status->ims_subscription_app_index != -1))
            {
                index = ril_card_status->ims_subscription_app_index;

                /* retrieve aid from ims subscription app info */
                res = qcril_qmi_nas_retrieve_aid_from_app_info(
                                                &ril_card_status->applications[index],
                                                aid_buffer, app_type);
            }
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

void qcril_qmi_nas_poll_qmi_and_handle_prov_state_change(qcril_qmi_prov_state_type);
void qcril_qmi_nas_prov_state_change_timed_handler
(
  qcril_timed_callback_handler_params_type *handler_params
)
{
  if (!handler_params || !handler_params->custom_param)
    return;

  qcril_qmi_nas_poll_qmi_and_handle_prov_state_change(
        *((qcril_qmi_prov_state_type*)handler_params->custom_param));

  if (handler_params->custom_param)
    qcril_free(handler_params->custom_param);
}

void qcril_qmi_nas_poll_qmi_and_handle_prov_state_change
(
  qcril_qmi_prov_state_type state
)
{
    auto ep = ModemEndPointFactory<NasModemEndPoint>::getInstance().buildEndPoint();
    if (ep && ep->getState() == ModemEndPoint::State::OPERATIONAL) {
      NAS_CACHE_LOCK();
      QCRIL_LOG_INFO( "Card status up... Start provisioning..." );
      nas_common_info.prov_in_progress = TRUE;
      qcril_qmi_prov_handle_prov_state_change(state);
      NAS_CACHE_UNLOCK();
    } else {
      auto data = (qcril_qmi_prov_state_type*)qcril_malloc(sizeof(qcril_qmi_prov_state_type));
      if (data) {
        *data = state;
        struct timeval timeout_value = {0, 1000}; // 1 ms
        qcril_setup_timed_callback_ex_params(QCRIL_DEFAULT_INSTANCE_ID,
                          QCRIL_DEFAULT_MODEM_ID,
                          qcril_qmi_nas_prov_state_change_timed_handler,
                          (void*)data,
                          &timeout_value,
                          NULL);
      } else {
        QCRIL_LOG_ERROR( "Failed to delay the prov state change handling: NO MEMORY");
      }
    }
}

/*===========================================================================

    qcril_qmi_nas_prov_check_sim_provisioning

============================================================================*/
/*!
    @brief
    Wrapper for qcril_qmi_prov_handle_prov_state_change.

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_prov_check_sim_provisioning(void)
{
    qcril_flexi_map_status     curr_status = QCRIL_FLEXI_MAP_STATUS_NONE;

    NAS_CACHE_LOCK();
    curr_status = qcril_qmi_nas_get_flexi_map_status();

    if( curr_status == QCRIL_FLEXI_MAP_STATUS_NONE )
    {
        QCRIL_LOG_INFO( "Card status up... Start provisioning..." );
        nas_common_info.prov_in_progress = TRUE;
        qcril_qmi_nas_poll_qmi_and_handle_prov_state_change(QCRIL_QMI_PROV_STATE_CARD_UP);
    }
    else
    {
        QCRIL_LOG_INFO( "Card status up... flex_map is in progress, do provisiong after flex_map complete..." );
        nas_common_info.card_prov_pending = TRUE;
    }
    NAS_CACHE_UNLOCK();
}

//===========================================================================
// qcril_qmi_nas_event_card_status_update
//===========================================================================
void qcril_qmi_nas_event_card_status_update
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  uint8 slot;
  qcril_uim_card_info_type *card_info_ptr;
  int card_status_changed;

  int                                   need_to_evaluate_emergency_number_list;
  qcril_uim_card_status_e_type          previous_card_status;
  qcril_uim_card_status_e_type          new_card_status;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );
  card_info_ptr = ( qcril_uim_card_info_type *) params_ptr->data;

  if( card_info_ptr != NULL )
  {
      slot = card_info_ptr->slot;
      QCRIL_LOG_INFO( "entered slot %d", (int) slot );

      if( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_POWER_ON_OPTIMIZATION) && (slot != qmi_ril_get_sim_slot()))
      {
        QCRIL_LOG_INFO("card slot %d, card status %d", card_info_ptr->slot, card_info_ptr->status );
        qcril_qmi_nas_dms_update_card_status( QCRIL_DEFAULT_INSTANCE_ID,
                                              card_info_ptr->slot,
                                              FALSE,
                                              card_info_ptr->status );
      }

      if( slot == qmi_ril_get_sim_slot() )
      {
          need_to_evaluate_emergency_number_list    = FALSE;
          previous_card_status                      = nas_common_info.card_info[ slot ].status;
          new_card_status                           = card_info_ptr->status;
          QCRIL_LOG_INFO( "Slot %d Card status: %s --> %s",
                           slot,
                          card_status_name[ nas_common_info.card_info[ slot ].status ],
                          card_status_name[ card_info_ptr->status ] );

          NAS_CACHE_LOCK();
          card_status_changed = (nas_common_info.card_info[ slot ].status != card_info_ptr->status) ? TRUE : FALSE;
          NAS_CACHE_UNLOCK();

          QCRIL_LOG_INFO("card status changed %d", card_status_changed );

          if ( card_status_changed )
          {
              qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch( QCRIL_DEFAULT_INSTANCE_ID,
                                                                       card_info_ptr->slot,
                                                                       FALSE,
                                                                       card_info_ptr->status );
              RADIO_POWER_LOCK();
              if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD == nas_common_info.radio_pwr_signal_cond )
              {
                  RADIO_POWER_SIGNAL();
                  nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
              }

              RADIO_POWER_UNLOCK();

              auto& msgList = getNasModule().getPendingMessageList();
              auto msg = msgList.find(RilRequestShutDownMessage::get_class_message_id());
              if ((msg != nullptr) && card_status_changed && (QCRIL_CARD_STATUS_UP != card_info_ptr->status))
              {
                  qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_CARD_SHUTDOWN_COMPLETE);
              }

              // designated country handling
              switch ( new_card_status )
              {
                  case QCRIL_CARD_STATUS_UP:        // bootup, or after APM still ok to initiate check
                      need_to_evaluate_emergency_number_list = TRUE;
                      qcril_qmi_nas_update_iccid_from_uim(slot);
                      if (qmi_ril_is_multi_sim_feature_supported())
                      {
                          qcril_qmi_nas_update_prov_iccid(slot);

                          if (qcril_mbn_hw_is_completed())
                          {
                              qcril_qmi_nas_prov_check_sim_provisioning();
                          }
                          else
                          {
                              /* Inform hardware update module */
                              qcril_mbn_hw_inform_wait_drop(
                                          qcril_qmi_nas_prov_check_sim_provisioning);
                          }
                      }
#if 0 // remove the logic of waiting for card status for allow data
                      {
                        // trigger the allow_data in the nas thread to avoid race condition
                        auto& msgList = getNasModule().getPendingMessageList();
                        auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
                        auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
                        if (allowDataMsg->isWaitForCard()) {
                        {
                          qcril_qmi_nas_request_allow_data(allowDataMsg);
                        }
                      }
#endif
                      break;

                  case QCRIL_CARD_STATUS_ABSENT:    // initial or card removal
                  case QCRIL_CARD_STATUS_DOWN:
                      qcril_qmi_prov_reset_prov_pref_info(FALSE);
                      need_to_evaluate_emergency_number_list = TRUE;
                      qcril_qmi_nas_update_sim_mcc_mnc(FALSE, NULL, NULL);
                      if (QCRIL_CARD_STATUS_ABSENT == new_card_status)
                      {
                          qcril_qmi_pdc_set_sim_info(NULL, NULL, NULL);
                      }

                      NAS_CACHE_LOCK();
                      memset(nas_cached_info.mcc_from_imsi_cache, NAS_NIL, sizeof(nas_cached_info.mcc_from_imsi_cache));
                      memset(nas_common_info.card_info[slot].iccid_from_uim, 0x0,
                             sizeof(nas_common_info.card_info[slot].iccid_from_uim));
                      nas_common_info.card_info[slot].iccid_len_from_uim = 0;
                      NAS_CACHE_UNLOCK();
                      break;

                  default:
                      QCRIL_LOG_INFO(".. Reset prov cache");
                      qcril_qmi_prov_reset_prov_pref_info(FALSE);
                      break;
              }
          }

          if ( need_to_evaluate_emergency_number_list )
          {
            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                           QCRIL_DEFAULT_MODEM_ID,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                           NULL,
                           QMI_RIL_ZERO,
                           (RIL_Token) QCRIL_CUSTOM_ECC_INTERNAL_TOKEN );
          }
      }
  }
  else
  {
     QCRIL_LOG_FATAL("CHECK FAILED");
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_event_card_status_update

/*===========================================================================

    qcril_qmi_nas_event_app_status_update

============================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CARD_APP_STATUS_CHANGED

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_event_app_status_update
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type       *const ret_ptr
)
{
    RIL_UIM_AppStatus              *card_app_info;
    string                          aid = {};
    RIL_UIM_AppType                 request_app_type;
    qcril_modem_id_e_type           modem_id;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(ret_ptr);

    if (params_ptr)
    {
        modem_id      = params_ptr->modem_id;
        card_app_info = (RIL_UIM_AppStatus *)(params_ptr->data);

        /* Process only this slots SIM card applications */
        if ( card_app_info != NULL )
        {
            QCRIL_LOG_INFO("app type - %d app state - %d", card_app_info->app_type, card_app_info->app_state);
#ifndef QMI_RIL_UTF
            if (card_app_info->app_state == RIL_UIM_APPSTATE_READY)
            {
              auto card_status = std::make_shared<UimGetCardStatusRequestSyncMsg>(qmi_ril_get_process_instance_id());
              std::shared_ptr<RIL_UIM_CardStatus> ril_card_status = nullptr;

              /* retrieve card status info */
              if (card_status != nullptr &&
                  card_status->dispatchSync(ril_card_status) == Message::Callback::Status::SUCCESS &&
                  ril_card_status != nullptr &&
                  ril_card_status->err == RIL_UIM_E_SUCCESS)
              {
                    /* retrieve aid from card status */
                    if (qcril_qmi_nas_retrieve_aid_from_card_status(ril_card_status,
                                                                    aid, &request_app_type)
                                                                   == E_SUCCESS)
                    {
                        qcril_uim_app_type  app_type = QCRIL_UIM_APP_UNKNOWN;

                        //proceed only when memory is allocated
                        if(!aid.empty())
                        {
                            switch(request_app_type)
                            {
                                case RIL_UIM_APPTYPE_SIM:
                                    app_type = QCRIL_UIM_APP_SIM;
                                    break;
                                case RIL_UIM_APPTYPE_USIM:
                                    app_type = QCRIL_UIM_APP_USIM;
                                    break;
                                case RIL_UIM_APPTYPE_RUIM:
                                    app_type = QCRIL_UIM_APP_RUIM;
                                    break;
                                case RIL_UIM_APPTYPE_CSIM:
                                    app_type = QCRIL_UIM_APP_CSIM;
                                    break;
                                default:
                                    app_type = QCRIL_UIM_APP_UNKNOWN;
                                    break;
                            }

                            NasGetMccMncCallback Cb("set-cb-token");
                            std::shared_ptr<UimGetMccMncRequestMsg> req =
                                std::make_shared<UimGetMccMncRequestMsg>(aid, app_type, &Cb);
                            if(req)
                            {
                                req->dispatch();
                            }
                        } else {
                            QCRIL_LOG_INFO("Memory allocation is failed");
                        }
                    }
                }

                if (qmi_ril_is_multi_sim_feature_supported())
                {
                    /* If Auto provisioning is enabled and PIN is locked, there is no way
                       for RIL to move to unresticted state after user enter PIN.
                       Move to unrestricted when ever app state is READY. */
                    QCRIL_LOG_INFO( "As SIM app state is READY, move RIL to unrestricted state" );
                    qmi_ril_enable_ril_operational_status();
                }
            }
            else
            {
                qcril_qmi_nas_post_voice_rte_change_ind_handler(NULL, NULL);
            }
#endif
        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_respond_to_last_modem_shutdown_request(RIL_Errno ril_req_res)
{

    QCRIL_LOG_FUNC_ENTRY();
    auto& msgList = getNasModule().getPendingMessageList();
    auto msg = msgList.find(RilRequestShutDownMessage::get_class_message_id());
    if (msg != nullptr)
    {
        auto shutDownMsg = std::static_pointer_cast<RilRequestShutDownMessage>(msg);
        shutDownMsg->sendResponse(shutDownMsg, Message::Callback::Status::SUCCESS,
            std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
        msgList.erase(msg);
    }

    QCRIL_LOG_FUNC_RETURN();
}

inline bool qcril_qmi_nas_is_card_shutdown_required()
{
    int                         is_no_wait_for_card;
    qcril_uim_card_status_e_type    card_status;
    dms_operating_mode_enum_v01 operating_mode;
    int                         operating_mode_valid;
    uint32_t                    slot;
    bool                        card_shutdown_required;

    NAS_CACHE_LOCK();
    slot                 = qmi_ril_get_sim_slot();
    is_no_wait_for_card  = nas_common_info.no_wait_for_card;
    card_status          = nas_common_info.card_info[slot].status;
    operating_mode       = nas_dms_cached_info.operating_mode;
    operating_mode_valid = nas_dms_cached_info.operating_mode_valid;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("is_no_wait_for_card: %d, card_status: %d, "
                   "operating_mode_valid: %d, operating_mode: %d",
                   is_no_wait_for_card,
                   (int) card_status,
                   operating_mode_valid,
                   operating_mode);

    if (operating_mode_valid && ( DMS_OP_MODE_ONLINE_V01 == operating_mode))
    {
        QCRIL_LOG_DEBUG("Unexpected modem operating mode");
    }

    /* If syncrhonization with card is not suppressed for RIL and
     * card is UP then the card needs to be powered down */
    card_shutdown_required = (!is_no_wait_for_card &&
                              (QCRIL_CARD_STATUS_UP == card_status));
    QCRIL_LOG_INFO("card_shutdown_required: %d", card_shutdown_required);

    return card_shutdown_required;
}

inline bool qcril_qmi_nas_request_data_shutdown()
{
    // TODO: Define timeout as a constant
    std::shared_ptr<NasRequestDataShutdownMessage> msg =
        std::make_shared<NasRequestDataShutdownMessage>(5000);

    if (msg)
    {
        GenericCallback<NasRequestDataShutdownResponse> cb(
            [] (std::shared_ptr<Message> msg,
                Message::Callback::Status status,
                std::shared_ptr<NasRequestDataShutdownResponse> rsp) -> void
            {
                QCRIL_NOTUSED(msg);
                QCRIL_NOTUSED(rsp);

                if (status == Message::Callback::Status::TIMEOUT)
                {
                    QCRIL_LOG_DEBUG("Request to shutdown data timed out.");
                    qcril_qmi_nas_modem_shutdown_state_machine(
                        QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_DATA_SHUTDOWN_TIMEOUT);
                }
                else
                {
                    qcril_qmi_nas_modem_shutdown_state_machine(
                        QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_DATA_SHUTDOWN_COMPLETE);
                }
        }
        );
        msg->setCallback(&cb);
        msg->dispatch();
        return true;
    }

    return false;
}

void qcril_qmi_nas_notify_ims_shutdown_timeout(void *param)
{
    QCRIL_NOTUSED(param);
    NAS_CACHE_LOCK();
    nas_cached_info.modem_shutdown_ims_shutdown_timer = NAS_NIL;
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_modem_shutdown_state_machine(
        QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_IMS_SHUTDOWN_TIMEOUT);
}

void qcril_qmi_nas_cancel_ims_shutdown_timer()
{
    NAS_CACHE_LOCK();
    if (nas_cached_info.modem_shutdown_ims_shutdown_timer)
    {
         qcril_cancel_timed_callback(
             (void *)(intptr_t)nas_cached_info.modem_shutdown_ims_shutdown_timer);
         nas_cached_info.modem_shutdown_ims_shutdown_timer = NAS_NIL;
    }
    NAS_CACHE_UNLOCK();
}

void qcril_qmi_nas_modem_shutdown_state_machine(qmi_ril_nas_modem_shutdown_events_e_type evt)
{
    QCRIL_LOG_INFO("current state: %d event: %d", nas_cached_info.modem_shutdown_state, evt);
    NAS_CACHE_LOCK();
    switch(evt)
    {
        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_BEGIN_SEQUENCE:
            nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_BEGIN;
            qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_REQUEST_DATA_SHUTDOWN);
            break;

        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_REQUEST_DATA_SHUTDOWN:
            if (nas_cached_info.modem_shutdown_state == QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_BEGIN)
            {
#ifndef QMI_RIL_UTF
                if (qcril_qmi_nas_request_data_shutdown())
                {
                    nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_WAITING_FOR_DATA_SHUTDOWN;
                }
                else
                {
                    qcril_qmi_nas_respond_to_last_modem_shutdown_request(RIL_E_NO_MEMORY);
                    nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_END;
                }
#else
                nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_WAITING_FOR_DATA_SHUTDOWN;
                qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_DATA_SHUTDOWN_COMPLETE);
#endif
            }
            else
            {
                QCRIL_LOG_ERROR("Invalid event (%d) in state (%d).", evt,
                                nas_cached_info.modem_shutdown_state);
            }
            break;

        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_DATA_SHUTDOWN_COMPLETE:
        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_DATA_SHUTDOWN_TIMEOUT:
            if (nas_cached_info.modem_shutdown_state == QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_WAITING_FOR_DATA_SHUTDOWN)
            {
                nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_WAITING_FOR_IMS_SHUTDOWN;
                if (qcril_qmi_nas_ims_is_pdp_connected())
                {
                    nas_cached_info.modem_shutdown_ims_shutdown_timer = NAS_NIL;
                    const struct timeval timeout = {6, 0};
                    int timer_setup_status = qcril_setup_timed_callback(
                        QCRIL_DEFAULT_INSTANCE_ID,
                        QCRIL_DEFAULT_MODEM_ID,
                        qcril_qmi_nas_notify_ims_shutdown_timeout,
                        &timeout,
                        &nas_cached_info.modem_shutdown_ims_shutdown_timer
                    );
                    // if a timer cannot be setup, consider it a timeout
                    if (timer_setup_status != E_SUCCESS ||
                            nas_cached_info.modem_shutdown_ims_shutdown_timer == NAS_NIL)
                    {
                        qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_IMS_SHUTDOWN_TIMEOUT);
                    }
                }
                else
                {
                    qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_IMS_SHUTDOWN_COMPLETE);
                }
            }
            else
            {
                QCRIL_LOG_ERROR("Invalid event (%d) in state (%d).", evt,
                                nas_cached_info.modem_shutdown_state);
            }
            break;

        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_IMS_SHUTDOWN_COMPLETE:
        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_IMS_SHUTDOWN_TIMEOUT:
            if (nas_cached_info.modem_shutdown_state == QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_WAITING_FOR_IMS_SHUTDOWN)
            {
                nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_IMS_SHUTDOWN_COMPLETED;
                if (qcril_qmi_nas_is_card_shutdown_required())
                {
                    qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_REQUEST_CARD_SHUTDOWN);
                }
                else
                {
                    qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_POWER_DOWN_MODEM);
                }
            }
            else
            {
                QCRIL_LOG_ERROR("Invalid event (%d) in state (%d).", evt,
                                nas_cached_info.modem_shutdown_state);
            }
            break;

        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_REQUEST_CARD_SHUTDOWN:
            if (nas_cached_info.modem_shutdown_state == QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_IMS_SHUTDOWN_COMPLETED)
            {
                nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_WAITING_FOR_CARD_SHUTDOWN;
#ifndef QMI_RIL_UTF
                qcril_qmi_nas_dms_handle_card_status(QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN);
#else
                qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_CARD_SHUTDOWN_COMPLETE);
#endif
            }
            else
            {
                QCRIL_LOG_ERROR("Invalid event (%d) in state (%d).", evt,
                                nas_cached_info.modem_shutdown_state);
            }
            break;

        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_CARD_SHUTDOWN_COMPLETE:
            if (nas_cached_info.modem_shutdown_state == QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_WAITING_FOR_CARD_SHUTDOWN)
            {
                nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_CARD_SHUTDOWN_COMPLETED;
                qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_POWER_DOWN_MODEM);
            }
            else
            {
                QCRIL_LOG_ERROR("Invalid event (%d) in state (%d).", evt,
                                nas_cached_info.modem_shutdown_state);
            }
            break;

        case QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_POWER_DOWN_MODEM:
            if (nas_cached_info.modem_shutdown_state == QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_CARD_SHUTDOWN_COMPLETED ||
                nas_cached_info.modem_shutdown_state == QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_IMS_SHUTDOWN_COMPLETED)
            {
                qcril_setup_timed_callback(
                    QCRIL_DEFAULT_INSTANCE_ID,
                    QCRIL_DEFAULT_MODEM_ID,
                    qmi_ril_process_oem_hook_shutdown,
                    NULL,
                    NULL
                );
                nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_END;
            }
            else
            {
                QCRIL_LOG_ERROR("Invalid event (%d) in state (%d).", evt,
                                nas_cached_info.modem_shutdown_state);
            }
            break;

        default:
            QCRIL_LOG_ERROR("Invalid event (%d).", evt);
            break;
    }
    NAS_CACHE_UNLOCK();
}

/*===========================================================================

    qcril_qmi_nas_request_shutdown_helper

============================================================================*/
/*!
    @brief
    Helper function for RIL_REQUEST_SHUTDOWN

    @return
    None
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_request_shutdown_helper
(
    std::shared_ptr<RilRequestShutDownMessage> msg
)
{
    RIL_Errno                   res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

    auto ret = getNasModule().getPendingMessageList().insert(msg);
    if (!ret.second)
    {
        QCRIL_LOG_ERROR("Failed to insert the message into the list");
        res = RIL_E_INTERNAL_ERR;
    }
    else
    {
        qcril_qmi_nas_modem_shutdown_state_machine(QMI_RIL_NAS_MODEM_SHUTDOWN_EVENT_BEGIN_SEQUENCE);
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);
    return res;
} // qcril_qmi_nas_request_shutdown_helper


/*===========================================================================

    qcril_qmi_nas_request_shutdown

============================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SHUTDOWN

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_request_shutdown
(
    std::shared_ptr<RilRequestShutDownMessage> msg
)
{
    RIL_Errno                      res = RIL_E_GENERIC_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();

    res = qcril_qmi_nas_request_shutdown_helper(msg);
    if (RIL_E_SUCCESS != res)
    {
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
            std::make_shared<QcRilRequestMessageCallbackPayload>(res, nullptr));
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);
} // qcril_qmi_nas_request_shutdown

//===========================================================================
// qmi_ril_process_oem_hook_shutdown
//===========================================================================
void qmi_ril_process_oem_hook_shutdown(void * param)
{
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    if (qcril_qmi_modem_power_is_voting_feature_supported_for_primary_modem())
    {
        if (qcril_qmi_is_secondary_modem_present())
        {
            qcril_qmi_vote_down_secondary_modem();
        }
        qcril_qmi_vote_down_primary_modem();
        ril_req_res = RIL_E_SUCCESS;
    }
    else if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_APQ) ||
         qmi_ril_is_feature_supported(QMI_RIL_FEATURE_SGLTE2) )
    {
        ril_req_res = qcril_process_mdm_shutdown();
    }
    else
    {
        ril_req_res = RIL_E_SUCCESS;
    }

    qcril_qmi_nas_respond_to_last_modem_shutdown_request(ril_req_res);

    QCRIL_LOG_FUNC_RETURN();
} //qmi_ril_process_oem_hook_shutdown

dms_operating_mode_enum_v01 qcril_qmi_nas_dms_get_current_operating_mode()
{
    dms_operating_mode_enum_v01 cur_op_mode = DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
    int cur_op_mode_valid = FALSE;

    QCRIL_LOG_FUNC_ENTRY();
    if ( qcril_qmi_client_is_available() )
    {
        QCRIL_LOG_INFO( ".. client available" );

        NAS_CACHE_LOCK();
        cur_op_mode_valid = NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode );
        if (cur_op_mode_valid)
        {
            cur_op_mode = nas_dms_cached_info.operating_mode;
        }
        else
        {   // subfetch
            qcril_qmi_nas_query_cur_power_state(&cur_op_mode_valid, &cur_op_mode);
            QCRIL_LOG_INFO("subfetched" );
        }
        NAS_CACHE_UNLOCK();
    }

    return cur_op_mode_valid ? cur_op_mode :
            DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
}

//===========================================================================
// qcril_qmi_nas_dms_get_current_power_state
// - This function will be called when send UNSOL_RADIO_STATE_CHANGED. When
// op_mode is not available (like CM is not ready), it will send RADIO_UNA-
// VAILABLE and "poll the op_mode". The "polling" behavior will be removed
// in the future when DMS sends indication after op_mode is available
//===========================================================================
RIL_RadioState qcril_qmi_nas_dms_get_current_power_state()
{
    RIL_RadioState res = RADIO_STATE_UNAVAILABLE;

    QCRIL_LOG_FUNC_ENTRY();

    auto cur_op_mode = qcril_qmi_nas_dms_get_current_operating_mode();
    QCRIL_LOG_DEBUG(".. known modem operating mode %d ", cur_op_mode  );

    switch (cur_op_mode) {
    case DMS_OP_MODE_ONLINE_V01:
        res = RADIO_STATE_ON;
        break;

    case DMS_OP_MODE_LOW_POWER_V01:
    case DMS_OP_MODE_OFFLINE_V01:
    case DMS_OP_MODE_RESETTING_V01:
    case DMS_OP_MODE_SHUTTING_DOWN_V01:
        res = RADIO_STATE_OFF;
        break;

    case DMS_OP_MODE_FACTORY_TEST_MODE_V01:
        res = RADIO_STATE_UNAVAILABLE;
        break;

    case DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01:
        res = RADIO_STATE_UNAVAILABLE;
#ifndef QMI_RIL_UTF
        qcril_qmi_nas_trigger_polling_operating_mode();
#endif
        break;

    default:
        res = RADIO_STATE_UNAVAILABLE; // still unknown
        break;
    }
    QCRIL_LOG_INFO("compled with %d", (int) res  );

    return res;
} // qcril_qmi_nas_dms_get_current_power_state

//===========================================================================
// qcril_qmi_nas_dms_is_in_online_mode
//===========================================================================
boolean qcril_qmi_nas_dms_is_in_online_mode()
{
    boolean ret = FALSE;
    NAS_CACHE_LOCK();
    if (  NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode )&&
         DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode )
    {
        ret = TRUE;
    }
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} // qcril_qmi_nas_dms_is_in_online_mode

//===========================================================================
// qcril_qmi_nas_dms_is_in_ftm_mode
//===========================================================================
boolean qcril_qmi_nas_dms_is_in_ftm_mode()
{
    boolean ret = FALSE;
    if (qcril_qmi_nas_dms_get_current_operating_mode() == DMS_OP_MODE_FACTORY_TEST_MODE_V01) {
        ret = TRUE;
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} // qcril_qmi_nas_dms_is_in_ftm_mode

//===========================================================================
// qcril_qmi_nas_is_radio_power_check_enabled
//===========================================================================
boolean qcril_qmi_nas_is_radio_power_check_enabled()
{
    boolean ret;
    NAS_CACHE_LOCK();
    ret = nas_common_info.is_radio_power_check_enabled;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} // qcril_qmi_nas_is_radio_power_check_enabled

//===========================================================================
// qcril_qmi_nas_query_cur_power_state
//===========================================================================
void qcril_qmi_nas_query_cur_power_state(int * op_mode_valid, dms_operating_mode_enum_v01 * op_mode)
{
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
    dms_get_operating_mode_resp_msg_v01 qmi_response;
    qmi_client_error_type qmi_transport_error;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_response,0,sizeof(qmi_response));

    NAS_CACHE_LOCK();
    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_GET_OPERATING_MODE_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_response,
                                                       sizeof( qmi_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);

    QCRIL_LOG_DEBUG("qmi transport error %d, qmi resp error %d, ril resp error %d",
            qmi_transport_error, qmi_response.resp, ril_req_res);

    if ( RIL_E_SUCCESS == ril_req_res )
    {
        QCRIL_LOG_INFO(".. known modem operating mode %d ", (int) qmi_response.operating_mode );

        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.operating_mode, qmi_response.operating_mode );

        *op_mode_valid = TRUE;
        *op_mode = qmi_response.operating_mode;

        qcril_qmi_nas_dms_update_common_modem_state();

    }
    else
    {
        *op_mode_valid = FALSE;
        *op_mode = DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_query_cur_power_state

//===========================================================================
// qcril_qmi_nas_initiate_radio_state_changed_ind
//===========================================================================
void qcril_qmi_nas_initiate_radio_state_changed_ind(void)
{
    QCRIL_LOG_FUNC_ENTRY();
    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_RIL_SEND_UNSOL_RADIO_STATE_CHANGED,
                   NULL,
                   NAS_NIL,
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_initiate_radio_state_changed_ind


//===========================================================================
// QCRIL_EVT_QMI_RIL_SEND_UNSOL_RADIO_STATE_CHANGED
//===========================================================================
void qcril_qmi_nas_send_unsol_radio_state_changed
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(params_ptr);
    QCRIL_NOTUSED(ret_ptr);

    qmi_ril_wave_modem_status();
    qcril_qmi_nas_wave_voice_data_status();

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_send_unsol_radio_state_changed

//===========================================================================
// qcril_qmi_nas_dms_update_multisim_config_property
//===========================================================================
void qcril_qmi_nas_dms_update_multisim_config_property()
{

    char prop_val[ PROPERTY_VALUE_MAX ];
    int is_prop_set_required = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    property_get( QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val, "" );
    QCRIL_LOG_INFO ( "Multisim prop val %s", prop_val );

    if (qmi_ril_is_multi_sim_feature_supported())
    {
        if ( ( nas_dms_cached_info.max_subscriptions == QMI_RIL_NUM_TRIPLE_SUB ) &&
             ( nas_dms_cached_info.max_subscriptions_active == QMI_RIL_NUM_SINGLE_ACTIVE ) )
        {
             if ( strncmp(prop_val, "tsts", QMI_RIL_SYS_PROP_LENGTH_MULTI_SIM ) != 0 )
             {
                 strlcpy(prop_val,"tsts",sizeof(prop_val));
                 is_prop_set_required = TRUE;
             }
        }
        else if ( ( nas_dms_cached_info.max_subscriptions ==  QMI_RIL_NUM_DUAL_SUB ) &&
                  ( nas_dms_cached_info.max_subscriptions_active == QMI_RIL_NUM_DUAL_ACTIVE ) )
        {
            if ( strncmp(prop_val, "dsda", PROPERTY_VALUE_MAX ) != 0 )
            {
                strlcpy(prop_val,"dsda",sizeof(prop_val));
                is_prop_set_required = TRUE;
            }
        }
        else if ( ( nas_dms_cached_info.max_subscriptions == QMI_RIL_NUM_DUAL_SUB ) &&
                  ( nas_dms_cached_info.max_subscriptions_active == QMI_RIL_NUM_SINGLE_ACTIVE ) )
        {
            if ( strncmp(prop_val, "dsds", PROPERTY_VALUE_MAX ) != 0 )
            {
                strlcpy(prop_val,"dsds",sizeof(prop_val));
                is_prop_set_required = TRUE;
            }
        }
    }

    if ( is_prop_set_required == TRUE )
    {
        QCRIL_LOG_INFO ( "Setting Multisim prop val %s", prop_val );
        if ( property_set( QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val ) != E_SUCCESS )
        {
            QCRIL_LOG_ERROR( "Fail to save %s to system property", QMI_RIL_SYS_PROP_NAME_MULTI_SIM );
        }
        else
        {
           // On successful property setting, reset multi sim feature info.
           qmi_ril_reset_multi_sim_ftr_info();
        }
    }
    else
    {
        QCRIL_LOG_INFO ( "Property %s already set to %s", QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val );
    }
    QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// qcril_qmi_nas_dms_update_common_modem_state
//===========================================================================
void qcril_qmi_nas_dms_update_common_modem_state()
{
    qcril_modem_state_e_type modem_state;

    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        switch ( nas_dms_cached_info.operating_mode )
        {
            case DMS_VAL_ONLINE:
                modem_state = QCRIL_MODEM_STATE_ON;
                break;

            case DMS_VAL_LOW_POWER:
            case DMS_VAL_OFFLINE:
            case DMS_VAL_RESETTING:
            case DMS_VAL_SHUTTING_DOWN:
                modem_state = QCRIL_MODEM_STATE_OFF;
                break;

            case DMS_VAL_FACTORY_TEST_MODE:    // fallthrough
            default:
                modem_state = QCRIL_MODEM_STATE_UNAVAILABLE; // unknown
                break;
        }
        qcril_qmi_mgr_modem_state_updated( QCRIL_DEFAULT_INSTANCE_ID, modem_state );
    }
} // qcril_qmi_nas_dms_update_common_modem_state

//===========================================================================
// qcril_qmi_nas_update_radio_power_request_info
//===========================================================================
void qcril_qmi_nas_update_radio_power_request_info()
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if( QMI_RIL_DMS_RADIO_PWR_REQUEST_NONE == nas_common_info.radio_power_request_type )
    {
        nas_common_info.radio_power_request_type = QMI_RIL_DMS_RADIO_PWR_REQUEST_BOOTUP_RADIO_POWER_OFF;
    }
    else
    {
        nas_common_info.radio_power_request_type = QMI_RIL_DMS_RADIO_PWR_REQUEST_OTHER;
    }
    QCRIL_LOG_INFO("Updated the radio power request type to %s",radio_power_request_name[nas_common_info.radio_power_request_type]);
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_update_radio_power_request_info

//===========================================================================
// qcril_qmi_nas_is_bootup_radio_power_off_request
//===========================================================================
int qcril_qmi_nas_is_bootup_radio_power_off_request()
{
    int ret = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    QCRIL_LOG_INFO("radio power request type is %s",radio_power_request_name[nas_common_info.radio_power_request_type]);
    if( QMI_RIL_DMS_RADIO_PWR_REQUEST_BOOTUP_RADIO_POWER_OFF == nas_common_info.radio_power_request_type )
    {
        ret = TRUE;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_bootup_radio_power_off_request

//===========================================================================
// qcril_qmi_nas_is_apm_enabled
//===========================================================================
int qcril_qmi_nas_is_apm_enabled()
{
    unsigned long res = FALSE;
    int temp_len;
    char property_name[ PROPERTY_NAME_MAX ];
    char args[ PROPERTY_VALUE_MAX ];
    char *end_ptr;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_APM_ON );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      res = strtoul( args, &end_ptr, 0 );
      if ( (( errno == ERANGE ) && ( res == ULONG_MAX )) || res > 1 )
      {
        QCRIL_LOG_ERROR( "Fail to convert QMI_RIL_APM_ON %s", args );
        res = FALSE;
      }
    }

    QCRIL_LOG_INFO( "completed, QMI_RIL_APM_ON = %d", res);

    return res;

} // qcril_qmi_nas_is_apm_enabled

//===========================================================================
//qcril_qmi_nas_multiple_rild_radio_power_timeout_cb
//===========================================================================
void qcril_qmi_nas_multiple_rild_radio_power_timeout_cb(void * param)
{
    errno_enum_type                       found_qcril_request;
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(param);

    auto& msgList = getDmsModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestRadioPowerMessage::get_class_message_id());
    found_qcril_request = pendingMsg ? E_SUCCESS : E_FAILURE;

    RADIO_POWER_LOCK();
    nas_common_info.radio_power_multiple_rild_process_timer_valid = FALSE;

    if ( E_SUCCESS != found_qcril_request )
    {
       //communicate to the other rild that your radio power process is complete - FAKE signal
       nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN;
       nas_common_info.radio_power_multiple_rild_process_complete_num = NAS_NIL;
       qcril_multiple_rild_ipc_radio_power_propagation_helper_func(FALSE);
    }
    RADIO_POWER_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_multiple_rild_radio_power_timeout_cb

//===========================================================================
// qcril_qmi_nas_handle_multiple_rild_radio_power_sync
//===========================================================================
void qcril_qmi_nas_handle_multiple_rild_radio_power_sync(int requested_telephony_power_state)
{
  QCRIL_LOG_FUNC_ENTRY();

  RADIO_POWER_LOCK();
  qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_INITIATING_MULTIPLE_RILD_SYNC);

  if( TRUE == nas_common_info.radio_power_multiple_rild_process_timer_valid )
  {
      QCRIL_LOG_INFO("Cancelling the radio power expiry timer as we have completed our radio power process");
      qcril_cancel_timed_callback( (void*)(uintptr_t) nas_common_info.radio_power_multiple_rild_process_timer );
      nas_common_info.radio_power_multiple_rild_process_timer_valid = FALSE;
  }

  qcril_multiple_rild_ipc_radio_power_propagation_helper_func(TRUE); //communicate to the other rild that your radio power process is complete  - GENUINE signal
  if( QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_DONE != nas_common_info.radio_power_sync_type ) //other rild's radio power process is not yet complete, so wait for its completion
  {
      qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_MULTIPLE_RILD_SYNC);
      nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_WAITING;
      RADIO_POWER_WAIT();
  }
  nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN; //resetting state information
  qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_MULTIPLE_RILD_SYNC_DONE);
  RADIO_POWER_UNLOCK();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_handle_multiple_rild_radio_power_sync


//===========================================================================
// qcril_qmi_nas_handle_multiple_rild_radio_power_state_propagation
//===========================================================================
//called when the other rild wants to indicate that its radio power process is complete
void qcril_qmi_nas_handle_multiple_rild_radio_power_state_propagation(int is_genuine_signal)
{
  errno_enum_type                       found_qcril_request;
  const struct timeval radio_power_tmr_expiry = { 5 , 0 }; // 5 seconds
  int wake_up_radio_power_thread = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  auto& msgList = getDmsModule().getPendingMessageList();
  auto pendingMsg = msgList.find(RilRequestRadioPowerMessage::get_class_message_id());
  found_qcril_request = pendingMsg ? E_SUCCESS : E_FAILURE;

  qmi_ril_gen_operational_status_type op_status = qmi_ril_get_operational_status();
  QCRIL_LOG_INFO( "client available %d, operational state %d, RADIO_POWER received %d ",
     qcril_qmi_client_is_available(), op_status, found_qcril_request);

  if((!qcril_qmi_client_is_available() || (QMI_RIL_GEN_OPERATIONAL_STATUS_SUSPENDING == op_status)) &&
     (E_SUCCESS != found_qcril_request))
  {
    RADIO_POWER_LOCK();
    qcril_log_update_early_radio_power_req(is_genuine_signal);
    RADIO_POWER_UNLOCK();
  }
  else
  {
    RADIO_POWER_LOCK();
    if ( is_genuine_signal || E_SUCCESS == found_qcril_request )
    {
       nas_common_info.radio_power_multiple_rild_process_complete_num++;
    }

    QCRIL_LOG_INFO( "is_genuine_signal from other rild %d, completed number of other rilds %d,"
                  "is radio power request received %d, radio power expiry timer already created %d",
                  is_genuine_signal,
                  nas_common_info.radio_power_multiple_rild_process_complete_num,
                  (E_SUCCESS == found_qcril_request),
                  nas_common_info.radio_power_multiple_rild_process_timer_valid );

    //other rild's have completed their radio power processes
    if( nas_common_info.radio_power_multiple_rild_process_complete_num == (qmi_ril_retrieve_number_of_rilds() - 1) )
    {
      // if our radio power process is NOT complete, we just remember that the other rild's radio power
      // process is complete.
      wake_up_radio_power_thread = ( QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_WAITING
                                    == nas_common_info.radio_power_sync_type );
      nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_DONE;
      nas_common_info.radio_power_multiple_rild_process_complete_num = NAS_NIL;
    }

    // radio power request has been sent to us
    if ( E_SUCCESS == found_qcril_request )
    {
       // our radio power process thread is complete and is waiting
       if( TRUE == wake_up_radio_power_thread )
       {
          // since the other rild's radio power process is complete,wake up our radio power
          // process thread so that it can respond back to RADIO_POWER request
          RADIO_POWER_SIGNAL();
       }
    }
  // no radio power request has been sent to us- We would fake signal the other rilds after
  // radio_power_tmr_expiry time period. We create a radio_power timer only If the signal is
  // genuine and we have not already created it.
    else
    {
      if( TRUE == is_genuine_signal && FALSE == nas_common_info.radio_power_multiple_rild_process_timer_valid )
      {
          nas_common_info.radio_power_multiple_rild_process_timer_valid = TRUE;
          qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_DEFAULT_MODEM_ID,
                                      qcril_qmi_nas_multiple_rild_radio_power_timeout_cb,
                                      &radio_power_tmr_expiry,
                                      &nas_common_info.radio_power_multiple_rild_process_timer );
      }
    }

    RADIO_POWER_UNLOCK();
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_handle_multiple_rild_radio_power_state_propagation


//===========================================================================
// RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE
//===========================================================================
void qcril_qmi_nas_query_network_selection_mode
(
  std::shared_ptr<RilRequestQueryNetworkSelectModeMessage> msg
)
{
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_get_system_selection_preference_resp_msg_v01 qmi_response;
  qmi_client_error_type qmi_client_error;
  int is_cached;
  bool is_mode_manual = false;

  qcril_suppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_suppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());

  NAS_CACHE_LOCK();

  is_cached = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.net_sel_pref);
  QCRIL_LOG_INFO( "is_cached=%d",is_cached );
  if( !is_cached )
  {
      memset(&qmi_response,0,sizeof(qmi_response));
      qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_ZERO,
                                                    (void*) &qmi_response,
                                                    sizeof( qmi_response ),
                                                    ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
      QCRIL_LOG_INFO( "code=%d-value=%d",ril_req_res,qmi_response.net_sel_pref_valid );
      if( RIL_E_SUCCESS == ril_req_res )
      {
          NAS_CACHE_LOCK();
          NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.net_sel_pref, qmi_response.net_sel_pref);
          if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.net_sel_pref))
          {
              QCRIL_LOG_ERROR("network selection preference entry not present in the response");
              ril_req_res = RIL_E_MODEM_ERR;
          }
          NAS_CACHE_UNLOCK();
      }
  }
  else
  {
      ril_req_res = RIL_E_SUCCESS;
  }

  if( RIL_E_SUCCESS == ril_req_res )
  {
      NAS_CACHE_LOCK();
      is_mode_manual = (nas_cached_info.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01);
      NAS_CACHE_UNLOCK();
  }
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO( "network_selection_mode: %d, ril_req_res: %d", (int)is_mode_manual, (int)ril_req_res );
  // ** respond
  auto payload = std::make_shared<qcril::interfaces::RilGetSelectModeResult_t>(is_mode_manual);
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

  qcril_unsuppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());
  qcril_unsuppress_unsol_msg(RilUnsolVoiceRadioTechChangedMessage::get_class_message_id());
} // qcril_qmi_nas_query_network_selection_mode

//===========================================================================
// RIL_REQUEST_SET_BAND_MODE
//===========================================================================
void qcril_qmi_nas_set_band_mode
(
  std::shared_ptr<RilRequestSetBandModeMessage> msg
)
{
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_set_system_selection_preference_resp_msg_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  QCRIL_LOG_FUNC_ENTRY();

  // todo: add check if manual nw selection or nw scan is ongoing -> block set band mode in that case
  memset( &qmi_request, 0, sizeof( qmi_request ) );
  memset( &qmi_response, 0, sizeof( qmi_response ) );
  qmi_request.band_pref_valid = TRUE;

  ril_req_res = RIL_E_SUCCESS;
  switch (msg->getBandMode())
  {
      case RIL_VAL_BAND_ANY: // for "unspecified" (selected by baseband automatically)
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_ANY;
          break;

      case RIL_VAL_BAND_EURO: // for "EURO band" (GSM-900 / DCS-1800 / WCDMA-IMT-2000)
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_EURO;
          break;

      case RIL_VAL_BAND_US: // for "US band" (GSM-850 / PCS-1900 / WCDMA-850 / WCDMA-PCS-1900)
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_US;
          break;

      case RIL_VAL_BAND_JPN: // for "JPN band" (WCDMA-800 / WCDMA-IMT-2000)
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_JPN;
          break;

      case RIL_VAL_BAND_AUS: // for "AUS band" (GSM-900 / DCS-1800 / WCDMA-850 / WCDMA-IMT-2000):
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_AUS;
          break;

      case RIL_VAL_BAND_AUS2: // for "AUS band 2" (GSM-900 / DCS-1800 / WCDMA-850)
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_AUS2;
          break;

      case RIL_VAL_BAND_CELLULAR: // for "Cellular (800-MHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_CELLULAR;
          break;

      case RIL_VAL_BAND_PCS: // for "PCS (1900-MHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_PCS;
          break;

      case RIL_VAL_BAND_JTACS: // for "Band Class 3 (JTACS Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_JTACS;
          break;

      case RIL_VAL_BAND_KOREAN_PCS: // for "Band Class 4 (Korean PCS Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_KOREAN_PCS;
          break;

      case RIL_VAL_BAND_450_MHZ: // for "Band Class 5 (450-MHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_450_MHZ;
          break;

      case RIL_VAL_BAND_2_GHZ: // for "Band Class 6 (2-GMHz IMT2000 Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_2_GHZ;
          break;

      case RIL_VAL_BAND_UPPER_700_MHZ: // for "Band Class 7 (Upper 700-MHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ;
          break;

      case RIL_VAL_BAND_1800_MHZ: // for "Band Class 8 (1800-MHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_1800_MHZ;
          break;

      case RIL_VAL_BAND_900_MHZ: // for "Band Class 9 (900-MHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_900_MHZ;
          break;

      case RIL_VAL_BAND_SEC_800_MHZ: // for "Band Class 10 (Secondary 800-MHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ;
          break;

      case RIL_VAL_BAND_SEC_EUOROPEAN_PAMR: // for "Band Class 11 (400-MHz European PAMR Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR;
          break;

      case RIL_VAL_BAND_SEC_AWS: // for "Band Class 15 (AWS Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_AWS;
          break;

      case RIL_VAL_BAND_SEC_US_2_5_GHZ: // for "Band Class 16 (US 2.5-GHz Band)"
          qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ;
          break;

      default: // unsupported
          QCRIL_LOG_ERROR("Invalid arguments..unsupported band mode");
          ril_req_res = RIL_E_INVALID_ARGUMENTS;
          break;
  }

  if ( RIL_E_SUCCESS == ril_req_res )
  {
      qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                    &qmi_request,
                                                    sizeof( qmi_request ),
                                                    (void*) &qmi_response,
                                                    sizeof( qmi_response ),
                                                    ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  }

  // ** respond
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res );

} // qcril_qmi_nas_set_band_mode

//===========================================================================
// RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE
//===========================================================================
void qcril_qmi_nas_query_available_band_mode
(
  std::shared_ptr<RilRequestQueryAvailBandModeMessage> msg
)
{
  std::vector<int> ril_response;

  uint64_t  band_capability_remains;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  dms_get_band_capability_resp_msg_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_response, 0, sizeof(qmi_response));

  NAS_CACHE_LOCK();
  qmi_client_error =  qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                      QMI_DMS_GET_BAND_CAPABILITY_REQ_V01,
                                                         NULL,
                                                         NAS_ZERO, // empty payload
                                                         (void*) &qmi_response,
                                                         sizeof( qmi_response ),
                                                         QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

      if ( RIL_E_SUCCESS == ril_req_res )
      {
          NAS_CACHE_LOCK();
          NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.band_capability, qmi_response.band_capability );
          NAS_CACHE_UNLOCK();
      }
      else
      {
          QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)ril_req_res, (int)qmi_client_error );
      }

  if ( RIL_E_SUCCESS == ril_req_res )
  {
      NAS_CACHE_LOCK();
      band_capability_remains = nas_dms_cached_info.band_capability;
      NAS_CACHE_UNLOCK();

      ril_response.push_back(RIL_VAL_BAND_ANY);
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_EURO ) == NAS_VAL_BAND_PREF_COMB_EURO )
      {
          ril_response.push_back(RIL_VAL_BAND_EURO);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_US ) == NAS_VAL_BAND_PREF_COMB_US )
      {
          ril_response.push_back(RIL_VAL_BAND_US);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_JPN ) == NAS_VAL_BAND_PREF_COMB_JPN )
      {
          ril_response.push_back(RIL_VAL_BAND_JPN);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_AUS ) == NAS_VAL_BAND_PREF_COMB_AUS )
      {
          ril_response.push_back(RIL_VAL_BAND_AUS);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_AUS2 ) == NAS_VAL_BAND_PREF_COMB_AUS2 )
      {
          ril_response.push_back(RIL_VAL_BAND_AUS2);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_CELLULAR ) == NAS_VAL_BAND_PREF_COMB_CELLULAR )
      {
          ril_response.push_back(RIL_VAL_BAND_CELLULAR);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_PCS ) == NAS_VAL_BAND_PREF_COMB_PCS )
      {
          ril_response.push_back(RIL_VAL_BAND_PCS);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_JTACS ) == NAS_VAL_BAND_PREF_COMB_JTACS )
      {
          ril_response.push_back(RIL_VAL_BAND_JTACS);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_KOREAN_PCS ) == NAS_VAL_BAND_PREF_COMB_KOREAN_PCS )
      {
          ril_response.push_back(RIL_VAL_BAND_KOREAN_PCS);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_450_MHZ ) == NAS_VAL_BAND_PREF_COMB_450_MHZ )
      {
          ril_response.push_back(RIL_VAL_BAND_450_MHZ);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_2_GHZ ) == NAS_VAL_BAND_PREF_COMB_2_GHZ )
      {
          ril_response.push_back(RIL_VAL_BAND_2_GHZ);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ ) == NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ )
      {
          ril_response.push_back(RIL_VAL_BAND_UPPER_700_MHZ);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_1800_MHZ ) == NAS_VAL_BAND_PREF_COMB_1800_MHZ )
      {
          ril_response.push_back(RIL_VAL_BAND_1800_MHZ);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_900_MHZ ) == NAS_VAL_BAND_PREF_COMB_900_MHZ )
      {
          ril_response.push_back(RIL_VAL_BAND_900_MHZ);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ ) == NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ )
      {
          ril_response.push_back(RIL_VAL_BAND_SEC_800_MHZ);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR ) == NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR )
      {
          ril_response.push_back(RIL_VAL_BAND_SEC_EUOROPEAN_PAMR);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_AWS ) == NAS_VAL_BAND_PREF_COMB_AWS )
      {
          ril_response.push_back(RIL_VAL_BAND_SEC_AWS);
      }
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ ) == NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ )
      {
          ril_response.push_back(RIL_VAL_BAND_SEC_US_2_5_GHZ);
      }
  }

  NAS_CACHE_UNLOCK();
  // ** respond
  auto payload = std::make_shared<qcril::interfaces::RilQueryAvailBandsResult_t>(std::move(ril_response));
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      QCRIL_LOG_INFO( ".. nof bands returned %d", ril_response.size());
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET( ril_req_res );
} // qcril_qmi_nas_query_available_band_mode

//===========================================================================
// qcril_qmi_nas_retrieve_scan_network_type
//===========================================================================
int qcril_qmi_nas_retrieve_scan_network_type(nas_network_type_mask_type_v01 *scan_network_type, uint8_t is_incremental_scan)
{
    int ret;
    uint8_t mode_pref_valid;
    uint16_t mode_pref;

    QCRIL_LOG_FUNC_ENTRY();

    ret = FALSE;

    if( scan_network_type )
    {
        *scan_network_type = NAS_NIL;
        mode_pref_valid = qcril_qmi_nas_get_mode_pref(&mode_pref);
        if( FALSE == mode_pref_valid )
        {
            qcril_qmi_fetch_system_selection_preference();
            mode_pref_valid = qcril_qmi_nas_get_mode_pref(&mode_pref);
        }

        if( TRUE == mode_pref_valid )
        {
            if( ( FALSE == is_incremental_scan ) && ( mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G_V01 ) )
            {
                QCRIL_LOG_INFO("If NR5G mode present, don't sent QMI_NAS_PERFORM_NETWORK_SCAN request to modem");
                ret = FALSE;
            }
            else
            {
                if( mode_pref & QMI_NAS_RAT_MODE_PREF_GSM_V01 )
                {
                    *scan_network_type |= NAS_NETWORK_TYPE_GSM_ONLY_V01;
                }
                if( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS_V01 )
                {
                    *scan_network_type |= NAS_NETWORK_TYPE_WCDMA_ONLY_V01;
                }
                if( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE_V01 )
                {
                    *scan_network_type |= NAS_NETWORK_TYPE_LTE_ONLY_V01;
                }
                if( mode_pref & QMI_NAS_RAT_MODE_PREF_TDSCDMA_V01 )
                {
                    *scan_network_type |= NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01;
                }
                if( mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G_V01 )
                {
                    *scan_network_type |= NAS_NETWORK_TYPE_NR5G_ONLY_V01;
                }
                ret = TRUE;
            }
        }
        QCRIL_LOG_INFO("scan network type is %d", *scan_network_type);
    }
    else
    {
        QCRIL_LOG_FATAL("Null pointer passed for scan_network_type");
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_retrieve_scan_network_type

int qcril_qmi_nas_fill_network_scan_response
(
uint32 nw_info_len,
qcril_qmi_nas_nw_scan_info_helper_type * nw_scan_helper,
qcril_qmi_nw_scan_resp_helper_type * ril_rep_helper,
int *p_entries
)
{
  unsigned int nw_cnt = 0;
  unsigned int no_of_entries;
  unsigned int iter_j;
  unsigned int iter_i;

  char * info_str;
  uint8_t nw_status;
  int res, is_current_nw, duplicate_name_found;
  char current_mcc_str[NAS_MCC_MNC_MAX_SIZE],current_mnc_str[NAS_MCC_MNC_MAX_SIZE],qmi_nw_info_mcc_str[NAS_MCC_MNC_MAX_SIZE],qmi_nw_info_mnc_str[NAS_MCC_MNC_MAX_SIZE];
  int rat = RADIO_TECH_UNKNOWN;
  char*  ref_name;
  char   ref_name_org[NAS_OPERATOR_RESP_MAX_EONS_LEN];

  char*  long_name_for_dup;
  char*  short_name_for_dup;
  int    any_changes_from_duplicate_filtering;


  uint8_t slot;
  boolean use_cc_names = FALSE;
  char sim_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  const char *op_name_short = NULL;
  const char *op_name_long = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  res = qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, FALSE, NULL);
  use_cc_names = nas_common_info.use_cc_names;
  slot = qmi_ril_get_process_instance_id();
  if (nas_common_info.card_info[slot].mcc_from_iccid)
  {
    strlcpy(sim_mcc_str, nas_common_info.card_info[slot].mcc_from_iccid, NAS_MCC_MNC_MAX_SIZE);
  }
  NAS_CACHE_UNLOCK();

  no_of_entries = ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_LEGACY_RAT) ) ?
      NUM_OF_STRINGS_WITH_LEGACY_RAT : NUM_OF_STRINGS_WITH_COMBINED_RAT_OR_NO_RAT;
  *p_entries = no_of_entries;
  memset( ril_rep_helper, 0, sizeof( qcril_qmi_nw_scan_resp_helper_type ) );
  QCRIL_LOG_INFO("Network Info (long/short/mcc_mnc/status)");
  QCRIL_LOG_INFO("Number of Scanned Network(s) : %d", nw_info_len);
  for ( iter_i = 0; iter_i < nw_info_len; iter_i++ )
  {
    snprintf( qmi_nw_info_mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)nw_scan_helper->mcc );
    if ( (nw_scan_helper->mnc > 99) ||  (nw_scan_helper->mnc_includes_pcs_digit) )
    {
      snprintf( qmi_nw_info_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)nw_scan_helper->mnc );
    }
    else
    {
      snprintf( qmi_nw_info_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int)nw_scan_helper->mnc );
    }
    info_str = ril_rep_helper->mccmnc_info[ nw_cnt ];
    snprintf( ril_rep_helper->mccmnc_info[ nw_cnt ], sizeof(ril_rep_helper->mccmnc_info[ nw_cnt ]), "%s%s", qmi_nw_info_mcc_str,qmi_nw_info_mnc_str);
    is_current_nw = res && !strcmp(current_mcc_str,qmi_nw_info_mcc_str) && !strcmp(current_mnc_str,qmi_nw_info_mnc_str);
    op_name_short = NULL;
    op_name_long = NULL;
    if (use_cc_names)
    {
      qcril_qmi_nas2_find_static_cc_operator_name(sim_mcc_str,
             qmi_nw_info_mcc_str,
             qmi_nw_info_mnc_str,
             &op_name_short,
             &op_name_long);
    }

    if ((op_name_short != NULL && op_name_short[0] != 0) ||
        (op_name_long != NULL && op_name_long[0] != 0))
    {
      if (op_name_long != NULL)
      {
        memcpy(ril_rep_helper->long_eons[ nw_cnt ],
               op_name_long,
               sizeof(ril_rep_helper->long_eons[ nw_cnt ]));
      }
      if (op_name_short != NULL)
      {
        memcpy(ril_rep_helper->short_eons[ nw_cnt ],
               op_name_short,
               sizeof(ril_rep_helper->short_eons[ nw_cnt ]));
      }
    }
    else
    {
      if ( nw_scan_helper->plmn_rat_valid )
      {
        QCRIL_LOG_INFO ("RAT received in perform_nw_scan response %d", (int) nw_scan_helper->plmn_rat);
      }
      qcril_qmi_util_handle_centralized_short_long_eons(qmi_nw_info_mcc_str,
              qmi_nw_info_mnc_str,
              ril_rep_helper->short_eons[ nw_cnt ],
              sizeof(ril_rep_helper->short_eons[ nw_cnt ]),
              ril_rep_helper->long_eons[ nw_cnt ],
              sizeof(ril_rep_helper->long_eons[ nw_cnt ]),
              TRUE,
              (nas_radio_if_enum_v01) nw_scan_helper->plmn_rat,
              FALSE,
              0);
    }

    if ( *(ril_rep_helper->long_eons[ nw_cnt ]) && !*(ril_rep_helper->short_eons[ nw_cnt ]) && TRUE == nas_common_info.fill_eons)
    {
      QCRIL_LOG_INFO("Filling short eons with long eons");
      strlcpy( ril_rep_helper->short_eons[ nw_cnt ], ril_rep_helper->long_eons[ nw_cnt ] , sizeof(ril_rep_helper->short_eons[ nw_cnt ]));
    }

    if ( *(ril_rep_helper->short_eons[ nw_cnt ]) && !*(ril_rep_helper->long_eons[ nw_cnt ]) && TRUE == nas_common_info.fill_eons)
    {
      QCRIL_LOG_INFO("Filling long eons with short eons");
      strlcpy( ril_rep_helper->long_eons[ nw_cnt ], ril_rep_helper->short_eons[ nw_cnt ] , sizeof(ril_rep_helper->long_eons[ nw_cnt ]));
    }

    if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() ) //Need to filter duplicate PLMN's when RAT reporting is not supported in ril.h interface
    {
      if( TRUE == qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(qmi_nw_info_mcc_str, qmi_nw_info_mnc_str, ril_rep_helper->short_eons[ nw_cnt ], ril_rep_helper->long_eons[ nw_cnt ], ril_rep_helper, nw_cnt) )
      {
        QCRIL_LOG_INFO("PLMN already added!");
        ril_rep_helper->short_eons[ nw_cnt ][0] = '\0';
        ril_rep_helper->long_eons[ nw_cnt ][0]  = '\0';

        nw_status = nw_scan_helper->network_status;
        if ( nw_status & NAS_NW_SCAN_RES_ENTRY_FORBIDDEN )
        {
            info_str = (char *) "forbidden";
        }
        else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_CUR_SERVING )
        {
            info_str = (char *) "current";
        }
        else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_AVAILABLE )
        {
            info_str = (char *) "available";
        }
        else
        {
            info_str = (char *) "unknown";
        }

        qcril_qmi_util_proper_network_status_notify_for_plmn(qmi_nw_info_mcc_str, qmi_nw_info_mnc_str, no_of_entries, info_str, ril_rep_helper, nw_cnt);
        nw_scan_helper++;
        continue;
      }
    }

    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ] = ril_rep_helper->long_eons[ nw_cnt ];
    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ] = ril_rep_helper->short_eons[ nw_cnt ];
    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ] = info_str;  // 5 or 6 digit numeric code (MCC + MNC)


    nw_status = nw_scan_helper->network_status;

    /* UE might limited service on forbidden plmn for emergency calls.
       As part of network scan response, show network as forbidden
       to user instead of "current". */
    if ( nw_status & NAS_NW_SCAN_RES_ENTRY_FORBIDDEN )
    {
      info_str = (char *) "forbidden";
    }
    else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_CUR_SERVING)
    {
      info_str = (char *) "current";
    }
    else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_AVAILABLE )
    {
      info_str = (char *) "available";
    }
    else
    {
      info_str = (char *) "unknown";
    }

    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ] = info_str;  // nw status
    if ( QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() )
    {
      if( nw_scan_helper->plmn_rat_valid )
      {
        switch(nw_scan_helper->plmn_rat)
        {
          case NAS_RADIO_IF_GSM:
               rat = RADIO_TECH_EDGE;
               break;

          case NAS_RADIO_IF_UMTS:
               rat = RADIO_TECH_UMTS;
               break;

          case NAS_RADIO_IF_LTE:
               rat = RADIO_TECH_LTE;
               break;

          case NAS_RADIO_IF_TDSCDMA:
               rat = RADIO_TECH_TD_SCDMA;
               break;
          case NAS_RADIO_IF_NR5G:
               rat = RADIO_TECH_5G;
               break;

          default:
               rat = RADIO_TECH_UNKNOWN;
               break;
        }
      }
      else
      {
        rat = RADIO_TECH_UNKNOWN;
      }

      QCRIL_SNPRINTF( ril_rep_helper->rat[ nw_cnt ], sizeof( ril_rep_helper->rat[ nw_cnt ] ), "%d", rat );
      if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_LEGACY_RAT) )
      {
        ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 4 ] =  ril_rep_helper->rat[ nw_cnt ];
        QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%s/%s",nw_cnt+1,
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 4 ]);
      }
      else if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_COMBINE_RAT) )
      {
        /*
         * Append "+RAT" to PLMN string
         * ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ]
         * is pointing to ril_rep_helper->mccmnc_info[ nw_cnt ]
         */
         strlcat( ril_rep_helper->mccmnc_info[ nw_cnt ], "+",
                sizeof( ril_rep_helper->mccmnc_info[ nw_cnt ] ) );
         strlcat( ril_rep_helper->mccmnc_info[ nw_cnt ],
                ril_rep_helper->rat[ nw_cnt ], sizeof( ril_rep_helper->mccmnc_info[ nw_cnt ] ) );
         ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ] =
                ril_rep_helper->mccmnc_info[ nw_cnt ];
         QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%s",nw_cnt+1,
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ]);
      }
    }
    else
    {
      QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%s",nw_cnt+1,
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ],
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ],
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ],
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ]);
    }
    nw_cnt++;
    nw_scan_helper++;
  } /* for loop of iter_i */

  if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() && nw_cnt > 1 && TRUE == nas_common_info.process_duplicate_nw_scan_names )
  {
    any_changes_from_duplicate_filtering = FALSE;
    QCRIL_LOG_INFO( "attempt to filter out duplicate names" );
    for ( iter_i = 0; iter_i < (unsigned)(nw_cnt - 1); iter_i++ )
    {
      // long
      ref_name = ril_rep_helper->long_eons[ iter_i ];
      duplicate_name_found = FALSE;
      for ( iter_j = iter_i + 1; iter_j < nw_cnt && !duplicate_name_found ; iter_j++ )
      {
        if ( 0 == strcmp( ref_name, ril_rep_helper->long_eons[ iter_j ] ) )
        {
          duplicate_name_found = TRUE;
        }
      }
      if ( duplicate_name_found )
      { // patch all duplicate names
        strlcpy( ref_name_org, ref_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
        for ( iter_j = iter_i; iter_j < nw_cnt; iter_j++ )
        {
          if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->long_eons[ iter_j ] ) ) )
          {
             long_name_for_dup   = NULL;
             qcril_qmi_nas2_find_elaboration_static_name( ril_rep_helper->mccmnc_info[ iter_j ], &long_name_for_dup, NULL );
             if ( NULL != long_name_for_dup )
             {
               strlcpy( ril_rep_helper->long_eons[ iter_j ], long_name_for_dup, NAS_OPERATOR_RESP_MAX_EONS_LEN );
               any_changes_from_duplicate_filtering = TRUE;
             }
           } // if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->long_eons[ iter_j ] ) ) )
         }
       }  // if ( duplicate_name_found )

       // short
       ref_name = ril_rep_helper->short_eons[ iter_i ];
       duplicate_name_found = FALSE;
       for ( iter_j = iter_i + 1; iter_j < nw_cnt && !duplicate_name_found ; iter_j++ )
       {
         if ( 0 == strcmp( ref_name, ril_rep_helper->short_eons[ iter_j ] ) )
         {
           duplicate_name_found = TRUE;
         }
       }
       if ( duplicate_name_found )
       { // patch all duplicate names
         strlcpy( ref_name_org, ref_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
         for ( iter_j = iter_i; iter_j < nw_cnt; iter_j++ )
         {
           if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->short_eons[ iter_j ] ) ) )
           {
              short_name_for_dup  = NULL;
              qcril_qmi_nas2_find_elaboration_static_name( ril_rep_helper->mccmnc_info[ iter_j ], NULL, &short_name_for_dup  );
              if ( NULL != short_name_for_dup )
              {
                strlcpy( ril_rep_helper->short_eons[ iter_j ], short_name_for_dup, NAS_OPERATOR_RESP_MAX_EONS_LEN );
                any_changes_from_duplicate_filtering = TRUE;
              }
           } // if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->short_eons[ iter_j ] ) ) )
          }
        } // if ( duplicate_name_found )

    } // for ( iter_i = 0; iter_i < (nw_cnt - 1); iter_i++ )

    QCRIL_LOG_INFO( "duplicate names filtering applied %d", any_changes_from_duplicate_filtering );
    if ( any_changes_from_duplicate_filtering )
    {
       for ( iter_i = 0; iter_i < nw_cnt; iter_i++ )
       {
          QCRIL_LOG_INFO("post filter network #%d - %s/%s/%s/%s", iter_i+1,
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ],
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1 ],
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2 ],
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3 ]);
       }
    } // any_changes_from_duplicate_filtering

  } // if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() && nw_cnt > 1 && && TRUE == nas_common_info.process_duplicate_nw_scan_names )
  QCRIL_LOG_FUNC_RETURN();
  return nw_cnt;
}

int qcril_qmi_nas_fill_network_scan_response
(
  uint32 nw_info_len,
  qcril_qmi_nas_nw_scan_info_helper_type * nw_scan_helper,
  std::vector<qcril::interfaces::NetworkInfo>& list
)
{
  unsigned int nw_cnt = 0;
  unsigned int iter_j;
  unsigned int iter_i;

  int res, is_current_nw, duplicate_name_found;
  char current_mcc_str[NAS_MCC_MNC_MAX_SIZE],current_mnc_str[NAS_MCC_MNC_MAX_SIZE],qmi_nw_info_mcc_str[NAS_MCC_MNC_MAX_SIZE],qmi_nw_info_mnc_str[NAS_MCC_MNC_MAX_SIZE];
  int rat = RADIO_TECH_UNKNOWN;

  char*  long_name_for_dup;
  char*  short_name_for_dup;
  int    any_changes_from_duplicate_filtering;


  uint8_t slot;
  boolean use_cc_names = FALSE;
  char sim_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  const char *op_name_short = NULL;
  const char *op_name_long = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  res = qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, FALSE, NULL);
  use_cc_names = nas_common_info.use_cc_names;
  slot = qmi_ril_get_sim_slot();
  if (nas_common_info.card_info[slot].mcc_from_iccid)
  {
    strlcpy(sim_mcc_str, nas_common_info.card_info[slot].mcc_from_iccid, NAS_MCC_MNC_MAX_SIZE);
  }
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO("Network Info (long/short/mcc_mnc/status)");
  QCRIL_LOG_INFO("Number of Scanned Network(s) : %d", nw_info_len);

  for ( iter_i = 0; iter_i < nw_info_len; iter_i++ )
  {
    qcril::interfaces::NetworkInfo item;
    snprintf( qmi_nw_info_mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)nw_scan_helper->mcc );
    if ( (nw_scan_helper->mnc > 99) ||  (nw_scan_helper->mnc_includes_pcs_digit) )
    {
      snprintf( qmi_nw_info_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)nw_scan_helper->mnc );
    }
    else
    {
      snprintf( qmi_nw_info_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int)nw_scan_helper->mnc );
    }
    item.operatorNumeric.append(qmi_nw_info_mcc_str).append(qmi_nw_info_mnc_str);
#if 0
    char long_eons[NAS_OPERATOR_RESP_MAX_EONS_LEN] = {};
    char short_eons[NAS_OPERATOR_RESP_MAX_EONS_LEN] = {};
#else
    char long_eons[NAS_OPERATOR_RESP_MAX_EONS_LEN];
    char short_eons[NAS_OPERATOR_RESP_MAX_EONS_LEN];
    memset(long_eons, 0, sizeof(long_eons));
    memset(short_eons, 0, sizeof(short_eons));
#endif

    is_current_nw = res && !strcmp(current_mcc_str,qmi_nw_info_mcc_str) && !strcmp(current_mnc_str,qmi_nw_info_mnc_str);
    op_name_short = NULL;
    op_name_long = NULL;
    if (use_cc_names)
    {
      qcril_qmi_nas2_find_static_cc_operator_name(sim_mcc_str,
             qmi_nw_info_mcc_str,
             qmi_nw_info_mnc_str,
             &op_name_short,
             &op_name_long);
    }

    if ((op_name_short != NULL && op_name_short[0] != 0) ||
        (op_name_long != NULL && op_name_long[0] != 0))
    {
      if (op_name_long != NULL)
      {
        strlcpy(long_eons, op_name_long, sizeof(long_eons));
      }
      if (op_name_short != NULL)
      {
        strlcpy(short_eons, op_name_short, sizeof(short_eons));
      }
    }
    else
    {
      if ( nw_scan_helper->plmn_rat_valid )
      {
        QCRIL_LOG_INFO ("RAT received in perform_nw_scan response %d", (int) nw_scan_helper->plmn_rat);
      }
      qcril_qmi_util_handle_centralized_short_long_eons(qmi_nw_info_mcc_str,
              qmi_nw_info_mnc_str,
              short_eons,
              sizeof(short_eons),
              long_eons,
              sizeof(long_eons),
              TRUE,
              (nas_radio_if_enum_v01) nw_scan_helper->plmn_rat,
              FALSE,
              0);
    }

    if (long_eons[0] && !short_eons[0] && TRUE == nas_common_info.fill_eons)
    {
      QCRIL_LOG_INFO("Filling short eons with long eons");
      strlcpy(short_eons, long_eons, sizeof(short_eons));
    }

    if (short_eons[0] && !long_eons[0] && TRUE == nas_common_info.fill_eons)
    {
      QCRIL_LOG_INFO("Filling long eons with short eons");
      strlcpy(long_eons, short_eons, sizeof(long_eons));
    }

    if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() ) //Need to filter duplicate PLMN's when RAT reporting is not supported in ril.h interface
    {
      if( TRUE == qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(qmi_nw_info_mcc_str, qmi_nw_info_mnc_str, short_eons, long_eons, list) )
      {
        QCRIL_LOG_INFO("PLMN already added!");
        long_eons[0] = '\0';
        short_eons[0] = '\0';

        uint8_t nw_status = nw_scan_helper->network_status;
        if ( nw_status & NAS_NW_SCAN_RES_ENTRY_FORBIDDEN )
        {
            item.status = qcril::interfaces::NetworkStatus::FORBIDDEN;
        }
        else if ( is_current_nw && (nw_status & NAS_NW_SCAN_RES_ENTRY_CUR_SERVING) )
        {
            item.status = qcril::interfaces::NetworkStatus::CURRENT;
        }
        else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_AVAILABLE )
        {
            item.status = qcril::interfaces::NetworkStatus::AVAILABLE;
        }
        else
        {
            item.status = qcril::interfaces::NetworkStatus::UNKNOWN;
        }

        qcril_qmi_util_proper_network_status_notify_for_plmn(qmi_nw_info_mcc_str, qmi_nw_info_mnc_str, item.status, list);
        nw_scan_helper++;
        continue;
      }
    }

    item.alphaLong = long_eons;
    item.alphaShort = short_eons;


    /* UE might limited service on forbidden plmn for emergency calls.
       As part of network scan response, show network as forbidden
       to user instead of "current". */
    uint8_t nw_status = nw_scan_helper->network_status;
    if ( nw_status & NAS_NW_SCAN_RES_ENTRY_FORBIDDEN )
    {
      item.status = qcril::interfaces::NetworkStatus::FORBIDDEN;
    }
    else if ( is_current_nw && (nw_status & NAS_NW_SCAN_RES_ENTRY_CUR_SERVING) )
    {
      item.status = qcril::interfaces::NetworkStatus::CURRENT;
    }
    else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_AVAILABLE )
    {
      item.status = qcril::interfaces::NetworkStatus::AVAILABLE;
    }
    else
    {
      item.status = qcril::interfaces::NetworkStatus::UNKNOWN;
    }

    if ( QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() )
    {
      if( nw_scan_helper->plmn_rat_valid )
      {
        switch(nw_scan_helper->plmn_rat)
        {
          case NAS_RADIO_IF_GSM:
               rat = RADIO_TECH_EDGE;
               break;

          case NAS_RADIO_IF_UMTS:
               rat = RADIO_TECH_UMTS;
               break;

          case NAS_RADIO_IF_LTE:
               rat = RADIO_TECH_LTE;
               break;

          case NAS_RADIO_IF_TDSCDMA:
               rat = RADIO_TECH_TD_SCDMA;
               break;
          case NAS_RADIO_IF_NR5G:
               rat = RADIO_TECH_5G;
               break;

          default:
               rat = RADIO_TECH_UNKNOWN;
               break;
        }
      }
      else
      {
        rat = RADIO_TECH_UNKNOWN;
      }

      /*
       * Append "+RAT" to PLMN string
       */
      item.operatorNumeric.append("+").append(std::to_string(static_cast<int>(rat)));
    }

    QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%d", nw_cnt+1,
        item.alphaLong.c_str(), item.alphaShort.c_str(),
        item.operatorNumeric.c_str(), item.status);
    list.push_back(item);
    nw_cnt++;
    nw_scan_helper++;
  } /* for loop of iter_i */

  auto list_len = list.size();
  if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() && list_len > 1 && TRUE == nas_common_info.process_duplicate_nw_scan_names )
  {
    any_changes_from_duplicate_filtering = FALSE;
    QCRIL_LOG_INFO( "attempt to filter out duplicate names" );
    for ( iter_i = 0; iter_i < (unsigned)(list_len - 1); iter_i++ )
    {
      // long
      duplicate_name_found = FALSE;
      for ( iter_j = iter_i + 1; iter_j < list_len && !duplicate_name_found ; iter_j++ )
      {
        if (!list[iter_i].alphaLong.compare(list[iter_i].alphaLong))
        {
          duplicate_name_found = TRUE;
        }
      }
      if ( duplicate_name_found )
      { // patch all duplicate names
        auto ref_name = list[iter_i].alphaLong;
        for ( iter_j = iter_i; iter_j < list_len; iter_j++ )
        {
          if ((iter_j == iter_i) || (!ref_name.compare(list[iter_j].alphaLong)))
          {
             long_name_for_dup = NULL;
             qcril_qmi_nas2_find_elaboration_static_name(list[iter_j].operatorNumeric.c_str(), &long_name_for_dup, NULL);
             if (NULL != long_name_for_dup)
             {
               list[iter_j].alphaLong = long_name_for_dup;
               any_changes_from_duplicate_filtering = TRUE;
             }
           } // if ((iter_j == iter_i) || (!ref_name.compare(list[iter_j].alphaLong)))
         }
       }  // if ( duplicate_name_found )

       // short
       duplicate_name_found = FALSE;
       for ( iter_j = iter_i + 1; iter_j < list_len && !duplicate_name_found ; iter_j++ )
       {
         if (!list[iter_i].alphaShort.compare(list[iter_i].alphaShort))
         {
           duplicate_name_found = TRUE;
         }
       }
       if ( duplicate_name_found )
       { // patch all duplicate names
         auto ref_name = list[iter_i].alphaShort;
         for ( iter_j = iter_i; iter_j < list_len; iter_j++ )
         {
           if ((iter_j == iter_i) || (!ref_name.compare(list[iter_j].alphaShort)))
           {
              short_name_for_dup  = NULL;
              qcril_qmi_nas2_find_elaboration_static_name(list[iter_j].operatorNumeric.c_str(), NULL, &short_name_for_dup);
              if ( NULL != short_name_for_dup )
              {
                list[iter_j].alphaShort = short_name_for_dup;
                any_changes_from_duplicate_filtering = TRUE;
              }
           } // if ((iter_j == iter_i) || (!ref_name.compare(list[iter_j].alphaShort)))
          }
        } // if ( duplicate_name_found )

    } // for ( iter_i = 0; iter_i < (list_len - 1); iter_i++ )

    QCRIL_LOG_INFO( "duplicate names filtering applied %d", any_changes_from_duplicate_filtering );
    if ( any_changes_from_duplicate_filtering )
    {
      for ( iter_i = 0; iter_i < list_len; iter_i++ )
      {
          QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%d", nw_cnt+1,
                    list[iter_i].alphaLong.c_str(), list[iter_i].alphaShort.c_str(),
                    list[iter_i].operatorNumeric.c_str(), list[iter_i].status);
      }
    } // any_changes_from_duplicate_filtering

  } // if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() && list_len > 1 && && TRUE == nas_common_info.process_duplicate_nw_scan_names )
  QCRIL_LOG_FUNC_RETURN();
  return list_len;
}

//===========================================================================
// qcril_qmi_nas_is_current_nw
//===========================================================================
int qcril_qmi_nas_is_current_nw
(
    int mobile_country_code,
    int mobile_network_code,
    int mnc_includes_pcs_digit
)
{
    int res = 0, is_current_nw = FALSE;
    char current_mcc_str[NAS_MCC_MNC_MAX_SIZE],current_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    char qmi_mcc_str[NAS_MCC_MNC_MAX_SIZE], qmi_mnc_str[NAS_MCC_MNC_MAX_SIZE];

    QCRIL_LOG_FUNC_ENTRY();

    res = qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, FALSE, NULL);

    snprintf( qmi_mcc_str,
        NAS_MCC_MNC_MAX_SIZE,
        "%03d",
        (int)mobile_country_code);
    if ( (mobile_network_code > 99) || mnc_includes_pcs_digit )
    {
      snprintf( qmi_mnc_str,
        NAS_MCC_MNC_MAX_SIZE,
        "%03d",
        (int)mobile_network_code );
    }
    else
    {
      snprintf( qmi_mnc_str,
        NAS_MCC_MNC_MAX_SIZE,
        "%02d",
        (int)mobile_network_code );
    }

    is_current_nw = res && !strcmp(current_mcc_str,qmi_mcc_str) &&
        !strcmp(current_mnc_str,qmi_mnc_str);

    return is_current_nw;

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_send_oemhook_incremental_network_scan_unsol
//===========================================================================
void qcril_qmi_nas_send_oemhook_incremental_network_scan_unsol
(
    nas_perform_incremental_network_scan_ind_msg_v01 * nw_scan_ind
)
{
    qcril_qmi_nw_scan_resp_helper_type *    ril_rep_helper = NULL;
    int nw_cnt = 0, iter_i = 0, no_of_entries = 0, scan_info_len = 0;
    uint16_t len = 0, total_len = 0;
    unsigned char *resp_byte_stream_ptr = NULL;
    unsigned char *resp_byte_stream = NULL;
    qcril_qmi_nas_nw_scan_info_helper_type * nw_scan_helper = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    if (nw_scan_ind)
    {
        QCRIL_LOG_INFO("Scan Status : %d", nw_scan_ind->scan_status);
        scan_info_len = nw_scan_ind->nas_network_scan_info_len;
        QCRIL_LOG_INFO("Scan info len: %d", scan_info_len);

        if ( scan_info_len > 0 )
        {
            nw_scan_helper = (qcril_qmi_nas_nw_scan_info_helper_type*)
                qcril_malloc (sizeof(qcril_qmi_nas_nw_scan_info_helper_type)*scan_info_len);
            ril_rep_helper = (qcril_qmi_nw_scan_resp_helper_type*)
                qcril_malloc (sizeof(qcril_qmi_nw_scan_resp_helper_type)*scan_info_len);
            if ( ril_rep_helper && nw_scan_helper )
            {
                memset(nw_scan_helper, 0, sizeof(qcril_qmi_nas_nw_scan_info_helper_type)*scan_info_len);
                memset(ril_rep_helper, 0, sizeof(qcril_qmi_nw_scan_resp_helper_type)*scan_info_len);
                for ( iter_i = 0; iter_i < scan_info_len; iter_i++)
                {
                    nw_scan_helper[iter_i].mcc = nw_scan_ind->nas_network_scan_info[iter_i].mobile_country_code;
                    nw_scan_helper[iter_i].mnc_includes_pcs_digit = nw_scan_ind->nas_network_scan_info[iter_i].mnc_includes_pcs_digit;
                    nw_scan_helper[iter_i].mnc = nw_scan_ind->nas_network_scan_info[iter_i].mobile_network_code;
                    nw_scan_helper[iter_i].network_status = nw_scan_ind->nas_network_scan_info[iter_i].network_status;
                    nw_scan_helper[iter_i].plmn_rat_valid = TRUE;
                    nw_scan_helper[iter_i].plmn_rat = nw_scan_ind->nas_network_scan_info[iter_i].rat;
                }
                nw_cnt = qcril_qmi_nas_fill_network_scan_response (nw_scan_ind->nas_network_scan_info_len,
                                                                   nw_scan_helper,
                                                                   ril_rep_helper,
                                                                   &no_of_entries);
                QCRIL_LOG_INFO("Network scan plmn count = %d", nw_cnt );
            }
        }
        // Send UNSOL OEM HOOK response to telephony
        // NOTE: for RAT, incrementenal search only support "combine". It does not support "legacy"
        len = (sizeof(qcril_qmi_nw_scan_resp_helper_type) * nw_cnt) + (sizeof(uint16) * no_of_entries * nw_cnt) + 2;
        resp_byte_stream = (unsigned char*) qcril_malloc(len);
        if ( resp_byte_stream )
        {
            resp_byte_stream_ptr = resp_byte_stream;
            memset( resp_byte_stream, 0, len );
            // Scan status
            *resp_byte_stream_ptr = (uint8_t) nw_scan_ind->scan_status;
            resp_byte_stream_ptr = resp_byte_stream_ptr + 1;
            total_len =  total_len + 1;
            // No. of network info
            *resp_byte_stream_ptr = (uint8_t)nw_cnt;
            resp_byte_stream_ptr = resp_byte_stream_ptr + 1;
            total_len =  total_len + 1;
            for ( iter_i = 0; iter_i < nw_cnt; iter_i++ )
            {
                QCRIL_LOG_INFO("Network scan response #%d - %s/%s/%s/%s", iter_i+1,
                ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3 ]);
                // Length followed by value
                // long alpha ONS or EONS
                len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ]);
                memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
                resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
                memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ], len);
                resp_byte_stream_ptr = resp_byte_stream_ptr + len;
                total_len =  total_len +  sizeof(uint16) + len;

                // short alpha ONS or EONS
                len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1 ]);
                memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
                resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
                memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1], len);
                resp_byte_stream_ptr = resp_byte_stream_ptr + len;
                total_len =  total_len +  sizeof(uint16) + len;

                // MCC+MNC
                len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2]);
                memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
                resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
                memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2], len);
                resp_byte_stream_ptr = resp_byte_stream_ptr + len;
                total_len =  total_len +  sizeof(uint16) + len;

                // NW status
                len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3]);
                memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
                resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
                memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3], len);
                resp_byte_stream_ptr = resp_byte_stream_ptr + len;
                total_len =  total_len +  sizeof(uint16) + len;
            }
            QCRIL_LOG_INFO("RIL response len: %d", total_len);
            resp_byte_stream_ptr = resp_byte_stream;
            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_INCREMENTAL_NW_SCAN_IND, (char *)resp_byte_stream, total_len);
        }

        if (nw_scan_helper)
        {
            qcril_free(nw_scan_helper);
        }
        if (ril_rep_helper)
        {
            qcril_free(ril_rep_helper);
        }
        if (resp_byte_stream)
        {
            qcril_free(resp_byte_stream);
        }
    }
  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_send_advanced_network_scan_unsol
//===========================================================================
void qcril_qmi_nas_send_advanced_network_scan_unsol
(
    nas_perform_incremental_network_scan_ind_msg_v01 * nw_scan_ind
)
{
    int is_current_nw = 0;
    uint32_t iter_i = 0;
    RIL_CellInfoGsm_v12   *gsm_cellinfo;
    RIL_CellInfoWcdma_v12 *wcdma_cellinfo;
    RIL_CellInfoLte_v12   *lte_cellinfo;
    RIL_CellInfoTdscdma   *tdscdma_cellinfo;
    RIL_CellInfoNr        *nr_cellinfo;
    nas_3gpp_network_scan_result_type_v01 *scan_info;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char mnc_str[NAS_MCC_MNC_MAX_SIZE];
    char alphaLong[MAX_OPERATOR_NAME_LEN];
    char alphaShort[MAX_OPERATOR_NAME_LEN];

    QCRIL_LOG_FUNC_ENTRY();

    if (nw_scan_ind)
    {
        uint32_t nw_cnt = nw_scan_ind->nas_network_scan_info_len;
        RIL_ScanStatus status;
        RIL_Errno ril_err = RIL_E_SUCCESS;
        switch (nw_scan_ind->scan_status)
        {
            case NAS_SCAN_STATUS_PARTIAL_V01:
            case NAS_SCAN_STATUS_PARTIAL_PERIODIC_V01:
                status = PARTIAL;
                break;
            case NAS_SCAN_STATUS_ABORT_V01:
            case NAS_SCAN_STATUS_REJ_IN_RLF_V01:
            case NAS_SCAN_STATUS_INCREMENT_ERROR_V01:
                status = COMPLETE;
                ril_err = RIL_E_ABORTED;
                break;

            // other than partial result, mark all other as complete
            default:
                status = COMPLETE;
                break;
        }

        std::vector<RIL_CellInfo_v12> network_infos;
        int is_full_service = qcril_qmi_nas_is_considered_registered(NULL);
        if (nw_cnt > 0)
        {
            network_infos.reserve(nw_cnt);
            for (iter_i = 0; iter_i < nw_cnt; iter_i++)
            {
                RIL_CellInfo_v12 item;
                qcril_qmi_nas_init_cell_info_struct_v12(&item);

                scan_info = &nw_scan_ind->nas_network_scan_info[iter_i];

                is_current_nw = qcril_qmi_nas_is_current_nw(scan_info->mobile_country_code,
                    scan_info->mobile_network_code, scan_info->mnc_includes_pcs_digit);
                item.registered = (is_current_nw &&
                    is_full_service && (scan_info->network_status & NAS_NW_SCAN_RES_ENTRY_CUR_SERVING)) ?
                    TRUE : FALSE;

                snprintf( mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)scan_info->mobile_country_code);
                if ( (scan_info->mobile_network_code > 99) ||  (scan_info->mnc_includes_pcs_digit) )
                {
                    snprintf (mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)scan_info->mobile_network_code);
                }
                else
                {
                    snprintf (mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int)scan_info->mobile_network_code);
                }

                qcril_qmi_util_handle_centralized_short_long_eons(mcc_str,
                    mnc_str,
                    alphaShort,
                    sizeof(alphaShort),
                    alphaLong,
                    sizeof(alphaLong),
                    TRUE,
                    (nas_radio_if_enum_v01) scan_info->rat,
                    FALSE,
                    0);

                switch (scan_info->rat)
                {
                    case NAS_RADIO_IF_GSM_V01:
                        item.cellInfoType = RIL_CELL_INFO_TYPE_GSM;
                        snprintf(item.CellInfo.gsm.cellIdentityGsm.mcc, NAS_MCC_MNC_MAX_SIZE,
                            "%03d", (int)scan_info->mobile_country_code);
                        if ( (scan_info->mobile_network_code > 99) ||  (scan_info->mnc_includes_pcs_digit) )
                        {
                            snprintf (item.CellInfo.gsm.cellIdentityGsm.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%03d", (int)scan_info->mobile_network_code);
                        }
                        else
                        {
                            snprintf (item.CellInfo.gsm.cellIdentityGsm.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%02d", (int)scan_info->mobile_network_code);
                        }

                        strlcpy(item.CellInfo.gsm.cellIdentityGsm.operatorNames.alphaLong,
                            alphaLong,
                            MAX_OPERATOR_NAME_LEN);

                        strlcpy(item.CellInfo.gsm.cellIdentityGsm.operatorNames.alphaShort,
                            alphaShort,
                            MAX_OPERATOR_NAME_LEN);

                        if (nw_scan_ind->signal_strength_valid)
                        {
                            gsm_cellinfo = &item.CellInfo.gsm;
                            /* As modem will be sending rssi in positive no need to mul with -1 */
                            qcril_cm_util_rssi_to_gw_signal_strength(
                                nw_scan_ind->signal_strength[iter_i],
                                &gsm_cellinfo->signalStrengthGsm.signalStrength);
                        }

                        break;
                    case NAS_RADIO_IF_UMTS_V01:
                        item.cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
                        snprintf(item.CellInfo.wcdma.cellIdentityWcdma.mcc, NAS_MCC_MNC_MAX_SIZE,
                            "%03d", (int)scan_info->mobile_country_code);
                        if ( (scan_info->mobile_network_code > 99) ||  (scan_info->mnc_includes_pcs_digit) )
                        {
                            snprintf (item.CellInfo.wcdma.cellIdentityWcdma.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%03d", (int)scan_info->mobile_network_code);
                        }
                        else
                        {
                            snprintf (item.CellInfo.wcdma.cellIdentityWcdma.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%02d", (int)scan_info->mobile_network_code);
                        }

                        strlcpy(item.CellInfo.wcdma.cellIdentityWcdma.operatorNames.alphaLong,
                            alphaLong,
                            MAX_OPERATOR_NAME_LEN);

                        strlcpy(item.CellInfo.wcdma.cellIdentityWcdma.operatorNames.alphaShort,
                            alphaShort,
                            MAX_OPERATOR_NAME_LEN);

                        if (nw_scan_ind->signal_strength_valid)
                        {
                            wcdma_cellinfo = &item.CellInfo.wcdma;
                            /* As modem will be sending rssi in positive no need to mul with -1 */
                            qcril_cm_util_rssi_to_gw_signal_strength(
                                nw_scan_ind->signal_strength[iter_i],
                                &wcdma_cellinfo->signalStrengthWcdma.signalStrength);
                        }

                        break;
                    case NAS_RADIO_IF_LTE_V01:
                        item.cellInfoType = RIL_CELL_INFO_TYPE_LTE;
                        snprintf(item.CellInfo.lte.cellIdentityLte.mcc, NAS_MCC_MNC_MAX_SIZE,
                            "%03d", (int)scan_info->mobile_country_code);
                        if ( (scan_info->mobile_network_code > 99) ||  (scan_info->mnc_includes_pcs_digit) )
                        {
                            snprintf (item.CellInfo.lte.cellIdentityLte.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%03d", (int)scan_info->mobile_network_code);
                        }
                        else
                        {
                            snprintf (item.CellInfo.lte.cellIdentityLte.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%02d", (int)scan_info->mobile_network_code);
                        }

                        strlcpy(item.CellInfo.lte.cellIdentityLte.operatorNames.alphaLong,
                            alphaLong,
                            MAX_OPERATOR_NAME_LEN);

                        strlcpy(item.CellInfo.lte.cellIdentityLte.operatorNames.alphaShort,
                            alphaShort,
                            MAX_OPERATOR_NAME_LEN);

                        if (nw_scan_ind->signal_strength_valid)
                        {
                            lte_cellinfo = &item.CellInfo.lte;

                            /* As modem will be sending rsrp in positive no need to mul with -1 */
                            qcril_cm_util_rsrp_to_lte_signal_strength(
                                nw_scan_ind->signal_strength[iter_i],
                                &lte_cellinfo->signalStrengthLte.signalStrength);

                            lte_cellinfo->signalStrengthLte.rsrp =
                                nw_scan_ind->signal_strength[iter_i];
                        }
                        break;
                    case NAS_RADIO_IF_TDSCDMA_V01:
                        item.cellInfoType = RIL_CELL_INFO_TYPE_TD_SCDMA;
                        snprintf(item.CellInfo.tdscdma.cellIdentityTdscdma.mcc, NAS_MCC_MNC_MAX_SIZE,
                            "%03d", (int)scan_info->mobile_country_code);
                        if ( (scan_info->mobile_network_code > 99) ||  (scan_info->mnc_includes_pcs_digit) )
                        {
                            snprintf (item.CellInfo.tdscdma.cellIdentityTdscdma.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%03d", (int)scan_info->mobile_network_code);
                        }
                        else
                        {
                            snprintf (item.CellInfo.tdscdma.cellIdentityTdscdma.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%02d", (int)scan_info->mobile_network_code);
                        }

                        strlcpy(item.CellInfo.tdscdma.cellIdentityTdscdma.operatorNames.alphaLong,
                            alphaLong,
                            MAX_OPERATOR_NAME_LEN);

                        strlcpy(item.CellInfo.tdscdma.cellIdentityTdscdma.operatorNames.alphaShort,
                            alphaShort,
                            MAX_OPERATOR_NAME_LEN);

                        if (nw_scan_ind->signal_strength_valid)
                        {
                            tdscdma_cellinfo = &item.CellInfo.tdscdma;
                            tdscdma_cellinfo->signalStrengthTdscdma.rscp =
                                nw_scan_ind->signal_strength[iter_i];
                        }

                        break;
                    case NAS_RADIO_IF_NR5G_V01:
                        item.cellInfoType = RIL_CELL_INFO_TYPE_NR;
                        snprintf(item.CellInfo.nr.cellIdentityNr.mcc, NAS_MCC_MNC_MAX_SIZE,
                            "%03d", (int)scan_info->mobile_country_code);
                        if ( (scan_info->mobile_network_code > 99) ||  (scan_info->mnc_includes_pcs_digit) )
                        {
                            snprintf (item.CellInfo.nr.cellIdentityNr.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%03d", (int)scan_info->mobile_network_code);
                        }
                        else
                        {
                            snprintf (item.CellInfo.nr.cellIdentityNr.mnc, NAS_MCC_MNC_MAX_SIZE,
                                "%02d", (int)scan_info->mobile_network_code);
                        }

                        strlcpy(item.CellInfo.nr.cellIdentityNr.operatorNames.alphaLong,
                            alphaLong,
                            MAX_OPERATOR_NAME_LEN);

                        strlcpy(item.CellInfo.nr.cellIdentityNr.operatorNames.alphaShort,
                            alphaShort,
                            MAX_OPERATOR_NAME_LEN);

                        if (nw_scan_ind->signal_strength_valid)
                        {
                            nr_cellinfo = &item.CellInfo.nr;
                            nr_cellinfo->signalStrengthNr.ssRsrp =
                                nw_scan_ind->signal_strength[iter_i];
                        }

                        break;
                    default:
                        break;
                }
                network_infos.push_back(item);
            }
        }

        // report network scan report to client
        auto msg = std::make_shared<RilUnsolNetworkScanResultMessage>(status, ril_err,
                std::move(network_infos));
        Dispatcher::getInstance().dispatchSync(msg);

        if(status == COMPLETE)
        {
            // Reset flag after sending unsol
            NAS_CACHE_LOCK();
            nas_cached_info.is_adv_nw_scan = FALSE;
            NAS_CACHE_UNLOCK();
        }
    }

    QCRIL_LOG_FUNC_RETURN();

}

//===========================================================================
// qcril_qmi_nas_perform_incremental_network_scan_ind_handler
//===========================================================================
void qcril_qmi_nas_perform_incremental_network_scan_ind_handler
(
    nas_perform_incremental_network_scan_ind_msg_v01 * nw_scan_ind
)
{
  int is_adv_scan = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  is_adv_scan = nas_cached_info.is_adv_nw_scan;
  NAS_CACHE_UNLOCK();

  if (is_adv_scan == TRUE)
      qcril_qmi_nas_send_advanced_network_scan_unsol(nw_scan_ind);
  else
      qcril_qmi_nas_send_oemhook_incremental_network_scan_unsol(nw_scan_ind);

  QCRIL_LOG_FUNC_RETURN();
}

static void qcril_qmi_nas_get_serv_cell_sib_ind_handler
(
    nas_get_serv_cell_sib_ind_msg_v01 * serv_cell_sib_ind
)
{
  qcril_request_resp_params_type   resp;
  embms_get_sib_plmn_resp_msg_v01  ril_resp_payload;
  RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_reqlist_public_type        request_info;

  uint32_t i;

  memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
  NAS_SIB_CACHE_LOCK();
  ril_resp_payload.dbg_trace_id = sib_info.dbg_trace_id;
  uint8_t sequence = sib_info.sequence;

  // Update nas cache, send RIL RESP if all inds are received
  IxErrnoType all_ind_received = E_IN_PROGRESS;

  do
  {
    // Invalid indication with wrong order after RIL RESP has been sent
    if ( E_SUCCESS != qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN,
                                                     &request_info))
    {
      QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN not found");
      all_ind_received = E_ALREADY_DONE;
      break;
    }
    // Sequence number doesn't match
    if (serv_cell_sib_ind->sequence != sequence)
    {
      all_ind_received = E_FAILURE;
      break;
    }
    else
    {
      uint32_t current_size = sib_info.current_size;
      uint32_t max_size = sib_info.bin_data.len;
      boolean data_valid = sib_info.bin_data.data ? TRUE: FALSE;
      uint32_t sib_pkt_size = serv_cell_sib_ind->sib_pkt_len;

      // bin data is not initilized
      if (!data_valid)
      {
        all_ind_received = E_FAILURE;
        break;
      }

      // Received size exceed allowed maximum
      if (current_size + sib_pkt_size > max_size)
      {
        all_ind_received = E_FAILURE;
        break;
      }

      // No error
      sib_info.sequence++;
      memcpy(&sib_info.bin_data.data[current_size],
             serv_cell_sib_ind->sib_pkt,
             sib_pkt_size);
      sib_info.current_size = current_size + sib_pkt_size;
      if (current_size + sib_pkt_size == max_size)
      {
        all_ind_received = E_SUCCESS;
      }
      break;
    }
  } while(0);

  if (all_ind_received == E_SUCCESS) // All indication received, send RIL RESP SUCCESS
  {
    // Update RIL RESP
    ril_req_res = qcril_qmi_nas_embms_parse_embms_plmn(sib_info.bin_data,
                                         PLMN_LIST_MAX_V01,
                                         &ril_resp_payload.plmn_len,
                                         ril_resp_payload.plmn);

    if (ril_req_res == RIL_E_SUCCESS)
    {
      QCRIL_LOG_INFO("plmn len: %d", ril_resp_payload.plmn_len);
      for (i = 0; i < ril_resp_payload.plmn_len; ++i)
      {
        QCRIL_LOG_INFO("plmn[%d] mcc:%s, mnc:%s", i,
                        ril_resp_payload.plmn[i].mcc,
                        ril_resp_payload.plmn[i].mnc);
      }
    }
    // Send RIL RESP
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       request_info.t,
                                       request_info.request,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &ril_resp_payload;
    resp.resp_len = sizeof( ril_resp_payload );
    qcril_send_request_response( &resp );
    if (sib_info.bin_data.data)
    {
      qcril_free(sib_info.bin_data.data);
      sib_info.bin_data.data = NULL;
    }
  }
  else if (all_ind_received == E_FAILURE)
  {
    // Send RIL RESP
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       request_info.t,
                                       request_info.request,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &ril_resp_payload;
    resp.resp_len = sizeof( ril_resp_payload );
    qcril_send_request_response( &resp );
    if (sib_info.bin_data.data)
    {
      qcril_free(sib_info.bin_data.data);
      sib_info.bin_data.data = NULL;
    }
  }
  else if (all_ind_received == E_ALREADY_DONE)
  {
    if (sib_info.bin_data.data)
    {
      qcril_free(sib_info.bin_data.data);
      sib_info.bin_data.data = NULL;
    }
  }
  else // if (all_ind_received == E_IN_PROGRESS
  {
    // Waiting for more indications to come
    // Nothing need to be done here
    // Intentionally leave blank
  }
  NAS_SIB_CACHE_UNLOCK();
  QCRIL_LOG_FUNC_RETURN();
  return;
}

//===========================================================================
// qcril_qmi_nas_map_atel_eutran_bands
//===========================================================================
RIL_Errno qcril_qmi_nas_map_atel_eutran_bands
(
    const RIL_EutranBands *band_arr,
    uint32_t band_len,
    nas_perform_incremental_network_scan_req_msg_v01 *qmi_req
)
{
    uint32_t i = 0;
    RIL_Errno res = RIL_E_SUCCESS;
    lte_band_pref_mask_type_v01 eutran_band_pref = 0;

    QCRIL_LOG_FUNC_ENTRY();

    for(i = 0; (i < band_len) && (band_len <= MAX_BANDS); i++)
    {
        switch (band_arr[i])
        {
            case EUTRAN_BAND_1:
                 eutran_band_pref |= E_UTRA_OPERATING_BAND_1_V01;
                break;

            case EUTRAN_BAND_2:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_2_V01;
                break;

            case EUTRAN_BAND_3:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_3_V01;
                break;

            case EUTRAN_BAND_4:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_4_V01;
                break;

            case EUTRAN_BAND_5:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_5_V01;
                break;

            case EUTRAN_BAND_6:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_6_V01;
                break;

            case EUTRAN_BAND_7:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_7_V01;
                break;

            case EUTRAN_BAND_8:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_8_V01;
                break;

            case EUTRAN_BAND_9:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_9_V01;
                break;

            case EUTRAN_BAND_10:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_10_V01;
                break;

            case EUTRAN_BAND_11:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_11_V01;
                break;

            case EUTRAN_BAND_12:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_12_V01;
                break;

            case EUTRAN_BAND_13:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_13_V01;
                break;

            case EUTRAN_BAND_14:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_14_V01;
                break;

            case EUTRAN_BAND_17:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_17_V01;
                break;

            case EUTRAN_BAND_18:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_18_V01;
                break;

            case EUTRAN_BAND_19:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_19_V01;
                break;

            case EUTRAN_BAND_20:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_20_V01;
                break;

            case EUTRAN_BAND_21:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_21_V01;
                break;

            case EUTRAN_BAND_23:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_23_V01;
                break;

            case EUTRAN_BAND_24:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_24_V01;
                break;

            case EUTRAN_BAND_25:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_25_V01;
                break;

            case EUTRAN_BAND_26:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_26_V01;
                break;

            case EUTRAN_BAND_28:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_28_V01;
                break;

            case EUTRAN_BAND_30:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_30_V01;
                break;

            case EUTRAN_BAND_33:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_33_V01;
                break;

            case EUTRAN_BAND_34:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_34_V01;
                break;

            case EUTRAN_BAND_35:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_35_V01;
                break;

            case EUTRAN_BAND_36:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_36_V01;
                break;

            case EUTRAN_BAND_37:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_37_V01;
                break;

            case EUTRAN_BAND_38:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_38_V01;
                break;

            case EUTRAN_BAND_39:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_39_V01;
                break;

            case EUTRAN_BAND_40:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_40_V01;
                break;

            case EUTRAN_BAND_41:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_41_V01;
                break;

            case EUTRAN_BAND_42:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_42_V01;
                break;

            case EUTRAN_BAND_43:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_43_V01;
                break;

            case EUTRAN_BAND_46:
                eutran_band_pref |= E_UTRA_OPERATING_BAND_46_V01;
                break;

            case EUTRAN_BAND_22:
            case EUTRAN_BAND_66:
            case EUTRAN_BAND_68:
            case EUTRAN_BAND_70:
            case EUTRAN_BAND_27:
            case EUTRAN_BAND_31:
            case EUTRAN_BAND_44:
            case EUTRAN_BAND_45:
            case EUTRAN_BAND_47:
            case EUTRAN_BAND_48:
            case EUTRAN_BAND_65:
                break;

            default:
                break;
        }
    }

    if (band_len > 0)
    {
        if (eutran_band_pref != NIL)
        {
            qmi_req->lte_band_pref_valid = TRUE;
            qmi_req->lte_band_pref |= eutran_band_pref;
        }
        else
        {
            res = RIL_E_INVALID_ARGUMENTS;
        }
    }

    QCRIL_LOG_INFO("qmi eutran bands to scan - 0x%x res - %d", eutran_band_pref, res);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

//===========================================================================
// qcril_qmi_nas_map_atel_utran_bands
//===========================================================================
RIL_Errno qcril_qmi_nas_map_atel_utran_bands
(
    const RIL_UtranBands *band_arr,
    uint32_t band_len,
    nas_perform_incremental_network_scan_req_msg_v01 *qmi_req
)
{
    uint32_t i = 0;
    RIL_Errno res = RIL_E_SUCCESS;
    nas_band_pref_mask_type_v01 utran_band_pref = 0;

    QCRIL_LOG_FUNC_ENTRY();

    for(i = 0; (i < band_len) && (band_len <= MAX_BANDS); i++)
    {
        switch (band_arr[i])
        {
            case UTRAN_BAND_1:
                utran_band_pref |= QMI_NAS_WCDMA_EU_J_CH_IMT_2100_BAND_V01;
                break;

            case UTRAN_BAND_2:
                utran_band_pref |= QMI_NAS_WCDMA_US_PCS_1900_BAND_V01;
                break;

            case UTRAN_BAND_3:
                utran_band_pref |= QMI_NAS_EU_CH_DCS_1800_BAND_V01;
                break;

            case UTRAN_BAND_4:
                utran_band_pref |= QMI_NAS_WCDMA_US_1700_BAND_V01;
                break;

            case UTRAN_BAND_5:
                utran_band_pref |= QMI_NAS_WCDMA_US_850_BAND_V01;
                break;

            case UTRAN_BAND_7:
                utran_band_pref |= QMI_NAS_WCDMA_EU_2600_BAND_V01;
                break;

            case UTRAN_BAND_8:
                utran_band_pref |= QMI_NAS_WCDMA_EU_J_900_BAND_V01;
                break;

            case UTRAN_BAND_9:
                utran_band_pref |= QMI_NAS_WCDMA_J_1700_BAND_V01;
                break;

            case UTRAN_BAND_19:
                utran_band_pref |= QMI_NAS_WCDMA_JAPAN_800_BAND_V01;
                break;

            case UTRAN_BAND_6:
            case UTRAN_BAND_10:
            case UTRAN_BAND_11:
            case UTRAN_BAND_12:
            case UTRAN_BAND_13:
            case UTRAN_BAND_14:
            case UTRAN_BAND_20:
            case UTRAN_BAND_21:
            case UTRAN_BAND_22:
            case UTRAN_BAND_25:
            case UTRAN_BAND_26:
                break;

            default:
                break;
        }
    }

    if (band_len > 0)
    {
        if (utran_band_pref != NIL)
        {
            qmi_req->band_pref_valid = TRUE;
            qmi_req->band_pref |= utran_band_pref;
        }
        else
        {
            res = RIL_E_INVALID_ARGUMENTS;
        }
    }

    QCRIL_LOG_INFO("qmi utran bands to scan - 0x%x res - %d", utran_band_pref, res);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}


//===========================================================================
// qcril_qmi_nas_map_atel_geran_bands
//===========================================================================
RIL_Errno qcril_qmi_nas_map_atel_geran_bands
(
    const RIL_GeranBands *band_arr,
    uint32_t band_len,
    nas_perform_incremental_network_scan_req_msg_v01 *qmi_req
)
{
    uint32_t i = 0;
    RIL_Errno res = RIL_E_SUCCESS;
    nas_band_pref_mask_type_v01 gsm_band_pref = 0;

    QCRIL_LOG_FUNC_ENTRY();

    for(i = 0; (i < band_len) && (band_len <= MAX_BANDS); i++)
    {
        switch (band_arr[i])
        {
            case GERAN_BAND_450:
                gsm_band_pref |= QMI_NAS_GSM_BAND_450_V01;
                break;

            case GERAN_BAND_480:
                gsm_band_pref |= QMI_NAS_GSM_BAND_480_V01;
                break;

            case GERAN_BAND_750:
                gsm_band_pref |= QMI_NAS_GSM_BAND_750_V01;
                break;

            case GERAN_BAND_850:
                gsm_band_pref |= QMI_NAS_GSM_BAND_850_V01;
                break;

            case GERAN_BAND_P900:
                gsm_band_pref |= QMI_NAS_P_GSM_900_BAND_V01;
                break;

            case GERAN_BAND_E900:
                gsm_band_pref |= QMI_NAS_E_GSM_900_BAND_V01;
                break;

            case GERAN_BAND_R900:
                gsm_band_pref |= QMI_NAS_GSM_BAND_RAILWAYS_900_BAND_V01;
                break;

            case GERAN_BAND_PCS1900:
                gsm_band_pref |= QMI_NAS_GSM_BAND_PCS_1900_BAND_V01;
                break;

            // Looks like there are no commercial deployments for these bands
            case GERAN_BAND_T380:
            case GERAN_BAND_T410:
            case GERAN_BAND_710:
            case GERAN_BAND_T810:
            case GERAN_BAND_DCS1800:
            case GERAN_BAND_ER900:
                break;

            default:
                break;
        }
    }

    if (band_len > 0)
    {
        if (gsm_band_pref != NIL)
        {
            qmi_req->band_pref_valid = TRUE;
            qmi_req->band_pref |= gsm_band_pref;
        }
        else
        {
            res = RIL_E_INVALID_ARGUMENTS;
        }
    }

    QCRIL_LOG_INFO("qmi geran bands to scan - 0x%x res - %d", gsm_band_pref, res);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

//===========================================================================
// RIL_REQUEST_START_NETWORK_SCAN
//===========================================================================
void qcril_qmi_nas_start_advanced_scan
(
    std::shared_ptr<RilRequestStartNetworkScanMessage> msg
)
{
    uint32_t i = 0;
    uint32_t j = 0;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char mnc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    int   pcs_digit_present = FALSE;
    uint32_t wcdma_arfcn_index = 0;
    uint32_t lte_arfcn_index = 0;
    RIL_Errno ril_req_res;
    qmi_client_error_type qmi_client_error;
    nas_network_type_mask_type_v01 nw_type = NIL;
    nas_perform_incremental_network_scan_req_msg_v01  qmi_request;
    nas_perform_incremental_network_scan_resp_msg_v01 qmi_response;
    uint8_t mode_pref_valid = FALSE;
    uint16_t mode_pref;

    ril_req_res = RIL_E_GENERIC_FAILURE;


    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if (qmi_ril_is_multi_sim_feature_supported() && !nas_common_info.is_feature_msim_adv_scan)
        {
            ril_req_res = RIL_E_REQUEST_NOT_SUPPORTED;
            QCRIL_LOG_INFO("Periodic search is not supported for multisim");
            break;
        }

        auto ril_req_data = &(msg->getNetworkScanRequest());
        // If specifier length is not valid, return failure
        if (ril_req_data->specifiers_length <= 0 ||
            ril_req_data->specifiers_length > MAX_RADIO_ACCESS_NETWORKS)
        {
            ril_req_res = RIL_E_INVALID_ARGUMENTS;
            QCRIL_LOG_INFO("invalid specifier length - %d", ril_req_data->specifiers_length);
            break;
        }

        // If interval is less than 5 or greater than 300, return failure
        if ((ril_req_data->interval < SCAN_MIN_INTERVAL) ||
                (ril_req_data->interval > SCAN_MAX_INTERVAL))
        {
            ril_req_res = RIL_E_INVALID_ARGUMENTS;
            QCRIL_LOG_INFO("invalid interval - %d", ril_req_data->interval);
            break;
        }

        memset(&qmi_request, 0, sizeof(qmi_request));
        memset(&qmi_response, 0, sizeof(qmi_response));

        mode_pref_valid = qcril_qmi_nas_get_mode_pref(&mode_pref);
        if( FALSE == mode_pref_valid )
        {
            qcril_qmi_fetch_system_selection_preference();
            mode_pref_valid = qcril_qmi_nas_get_mode_pref(&mode_pref);
        }

        if (FALSE == mode_pref_valid)
        {
            ril_req_res = RIL_E_GENERIC_FAILURE;
            QCRIL_LOG_INFO("Invalid mode pref");
            break;
        }

        for(i = 0; i < ril_req_data->specifiers_length; i++)
        {
            nw_type = NIL;
            switch (ril_req_data->specifiers[i].radio_access_network)
            {
                case GERAN:
                    nw_type = NAS_NETWORK_TYPE_GSM_ONLY_V01;
                    ril_req_res = qcril_qmi_nas_map_atel_geran_bands(
                        ril_req_data->specifiers[i].bands.geran_bands,
                        ril_req_data->specifiers[i].bands_length, &qmi_request);
                    break;

                case UTRAN:
                    if( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS_V01 )
                    {
                        nw_type |= NAS_NETWORK_TYPE_WCDMA_ONLY_V01;
                    }
                    if( mode_pref & QMI_NAS_RAT_MODE_PREF_TDSCDMA_V01 )
                    {
                        nw_type |= NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01;
                    }
                    ril_req_res = qcril_qmi_nas_map_atel_utran_bands(
                        ril_req_data->specifiers[i].bands.utran_bands,
                        ril_req_data->specifiers[i].bands_length, &qmi_request);

                    if (ril_req_data->specifiers[i].channels_length > 0)
                    {
                        for(j=0; (wcdma_arfcn_index < NAS_WCDMA_ARFCN_LIST_MAX_V01) &&
                            (j < ril_req_data->specifiers[i].channels_length); j++)
                        {
                            qmi_request.wcdma_arfcn_valid = TRUE;
                            qmi_request.wcdma_arfcn[wcdma_arfcn_index] =
                                ril_req_data->specifiers[i].channels[j];
                            wcdma_arfcn_index++;
                            qmi_request.wcdma_arfcn_len = wcdma_arfcn_index;
                        }
                    }
                    break;

                case EUTRAN:
                    if( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE_V01 )
                    {
                        nw_type |= NAS_NETWORK_TYPE_LTE_ONLY_V01;
                    }
                    if( mode_pref & QMI_NAS_RAT_MODE_PREF_NR5G_V01 )
                    {
                        nw_type |= NAS_NETWORK_TYPE_NR5G_ONLY_V01;
                    }
                    ril_req_res = qcril_qmi_nas_map_atel_eutran_bands(
                        ril_req_data->specifiers[i].bands.eutran_bands,
                        ril_req_data->specifiers[i].bands_length, &qmi_request);

                    if (ril_req_data->specifiers[i].channels_length > 0)
                    {
                        for(j=0; (lte_arfcn_index < NAS_LTE_ARFCN_LIST_MAX_V01) &&
                            (j < ril_req_data->specifiers[i].channels_length); j++)
                        {
                            qmi_request.lte_arfcn_valid = TRUE;
                            qmi_request.lte_arfcn[lte_arfcn_index] =
                                ril_req_data->specifiers[i].channels[j];
                            lte_arfcn_index++;
                            qmi_request.lte_arfcn_len = lte_arfcn_index;
                        }
                    }
                    break;

                default:
                    break;
            }

            if (nw_type != NIL)
            {
                qmi_request.network_type_valid = TRUE;
                qmi_request.network_type |= nw_type;
            }
        }

        // return failure if atleast one rat is not added to qmi request
        if (!qmi_request.network_type_valid)
        {
            ril_req_res = RIL_E_INVALID_ARGUMENTS;
            QCRIL_LOG_INFO("no valid rat-band combination received");
            break;
        }

        // Need to set scan_type to MODE_PREF when bands/channels valid
        // Otherwise set scan type to PLMN
        if (qmi_request.band_pref_valid || qmi_request.lte_band_pref_valid ||
            qmi_request.wcdma_arfcn_valid || qmi_request.lte_arfcn_valid)
        {
            qmi_request.scan_type_valid = TRUE;
            qmi_request.scan_type = NAS_SCAN_TYPE_MODE_PREF_V01;
        }
        else
        {
            qmi_request.scan_type_valid = TRUE;
            qmi_request.scan_type = NAS_SCAN_TYPE_PLMN_V01;
        }

        QCRIL_LOG_INFO("max search time - %d report incremental results - %d",
            ril_req_data->maxSearchTime, ril_req_data->incrementalResults);

         QCRIL_LOG_INFO("qmi network search periodicity - %d qmi network results periodicity - %d",
             ril_req_data->interval, ril_req_data->incrementalResultsPeriodicity);

        // If interval is less than 60 or greater than 3600, return failure
        if ((ril_req_data->maxSearchTime < SCAN_MIN_SEARCH_TIME) ||
                (ril_req_data->maxSearchTime > SCAN_MAX_SEARCH_TIME))
        {
            ril_req_res = RIL_E_INVALID_ARGUMENTS;
            QCRIL_LOG_INFO("invalid max_search_time - %d", ril_req_data->maxSearchTime);
            break;
        } else
        {
            qmi_request.max_search_time_valid = TRUE;
            qmi_request.max_search_time = ril_req_data->maxSearchTime;
        }

        qmi_request.incremental_results_valid = TRUE;
        if (ril_req_data->incrementalResults == 0)
        {
            qmi_request.incremental_results = 0;
        }
        else
        {
            qmi_request.incremental_results = 1;
            //set periodicity only when incrementalResults are set
            qmi_request.incremental_results_periodicity_valid = FALSE;
            if (ril_req_data->incrementalResultsPeriodicity > 0)
            {
                qmi_request.incremental_results_periodicity_valid = TRUE;
                qmi_request.incremental_results_periodicity =
                    ril_req_data->incrementalResultsPeriodicity;
            }
        }

        if (ril_req_data->type == RIL_PERIODIC)
        {
            qmi_request.search_periodicity_valid = TRUE;
            qmi_request.search_periodicity = ril_req_data->interval;
        }

        QCRIL_LOG_INFO("mcc mnc list len - %d", ril_req_data->mccMncLength);
        for (i = 0, j = 0; i < ril_req_data->mccMncLength; i++)
        {
            /* Added appropriate checks to avoid array out of bound for telephony,
               qmi message structures */
            if ( (j >= NAS_PREFERRED_PLMN_LIST_MAX_V01) || (i >= MAX_MCC_MNC_LIST_SIZE) )
                break;

            if ((ril_req_data->mccMncs[i] != NULL) && (strlen(ril_req_data->mccMncs[i]) > 3))
            {
                QCRIL_LOG_INFO("mcc mnc string - %s", ril_req_data->mccMncs[i]);

                // If MNC is 3 digit, mark pcs digit as present.
                pcs_digit_present = (strlen(ril_req_data->mccMncs[i]) == MCC_MNC_PCS_DIGIT_LEN);

                qcril_qmi_nas_fillup_mcc_mnc_helper((char*)ril_req_data->mccMncs[i], mcc_str);
                qmi_request.preferred_plmn_list[j].mcc = atoi(mcc_str);
                qcril_qmi_nas_fillup_mcc_mnc_helper((char*)ril_req_data->mccMncs[i]+3, mnc_str);
                qmi_request.preferred_plmn_list[j].mnc = atoi(mnc_str);
                qmi_request.preferred_plmn_list[j].mnc_includes_pcs_digit = pcs_digit_present;

                j++;
            }
        }

        /* Make sure to fill only valid mcc mnc information */
        if (j > 0)
        {
            qmi_request.preferred_plmn_list_valid = TRUE;
            qmi_request.preferred_plmn_list_len = j;
        }

        QCRIL_LOG_INFO("qmi network scan params: network type - %d, bands - %d, lte bands - %d",
            qmi_request.network_type, qmi_request.band_pref, qmi_request.lte_band_pref);

        qmi_client_error =  qmi_client_nas_send_sync(
            QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_REQ_MSG_V01,
            &qmi_request,
            sizeof(qmi_request),
            (void*) &qmi_response,
            sizeof( qmi_response ),
            ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_client_error,
            &qmi_response.resp);
        if (ril_req_res == RIL_E_SUCCESS)
        {
            // set this flag for sending ADVANCED NW SCAN UNSOL when
            // incremental network scan indication is received.
            NAS_CACHE_LOCK();
            nas_cached_info.is_adv_nw_scan = TRUE;
            NAS_CACHE_UNLOCK();
        }
    } while(FALSE);

    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    QCRIL_LOG_INFO("completed with %d", ril_req_res );
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// RIL_REQUEST_STOP_NETWORK_SCAN
//===========================================================================
void qcril_qmi_nas_cancel_query_available_networks
(
    std::shared_ptr<RilRequestStopNetworkScanMessage> msg
)
{
    // Always return success to this request
    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    qmi_client_error_type       qmi_client_error;
    nas_abort_scan_resp_msg_v01 qmi_response;

    QCRIL_LOG_FUNC_ENTRY();

    /* Irrespective of there is network going on or not, send request to modem.
       This is to ensure that we handle both normal, incremental network scan.
       QMI_NAS_ABORT_SCAN_REQ_V01 should cancel both normal, incremental scan.*/
    memset(&qmi_response, 0, sizeof(qmi_response));
    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_ABORT_SCAN_REQ_V01,
                                                NULL,
                                                NAS_ZERO,
                                                (void*) &qmi_response,
                                                sizeof( qmi_response ));
    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_client_error,
            &qmi_response.resp);

    if ( ril_req_res == RIL_E_SUCCESS )
    {
        /* Acquire lock to make sure that there are no race conditions.
           Check if QUERY AVAILABLE NETWORKS is in progress, if it is send
           generic failure to telephony so that it can cleanup request */
        NAS_CACHE_LOCK();
        auto& msgList = getNasModule().getPendingMessageList();
        auto pendingMsg = msgList.find(RilRequestQueryAvailNetworkMessage::get_class_message_id());
        if (pendingMsg)
        {
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    RIL_E_CANCELLED, nullptr);
            auto queryMsg = std::static_pointer_cast<RilRequestQueryAvailNetworkMessage>(pendingMsg);
            queryMsg->sendResponse(queryMsg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(pendingMsg);
        }
        NAS_CACHE_UNLOCK();
    }

    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    QCRIL_LOG_INFO("completed with %d", ril_req_res );
}

//===========================================================================
// QCRIL_EVT_HOOK_PERFORM_INCREMENTAL_NW_SCAN
//===========================================================================
void qcril_qmi_nas_perform_incremental_network_scan
(
    std::shared_ptr<RilRequestStartNetworkScanMessage> msg
)
{
  qcril_instance_id_e_type instance_id;


  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_perform_incremental_network_scan_req_msg_v01 qmi_request;
  nas_perform_incremental_network_scan_resp_msg_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  if (msg != nullptr) {
    do {
      memset(&qmi_request, 0, sizeof(qmi_request));
      memset(&qmi_response, 0, sizeof(qmi_response));
      qmi_request.network_type_valid =
        qcril_qmi_nas_retrieve_scan_network_type(&qmi_request.network_type, TRUE);
      qmi_client_error =
        qmi_client_nas_send_sync(QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_REQ_MSG_V01,
                                                 &qmi_request,
                                                 sizeof(qmi_request),
                                                 (void*) &qmi_response,
                                                 sizeof( qmi_response ),
                                                 ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

      ril_req_res = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
      if ( ril_req_res == RIL_E_SUCCESS )
      {
        if (qmi_response.resp.result != QMI_RESULT_SUCCESS_V01)
        {
          QCRIL_LOG_ERROR("QMI Result = %d,error=%d\n",
                    qmi_response.resp.result,qmi_response.resp.error);
          ril_req_res =  RIL_E_GENERIC_FAILURE;
        }
        else
        {
          // reset advanced network scan flag when oem hook network scan is success
          NAS_CACHE_LOCK();
          nas_cached_info.is_adv_nw_scan = FALSE;
          NAS_CACHE_UNLOCK();
        }
      }
    } while(FALSE);
    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    QCRIL_LOG_INFO("completed with %d", ril_req_res );
  }

  QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// RIL_REQUEST_QUERY_AVAILABLE_NETWORKS
//===========================================================================
void qcril_qmi_nas_query_available_networks
(
  std::shared_ptr<RilRequestQueryAvailNetworkMessage> msg
)
{
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_perform_network_scan_req_msg_v01 qmi_request;
  nas_perform_network_scan_resp_msg_v01 * qmi_response = NULL;

  qmi_client_error_type qmi_client_error;

  auto ret = getNasModule().getPendingMessageList().insert(msg);
  if (!ret.second)
  {
    ril_req_res = RIL_E_INTERNAL_ERR;
  }
  else
  {
    uint16_t token = ret.first;
    uint32_t user_data = QCRIL_COMPOSE_USER_DATA(QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID, token);

    memset(&qmi_request, 0, sizeof(qmi_request));
    qmi_request.network_type_valid = qcril_qmi_nas_retrieve_scan_network_type(&qmi_request.network_type, FALSE);

    if(TRUE == qmi_request.network_type_valid)
    {
        qmi_client_error =  qmi_client_nas_send_async(QMI_NAS_PERFORM_NETWORK_SCAN_REQ_MSG_V01,
                                                  &qmi_request,
                                                  sizeof(qmi_request),
                                                  sizeof( *qmi_response ),
                                                  qcril_qmi_nas_perform_network_scan_command_cb,
                                                  (void *)(uintptr_t) user_data);
        if (qmi_client_error == QMI_NO_ERR)
        {
            QCRIL_LOG_INFO("QMI_NAS_PERFORM_NETWORK_SCAN_REQ_MSG sent to modem successfully");
            QCRIL_LOG_INFO("RIL_REQUEST_QUERY_AVAILABLE_NETWORKS - sending ack back to release wakelock");
            auto ackMsg = std::make_shared<RilAcknowledgeRequestMessage>(msg->getContext());
            Dispatcher::getInstance().dispatch(ackMsg);
            ril_req_res = RIL_E_SUCCESS;
        }
        else
        {
            QCRIL_LOG_ERROR("Error while sending qmi msg: %d", qmi_client_error);
            ril_req_res = RIL_E_SYSTEM_ERR;
        }
    }
    else
    {
        QCRIL_LOG_ERROR("Not proper mode pref");
        ril_req_res = RIL_E_SYSTEM_ERR;
    }
  }

  if (RIL_E_SUCCESS != ril_req_res)
  {
    if (ret.second)
    {
      getNasModule().getPendingMessageList().erase(ret.first);
    }
    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  }
  QCRIL_LOG_INFO("completed with %d", ril_req_res );
} // qcril_qmi_nas_query_available_networks


/*
 * this function will allocate a buffer, pointed by
 * nw_scan_helper
 */
RIL_Errno qcril_qmi_nas_copy_from_scan_msg
(
nas_perform_network_scan_resp_msg_v01 *scan_resp, /* from */
qcril_qmi_nas_nw_scan_info_helper_type **p_nw_scan_helper, /* to */
int *nw_scan_len
)
{
    RIL_Errno ret = RIL_E_GENERIC_FAILURE;
    qcril_qmi_nas_nw_scan_info_helper_type *nw_scan_helper;
    unsigned int i;

    *nw_scan_len = 0;
    *p_nw_scan_helper = NULL;

    if( scan_resp == NULL )
    {
      QCRIL_LOG_ERROR("Modem error.. response data is null");
      ret = RIL_E_MODEM_ERR;
    }
    else if( scan_resp->resp.result != QMI_RESULT_SUCCESS_V01 )
    {
      ret = qcril_qmi_client_map_qmi_err_to_ril_err(scan_resp->resp.error);
    }
    /* NOTE: if scan_result is not valid, we will go on */
    else if ( ( ( scan_resp->scan_result_valid ) && ( scan_resp->scan_result != NAS_SCAN_SUCCESS_V01 ) ) )
    {
        switch(scan_resp->scan_result)
        {
          case NAS_SCAN_AS_ABORT_V01:
             QCRIL_LOG_ERROR("Network Scan error: NAS_SCAN_AS_ABORT");
             break;

          case NAS_SCAN_REJ_IN_RLF_V01:
             QCRIL_LOG_ERROR("Network Scan error: NAS_SCAN_REJ_IN_RLF");
             break;

          default:
             QCRIL_LOG_ERROR("Network Scan result: %d",scan_resp->scan_result);
             break;
        }
        ret = RIL_E_MODEM_ERR;
    }
    else if( !( ( scan_resp->nas_3gpp_network_info_valid ) && ( scan_resp->nas_3gpp_network_info_len > 0 ) ) )
    {
        QCRIL_LOG_ERROR("Modem error..required data not present in response");
        ret = RIL_E_MODEM_ERR;
    }
    else
    {
      /* allocate the memory and reset all as 0 */
      if ( scan_resp->nas_3gpp_network_info_len <= NAS_3GPP_NETWORK_INFO_LIST_MAX_V01 )
      {
        nw_scan_helper = (qcril_qmi_nas_nw_scan_info_helper_type *)
                qcril_malloc(sizeof(qcril_qmi_nas_nw_scan_info_helper_type)
                * scan_resp->nas_3gpp_network_info_len );
        if ( nw_scan_helper )
        {
          memset( nw_scan_helper, 0, sizeof(qcril_qmi_nas_nw_scan_info_helper_type) *
                                    scan_resp->nas_3gpp_network_info_len );
          *nw_scan_len = scan_resp->nas_3gpp_network_info_len;
          *p_nw_scan_helper = nw_scan_helper;
          ret = RIL_E_SUCCESS;

          for (i = 0; i < scan_resp->nas_3gpp_network_info_len; i++)
          {
            nw_scan_helper[i].mcc = scan_resp->nas_3gpp_network_info[i].mobile_country_code;
            nw_scan_helper[i].mnc = scan_resp->nas_3gpp_network_info[i].mobile_network_code;
            nw_scan_helper[i].network_status = scan_resp->nas_3gpp_network_info[i].network_status;
            if ( scan_resp->nas_network_radio_access_technology_valid )
            {
              nw_scan_helper[i].plmn_rat_valid = 1;
              nw_scan_helper[i].plmn_rat = scan_resp->nas_network_radio_access_technology[i].rat;
            }
            if ( scan_resp->mnc_includes_pcs_digit_valid )
            {
              nw_scan_helper[i].mnc_includes_pcs_digit = scan_resp->mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
            }
          } /* for loop i */
        } /* nw_scan_helper not NULL */
        else
        {
          QCRIL_LOG_ERROR("Memory allocation failed..");
          ret = RIL_E_NO_MEMORY;
        }
      } /* scan_resp->nas_3gpp_network_info_len <= NAS_3GPP_NETWORK_INFO_LIST_MAX_V01 */
      else
      {
        QCRIL_LOG_ERROR("Modem error..got invalid data in response");
        ret = RIL_E_MODEM_ERR;
      }
    }

    return ret;
}
//===========================================================================
// qcril_qmi_nas_perform_network_scan_command_cb
//===========================================================================
void qcril_qmi_nas_perform_network_scan_command_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_struct,
    unsigned int                   resp_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    RIL_Errno   ril_req_res                                = RIL_E_GENERIC_FAILURE;
    int  nw_cnt = 0, nw_scan_len = 0;
    nas_perform_network_scan_resp_msg_v01 * qmi_response = NULL;
    qcril_qmi_nas_nw_scan_info_helper_type *nw_scan_helper = NULL;

    QCRIL_NOTUSED(msg_id);
    QCRIL_NOTUSED(resp_struct_len);

    if ( resp_struct )
    {
        qmi_response = (nas_perform_network_scan_resp_msg_v01 *) resp_struct.get();
        uint16_t token = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA((uint32_t)(uintptr_t)resp_cb_data);
        auto msg = getNasModule().getPendingMessageList().extract(token);

        // XXX: necessary for big LOCK????
        NAS_CACHE_LOCK();

        if (qmi_response && (msg != nullptr))
        {
            std::vector<qcril::interfaces::NetworkInfo> list;
            if ( QMI_NO_ERR == transp_err && qmi_response->nas_3gpp_network_info_valid )
            {
                ril_req_res = qcril_qmi_nas_copy_from_scan_msg( qmi_response, &nw_scan_helper, &nw_scan_len);
                if ( ril_req_res == RIL_E_SUCCESS && nw_scan_helper )
                {
                    nw_cnt = qcril_qmi_nas_fill_network_scan_response(nw_scan_len,
                            nw_scan_helper, list);
                    if(nw_cnt > 0)
                    {
                      ril_req_res = RIL_E_SUCCESS;
                    }
                    else
                    {
                      QCRIL_LOG_ERROR("Modem err..nw cnt < 0, invalid response from modem");
                      ril_req_res = RIL_E_MODEM_ERR;
                    }
                    if ( nw_scan_helper )
                    {
                      qcril_free( nw_scan_helper );
                    }
                }
            }
            else
            {
               QCRIL_LOG_ERROR("Modem err.. information needed not present in the response");
               ril_req_res = RIL_E_MODEM_ERR;
            }

            // ** respond
            auto queryMsg = std::static_pointer_cast<RilRequestQueryAvailNetworkMessage>(msg);
            auto payload = std::make_shared<qcril::interfaces::RilGetAvailNetworkResult_t>(std::move(list));
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    ril_req_res, payload);
            queryMsg->sendResponse(queryMsg, Message::Callback::Status::SUCCESS, respData);
        }

        NAS_CACHE_UNLOCK();
    }
    QCRIL_LOG_INFO("completed with %d", ril_req_res );

} // qcril_qmi_nas_perform_network_scan_command_cb

/*=========================================================================

  FUNCTION:  qcril_qmi_nas_parse_csg_scan_oem_req

===========================================================================*/
/*!
    @brief
    Parse OEM Hook Header related to Network scan.

    @return
    If success then the Filled structure will be returned
*/
/*=========================================================================*/

RIL_Errno qcril_qmi_nas_parse_csg_scan_oem_req(uint8 *oem_hook_data,nas_perform_network_scan_req_msg_v01 *filled_data,uint8 oem_data_len )
{
  uint16 i=0,len=0;
  RIL_Errno result = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  memset(filled_data,0,sizeof(nas_perform_network_scan_req_msg_v01));
  QCRIL_LOG_DEBUG("Length : %d, found while parsing request",oem_data_len);

  for(i=0;i<oem_data_len;)
  {
    switch(oem_hook_data[i])
    {
      case  0x10:
        if ( i + 1 < oem_data_len )
        {
          memcpy(&len,(void *)&oem_hook_data[i+1],sizeof(uint16));
          if(len == 1)
          {
            if ( i + 3 < oem_data_len )
            {
              filled_data->network_type_valid = TRUE;
              filled_data->network_type = oem_hook_data[i+3];
              i=i+4;
            }
            else
            {
              QCRIL_LOG_ERROR("out of boundary when parsing");
              result = RIL_E_GENERIC_FAILURE;
            }
          }
          else if(len == 0)
          {
            i=i+3;
          }
          else
          {
            QCRIL_LOG_ERROR("Invalid Tag length : %d, found while parsing",len);
            result = RIL_E_GENERIC_FAILURE;
          }
          len=0;
        }
        else
        {
            QCRIL_LOG_ERROR("out of boundary when parsing");
            result = RIL_E_GENERIC_FAILURE;
        }
        break;
      case  0x11:
        if ( i + 1 < oem_data_len )
        {
          memcpy(&len,(void *)&oem_hook_data[i+1],sizeof(uint16));
          if(len == 1)
          {
            if ( i + 3 < oem_data_len )
            {
              filled_data->scan_type_valid = TRUE;
              filled_data->scan_type = (nas_nw_scan_type_enum_v01)oem_hook_data[i+3];
              i=i+4;
            }
            else
            {
              QCRIL_LOG_ERROR("out of boundary when parsing");
              result = RIL_E_GENERIC_FAILURE;
            }
          }
          else if(len == 0)
          {
            filled_data->scan_type_valid = TRUE;
            filled_data->scan_type = NAS_SCAN_TYPE_CSG_V01;
            i=i+3;
          }
          else
          {
            QCRIL_LOG_ERROR("Invalid Tag length : %d, found while parsing",len);
            result = RIL_E_GENERIC_FAILURE;
          }
          len=0;
        }
        else
        {
            QCRIL_LOG_ERROR("out of boundary when parsing");
            result = RIL_E_GENERIC_FAILURE;
        }
        break;
      default:
        QCRIL_LOG_ERROR("Invalid Tag:%d, length :%d, found while parsing",oem_hook_data[i],len);
        result = RIL_E_GENERIC_FAILURE;
    }

    if( RIL_E_GENERIC_FAILURE == result )
       break;
  }
  QCRIL_LOG_FUNC_RETURN();
  return result;
}


/*=========================================================================

  FUNCTION:  qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan

===========================================================================*/
/*!
    @brief
    Perform CSG related Network scan.

    @return
    If success then the neighboring cells information is returned
*/
/*=========================================================================*/
void qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan
(
 const qcril_request_params_type *const params_ptr,
 qcril_request_return_type *const ret_ptr /*!< Output parameter */
 )
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;


  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_perform_network_scan_req_msg_v01 qmi_request;
  nas_perform_network_scan_resp_msg_v01 * qmi_response = NULL;

  qcril_qmi_nas_perform_network_scan_csg_resp_msg * ril_rep_helper = NULL;

  qcril_reqlist_public_type qcril_req_info_ptr;

  qmi_client_error_type qmi_client_error;

  uint8 csg_perform_nw_scan_req[QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD];
  uint8 *csg_perform_nw_scan_req_ptr;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_request,0,sizeof(qmi_request));
  memset(csg_perform_nw_scan_req,0,QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD);


  do
  {
    if ( params_ptr->datalen > QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD )
    {
        ril_req_res = RIL_E_GENERIC_FAILURE;
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
        qcril_send_request_response( &resp );
        break;
    }

    memcpy(csg_perform_nw_scan_req, params_ptr->data, params_ptr->datalen);
    csg_perform_nw_scan_req_ptr = csg_perform_nw_scan_req;
    QCRIL_LOG_DEBUG("Recieved Data length from oem hook: %d ",params_ptr->datalen);
    ril_req_res = qcril_qmi_nas_parse_csg_scan_oem_req(csg_perform_nw_scan_req_ptr,&qmi_request,(uint8)params_ptr->datalen);

    if( ril_req_res == RIL_E_GENERIC_FAILURE )
    {
        qcril_default_request_resp_params( instance_id,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        qcril_send_request_response( &resp );
        break;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                 QCRIL_EVT_HOOK_CSG_PERFORM_NW_SCAN,
                                 NULL,
                                 &qcril_req_info_ptr );
    if ( qcril_reqlist_new( instance_id, &qcril_req_info_ptr ) == E_SUCCESS )
    {
        ril_rep_helper = (qcril_qmi_nas_perform_network_scan_csg_resp_msg  *)
            qcril_malloc( sizeof( *ril_rep_helper ) );

        if ( ril_rep_helper )
        {
            qmi_client_error =  qmi_client_nas_send_async(QMI_NAS_PERFORM_NETWORK_SCAN_REQ_MSG_V01,
                                                            &qmi_request,
                                                            sizeof(qmi_request),
                                                            sizeof( *qmi_response ),
                                                            qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb,
                                                            (void *)ril_rep_helper);
            ril_req_res = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
        }

        if ( RIL_E_SUCCESS != ril_req_res )
        {
            qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
            qcril_send_request_response( &resp );

            if ( ril_rep_helper )
            {
                qcril_free( ril_rep_helper );
            }
        }
    }
  } while (0);

  QCRIL_LOG_INFO("completed with %d", ril_req_res );
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan */

//===========================================================================
// qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb
//===========================================================================
void qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
  nas_perform_network_scan_resp_msg_v01 * qmi_response   = (nas_perform_network_scan_resp_msg_v01 *) resp_c_struct.get();
  qcril_qmi_nas_perform_network_scan_csg_resp_msg *ril_resp_helper =  (qcril_qmi_nas_perform_network_scan_csg_resp_msg *) resp_cb_data;
  RIL_Errno   ril_req_res                                = RIL_E_SUCCESS;
  qcril_reqlist_public_type qcril_req_info;
  errno_enum_type           found_qcril_request;
  qcril_request_resp_params_type resp;
  unsigned int i=0;
  uint16 total_len=0,csg_len=0,csg_info_len_position=0,csg_sig_len=0,csg_sig_info_len_position=0;
  uint8 *resp_byte_stream_ptr = NULL;
  uint8 *resp_byte_stream = NULL;
  uint8 *resp_print = NULL;

  QCRIL_NOTUSED(msg_id);
  QCRIL_NOTUSED(resp_c_struct_len);

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_LOG_DEBUG("resp_c_struct_len = %d", resp_c_struct_len );

  memset( &qcril_req_info, 0, sizeof(qcril_req_info) );

  found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                      QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_HOOK_CSG_PERFORM_NW_SCAN,
                                                      &qcril_req_info );
  do
  {
    if ( qmi_response && (E_SUCCESS == found_qcril_request) )
    {
      resp_byte_stream = (uint8 *)qcril_malloc(sizeof(*ril_resp_helper)); //Max length allocated may not be the final length sent in response.
      resp_byte_stream_ptr = resp_byte_stream;

      if(NULL == resp_byte_stream)
      {
        QCRIL_LOG_ERROR("resp_byte_stream malloc failed");
        ril_req_res = RIL_E_GENERIC_FAILURE;
        break;
      }

      if ( QMI_NO_ERR == transp_err )
      {
        memset( ril_resp_helper, 0, sizeof(*ril_resp_helper) );
        memset(resp_byte_stream, 0, sizeof(*ril_resp_helper));
        if( qmi_response->resp.result == QMI_RESULT_SUCCESS_V01 )
        {
          ril_resp_helper->resp.error = QMI_ERR_NONE_V01;
          ril_resp_helper->resp.result = QMI_RESULT_SUCCESS_V01; //No  need to calcualte len for this as we dont send in response.
          QCRIL_LOG_DEBUG("Result from QMI-NAS = %d,%d", qmi_response->resp.error,qmi_response->resp.result);

          /*Scan result TLV parsing*/
          if(qmi_response->scan_result_valid == TRUE)
          {
            QCRIL_LOG_DEBUG("Scan result TLV filled from QMI-NAS = %d", qmi_response->scan_result);
            ril_resp_helper->scan_result_tag = 0x13;
            *resp_byte_stream_ptr = ril_resp_helper->scan_result_tag;
            total_len= total_len+1;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;

            ril_resp_helper->scan_result_len = 4;
            memcpy(resp_byte_stream_ptr, &ril_resp_helper->scan_result_len,sizeof(uint16));
            total_len= total_len+2;
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;

            ril_resp_helper->scan_result = (uint32_t)qmi_response->scan_result;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->scan_result,sizeof(uint32));
            total_len = total_len+4;
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
          }
          else
          {
            ril_resp_helper->scan_result_tag = 0x13;
            *resp_byte_stream_ptr = ril_resp_helper->scan_result_tag;
            total_len = total_len+1;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;

            ril_resp_helper->scan_result_len = 0;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->scan_result_len,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
          }

        QCRIL_LOG_DEBUG("Total length filled after processing scan result = %d", total_len);
        resp_print = resp_byte_stream;

        /*CSG Info TLV parsing*/
        if(qmi_response->csg_info_valid == TRUE && qmi_response->csg_info_len > 0)
        {
          QCRIL_LOG_DEBUG("CSG result TLV got from QMI-NAS no of entries = %d", qmi_response->csg_info_len);
          ril_resp_helper->csg_info_tag = 0x14;
          *resp_byte_stream_ptr=ril_resp_helper->csg_info_tag;

          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          resp_print = resp_byte_stream;

          csg_info_len_position = total_len; //Noted the position of csg_info_len
          //2-bytes Space holder for CSG total length calculated later.
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;

          ril_resp_helper->csg_info_no_of_entries = (uint8)qmi_response->csg_info_len;
          *resp_byte_stream_ptr = ril_resp_helper->csg_info_no_of_entries;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;

          resp_print = resp_byte_stream;

          if(qmi_response->csg_info_len > 0 )
          {
            csg_len=1; // Default one byte for no of entries
          }
          else
          {
            csg_len = 0;
          }

          for(i=0;i<qmi_response->csg_info_len;i++)
          {
            ril_resp_helper->csg_info[i].mcc = qmi_response->csg_info[i].mcc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_info[i].mcc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_len = csg_len+2;

            ril_resp_helper->csg_info[i].mnc = qmi_response->csg_info[i].mnc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_info[i].mnc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_len = csg_len+2;

            if(qmi_response->mnc_includes_pcs_digit_valid)
            {
              ril_resp_helper->csg_info[i].mnc_includes_pcs_digit = qmi_response->mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
            }
            else
            {
              ril_resp_helper->csg_info[i].mnc_includes_pcs_digit = FALSE;
            }

            /*CSG pcs 1-bytes*/
            *resp_byte_stream_ptr = ril_resp_helper->csg_info[i].mnc_includes_pcs_digit;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;
            total_len = total_len+1;
            csg_len = csg_len+1;

            /*CSG Category 4-bytes*/
            ril_resp_helper->csg_info[i].csg_list_cat = qmi_response->csg_info[i].csg_list_cat ;
            memcpy(resp_byte_stream_ptr,&ril_resp_helper->csg_info[i].csg_list_cat,sizeof(uint32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_len = csg_len+4;

            /*CSG ID 4-bytes*/
            ril_resp_helper->csg_info[i].csg_info.id = qmi_response->csg_info[i].csg_info.id ;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_info[i].csg_info.id,sizeof(uint32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_len = csg_len+4;

            /*CSG name_len 1-bytes*/
            ril_resp_helper->csg_info[i].csg_info.name_len = qmi_response->csg_info[i].csg_info.name_len;
            *resp_byte_stream_ptr = ril_resp_helper->csg_info[i].csg_info.name_len;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;
            total_len = total_len+1;
            csg_len = csg_len+1;

            /*CSG name  len*2-UCS2 bytes*/
            memcpy(ril_resp_helper->csg_info[i].csg_info.name,qmi_response->csg_info[i].csg_info.name,ril_resp_helper->csg_info[i].csg_info.name_len*2) ;
            memcpy(resp_byte_stream_ptr,(void *)ril_resp_helper->csg_info[i].csg_info.name,ril_resp_helper->csg_info[i].csg_info.name_len*2);
            resp_byte_stream_ptr = resp_byte_stream_ptr+(ril_resp_helper->csg_info[i].csg_info.name_len*2);
            total_len = total_len+(ril_resp_helper->csg_info[i].csg_info.name_len*2);
            csg_len = csg_len+(ril_resp_helper->csg_info[i].csg_info.name_len*2);

          } //For loop
          /*Filing the finally calculated csg_length Here*/

          ril_resp_helper->csg_info_total_len = csg_len;
          memcpy(&resp_byte_stream[csg_info_len_position],(void *)&csg_len,sizeof(uint16));
          QCRIL_LOG_DEBUG("CSG total TLV length  = %d\n", resp_byte_stream[csg_info_len_position]);
          resp_print = resp_byte_stream;
        }
        else
        {
          QCRIL_LOG_DEBUG("CSG result TLV not present=%d or len is = %d", qmi_response->csg_info_valid,qmi_response->csg_info_len);
          ril_resp_helper->csg_info_tag = 0x14;
          *resp_byte_stream_ptr = ril_resp_helper->csg_info_tag;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          ril_resp_helper->csg_info_total_len = csg_len; //In this case csg len = 0
          memcpy(resp_byte_stream_ptr,(void *)&csg_len,sizeof(uint16));
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;
        }

        /*CSG Signal Strength Info TLV parsing*/
        if(qmi_response->csg_sig_info_valid == TRUE && qmi_response->csg_sig_info_len > 0)
        {
          QCRIL_LOG_DEBUG("CSG Signal Strength result TLV got from QMI-NAS no of entries = %d", qmi_response->csg_sig_info_len);
          ril_resp_helper->csg_sig_info_tag = 0x15;
          *resp_byte_stream_ptr=ril_resp_helper->csg_sig_info_tag;

          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          resp_print = resp_byte_stream;

          csg_sig_info_len_position = total_len; //Noted the position of csg_sig_info_len
          //2-bytes Space holder for CSG Signal Strength total length calculated later.
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;

          ril_resp_helper->csg_sig_info_no_of_entries = (uint8)qmi_response->csg_sig_info_len;
          *resp_byte_stream_ptr = ril_resp_helper->csg_sig_info_no_of_entries;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;

          resp_print = resp_byte_stream;

          if(qmi_response->csg_sig_info_len > 0 )
          {
            csg_sig_len=1; // Default one byte for no of entries
          }
          else
          {
            csg_sig_len = 0;
          }

          for(i=0;i<qmi_response->csg_sig_info_len;i++)
          {
            ril_resp_helper->csg_sig_info[i].mcc = qmi_response->csg_sig_info[i].mcc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].mcc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_sig_len = csg_sig_len+2;

            ril_resp_helper->csg_sig_info[i].mnc = qmi_response->csg_sig_info[i].mnc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].mnc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_sig_len = csg_sig_len+2;

            if(qmi_response->mnc_includes_pcs_digit_valid)
            {
              ril_resp_helper->csg_sig_info[i].mnc_includes_pcs_digit = qmi_response->mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
            }
            else
            {
              ril_resp_helper->csg_sig_info[i].mnc_includes_pcs_digit = FALSE;
            }

            *resp_byte_stream_ptr = ril_resp_helper->csg_sig_info[i].mnc_includes_pcs_digit;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;
            total_len = total_len+1;
            csg_sig_len = csg_sig_len+1;

            ril_resp_helper->csg_sig_info[i].csg_id = qmi_response->csg_sig_info[i].csg_id;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].csg_id,sizeof(uint32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_sig_len = csg_sig_len+4;

            ril_resp_helper->csg_sig_info[i].signal_strength = qmi_response->csg_sig_info[i].signal_strength;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].signal_strength,sizeof(int32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_sig_len = csg_sig_len+4;
          }

          /*Filing the finally calculated csg_sig_length Here*/

          ril_resp_helper->csg_sig_info_total_len = csg_sig_len;
          memcpy(&resp_byte_stream[csg_sig_info_len_position],(void *)&csg_sig_len,sizeof(uint16));
          QCRIL_LOG_DEBUG("CSG Signal Strength total TLV length  = %d\n", resp_byte_stream[csg_sig_info_len_position]);
          resp_print = resp_byte_stream;
        }
        else
        {
          QCRIL_LOG_DEBUG("CSG Signal Strength result TLV not present=%d or len is = %d", qmi_response->csg_sig_info_valid,qmi_response->csg_sig_info_len);
          ril_resp_helper->csg_sig_info_tag = 0x15;
          *resp_byte_stream_ptr = ril_resp_helper->csg_sig_info_tag;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          ril_resp_helper->csg_sig_info_total_len = csg_sig_len; //In this case csg_sig_len = 0
          memcpy(resp_byte_stream_ptr,(void *)&csg_sig_len,sizeof(uint16));
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;
        }
       } //if check response
       else
       {
         QCRIL_LOG_ERROR("QMI-NAS CSG Scan Response Not success  = %d\n", qmi_response->resp.result);
         ril_req_res = RIL_E_GENERIC_FAILURE;
       }
     }//if Transport no error
     else
     {
       QCRIL_LOG_DEBUG("Transport error = %d\n", transp_err);
       ril_req_res = RIL_E_GENERIC_FAILURE;
     }
    }//if Found
    else
    {
      QCRIL_LOG_DEBUG("Request list not found = %d\n", found_qcril_request);
      ril_req_res = RIL_E_GENERIC_FAILURE;
    }
  }while(0);

  if (found_qcril_request == E_SUCCESS)
  {
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t, qcril_req_info.request, ril_req_res , &resp );
    if ( RIL_E_SUCCESS == ril_req_res )
    {
      QCRIL_LOG_DEBUG("Final response length = %d,Data in Hex=\n", total_len);
      resp_byte_stream_ptr = resp_byte_stream;
      resp.resp_pkt = (void *) resp_byte_stream;
      resp.resp_len = total_len;
    }
    qcril_send_request_response( &resp );
  }

  if ( ril_resp_helper )
  {
    qcril_free( ril_resp_helper );
  }
  if ( resp_byte_stream )
  {
    qcril_free( resp_byte_stream );
  }
}/* qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb */

/*=========================================================================

  FUNCTION:  qcril_qmi_nas_parse_csg_sys_selection_req

===========================================================================*/
/*!
    @brief
    Parse OEM Hook Header related to Manual System selection.

    @return
    If success then the Filled structure will be returned
*/
/*=========================================================================*/

RIL_Errno qcril_qmi_nas_parse_csg_sys_selection_req(uint8 *oem_hook_data,nas_set_system_selection_preference_req_msg_v01 *filled_data,uint8 oem_data_len )
{
  uint16 i=0,len=0;
  RIL_Errno result = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  if( NULL == oem_hook_data || NULL == filled_data)
    return RIL_E_GENERIC_FAILURE;

  memset(filled_data,0,sizeof(nas_set_system_selection_preference_req_msg_v01));
  QCRIL_LOG_DEBUG("Length : %d, found while parsing request",oem_data_len);

  for(i=0;i<oem_data_len;)
  {
    switch(oem_hook_data[i])
    {
      case  0x20:
        memcpy(&len,(void *)&oem_hook_data[i+1],sizeof(uint16));
        if(len == 10)
        {
          filled_data->csg_info_valid = TRUE;
          memcpy(&filled_data->csg_info.mcc,&oem_hook_data[i+3],sizeof(uint16));
          memcpy(&filled_data->csg_info.mnc,&oem_hook_data[i+5],sizeof(uint16));
          memcpy(&filled_data->csg_info.mnc_includes_pcs_digit,&oem_hook_data[i+7],sizeof(uint8));
          memcpy(&filled_data->csg_info.id,&oem_hook_data[i+8],sizeof(uint32));
          memcpy(&filled_data->csg_info.rat,&oem_hook_data[i+12],sizeof(uint8));

          i=i+13;
        }
        else if(len == 0)
        {
          filled_data->net_sel_pref.net_sel_pref = NAS_NET_SEL_PREF_AUTOMATIC_V01;
          filled_data->net_sel_pref_valid = TRUE;
          i=i+3;
          result = RIL_E_SUCCESS;
        }
        else
        {
          QCRIL_LOG_ERROR("Invalid Tag length : %d, found while parsing",len);
          result = RIL_E_GENERIC_FAILURE;
        }
        len=0;
        break;

      default:
        QCRIL_LOG_ERROR("Invalid Tag:%d, length :%d, found while parsing",oem_hook_data[i],len);
        result = RIL_E_GENERIC_FAILURE;
    }

    if( RIL_E_GENERIC_FAILURE == result || TRUE == filled_data->net_sel_pref_valid )
        break;
  }
  QCRIL_LOG_FUNC_RETURN();
  return result;
}/*qcril_qmi_nas_parse_csg_sys_selection_req*/


/*=========================================================================

  FUNCTION:  qcril_qmi_nas_csg_handle_oem_hook_set_sys_selection

===========================================================================*/
/*!
    @brief
    Manually select a CSG Network.

    @return
    If success then it indicates sys selection is set
*/
/*=========================================================================*/
void qcril_qmi_nas_csg_handle_oem_hook_set_sys_selection
(
 const qcril_request_params_type *const params_ptr,
 qcril_request_return_type *const ret_ptr /*!< Output parameter */
 )
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;


  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_set_system_selection_preference_resp_msg_v01 qmi_response;
  nas_get_system_selection_preference_resp_msg_v01 qmi_response_get;

  qcril_reqlist_public_type qcril_req_info_ptr;

  qmi_client_error_type qmi_client_error;

  uint8 csg_set_sys_sel_req[QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD];
  uint8 *csg_set_sys_sel_req_ptr;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_request, 0, sizeof(qmi_request));
  memset(&qmi_response, 0, sizeof(qmi_response));
  memset(&qmi_response_get, 0, sizeof(qmi_response_get));
  memset(csg_set_sys_sel_req, 0, QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD);

  if( params_ptr->datalen > QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD)
  {
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       RIL_E_GENERIC_FAILURE,
                                       &resp );
    qcril_send_request_response( &resp );
    QCRIL_LOG_ERROR("Recieved Data length from oem hook is exceeded the maximum limit");
    return;
  }

  memcpy(csg_set_sys_sel_req, params_ptr->data, params_ptr->datalen);

  csg_set_sys_sel_req_ptr = csg_set_sys_sel_req;

  QCRIL_LOG_DEBUG("Recieved Data length from oem hook: %d ",params_ptr->datalen);

  ril_req_res = qcril_qmi_nas_parse_csg_sys_selection_req(csg_set_sys_sel_req_ptr,&qmi_request,(uint8)params_ptr->datalen);

  if( ril_req_res == RIL_E_GENERIC_FAILURE )
  {
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );
    QCRIL_LOG_ERROR("Failed to parse CSG selction request.");
    return;
  }

  qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                NULL,
                                                NAS_ZERO,
                                                (void*) &qmi_response_get,
                                                sizeof( qmi_response_get ),
                                                ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

  if ( qmi_response_get.csg_info_valid && ( qmi_response_get.csg_info.id == qmi_request.csg_info.id )
        && ( qmi_response_get.csg_info.mcc == qmi_request.csg_info.mcc )
        && ( qmi_response_get.csg_info.mnc == qmi_request.csg_info.mnc ) )
  {
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       RIL_E_SUCCESS,
                                       &resp );
    qcril_send_request_response( &resp );
    QCRIL_LOG_DEBUG("Already camped on requested CSG ID");
    return;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_HOOK_CSG_SET_SYS_SEL_PREF,
                               NULL,
                               &qcril_req_info_ptr );

  if ( qcril_reqlist_new( instance_id, &qcril_req_info_ptr ) == E_SUCCESS )
  {
    qmi_client_error =  qmi_client_nas_send_sync(QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                   &qmi_request,
                                                   sizeof(qmi_request),
                                                   (void*) &qmi_response,
                                                   sizeof( qmi_response ),
                                                   ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    if ( RIL_E_SUCCESS == qmi_client_error )
    {
        if (qmi_response.resp.result != QMI_RESULT_SUCCESS_V01)
        {
           QCRIL_LOG_ERROR("CSG Manual Selection error,QMI Result = %d,error=%d\n", qmi_response.resp.result,qmi_response.resp.error);
           qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
           resp.resp_pkt = (void *) NULL;
           resp.resp_len = 0;
           qcril_send_request_response( &resp );
        }
        else
        {
           QCRIL_LOG_DEBUG("Waiting for System selection pref indication from QMI-NAS..");
        }
    }
    else
    {
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_nas_csg_handle_oem_hook_set_sys_selection */

//===========================================================================
// qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler
//===========================================================================

void qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler(nas_system_selection_preference_ind_msg_v01* qmi_ind)
{
  RIL_Errno   ril_req_res   = RIL_E_GENERIC_FAILURE;
  qcril_reqlist_public_type qcril_req_info;
  errno_enum_type           found_qcril_request;
  qcril_request_resp_params_type resp;

  QCRIL_LOG_FUNC_ENTRY();

  memset( &qcril_req_info, 0, sizeof(qcril_req_info) );

  found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                      QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_HOOK_CSG_SET_SYS_SEL_PREF,
                                                      &qcril_req_info );

  if ( (qmi_ind != NULL) && (E_SUCCESS == found_qcril_request) )
  {
    if ( qmi_ind->csg_info_valid )
    {
      QCRIL_LOG_DEBUG("CSG Manual Selection Set Successfully: CSG_ID: %d, MCC: %03d, MNC: %03d\n",
                       qmi_ind->csg_info.id, qmi_ind->csg_info.mcc, qmi_ind->csg_info.mnc);
      ril_req_res = RIL_E_SUCCESS;
    }
    else if ( qmi_ind->net_sel_pref_valid )
    {
      QCRIL_LOG_DEBUG("CSG Manual Selection Set Successfully: %d\n", qmi_ind->net_sel_pref);
      ril_req_res = RIL_E_SUCCESS;
    }
    else
    {
      QCRIL_LOG_ERROR("CSG Manual Selection Set Failed\n");
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t, qcril_req_info.request, ril_req_res , &resp );
    resp.resp_pkt = NULL;
    resp.resp_len = 0;
    qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler

//===========================================================================
// qcril_qmi_nas_fill_up_operator_name
//===========================================================================
void qcril_qmi_nas_fill_up_operator_name
(
  int is_current_nw,
  char * mcc_str,
  char * mnc_str,
  char * mcc_mnc_str_ref,
  char *long_ons_ptr,
  size_t long_ons_ptr_size,
  char *short_ons_ptr,
  size_t short_ons_ptr_size
)
{
    int res = FALSE;
    const char * op_name_short;
    const char * op_name_long;
    nas_plmn_network_name_type_v01* plmn_nw_name_ptr;

    *long_ons_ptr  = NAS_NIL;
    *short_ons_ptr = NAS_NIL;

    if ( NULL != mcc_str && NULL != mnc_str )
    {
        QCRIL_LOG_INFO("is_current_nw=%d", is_current_nw );
        if( is_current_nw )
        {
            QCRIL_LOG_INFO(".. nitz info is valid %d ", (int)NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) );
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) )
            {
                QCRIL_LOG_INFO(".. nitz long len %d, nitz short len %d ", (int)nas_cached_info.nitz_information->long_name_len, (int)nas_cached_info.nitz_information->short_name_len );
            }
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) &&
                 ( nas_cached_info.nitz_information->long_name_len > NAS_ZERO || nas_cached_info.nitz_information->short_name_len > NAS_ZERO )
               )
            { // operator name is with nitz message
              QCRIL_LOG_INFO( "..inclanation for nitz" );
              plmn_nw_name_ptr = nas_cached_info.nitz_information;
              qcril_qmi_util_decode_operator_name(long_ons_ptr,
                                                  NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                  plmn_nw_name_ptr->coding_scheme,
                                                  plmn_nw_name_ptr->long_name,
                                                  plmn_nw_name_ptr->long_name_len);

              qcril_qmi_util_decode_operator_name(short_ons_ptr,
                                                  NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                  plmn_nw_name_ptr->coding_scheme,
                                                  plmn_nw_name_ptr->short_name,
                                                  plmn_nw_name_ptr->short_name_len);

              QCRIL_LOG_INFO("..will return nitz %s, %s", long_ons_ptr, short_ons_ptr );
              res = TRUE;
            }
            else if ( qcril_qmi_nas_nitz_persistent_cache_is_shadow_available() &&
                    !strcmp(nas_cached_info.persistent_cached_mobile_country_code,mcc_str) &&
                    !strcmp(nas_cached_info.persistent_cached_mobile_network_code,mnc_str) )
            { // nitz shadow cache
              QCRIL_LOG_INFO( "..inclanation for shadow" );
              snprintf( long_ons_ptr, long_ons_ptr_size, "%s", nas_cached_info.persistent_cached_nitz_op_name_long);
              snprintf( short_ons_ptr, short_ons_ptr_size, "%s", nas_cached_info.persistent_cached_nitz_op_name_short );
              QCRIL_LOG_INFO("..will return shadow %s, %s", long_ons_ptr, short_ons_ptr );
              res = TRUE;
            }
        }

        if( FALSE == res )
        {  // look up for operator name in static table
          QCRIL_LOG_INFO( "..inclanation for static" );

          op_name_short = NULL;
          op_name_long = NULL;
          qcril_qmi_nas2_find_static_operator_name(
                                                    mcc_str,
                                                    mnc_str,
                                                    mcc_mnc_str_ref,
                                                    &op_name_long,
                                                    &op_name_short
                                                    );

          if(!op_name_long && !op_name_short)
          {
            op_name_long = mcc_mnc_str_ref;
            op_name_short = "";
          }

          if ( NULL != op_name_long )
          {
              snprintf( long_ons_ptr, long_ons_ptr_size, "%s", op_name_long);
          }
          if ( NULL != op_name_short )
          {
              snprintf( short_ons_ptr, short_ons_ptr_size, "%s", op_name_short);
          }
          QCRIL_LOG_INFO("..will return static %s, %s", long_ons_ptr, short_ons_ptr );
        }
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }
} // qcril_qmi_nas_fill_up_operator_name

//===========================================================================
// qcril_qmi_nas_fill_up_3gpp2_operator_name
//===========================================================================
int qcril_qmi_nas_fill_up_3gpp2_operator_name
(
  char * mcc_str,
  char * mnc_str,
  uint16_t sid,
  uint16_t nid,
  char *long_ons_ptr,
  size_t long_ons_ptr_size,
  char *short_ons_ptr,
  size_t short_ons_ptr_size
)
{
    int res = FALSE;
    char * op_name_short;
    char * op_name_long;

    if( NULL != mcc_str && NULL != mnc_str )
    {
      QCRIL_LOG_INFO("mcc %s mnc %s sid %d nid %d",mcc_str,mnc_str,sid,nid);
      // look up for operator name in static table
      op_name_short = NULL;
      op_name_long = NULL;
      res = qcril_qmi_nas2_find_3gpp2_static_operator_name(mcc_str,
                                                           mnc_str,
                                                           sid,
                                                           nid,
                                                           &op_name_long,
                                                           &op_name_short
                                                           );
      if ( NULL != op_name_long )
      {
          snprintf( long_ons_ptr, long_ons_ptr_size, "%s", op_name_long);
      }
      if ( NULL != op_name_short )
      {
          snprintf( short_ons_ptr, short_ons_ptr_size, "%s", op_name_short);
      }
      QCRIL_LOG_INFO("..will return static %s, %s", long_ons_ptr, short_ons_ptr );
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }

    QCRIL_LOG_INFO("completed with %d",res);
    return res;
} // qcril_qmi_nas_fill_up_3gpp2_operator_name


//===========================================================================
// qcril_qmi_nas_get_nw_select_state
//===========================================================================
qmi_ril_nas_nw_select_state_e_type qcril_qmi_nas_get_nw_select_state(void)
{
    qmi_ril_nas_nw_select_state_e_type res;
    NAS_CACHE_LOCK();
    res = nas_cached_info.nw_select_state;
    NAS_CACHE_UNLOCK();
    return res;
} // qcril_qmi_nas_get_nw_select_state

//===========================================================================
// qcril_qmi_nas_set_nw_select_state
//===========================================================================
RIL_Errno qcril_qmi_nas_set_nw_select_state(qmi_ril_nas_nw_select_state_e_type new_state)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;

    qmi_ril_nas_nw_select_state_e_type cur_state;
    qmi_ril_nas_nw_select_state_e_type final_new_state;

    qmi_client_error_type   client_err;
    uint32                  new_timeout_watch = 0;
    int                     new_timeout_set_res;
    qmi_client_error_type   qmi_transport_error;
    qmi_client_type         dedicated_client;
    qmi_client_os_params    os_params;
    int                     time_out = 4;


    nas_indication_register_req_msg_v01     nwreg_indications_qmi_request;
    nas_indication_register_resp_msg_v01    nwreg_indications_qmi_response;

    const struct timeval nw_select_timeout = {60 , 0}; // 60 seconds
    const struct timeval nw_select_limited_timeout = {25 , 0}; // 25 seconds

    nas_bind_subscription_req_msg_v01   nas_bind_request;
    nas_bind_subscription_resp_msg_v01  nas_bind_resp;



    QCRIL_LOG_INFO( "new_state: %d", (int) new_state );

    NAS_CACHE_LOCK();
    cur_state = nas_cached_info.nw_select_state;
    NAS_CACHE_UNLOCK();
    final_new_state = cur_state;
    QCRIL_LOG_INFO( ".. cur state %d (entry)", (int) cur_state );


    switch ( new_state )
    {
        case QMI_RIL_NAS_NW_SELECT_WAKING_UP:
            if ( QMI_RIL_NAS_NW_SELECT_NONE == cur_state )
            {
                NAS_CACHE_LOCK();
                nas_cached_info.nw_select_nas_client    = NAS_NIL;
                nas_cached_info.nw_select_timeout_watch = NAS_NIL;
                nas_common_info.manual_nw_reject_cause_counter = 0;

                NAS_CACHE_UNLOCK();

                dedicated_client = NULL;

                // open new client
                NAS_NW_SEL_LOCK();
                client_err = qmi_client_init_instance(nas_get_service_object_v01(),
                                                      qmi_ril_client_get_master_port(),
                                                      qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb,
                                                      NULL,
                                                      &os_params,
                                                      time_out,
                                                      &dedicated_client);
                if ( client_err == QMI_NO_ERR )
                {
                    NAS_CACHE_LOCK();
                    nas_cached_info.nw_select_nas_client = dedicated_client;
                    NAS_CACHE_UNLOCK();
                }

                if ( NULL != dedicated_client )
                {
                    /* Bind required only if its multi sim target */
                    if ( qmi_ril_is_multi_sim_feature_supported() )
                    {
                        memset( &nas_bind_request, 0, sizeof( nas_bind_request ) );

                        if ( QCRIL_MODEM_TERTIARY_STACK_ID == qcril_qmi_get_modem_stack_id())
                        {
                            nas_bind_request.subs_type = NAS_TERTIARY_SUBSCRIPTION_V01;
                        }
                        else if (QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_get_modem_stack_id())
                        {
                            nas_bind_request.subs_type = NAS_SECONDARY_SUBSCRIPTION_V01;
                        }
                        else
                        {
                            nas_bind_request.subs_type = NAS_PRIMARY_SUBSCRIPTION_V01;
                        }

                        (void)qmi_client_send_msg_sync_with_shm( dedicated_client,
                                                         QMI_NAS_BIND_SUBSCRIPTION_REQ_MSG_V01,
                                                         (void*)&nas_bind_request,
                                                         sizeof( nas_bind_request ),
                                                         (void*) &nas_bind_resp,
                                                         sizeof( nas_bind_resp ),
                                                         QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                                                          );
                        QCRIL_LOG_INFO( " .. dsds 2nd qmi_nas client bind res %d", (int) res );
                    }
                }

                NAS_NW_SEL_UNLOCK();

                if ( client_err != QMI_NO_ERR )
                {
                   // failed to init client
                   QCRIL_LOG_ESSENTIAL( "QCRIL_ERROR:INIT: Failed to open new nas client w/%d ",
                                        (int) client_err);
                   res = RIL_E_SYSTEM_ERR;
                   QCRIL_LOG_ERROR( "Failed to open new nas client %d ",
                                    (int) client_err );
                   QCRIL_ASSERT(0); // this is a noop in release build
                }
                else
                { // go on
                    QCRIL_LOG_INFO( ".. new nas client open res %d ", (int) client_err );

                    // subscribe for events
                    memset( &nwreg_indications_qmi_request, 0, sizeof( nwreg_indications_qmi_request ) );
                    nwreg_indications_qmi_request.reg_sys_sel_pref_valid = TRUE;
                    nwreg_indications_qmi_request.reg_sys_sel_pref = TRUE;

                    nwreg_indications_qmi_request.reg_ddtm_events_valid = TRUE;
                    nwreg_indications_qmi_request.reg_ddtm_events = FALSE;

                    nwreg_indications_qmi_request.dual_standby_pref_valid = TRUE;
                    nwreg_indications_qmi_request.dual_standby_pref = FALSE;

                    nwreg_indications_qmi_request.subscription_info_valid = TRUE;
                    nwreg_indications_qmi_request.subscription_info = FALSE;

                    nwreg_indications_qmi_request.reg_network_time_valid = TRUE;
                    nwreg_indications_qmi_request.reg_network_time = FALSE;

                    nwreg_indications_qmi_request.reg_rtre_cfg_valid = TRUE;
                    nwreg_indications_qmi_request.reg_rtre_cfg = FALSE;

                    nwreg_indications_qmi_request.reg_embms_status_valid = TRUE;
                    nwreg_indications_qmi_request.reg_embms_status = FALSE;

                    nwreg_indications_qmi_request.sig_info_valid = TRUE;
                    nwreg_indications_qmi_request.sig_info = FALSE;

                    nwreg_indications_qmi_request.err_rate_valid = TRUE;
                    nwreg_indications_qmi_request.err_rate = FALSE;

                    nwreg_indications_qmi_request.reg_managed_roaming_valid = TRUE;
                    nwreg_indications_qmi_request.reg_managed_roaming = FALSE;

                    nwreg_indications_qmi_request.reg_hdr_session_close_valid = TRUE;
                    nwreg_indications_qmi_request.reg_hdr_session_close = FALSE;

                    nwreg_indications_qmi_request.reg_hdr_uati_valid = TRUE;
                    nwreg_indications_qmi_request.reg_hdr_uati = FALSE;

                    nwreg_indications_qmi_request.reg_current_plmn_name_valid = TRUE;
                    nwreg_indications_qmi_request.reg_current_plmn_name = FALSE;

                    nwreg_indications_qmi_request.reg_manual_scan_fail_valid = TRUE;
                    nwreg_indications_qmi_request.reg_manual_scan_fail = TRUE;

                    if (nas_common_info.manual_nw_reject_cause_counter_enabled)
                    {
                        nwreg_indications_qmi_request.network_reject_valid  = TRUE;
                        nwreg_indications_qmi_request.network_reject.reg_network_reject  = TRUE;
                        nwreg_indications_qmi_request.network_reject.suppress_sys_info   = FALSE;
                    }

                    nwreg_indications_qmi_request.sys_info_valid = TRUE;
                    nwreg_indications_qmi_request.sys_info = TRUE;

                    nwreg_indications_qmi_request.req_serving_system_valid = TRUE;
                    nwreg_indications_qmi_request.req_serving_system = FALSE;

                    nwreg_indications_qmi_request.reg_operator_name_data_valid = TRUE;
                    nwreg_indications_qmi_request.reg_operator_name_data = FALSE;

                    qmi_transport_error = qmi_client_send_msg_sync_with_shm(
                                            nas_cached_info.nw_select_nas_client,
                                            QMI_NAS_INDICATION_REGISTER_REQ_MSG_V01,
                                            (void*) &nwreg_indications_qmi_request,
                                            sizeof( nwreg_indications_qmi_request ),
                                            (void*) &nwreg_indications_qmi_response,
                                            sizeof( nwreg_indications_qmi_response ),
                                            QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                                             );
                    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &nwreg_indications_qmi_response.resp );

                    QCRIL_LOG_INFO( ".. secondary QMI NAS handle configuring res %d, %d ", (int) res, (int) nwreg_indications_qmi_response.resp.error );

                    if ( RIL_E_SUCCESS == res )
                    {
                        // set timeout
                        new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                                          QCRIL_DEFAULT_MODEM_ID,
                                                                          qcril_qmi_nas_nw_select_timeout_cb,
                                                                          &nw_select_timeout, &new_timeout_watch );
                        QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );

                        if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
                        {
                            if(new_timeout_set_res == E_SUCCESS)
                            {
                              QCRIL_LOG_ERROR("Internal error..timed callback failed to set timer_id");
                              res = RIL_E_INTERNAL_ERR;
                            }
                            else
                            {
                              res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err((IxErrnoType) new_timeout_set_res);
                            }
                        }
                        else
                        {
                            // otherwise waking up is done
                            final_new_state = QMI_RIL_NAS_NW_SELECT_AWAKEN;
                            NAS_CACHE_LOCK();
                            nas_cached_info.nw_select_nw_reg_received       = FALSE;
                            nas_cached_info.nw_select_nw_set_pref_ackd      = FALSE;
                            nas_cached_info.nw_select_nw_reg_result         = RIL_E_RADIO_NOT_AVAILABLE;
                            nas_cached_info.nw_select_nw_set_pref_result    = RIL_E_RADIO_NOT_AVAILABLE;
                            nas_cached_info.nw_select_is_manual             = FALSE;
                            nas_cached_info.nw_select_is_current            = FALSE;
                            memset(&nas_cached_info.nw_select_manual_mcc_str, NAS_NIL, sizeof(nas_cached_info.nw_select_manual_mcc_str));
                            memset(&nas_cached_info.nw_select_manual_mnc_str, NAS_NIL, sizeof(nas_cached_info.nw_select_manual_mnc_str));
                            nas_cached_info.nw_select_is_modem_sel_pref_auto = FALSE;
                            nas_cached_info.nw_select_timeout_watch = new_timeout_watch;
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sim_rej_info);
                            nas_cached_info.nw_select_manual_rat = NAS_RADIO_IF_NO_SVC_V01;
                            NAS_CACHE_UNLOCK();
                        }

                    }

                    // check if need to rollback
                    if ( RIL_E_SUCCESS != res )
                    {
                        qcril_qmi_nas_nw_select_handle_total_cleanup();
                    }
                }
            }
            else
            {
              QCRIL_LOG_ERROR("Invalid state..to move to WAKING_UP state");
              res = RIL_E_INVALID_STATE;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
            if ( QMI_RIL_NAS_NW_SELECT_AWAKEN == cur_state )
            {
                final_new_state = QMI_RIL_NAS_NW_SELECT_SETTING_PREF;
                res = RIL_E_SUCCESS;
            }
            else
            {
              QCRIL_LOG_ERROR("Invalid state..to move to SETTING_PREF state");
              res = RIL_E_INVALID_STATE;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
            if ( QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state || QMI_RIL_NAS_NW_SELECT_AWAITING_REG == cur_state )
            {
                new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, qcril_qmi_nas_nw_select_limited_timeout_cb, &nw_select_limited_timeout, &new_timeout_watch );
                QCRIL_LOG_INFO( ".. set limited timeout cb res %d ", (int) new_timeout_set_res );
                if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
                {
                    if(new_timeout_set_res == E_SUCCESS)
                    {
                      QCRIL_LOG_ERROR("Internal error..timed callback failed to set timer_id");
                      res = RIL_E_INTERNAL_ERR;
                    }
                    else
                    {
                      res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err((IxErrnoType) new_timeout_set_res);
                    }
                    qcril_qmi_nas_nw_select_handle_total_cleanup(); //rollback
                }
                else
                {
                    NAS_CACHE_LOCK();
                    nas_cached_info.nw_select_limited_timeout_watch    = new_timeout_watch;
                    NAS_CACHE_UNLOCK();
                    final_new_state = QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD;
                    res = RIL_E_SUCCESS;
                }
            }
            else
            {
              QCRIL_LOG_ERROR("Invalid state..to move to SETTING_PREF_LIMITED_REGD state");
              res = RIL_E_INVALID_STATE;
            }
            break;


        case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
            if ( QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state || QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD == cur_state )
            {
                final_new_state = QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD;
                res = RIL_E_SUCCESS;
            }
            else
            {
              QCRIL_LOG_ERROR("Invalid state..to move to SETTING_PREF_REGD state");
              res = RIL_E_INVALID_STATE;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
                    final_new_state = QMI_RIL_NAS_NW_SELECT_AWAITING_REG;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    QCRIL_LOG_ERROR("Invalid state..to move to AWAITING_REG state");
                    res = RIL_E_INVALID_STATE;
                    break;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_CANCELLING_REQ:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:   // fallthrough
                case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
                    final_new_state = QMI_RIL_NAS_NW_SELECT_NONE;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    QCRIL_LOG_ERROR("Invalid state..to move to CANCELLING_REQ state");
                    res = RIL_E_INVALID_STATE;
                    break;
            }
            break;


        case QMI_RIL_NAS_NW_SELECT_DONE:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:   // fallthrough
                case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
                    qcril_qmi_nas_nw_select_handle_total_cleanup();
                    final_new_state = QMI_RIL_NAS_NW_SELECT_NONE;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    QCRIL_LOG_ERROR("Invalid state..to move to DONE state");
                    res = RIL_E_INVALID_STATE;
                    break;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_ROLLBACK:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_AWAKEN:
                    qcril_qmi_nas_nw_select_handle_total_cleanup();
                    final_new_state = QMI_RIL_NAS_NW_SELECT_NONE;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    QCRIL_LOG_ERROR("Invalid state..to move to ROLLBACK state");
                    res = RIL_E_INVALID_STATE;
                    break;
            }
            break;

        default: // invalid state or state may not be set directly
            QCRIL_LOG_ERROR("Invalid state..or state may not be set directly");
            res = RIL_E_INVALID_STATE;
            break;
    }

    if ( RIL_E_SUCCESS == res  )
    {
        NAS_CACHE_LOCK();
        nas_cached_info.nw_select_state = final_new_state;
        NAS_CACHE_UNLOCK();
    }
    QCRIL_LOG_INFO( "completed with %d and new state is %d ", (int)res, (int) final_new_state );
    return res;
} // qcril_qmi_nas_set_nw_select_state

//===========================================================================
// QCRIL_EVT_QMI_REQUEST_CLEANUP_NW_SEL
//===========================================================================
void qcril_qmi_nas_nw_select_handle_total_cleanup()
{
  qmi_client_type         new_nas_client;
  uint32                  new_timeout_watch,new_limited_timeout_watch;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  new_nas_client = nas_cached_info.nw_select_nas_client;
  NAS_CACHE_UNLOCK();
  if ( NAS_NIL != new_nas_client )
  {
      NAS_NW_SEL_LOCK();
      qmi_client_release(new_nas_client);
      NAS_CACHE_LOCK();
      nas_cached_info.nw_select_nas_client = NAS_NIL;
      NAS_CACHE_UNLOCK();
      NAS_NW_SEL_UNLOCK();
  }

  NAS_CACHE_LOCK();
  new_timeout_watch = nas_cached_info.nw_select_timeout_watch;
  new_limited_timeout_watch = nas_cached_info.nw_select_limited_timeout_watch;
  NAS_CACHE_UNLOCK();
  if ( NAS_NIL != new_timeout_watch )
  {
      qcril_cancel_timed_callback((void*)(uintptr_t)new_timeout_watch);
      NAS_CACHE_LOCK();
      nas_cached_info.nw_select_timeout_watch = NAS_NIL;
      NAS_CACHE_UNLOCK();
  }

  if ( NAS_NIL != new_limited_timeout_watch )
  {
      qcril_cancel_timed_callback((void*)(uintptr_t)new_limited_timeout_watch);
      NAS_CACHE_LOCK();
      nas_cached_info.nw_select_limited_timeout_watch = NAS_NIL;
      NAS_CACHE_UNLOCK();
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_nw_select_handle_total_cleanup


/*=========================================================================

    FUNCTION: qcril_qmi_nas_is_permanent_failure

===========================================================================*/
/*!

    @brief
    Check if reject_cause is a permanent failure or not.

    @return
    TRUE or FALSE

*/
/*=========================================================================*/
boolean qcril_qmi_nas_is_permanent_failure
(
    int reject_cause
)
{
    boolean ret;

    switch (reject_cause)
    {
        case ILLEGAL_MS:
        case GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED:
        case PLMN_NOT_ALLOWED:
        case LA_NOT_ALLOWED:
        case NATIONAL_ROAMING_NOT_ALLOWED:
        {
            ret = TRUE;
            break;
        }

        default:
        {
            ret = FALSE;
            break;
        }
    }

    return ret;
}
/*=========================================================================

    FUNCTION: qcril_qmi_nas_nw_select_restart_timer

===========================================================================*/
/*!

    @brief
    restart manual network selection timer

    @return
    0 on success.

*/
/*=========================================================================*/
int qcril_qmi_nas_nw_select_restart_timer
(
    void
)
{
    int             res = RIL_E_SUCCESS;
    const struct    timeval nw_select_timeout = {60 , 0};
    uint32          new_timeout_watch = 0;
    int             new_timeout_set_res;

    NAS_CACHE_LOCK();
    new_timeout_watch = nas_cached_info.nw_select_timeout_watch;

    if ( NAS_NIL != new_timeout_watch )
    {
        qcril_cancel_timed_callback((void*)(uintptr_t)new_timeout_watch);
        nas_cached_info.nw_select_timeout_watch = NAS_NIL;
    }

    new_timeout_set_res = qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     qcril_qmi_nas_nw_select_timeout_cb,
                                                     &nw_select_timeout,
                                                     &new_timeout_watch );

    QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );
    if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
    {
        res = RIL_E_GENERIC_FAILURE;
    }
    else
    {
        nas_cached_info.nw_select_timeout_watch = new_timeout_watch;
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
    return res;
}

//===========================================================================
//qcril_qmi_nas_nw_select_timeout_handler
//===========================================================================
void qcril_qmi_nas_nw_select_timeout_handler()
{
  qmi_ril_nas_nw_select_state_e_type cur_state;
  int     is_full_service;
  int     illegal_sim_or_me = FALSE;
  uint8_t is_reg_on_requested_plmn = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  cur_state = qcril_qmi_nas_get_nw_select_state();
  QCRIL_LOG_INFO(".. cur state 1 %d", (int) cur_state );

  switch ( cur_state )
  {
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
      case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
          // update NW reg info
          qcril_qmi_nas_fetch_sys_info();

          NAS_CACHE_LOCK();
          is_full_service = qcril_qmi_nas_is_considered_registered(NULL);
          is_reg_on_requested_plmn = qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat();
          NAS_CACHE_UNLOCK();
          QCRIL_LOG_INFO(".. is full service %d", (int) is_full_service );
          QCRIL_LOG_INFO(".. is_reg_on_requested_plmn %d", is_reg_on_requested_plmn );
          if ( is_full_service )
          {
              NAS_CACHE_LOCK();
              nas_cached_info.nw_select_nw_reg_received       = TRUE;
              if(is_reg_on_requested_plmn)
              {
                nas_cached_info.nw_select_nw_reg_result = RIL_E_SUCCESS;
              }
              else
              {
                nas_cached_info.nw_select_nw_reg_result = RIL_E_GENERIC_FAILURE;
              }
              NAS_CACHE_UNLOCK();
              qcril_qmi_nas_select_nw_conclusion_check();
          }
          else
          {
              NAS_CACHE_LOCK();
              if( ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason ) &&
                  ( QCRIL_QMI_NAS_REGISTRATION_REJECT_CAUSE_ILLEGAL_MS ==
                    nas_cached_info.registration_reject_reason->reject_cause ) ) ||
                  ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.sim_rej_info ) &&
                  ( ( NAS_SIM_NOT_AVAILABLE_V01 == nas_cached_info.sim_rej_info ) ||
                  ( NAS_SIM_CS_PS_INVALID_V01 == nas_cached_info.sim_rej_info ) ) )
                )
              {
                  illegal_sim_or_me = TRUE;
              }
              NAS_CACHE_UNLOCK();

              if( TRUE == illegal_sim_or_me )
              {
                  NAS_CACHE_LOCK();
                  nas_cached_info.nw_select_nw_reg_received       = TRUE;
                  nas_cached_info.nw_select_nw_reg_result         = RIL_E_ILLEGAL_SIM_OR_ME;
                  NAS_CACHE_UNLOCK();
                  qcril_qmi_nas_select_nw_conclusion_check();
              }
          }
          break;

      default:
          break;
  }

  // still nothing?
  cur_state = qcril_qmi_nas_get_nw_select_state();
  QCRIL_LOG_INFO(".. cur state 2 %d", (int) cur_state );
  switch ( cur_state )
  {
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
      case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
          // cancel op
          qcril_qmi_nas_send_response_for_pending_network_selection_request();
          qcril_qmi_nas_wave_voice_data_status();
          break;

      default:
          // ignore
          break;
  }
  // todo

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_timeout_handler


//===========================================================================
//qcril_qmi_nas_nw_select_timeout_cb
//===========================================================================
void qcril_qmi_nas_nw_select_timeout_cb(void * params)
{
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( params );
  qcril_qmi_nas_nw_select_timeout_handler();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_timeout_cb

//===========================================================================
//qcril_qmi_nas_nw_select_limited_timeout_cb
//===========================================================================
void qcril_qmi_nas_nw_select_limited_timeout_cb(void * params)
{
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( params );
  qcril_qmi_nas_nw_select_timeout_handler();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_limited_timeout_cb

//===========================================================================
// qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb
//===========================================================================
void qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb
(
  qmi_client_type                user_handle,
  unsigned int                   message_id,
  void                          *ind_buf,
  unsigned int                   ind_buf_len,
  void                          *ind_cb_data
)
{
  IxErrnoType res;
  qmi_ril_nw_reg_nw_select_passover_params_type * passover;
  int                                             is_success;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ind_cb_data );
  QCRIL_NOTUSED( user_handle );

  do
  {
      passover   = NULL;
      is_success = FALSE;

      passover = (qmi_ril_nw_reg_nw_select_passover_params_type *)
            qcril_malloc( sizeof(qmi_ril_nw_reg_nw_select_passover_params_type)  );
      if ( NULL == passover )
      {
          QCRIL_LOG_ERROR("passover alloc failure");
          break;
      }

      if ( ind_buf_len > NAS_NIL )
      {
          passover->payload = (void *)qcril_malloc( ind_buf_len  );
          if ( NULL == passover->payload )
          {
              QCRIL_LOG_ERROR("passover payload alloc failure");
              break;
          }
          memcpy( passover->payload, ind_buf, ind_buf_len );

          passover->payload_len = ind_buf_len;
      }

      passover->message_id = message_id;

      res = qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_NOT_ON_STACK,
                       QCRIL_EVT_QMI_NAS_PASSOVER_NW_SEL_IND,
                       passover,
                       sizeof(*passover),
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

      if( E_SUCCESS == res )
      {
          is_success = TRUE;
      }

  } while ( FALSE );

  if ( !is_success )
  {
      if ( NULL != passover )
      {
          if ( NULL != passover->payload )
          {
              qcril_free( passover->payload );
          }
          qcril_free( passover );
      }
  }

  QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb

//===========================================================================
// qcril_qmi_nas_nw_select_dedicated_unsolicited_indicaton_event_thrd_handler // QCRIL_EVT_QMI_NAS_PASSOVER_NW_SEL_IND
//===========================================================================
void qcril_qmi_nas_nw_select_dedicated_unsolicited_indicaton_event_thrd_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)

{
    qmi_ril_nw_reg_nw_select_passover_params_type * passover;

    unsigned long                                   message_id;
    unsigned char*                                  ind_buf;
    int                                             ind_buf_len;

    void *                                          decoded_payload = NULL;
    qmi_client_error_type                           qmi_err;
    uint32_t                                        decoded_payload_len;

    qmi_client_type                                 dedicated_nas_client;

    int                                             nw_reg_occured = FALSE;
    RIL_Errno                                       nw_reg_result = RIL_E_GENERIC_FAILURE;

    nas_system_selection_preference_ind_msg_v01 *   sys_sel_pref_ind;
    nas_network_reject_ind_msg_v01                 *network_reject_ind_msg = NULL;
    nas_sys_info_ind_msg_v01 *                      sys_info_ind;
    nas_3gpp_only_sys_info_type_v01*                three_3gpp_info;

    uint16_t                                        mode_pref;

    qmi_ril_nas_nw_select_state_e_type              cur_state;
    nas_sms_status_enum_type_v01 prev_lte_sms_status;
    uint8_t prev_lte_sms_status_valid = FALSE;
    nas_lte_voice_status_enum_type_v01 prev_lte_voice_status;
    uint8_t prev_lte_voice_status_valid = FALSE;
    qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
    qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
    int radio_tech_changed = FALSE;

    uint8_t old_mcc_mnc_valid;
    char old_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char old_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    uint8_t new_mcc_mnc_valid;
    char new_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char new_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    int  any_rte_change = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED( ret_ptr );
    qmi_ril_nw_reg_snapshot_init(&old_rte_snapshot);
    qmi_ril_nw_reg_snapshot_init(&new_rte_snapshot);
    if ( NULL != params_ptr )
    {
        passover = ( qmi_ril_nw_reg_nw_select_passover_params_type* ) (qmi_resp_callback_type *) params_ptr->data;

        if ( NULL != passover && NAS_NIL != passover->message_id )
        {

              message_id   = passover->message_id;
              ind_buf      = (unsigned char *) passover->payload;
              ind_buf_len  = passover->payload_len;

              do
              {
                  QCRIL_LOG_INFO("invoked msg 0x%x", (int) message_id);

                  qmi_err = qmi_idl_get_message_c_struct_len(nas_get_service_object_v01(),
                                                           QMI_IDL_INDICATION,
                                                           message_id,
                                                           &decoded_payload_len);

                  if ( qmi_err != QMI_NO_ERR ) {
                      QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
                      break;
                  }

                  if( decoded_payload_len )
                  {
                      decoded_payload = qcril_malloc( decoded_payload_len );
                      if (decoded_payload)
                      {
                        memset( decoded_payload, 0, decoded_payload_len );

                        NAS_NW_SEL_LOCK();

                        NAS_CACHE_LOCK();
                        dedicated_nas_client = nas_cached_info.nw_select_nas_client;
                        NAS_CACHE_UNLOCK();

                        if( NAS_NIL != dedicated_nas_client )
                        {
                            qmi_err = qmi_client_message_decode(  dedicated_nas_client,
                                                                QMI_IDL_INDICATION,
                                                                message_id,
                                                                ind_buf,
                                                                ind_buf_len,
                                                                decoded_payload,
                                                                (int)decoded_payload_len);
                        }
                        else
                        {
                            qmi_err = QMI_INTERNAL_ERR;
                        }

                        NAS_NW_SEL_UNLOCK();

                        if ( QMI_NO_ERR == qmi_err )
                        {
                            nw_reg_occured = FALSE;

                            cur_state = qcril_qmi_nas_get_nw_select_state();
                            QCRIL_LOG_INFO(".. nw sel state %d", (int) cur_state);

                            switch ( cur_state )
                            {
                                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
                                case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
                                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
                                    switch ( message_id )
                                    {
                                      case QMI_NAS_NETWORK_REJECT_IND_V01:
                                          {
                                              network_reject_ind_msg = (nas_network_reject_ind_msg_v01*)decoded_payload;
                                              if (network_reject_ind_msg)
                                              {
                                                  QCRIL_LOG_INFO(".. reg reject domain, cause %d, %d",
                                                                 network_reject_ind_msg->reject_srv_domain,
                                                                 network_reject_ind_msg->rej_cause);

                                                  if (nas_common_info.manual_nw_reject_cause_counter_enabled &&
                                                       (network_reject_ind_msg->rej_cause == QCRIL_REJECT_CAUSE_NETWORK_FAIL))
                                                  {
                                                      QCRIL_LOG_INFO(".. counter %d",
                                                                     nas_common_info.manual_nw_reject_cause_counter);
                                                      nas_common_info.manual_nw_reject_cause_counter++;
                                                      qcril_qmi_nas_nw_select_restart_timer();
                                                      if (nas_common_info.manual_nw_reject_cause_counter == QMI_RIL_MANUAL_NW_REJECT_MAX_COUNT)
                                                      {
                                                          nas_common_info.manual_nw_reject_cause_counter = 0;
                                                          nw_reg_occured = TRUE;
                                                          nw_reg_result  = RIL_E_INTERNAL_ERR;
                                                      }
                                                  }
                                              }
                                          }

                                          break;

                                      case QMI_NAS_SYS_INFO_IND_MSG_V01:
                                          sys_info_ind = (nas_sys_info_ind_msg_v01*)decoded_payload;

                                          if ( NULL != sys_info_ind )
                                          {
                                              qcril_qmi_nas_fetch_lte_voice_status( &prev_lte_voice_status_valid, &prev_lte_voice_status);
                                              qcril_qmi_nas_fetch_lte_sms_status( &prev_lte_sms_status_valid, &prev_lte_sms_status );
                                              qmi_ril_nw_reg_snapshot_cur_rte(&old_rte_snapshot);

                                              NAS_CACHE_LOCK();
                                              old_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(old_mcc_str, old_mnc_str, TRUE, NULL);
                                              qmi_ril_nw_reg_update_sys_info_cache_from_ind( sys_info_ind ); // store sys_info indication so we get adequate and up-to-date cache
                                              new_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(new_mcc_str, new_mnc_str, TRUE, NULL);
                                              if( old_mcc_mnc_valid != new_mcc_mnc_valid || strcmp(old_mcc_str, new_mcc_str) || strcmp(old_mnc_str, new_mnc_str) ) //invalidiating operator name specifics as PLMN has changed
                                              {
                                                  NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
                                                  NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
                                                  NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
                                                  NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
                                                  NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
                                                  radio_tech_changed = TRUE;
                                              }

                                              qmi_ril_nw_reg_snapshot_cur_rte(&new_rte_snapshot);
                                              any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
                                              QCRIL_LOG_INFO( "any rte change %d", any_rte_change);
                                              if (( TRUE == any_rte_change ) ||
                                                   qcril_qmi_nas_lte_sms_status_compare( prev_lte_sms_status_valid, prev_lte_sms_status) ||
                                                   qcril_qmi_nas_lte_voice_status_compare( prev_lte_voice_status_valid, prev_lte_voice_status ))
                                              {
                                                radio_tech_changed = TRUE;
                                              }

                                              if( TRUE == any_rte_change )
                                              {
                                                qcril_qmi_nas_drop_nw_info_cache();
                                                qcril_qmi_nas_fetch_sys_info();
                                              }
                                              else
                                              {
                                                  if(qcril_qmi_nas_is_considered_registered(NULL))
                                                  {
                                                      qcril_qmi_nas_report_change_in_rat_rac();
                                                  }
                                                  else
                                                  {
                                                      /* Device is OOS, so clear the cache */
                                                      qcril_qmi_nas_clear_reported_rat_rac_cache();
                                                  }
                                              }

                                              if ( radio_tech_changed == TRUE )
                                              {
#ifndef QMI_RIL_UTF
                                                qcril_qmi_nas_initiate_voice_rte_change_propagation();
#endif
                                              }

                                              three_3gpp_info = NULL;

                                              if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) )
                                              {
                                                  mode_pref = nas_cached_info.mode_pref; // this must be valid
                                              }
                                              else
                                              {
                                                  mode_pref = QMI_NAS_RAT_MODE_PREF_GSM_UMTS_TDSCDMA_LTE;
                                              }
                                              QCRIL_LOG_INFO(".. mode pref %d", (int) mode_pref);

                                              // gsm
                                              if ( mode_pref & QMI_NAS_RAT_MODE_PREF_GSM )
                                              {
                                                  if ( sys_info_ind->gsm_srv_status_info_valid && sys_info_ind->gsm_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->gsm_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                                TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                            if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                            {
                                                                nw_reg_occured = TRUE;
                                                                nw_reg_result = RIL_E_SUCCESS;
                                                            }
                                                            else
                                                            {
                                                                nw_reg_result  = RIL_E_INTERNAL_ERR;
                                                            }
                                                            QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. gsm srv status %d", (int) sys_info_ind->gsm_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->gsm_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for GSM
                                                    if( ((TRUE == sys_info_ind->gsm_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->gsm_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              // wcdma
                                              if ( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS )
                                              {
                                                  if ( sys_info_ind->wcdma_srv_status_info_valid && sys_info_ind->wcdma_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                               TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                          if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                          {
                                                              nw_reg_occured = TRUE;
                                                              nw_reg_result = RIL_E_SUCCESS;
                                                          }
                                                          else
                                                          {
                                                              nw_reg_result  = RIL_E_INTERNAL_ERR;
                                                          }
                                                          QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. wcdma srv status %d", (int) sys_info_ind->wcdma_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->wcdma_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for WCDMA
                                                    if( ((TRUE == sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              // tdscdma
                                              if ( ( mode_pref & QMI_NAS_RAT_MODE_PREF_TDSCDMA ) ||
                                                   ( ( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS ) &&
                                                     qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) &&
                                                     !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ) ) )
                                              {
                                                  if ( sys_info_ind->tdscdma_srv_status_info_valid && sys_info_ind->tdscdma_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                               TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                          nw_reg_occured = TRUE;
                                                          if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                          {
                                                              nw_reg_result = RIL_E_SUCCESS;
                                                          }
                                                          else
                                                          {
                                                              nw_reg_result  = RIL_E_INTERNAL_ERR;
                                                          }
                                                          QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. tdscdma srv status %d", (int) sys_info_ind->tdscdma_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->tdscdma_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for TDSCDMA
                                                    if( ((TRUE == sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              // lte
                                              if ( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE )
                                              {
                                                  if ( sys_info_ind->lte_srv_status_info_valid && sys_info_ind->lte_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->lte_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                               TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                        if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                        {
                                                            nw_reg_occured = TRUE;
                                                            nw_reg_result = RIL_E_SUCCESS;
                                                        }
                                                        else
                                                        {
                                                            nw_reg_result  = RIL_E_INTERNAL_ERR;
                                                        }
                                                        QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. lte srv status %d", (int) sys_info_ind->lte_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->lte_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for LTE
                                                    if( ((TRUE == sys_info_ind->lte_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->lte_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              NAS_CACHE_UNLOCK();


                                              if ( three_3gpp_info && three_3gpp_info->reg_reject_info_valid )
                                              {
                                                  QCRIL_LOG_INFO(".. reg reject domain, cause %d, %d",
                                                                 (int) three_3gpp_info->reg_reject_info.reject_srv_domain,
                                                                 (int) three_3gpp_info->reg_reject_info.rej_cause);

                                                  if (!nas_common_info.manual_nw_reject_cause_counter_enabled ||
                                                       (nas_common_info.manual_nw_reject_cause_counter_enabled &&
                                                        three_3gpp_info->reg_reject_info.rej_cause !=
                                                                                 QCRIL_REJECT_CAUSE_NETWORK_FAIL))
                                                  {
                                                      /* Check if we can return failure right away */
                                                      if (qcril_qmi_nas_is_permanent_failure(
                                                                        three_3gpp_info->reg_reject_info.rej_cause))
                                                      {
                                                          nw_reg_occured = TRUE;
                                                          nw_reg_result  = RIL_E_INTERNAL_ERR;
                                                      }
                                                      else
                                                      {
                                                          /* if temeporary failure, we should wait for modem retry */
                                                          qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD );
                                                      }
                                                  }
                                              }
                                          }

                                          break;

                                        case QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01:
                                            sys_sel_pref_ind = (nas_system_selection_preference_ind_msg_v01*)decoded_payload;
                                            if( sys_sel_pref_ind )
                                            {
                                                QCRIL_LOG_INFO(".. net sel pref valid %d, net sel pref %d",
                                                               (int) sys_sel_pref_ind->net_sel_pref_valid,
                                                               (int) sys_sel_pref_ind->net_sel_pref );

                                    if( sys_sel_pref_ind->net_sel_pref_valid && NAS_NET_SEL_PREF_AUTOMATIC_V01 == sys_sel_pref_ind->net_sel_pref )
                                                {
                                                    NAS_CACHE_LOCK();
                                                    nas_cached_info.nw_select_is_modem_sel_pref_auto = TRUE;
                                                    NAS_CACHE_UNLOCK();
                                                }
                                            }
                                            break;

                                        case QMI_NAS_MANUAL_SCAN_FAIL_IND_MSG_V01:
                                            nw_reg_occured = TRUE;
                                            nw_reg_result  = RIL_E_INTERNAL_ERR;
                                            break;

                                      default:
                                          break;
                                    }
                                    if ( nw_reg_occured && QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state)
                                    {
                                        qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD );
                                    }
                                    break;

                                default:
                                    // skip
                                    break;
                            }
                        }
                        else
                        {
                            nw_reg_occured = FALSE;
                        }

                        qcril_free( decoded_payload );
                      }
                  }

                  if ( nw_reg_occured )
                  {
                      NAS_CACHE_LOCK();
                      nas_cached_info.nw_select_nw_reg_received = TRUE;
                      nas_cached_info.nw_select_nw_reg_result   = nw_reg_result;
                      NAS_CACHE_UNLOCK();
                      qcril_qmi_nas_select_nw_conclusion_check();
                  }
              } while(0);

        }

        if ( NULL != passover )
        {
            qcril_free( passover->payload );
            qcril_free( passover );
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_dedicated_unsolicited_indicaton_event_thrd_handler

//===========================================================================
// qcril_qmi_nas_select_nw_conclusion_check
//===========================================================================
void qcril_qmi_nas_select_nw_conclusion_check(void)
{
    IxErrnoType                        found_qcril_request;
    RIL_Errno                          ril_req_res;

    int                                reg_received;
    RIL_Errno                          reg_result;
    int                                pref_ackd;
    RIL_Errno                          pref_result;
    qcril_arb_pref_data_type pref_data;
    int data_reg;
    int local_confident_response = FALSE;


    QCRIL_LOG_FUNC_ENTRY();

    // look for any on-going request (including manually and automatically network selection)
    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestSetNetworkSelectionManualMessage::get_class_message_id());
    if (!pendingMsg)
    {
        pendingMsg = msgList.find(RilRequestSetNetworkSelectionAutoMessage::get_class_message_id());
    }
    found_qcril_request = (pendingMsg != nullptr) ? E_SUCCESS : E_FAILURE;
    QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );

    NAS_CACHE_LOCK();
    if( nas_cached_info.nw_select_is_manual && nas_cached_info.nw_select_is_current && qcril_qmi_nas_is_considered_registered(NULL) )
    {//sending response to Android without waiting for sys_info ind as there is no change w.r.t network state
        QCRIL_LOG_INFO("Manual registration on current network");
        reg_received = TRUE;
        reg_result   = RIL_E_SUCCESS;
    }
    else
    {
        reg_received = nas_cached_info.nw_select_nw_reg_received;
        reg_result   = nas_cached_info.nw_select_nw_reg_result;
    }
    pref_ackd    = nas_cached_info.nw_select_nw_set_pref_ackd;
    pref_result  = nas_cached_info.nw_select_nw_set_pref_result;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. reg recv, res %d, %d", (int) reg_received, (int)reg_result );
    QCRIL_LOG_INFO( ".. pref ackd, res %d, %d", (int) pref_ackd, (int)pref_result );

    if (( reg_received && pref_ackd ) || (pref_ackd && (RIL_E_SUCCESS != pref_result)))
    { // all is done
        qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_DONE );

        if ( found_qcril_request == E_SUCCESS)
        {
            if ( RIL_E_SUCCESS == reg_result && RIL_E_SUCCESS == pref_result )
            {
                ril_req_res = RIL_E_SUCCESS;
            }
            else if ( RIL_E_SUCCESS == pref_result )
            {
                ril_req_res = reg_result;
            }
            else if ( RIL_E_SUCCESS == reg_result )
            {
                ril_req_res = pref_result;
            }
            else
            {
                ril_req_res = pref_result;
            }

            if ((pendingMsg->get_message_id() ==
                    RilRequestSetNetworkSelectionManualMessage::get_class_message_id())
                    && nas_common_info.is_restore_prev_mode_pref)
            {
                qcril_qmi_nas_restore_modem_pref();
            }
            QCRIL_LOG_INFO( ".. reporting %d", (int) ril_req_res );
            // signal done
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    ril_req_res, nullptr);
            auto selectMsg = std::static_pointer_cast<QcRilRequestMessage>(pendingMsg);
            selectMsg->sendResponse(selectMsg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(pendingMsg);

            qcril_qmi_arb_reset_pref_data_snapshot();
            if ( RIL_E_SUCCESS == ril_req_res )
            {
                memset(&pref_data, 0, sizeof(pref_data));
                qcril_qmi_get_pref_data_tech(&pref_data);
                if( (pref_data.radio_technology != RADIO_TECH_UNKNOWN) && (pref_data.radio_technology != RADIO_TECH_IWLAN) )
                {
                    local_confident_response = qcril_qmi_nas_decide_data_roam_status(pref_data.pref_data_tech, &data_reg);
                    if (FALSE == local_confident_response)
                    {
                        qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation_ncl();
                    }
                }
            }
            qcril_qmi_nas_wave_voice_data_status();
        }
    }


    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_select_nw_conclusion_check

//===========================================================================
// RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC
//===========================================================================
void qcril_qmi_nas_set_network_selection_automatic
(
  std::shared_ptr<RilRequestSetNetworkSelectionAutoMessage> msg
)
{
  qcril_qmi_util_initiate_network_selection_check(msg, TRUE, NAS_NIL, NAS_NIL, TRUE, NAS_NIL, RADIO_TECH_UNKNOWN );
} // qcril_qmi_nas_set_network_selection_automatic

//===========================================================================
// RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL
//===========================================================================
void qcril_qmi_nas_set_network_selection_manual
(
  std::shared_ptr<RilRequestSetNetworkSelectionManualMessage> msg
)
{
  auto& numeric = msg->getOperatorNumeric();

  if (numeric.length() == 0)
  {
      QCRIL_LOG_ERROR("Invalid arguments..Null params");
      auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            RIL_E_INVALID_ARGUMENTS, nullptr);
      msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  }
  else
  {
      std::string plmnStr;
      int mcc, mnc;
      int ok, pcs_digit_present;
      int rat = RADIO_TECH_UNKNOWN;
       /*
       * new format when RAT is enabled
       * This will avoid any changes in ril_command.h
       */
      if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_COMBINE_RAT) )
      {
        /* format: "mcc_mnc+rat\0" */
        auto pos = numeric.find('+', 0);
        if (pos != std::string::npos)
        {
            plmnStr = numeric.substr(0, pos);
            std::string ratStr = numeric.substr(pos + 1);
            rat = std::stoi(ratStr, nullptr, 10);
        }
        else
        {
            plmnStr = numeric;
        }
      }
      else
      {
        /* Case of MCC_MNC without RAT */
        plmnStr = numeric;
      }

      if (plmnStr.length() > 0)
      {
          auto param_str = plmnStr.c_str();
          pcs_digit_present = ((strlen(param_str) == MCC_MNC_PCS_DIGIT_LEN) && (param_str[MCC_MNC_PCS_DIGIT_POS] == '0'));
          ok = ( EOF != sscanf( param_str, "%03d%03d", &mcc, &mnc ) );
          QCRIL_LOG_INFO("mcc = %d, mnc = %d, rat = %d\n", mcc, mnc, rat);
      }
      else
      {
          ok = FALSE;
          mcc = NAS_NIL;
          mnc = NAS_NIL;
          pcs_digit_present = FALSE;
      }

      qcril_qmi_util_initiate_network_selection_check(msg, FALSE, mcc, mnc, ok, pcs_digit_present, (RIL_RadioTechnology) rat );
  }
} // qcril_qmi_nas_set_network_selection_manual

//===========================================================================
// qcril_qmi_util_initiate_network_selection_check
//===========================================================================
void qcril_qmi_util_initiate_network_selection_check(std::shared_ptr<QcRilRequestMessage> msg, int is_automatic, int mcc, int mnc, int move_on,int pcs_digit_present, RIL_RadioTechnology rat)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_ril_nas_nw_select_state_e_type cur_nw_select_state;

    QCRIL_LOG_INFO( "entry, is_auto %d, mcc %d, mnc %d, move_on %d, pcs_digit_present %d rat %d", (int) is_automatic, (int) mcc, (int) mnc, (int) move_on, (int) pcs_digit_present, rat );

    cur_nw_select_state = qcril_qmi_nas_get_nw_select_state();
    QCRIL_LOG_INFO( ".. cur nw select state %d ", (int) cur_nw_select_state );
    if ( QMI_RIL_NAS_NW_SELECT_NONE != cur_nw_select_state )
    {
        QCRIL_LOG_INFO( "clean up existing network selection request");
        qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_CANCELLING_REQ );
        qcril_qmi_nas_nw_select_handle_total_cleanup();
    }

    // Cleanup if any on going request (including manually and automatically network selection)
    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestSetNetworkSelectionManualMessage::get_class_message_id());
    if (!pendingMsg)
    {
        pendingMsg = msgList.find(RilRequestSetNetworkSelectionAutoMessage::get_class_message_id());
    }
    if (pendingMsg)
    {
        QCRIL_LOG_INFO("clean up existing network selection request");
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                RIL_E_CANCELLED, nullptr);
        auto selectMsg = std::static_pointer_cast<QcRilRequestMessage>(pendingMsg);
        selectMsg->sendResponse(selectMsg, Message::Callback::Status::SUCCESS, respData);
        msgList.erase(pendingMsg);
    }

    // Queue the new msg into the PendingMessageList
    auto ret = msgList.insert(msg);
    if (!ret.second)
    {
        res = RIL_E_INTERNAL_ERR;
        QCRIL_LOG_ERROR("Failed to to queue the message: %s", msg->dump().c_str());
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                res, nullptr);
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    }
    else
    {
        res = qcril_qmi_util_initiate_network_selection(msg, is_automatic, mcc, mnc, move_on, pcs_digit_present, rat);
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET( (int)res );
} // qcril_qmi_util_initiate_network_selection_check


//===========================================================================
// qcril_qmi_util_initiate_network_selection
//===========================================================================
RIL_Errno qcril_qmi_util_initiate_network_selection(std::shared_ptr<QcRilRequestMessage> msg, int is_automatic, int mcc, int mnc, int move_on,int pcs_digit_present, RIL_RadioTechnology rat)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    nas_set_system_selection_preference_req_msg_v01 qmi_request;
    nas_get_system_selection_preference_resp_msg_v01 qmi_get_mode_pref_response;
    qmi_client_error_type qmi_client_error;
    qmi_ril_nas_nw_select_state_e_type cur_nw_select_state;
    char current_mcc_str[NAS_MCC_MNC_MAX_SIZE],current_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    qmi_client_error_type qmi_error = QMI_ERR_NONE_V01;
    nas_radio_if_enum_v01 current_rat = NAS_RADIO_IF_NO_SVC_V01;

    QCRIL_LOG_INFO( "entry, is_auto %d, mcc %d, mnc %d, move_on %d, pcs_digit_present %d, rat %d ", (int) is_automatic, (int) mcc, (int) mnc, (int) move_on, (int) pcs_digit_present, rat );

    do
    {
        if ( !move_on )
        {
          QCRIL_LOG_ERROR("Invalid arguments..move_on is false");
          res = RIL_E_INVALID_ARGUMENTS;
          break;
        }

        if ( !qcril_qmi_nas_dms_is_in_online_mode())
        {
          QCRIL_LOG_ERROR("Not proper modem operating state");
          res = RIL_E_INVALID_STATE;
          break;
        }

        // fetch cur pref
        if ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref ) )
        {
            qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                   NULL,
                                                   NAS_ZERO, // empty payload
                                                   (void*) &qmi_get_mode_pref_response,
                                                   sizeof( qmi_get_mode_pref_response ),
                                                   ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
            res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, &qmi_get_mode_pref_response.resp);
            QCRIL_LOG_INFO( ".. mode_pref cache sub fetch val %d ", (int) res  );
            if ( RIL_E_SUCCESS == res )
            {
                NAS_CACHE_LOCK();
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.mode_pref, qmi_get_mode_pref_response.mode_pref );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_disable_cause, qmi_get_mode_pref_response.lte_disable_cause );
                NAS_CACHE_UNLOCK();
                QCRIL_LOG_INFO( ".. mode_pref cache sub fetch ok " );
            }
        }
        else
        {
            res = RIL_E_SUCCESS;
        }
        if ( RIL_E_SUCCESS != res )
            break;


        // set direction
        res = qcril_qmi_nas_set_nw_select_state(QMI_RIL_NAS_NW_SELECT_WAKING_UP);
        QCRIL_LOG_INFO( ".. set nw sel state %d ", (int) res  );
        if ( RIL_E_SUCCESS != res )
            break;

        qcril_qmi_nas_set_nw_select_state(QMI_RIL_NAS_NW_SELECT_SETTING_PREF); // this may not fail

        // initiate request

        memset( &qmi_request, 0, sizeof(qmi_request) );
        qmi_request.net_sel_pref_valid = TRUE;
        qmi_request.net_sel_pref.net_sel_pref = is_automatic ? NAS_NET_SEL_PREF_AUTOMATIC_V01 : NAS_NET_SEL_PREF_MANUAL_V01;
        if ( !is_automatic )
        {
            qmi_request.net_sel_pref.mcc = mcc;
            qmi_request.net_sel_pref.mnc = mnc;

            if( TRUE == pcs_digit_present )
            {
                qmi_request.mnc_includes_pcs_digit_valid = TRUE;
                qmi_request.mnc_includes_pcs_digit = TRUE;
            }
            NAS_CACHE_LOCK();
            nas_cached_info.nw_select_is_manual = TRUE;
            snprintf( nas_cached_info.nw_select_manual_mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)mcc );
            if ( (mnc > 99) ||  TRUE == pcs_digit_present )
            {
                snprintf( nas_cached_info.nw_select_manual_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)mnc );
            }
            else
            {
                snprintf( nas_cached_info.nw_select_manual_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int)mnc );
            }

            QCRIL_LOG_INFO( ".. mode_pref cache valid %d ", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref)  );

            if( RADIO_TECH_UNKNOWN != rat )
            {
                if ( !qmi_ril_is_rat_tlv_support_available() )
                {
                    qmi_request.mode_pref_valid = TRUE;
                    qmi_request.mode_pref = qcril_qmi_nas2_convert_rat_to_mode_pref(rat);
                    nas_cached_info.nw_select_manual_rat = qcril_qmi_nas2_convert_qcril_rat_to_qmi_rat(rat);
                    QCRIL_LOG_INFO( ".. requesting mode_pref valid %d, value %d",
                                    (int) qmi_request.mode_pref_valid,qmi_request.mode_pref );
                    if ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref) || qmi_request.mode_pref != nas_cached_info.mode_pref ||
                         (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_disable_cause) &&
                          (NAS_LTE_DISABLE_CAUSE_DOM_SEL_V01 == nas_cached_info.lte_disable_cause ||
                           NAS_LTE_DISABLE_CAUSE_DAM_V01 == nas_cached_info.lte_disable_cause))
                       )
                    {
                        nas_cached_info.nw_select_is_current = FALSE;
                        if ( ( nas_common_info.is_restore_prev_mode_pref )
                                && NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref) )
                        {
                            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prev_mode_pref, nas_cached_info.mode_pref );
                        }
                        else
                        {
                            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
                        }
                    }
                    else
                    {
                        // if the request mode_pref is the same as the previous one, no need to restore
                        NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
                    }
                }
                else
                {
                    qmi_request.rat_valid = TRUE;
                    qmi_request.rat = qcril_qmi_nas2_convert_qcril_rat_to_qmi_rat(rat);
                    nas_cached_info.nw_select_manual_rat = qmi_request.rat;
                }
            }

            if( qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, TRUE, &current_rat) )
            {
                QCRIL_LOG_INFO( "checking selected network is current or not - current_mcc=%s current_mnc=%s selected_mcc=%s selected_mnc=%s",current_mcc_str,current_mnc_str,
                                nas_cached_info.nw_select_manual_mcc_str,nas_cached_info.nw_select_manual_mnc_str);
                QCRIL_LOG_INFO( "checking selected network is current or not - current_rat=%d, selected_rat=%d", current_rat, nas_cached_info.nw_select_manual_rat);
                nas_cached_info.nw_select_is_current = (!strcmp(current_mcc_str,nas_cached_info.nw_select_manual_mcc_str) &&
                                                        !strcmp(current_mnc_str,nas_cached_info.nw_select_manual_mnc_str) &&
                                                        ((nas_cached_info.nw_select_manual_rat == NAS_RADIO_IF_NO_SVC_V01) || (nas_cached_info.nw_select_manual_rat == current_rat)));
            }

            NAS_CACHE_UNLOCK();
        }

        qmi_client_error = qmi_client_nas_send_async(QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                      &qmi_request,
                                                      sizeof(qmi_request),
                                                      sizeof(nas_set_system_selection_preference_resp_msg_v01),
                                                      qcril_qmi_nas_set_nw_selection_command_cb,
                                                      NULL);
        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );
        QCRIL_LOG_INFO("QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01 req sent error=%d",res);

    } while (FALSE);

    if ( RIL_E_SUCCESS != res )
    { // not done -- rollback
        cur_nw_select_state = qcril_qmi_nas_get_nw_select_state();
        QCRIL_LOG_INFO( ".. rolling back res, state %d, %d ", (int) res, (int) cur_nw_select_state );
        if ( QMI_RIL_NAS_NW_SELECT_AWAKEN == cur_nw_select_state )
        {
            qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_ROLLBACK );
        }

        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                res, nullptr);
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
        getNasModule().getPendingMessageList().erase(msg);
        // wave voice data status
        qcril_qmi_nas_wave_voice_data_status();
    }

    QCRIL_LOG_INFO( "completion, res %d ", (int) res );

    return res;
} // qcril_qmi_util_initiate_network_selection

//===========================================================================
// qcril_qmi_nas_restore_modem_pref
//===========================================================================
void qcril_qmi_nas_restore_modem_pref()
{
  qmi_client_error_type qmi_client_error;
  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_get_system_selection_preference_resp_msg_v01 qmi_response;
  RIL_Errno res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    memset( &qmi_request, 0, sizeof(qmi_request) );
    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.prev_mode_pref) )
    {
      QCRIL_LOG_INFO( "reset mode to %d", nas_cached_info.prev_mode_pref );
      qmi_request.mode_pref = nas_cached_info.prev_mode_pref;
      qmi_request.mode_pref_valid = TRUE;
    }
    NAS_CACHE_UNLOCK();

    if ( !qmi_request.mode_pref_valid )
    {
      QCRIL_LOG_ERROR("no saved previous mode preference");
      break;
    }

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                  &qmi_request,
                                                  sizeof( qmi_request ),
                                                  (void*) &qmi_response,
                                                  sizeof( qmi_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
    if ( RIL_E_SUCCESS != res )
    {
      QCRIL_LOG_INFO( ".. fail to set mode back to %d ", qmi_request.mode_pref );
    }

    NAS_CACHE_LOCK();
    NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
    NAS_CACHE_UNLOCK();

  } while (0);

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_set_nw_selection_command_cb
//===========================================================================
void qcril_qmi_nas_set_nw_selection_command_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    nas_set_system_selection_preference_resp_msg_v01 * res_holder;
    RIL_Errno                                          ril_req_res;
    qmi_ril_nas_nw_select_state_e_type                 cur_state;

    QCRIL_NOTUSED(msg_id);
    QCRIL_NOTUSED(resp_cb_data);
    QCRIL_NOTUSED(resp_c_struct_len);

    do
    {
        if (!resp_c_struct) {
           QCRIL_LOG_ERROR("Invalid parameter resp_c_struct is NULL, aborting!");
           QCRIL_ASSERT(0);
           break;
        }

        res_holder = (nas_set_system_selection_preference_resp_msg_v01 *) resp_c_struct.get();
        QCRIL_LOG_INFO( "trans_err, resp.err  %d, %d ", (int) transp_err, (int) res_holder->resp.error );

        cur_state = qcril_qmi_nas_get_nw_select_state();
        QCRIL_LOG_INFO( ".. nw sel state %d", (int) cur_state );

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &res_holder->resp );
        QCRIL_LOG_INFO( ".. set pref res %d, %d, %d ", (int) transp_err, (int) res_holder->resp.error, (int) ril_req_res );

        switch ( cur_state )
        {
            case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
            case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
            case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
                NAS_CACHE_LOCK();
                nas_cached_info.nw_select_nw_set_pref_ackd   = TRUE;
                nas_cached_info.nw_select_nw_set_pref_result = ril_req_res;
                NAS_CACHE_UNLOCK();
                if ( QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state )
                {
                    qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_AWAITING_REG );
                }
                qcril_qmi_nas_select_nw_conclusion_check();
                break;

            default: // skip
                break;
        }
    } while(0);

    QCRIL_LOG_FUNC_RETURN();

}  // qcril_qmi_nas_set_nw_selection_command_cb

//===========================================================================
// qcril_qmi_nas_wave_voice_data_status
//===========================================================================
void qcril_qmi_nas_wave_voice_data_status()
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO("qcril_qmi_nas_wave_voice_data_status");
    auto msg = std::make_shared<RilUnsolNetworkStateChangedMessage>();
    Dispatcher::getInstance().dispatchSync(msg);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_wave_voice_data_status

//===========================================================================
// RIL_REQUEST_SCREEN_STATE
//===========================================================================
void qcril_qmi_nas_request_screen_state
(
  std::shared_ptr<RilRequestScreenStateMessage> msg
)
{
  QCRIL_LOG_FUNC_ENTRY();

  auto operational_state = qmi_ril_get_operational_status();
  auto enable = msg->getState();
  QCRIL_LOG_INFO( ".. SCREEN_STATE commands to enable %d, while operation state %d ", (int) enable, operational_state );

  NAS_CACHE_LOCK();
  nas_common_info.is_screen_off = enable ? FALSE : TRUE;
  NAS_CACHE_UNLOCK();

  switch ( operational_state )
  {
      case QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING: // fallthrough
      case QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED: // fallthrough
      case QMI_RIL_GEN_OPERATIONAL_STATUS_RESUMING:
          qmi_ril_nwreg_common_ind_subscribe_consider_action_handler();
          break;

      default:
          // no action, just track UI's SCREEN_STATE
          break;
  }

  // ** respond
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_SUCCESS, nullptr));
} // qcril_qmi_nas_request_screen_state

//===========================================================================
// RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER
//===========================================================================
void qcril_qmi_nas_request_set_unsol_response_filter
(
  std::shared_ptr<RilRequestSetUnsolRespFilterMessage> msg
)
{
  RIL_Errno                            ril_req_res;
  int                                  unsol_response_filter;
  bool                                 enable_signal_strength_notification;
  bool                                 toggle_signal_strength_notification = false;
  bool                                 enable_full_network_state_notification;
  bool                                 toggle_full_network_state_notification = false;
  bool                                 enable_data_dormancy_notification;
  bool                                 toggle_data_dormancy_notification = false;
  bool                                 enable_lce_notification = false;
  qmi_ril_gen_operational_status_type  operational_state;

  QCRIL_LOG_FUNC_ENTRY();

  if (msg)
  {
    operational_state = qmi_ril_get_operational_status();
    unsol_response_filter = msg->getIndicationFilter();
    if ( unsol_response_filter > ( RIL_UR_SIGNAL_STRENGTH +
                                   RIL_UR_FULL_NETWORK_STATE +
                                   RIL_UR_DATA_CALL_DORMANCY_CHANGED +
                                   RIL_UR_LINK_CAPACITY_ESTIMATE) )
    {
      ril_req_res = RIL_E_INVALID_ARGUMENTS;
    }
    else
    {
      enable_signal_strength_notification =
        (bool) (unsol_response_filter & RIL_UR_SIGNAL_STRENGTH);
      enable_full_network_state_notification =
        (bool) (unsol_response_filter & RIL_UR_FULL_NETWORK_STATE);
      enable_data_dormancy_notification =
        (bool) (unsol_response_filter & RIL_UR_DATA_CALL_DORMANCY_CHANGED);
      //LINK_CAPACITY_ESTIMATE is handled by DataModule; a
      //SetLinkCapFilterMessage is dispatched to DataModule and response
      //posted from NasDataSetLinkCapRptFilterCallback::onResponse
      enable_lce_notification =
        (bool) (unsol_response_filter & RIL_UR_LINK_CAPACITY_ESTIMATE);

      NAS_CACHE_LOCK();
      if ( enable_signal_strength_notification !=
             nas_common_info.unsol_response_filter.signal_strength_notification_enabled )
      {
        nas_common_info.unsol_response_filter.signal_strength_notification_enabled =
          enable_signal_strength_notification;
        toggle_signal_strength_notification = true;
      }

      if ( enable_full_network_state_notification !=
            nas_common_info.unsol_response_filter.full_network_state_notification_enabled )
      {
        nas_common_info.unsol_response_filter.full_network_state_notification_enabled =
          enable_full_network_state_notification;
        toggle_full_network_state_notification = true;
      }

      if ( enable_data_dormancy_notification !=
            nas_common_info.unsol_response_filter.data_call_dormancy_notification_enabled )
      {
        nas_common_info.unsol_response_filter.data_call_dormancy_notification_enabled =
          enable_data_dormancy_notification;
        toggle_data_dormancy_notification = true;
      }
      NAS_CACHE_UNLOCK();

      if ( toggle_signal_strength_notification )
      {
        QCRIL_LOG_INFO( "Signal strength notification is being %s.",
                        enable_signal_strength_notification ? "enabled" : "disabled" );
      }

      if ( toggle_full_network_state_notification )
      {
        QCRIL_LOG_INFO( "Full network state notification is being %s.",
                        enable_full_network_state_notification ? "enabled" : "disabled" );
      }

      if ( toggle_data_dormancy_notification )
      {
        QCRIL_LOG_INFO( "Data call dormancy notification is being %s.",
                        enable_data_dormancy_notification ? "enabled" : "disabled" );
      }

      if ( toggle_signal_strength_notification ||
           toggle_full_network_state_notification ||
           toggle_data_dormancy_notification )
      {
        switch ( operational_state )
        {
          case QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING: // fallthrough
          case QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED: // fallthrough
          case QMI_RIL_GEN_OPERATIONAL_STATUS_RESUMING:
            qmi_ril_nwreg_common_ind_subscribe_consider_action_handler();
            break;
          default:
            break;
        }
      }
      ril_req_res = RIL_E_SUCCESS;
    }
  }
  else
  {
    ril_req_res = RIL_E_INVALID_ARGUMENTS;
    QCRIL_LOG_ERROR("msg is null.");
  }

  if(ril_req_res == RIL_E_SUCCESS)
  {
    //LINK_CAPACITY_ESTIMATE is handled by DataModule; a
    //SetLinkCapFilterMessage is dispatched to DataModule and response
    //posted from callback
    rildata::ReportFilter_t f = enable_lce_notification ? rildata::ReportFilter_t::enabled
                                                        : rildata::ReportFilter_t::disabled;
    auto linkCapFilterMsg = std::make_shared<rildata::SetLinkCapFilterMessage>(nullptr, f);
    if (linkCapFilterMsg != nullptr) {
      GenericCallback<int> cb([msg](std::shared_ptr<Message> /*solMsg*/,
                                    Message::Callback::Status status,
                                    std::shared_ptr<int> resp) -> void {
        RIL_Errno errorCode = RIL_E_INTERNAL_ERR;
        std::shared_ptr<qcril::interfaces::Registration> respData = nullptr;
        if (status == Message::Callback::Status::SUCCESS && resp != nullptr) {
          if (*resp == 0) {
            errorCode = RIL_E_SUCCESS;
          }
        }
        QCRIL_LOG_DEBUG("SetLinkCapFilterMessage cb: errorCode = %d", errorCode);
        msg->sendResponse(
            msg, Message::Callback::Status::SUCCESS,
            std::make_shared<QcRilRequestMessageCallbackPayload>(errorCode, nullptr));
      });
      linkCapFilterMsg->setCallback(&cb);
      linkCapFilterMsg->dispatch();
    }
  }
  else
  {
    //an error happened, cannnot continue, send response now
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET( (int) ril_req_res );
} // qcril_qmi_nas_request_set_unsol_response_filter

//===========================================================================
// RIL_REQUEST_SEND_DEVICE_STATE
//===========================================================================
void qcril_qmi_nas_request_send_device_state
(
  std::shared_ptr<RilRequestSendDeviceStateMessage> msg
)
{
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_LOG_INFO( "Device State Type: %d, Requested State: %d",
        msg->getType(), msg->getValue());

  // no operation for now

  // ** respond
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_SUCCESS, nullptr));

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_request_send_device_state

//===========================================================================
//qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl
//===========================================================================
void qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl( void )
{
  qcril_data_limited_sys_ind_switch_type limited_data_sys_ind_switch;
  int res = 0;
  int action_needed;

  NAS_CACHE_LOCK();
  if (nas_common_info.data_limited_sys_ind_toggle)
  {
    action_needed = TRUE;
  }
  else
  {
    action_needed = FALSE;
  }
#if (QCRIL_RIL_VERSION < 15)
  limited_data_sys_ind_switch = nas_common_info.is_screen_off ? LIMITED_SYS_INDICATIONS_ON : LIMITED_SYS_INDICATIONS_OFF;
#else
  limited_data_sys_ind_switch =
    nas_common_info.unsol_response_filter.full_network_state_notification_enabled ? LIMITED_SYS_INDICATIONS_OFF : LIMITED_SYS_INDICATIONS_ON;
#endif
  NAS_CACHE_UNLOCK();

  if (action_needed)
  {
#ifndef QMI_RIL_UTF
    std::shared_ptr<rildata::ToggleLimitedSysIndMessage> msg =
        std::make_shared<rildata::ToggleLimitedSysIndMessage>(limited_data_sys_ind_switch);
    if(msg)
    {
        msg->dispatch();
    }
    QCRIL_LOG_INFO( ".. data limited sys indications req: %d, res: %d", (int)limited_data_sys_ind_switch, res );
#endif
  }

} // qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl

//===========================================================================
//qmi_ril_nwreg_enforce_voice_ind_as_applicable_ncl
//===========================================================================

void qmi_ril_nwreg_enforce_voice_ind_as_applicable_ncl( void )
{
  boolean enable = TRUE;

  NAS_CACHE_LOCK();
#if (QCRIL_RIL_VERSION < 15)
  enable = nas_common_info.is_screen_off ? FALSE : TRUE;
#else
  enable = nas_common_info.unsol_response_filter.full_network_state_notification_enabled ? TRUE: FALSE;
#endif
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO( ".. enable = %d", enable);

  qcril_qmi_voice_enable_voice_indications(enable);
} // qmi_ril_nwreg_enforce_voice_ind_as_applicable_ncl


//===========================================================================
//qmi_ril_nwreg_enforce_data_dormancy_as_applicable
//===========================================================================
void qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl( void )
{
    int                                   action_needed;
    qcril_data_dormancy_ind_switch_type   data_dormancy_switch;
    int                                   is_currently_online;
    int                                   data_dormancy_res = 0;

    action_needed = FALSE;

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
    }
    else
    {
        is_currently_online  = TRUE; // assumed
    }

    //If true receive data dormancy ind based on screen state,
    //data call dormancy notification filter and modem status.
    if ( QMI_RIL_NAS_RECEIVE_DATA_DORMANCY_IND_ON_SCREEN_STATE ==
         nas_common_info.receive_data_dormancy_ind)
    {
        if ( is_currently_online )
        { // online
#if (QCRIL_RIL_VERSION < 15)
            data_dormancy_switch = nas_common_info.is_screen_off ? DORMANCY_INDICATIONS_OFF :
                                                                   DORMANCY_INDICATIONS_ON;
            nas_common_info.data_dormancy_ind_enabled = nas_common_info.is_screen_off ? FALSE :
                                                                                        TRUE;
#else
            data_dormancy_switch = nas_common_info.unsol_response_filter.data_call_dormancy_notification_enabled ? DORMANCY_INDICATIONS_ON : DORMANCY_INDICATIONS_OFF;
            nas_common_info.data_dormancy_ind_enabled = nas_common_info.unsol_response_filter.data_call_dormancy_notification_enabled ? TRUE : FALSE;
#endif
            action_needed = TRUE;
        }
        else
        { // LPM etc
            if ( nas_common_info.data_dormancy_ind_enabled )
            { // ind enabled
                data_dormancy_switch                      = DORMANCY_INDICATIONS_OFF;
                action_needed                             = TRUE;
                nas_common_info.data_dormancy_ind_enabled = FALSE;
            }
            else
            { // already disabled
                action_needed        = FALSE;
            }
        }
    }
    // If true, receive dormancy indication only based on modem status only.
    else if(QMI_RIL_NAS_RECEIVE_DATA_DORMANCY_IND_ON ==
            nas_common_info.receive_data_dormancy_ind)
    {
        if ( is_currently_online )
        { // online
            if ( !nas_common_info.data_dormancy_ind_enabled)
            { // no ind enabled
                data_dormancy_switch                        = DORMANCY_INDICATIONS_ON;
                action_needed                               = TRUE;
                nas_common_info.data_dormancy_ind_enabled   = TRUE;
            }
            else
            { // already enabled
                action_needed        = FALSE;
            }
        }
        else
        { // LPM etc
            if ( nas_common_info.data_dormancy_ind_enabled )
            { // still enabled
                data_dormancy_switch                        = DORMANCY_INDICATIONS_OFF;
                action_needed                               = TRUE;
                nas_common_info.data_dormancy_ind_enabled   = FALSE;
            }
            else
            { // already disabled
                action_needed        = FALSE;
            }
        }
    }
    NAS_CACHE_UNLOCK();
    if ( action_needed )
    {
#ifndef QMI_RIL_UTF
        std::shared_ptr<rildata::ToggleDormancyIndMessage> msg =
            std::make_shared<rildata::ToggleDormancyIndMessage>(data_dormancy_switch);
        if(msg)
        {
            msg->dispatch();
        }
        QCRIL_LOG_INFO( ".. data dormancy req %d, %d", (int)data_dormancy_switch, (int)data_dormancy_res );
#endif
    }
} // qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl

//===========================================================================
// qcril_qmi_nas_disable_data_dormancy_indication
//===========================================================================
void qcril_qmi_nas_disable_data_dormancy_indication(void)
{
    int                                   data_dormancy_res = 0;
    qcril_data_dormancy_ind_switch_type   data_dormancy_switch;

    NAS_CACHE_LOCK();
    nas_common_info.data_dormancy_ind_enabled = FALSE;
    NAS_CACHE_UNLOCK();
    data_dormancy_switch = DORMANCY_INDICATIONS_OFF;

#ifndef QMI_RIL_UTF
    std::shared_ptr<rildata::ToggleDormancyIndMessage> msg =
            std::make_shared<rildata::ToggleDormancyIndMessage>(data_dormancy_switch);
    if(msg)
    {
        msg->dispatch();
    }
    QCRIL_LOG_INFO( "setting data_dormancy_switch to %d, result is %d", (int)data_dormancy_switch, (int)data_dormancy_res );
#endif
} // qcril_qmi_nas_disable_data_dormancy_indication

//===========================================================================
//qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search
//===========================================================================
void qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search( void )
{
    int                                   is_currently_online;
    int                                   enable_nwreg_indications;
    int                                   enable_signal_strength_indications;
    int                                   action_needed;
    int                                   action_needed_for_pbm;

    action_needed = FALSE;
    action_needed_for_pbm = FALSE;

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
    }
    else
    {
        is_currently_online  = TRUE; // assumed
    }
    if ( is_currently_online )
    { // modem online
#if (QCRIL_RIL_VERSION < 15)
        enable_nwreg_indications                         = nas_common_info.is_screen_off ? FALSE : TRUE;
        enable_signal_strength_indications               = enable_nwreg_indications;
#else
        // RIL_REQUEST_SCREEN_STATE is deprecated beginning in RIL version 15,
        // and the value of nas_common_info.is_screen_off cannot be relied upon.
        enable_nwreg_indications                         = nas_common_info.unsol_response_filter.full_network_state_notification_enabled ? TRUE : FALSE;
        enable_signal_strength_indications               = nas_common_info.unsol_response_filter.signal_strength_notification_enabled ? TRUE : FALSE;
#endif
        nas_cached_info.common_indications_is_subscribed = ( enable_nwreg_indications || enable_signal_strength_indications );
        action_needed                                    = TRUE;
    }
    else
    { // in LPM etc
        if ( nas_cached_info.common_indications_is_subscribed )
        {
            enable_nwreg_indications                         = FALSE;
            enable_signal_strength_indications               = FALSE;
            nas_cached_info.common_indications_is_subscribed = FALSE;
            action_needed                                    = TRUE;
        }
        enable_nwreg_indications           = FALSE;
        enable_signal_strength_indications = FALSE;
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(
        ".. action needed %d, action_needed_for_pbm %d, enable_nwreg_indications %d, enable_signal_strength_indications %d, is_online %d ",
        action_needed, action_needed_for_pbm, enable_nwreg_indications, enable_signal_strength_indications, is_currently_online );

    if ( action_needed )
    {
        // For insignificant fields (like PBM indication) that is not controlled explicitly
        // by this request, enable it if network state or signal streangh is enabled
        qcril_qmi_nas_send_enable_indications( enable_nwreg_indications || enable_signal_strength_indications );

        (void) qcril_qmi_util_enable_networking_indications(
                   enable_nwreg_indications,
                   enable_signal_strength_indications,
                   enable_nwreg_indications || enable_signal_strength_indications
               );
    }

    if ( action_needed && ( enable_nwreg_indications || enable_signal_strength_indications ) && is_currently_online )
    {
        if( nas_common_info.force_nw_search )
        {
            qcril_qmi_nas_force_network_search();
        }
    }

} // qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search


//===========================================================================
//qcril_qmi_nas_force_network_search
//===========================================================================
void qcril_qmi_nas_force_network_search()
{
    QCRIL_LOG_FUNC_ENTRY();

    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_force_network_search_resp_msg_v01 qmi_response;
    qmi_client_error_type qmi_transport_error;


    memset(&qmi_response,0,sizeof(qmi_response));
    qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_FORCE_NETWORK_SEARCH_REQ_MSG_V01,
                                                     NULL,
                                                     NAS_NIL,
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);

    QCRIL_LOG_INFO("msg send error code %d, nas result %d, nas error code %d",ril_req_res,qmi_response.resp.result,qmi_response.resp.error);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_force_network_search


/*===========================================================================
  qcril_qmi_nas_populate_sig_config_delta_info
============================================================================*/
void qcril_qmi_nas_populate_sig_config_delta_info()
{
    QCRIL_LOG_FUNC_ENTRY();

    if ( qcril_db_query_sig_config("cdma_ecio_delta",&nas_common_info.sig_config.cdma_ecio_delta) ||
         nas_common_info.sig_config.cdma_ecio_delta == 0 )
    {
       nas_common_info.sig_config.cdma_ecio_delta = QMI_RIL_NAS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("cdma_rssi_delta",&nas_common_info.sig_config.cdma_rssi_delta)||
        nas_common_info.sig_config.cdma_rssi_delta == 0 )
    {
        nas_common_info.sig_config.cdma_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("gsm_rssi_delta",&nas_common_info.sig_config.gsm_rssi_delta) ||
        nas_common_info.sig_config.gsm_rssi_delta == 0 )
    {
        nas_common_info.sig_config.gsm_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("hdr_ecio_delta",&nas_common_info.sig_config.hdr_ecio_delta) ||
        nas_common_info.sig_config.hdr_ecio_delta == 0 )
    {
        nas_common_info.sig_config.hdr_ecio_delta = QMI_RIL_NAS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("hdr_rssi_delta",&nas_common_info.sig_config.hdr_rssi_delta) ||
        nas_common_info.sig_config.hdr_rssi_delta == 0 )
    {
        nas_common_info.sig_config.hdr_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("hdr_sinr_delta",&nas_common_info.sig_config.hdr_sinr_delta) ||
        nas_common_info.sig_config.hdr_sinr_delta == 0 )
    {
        nas_common_info.sig_config.hdr_sinr_delta = QMI_RIL_NAS_SINR_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_rsrp_delta",&nas_common_info.sig_config.lte_rsrp_delta) ||
        nas_common_info.sig_config.lte_rsrp_delta == 0 )
    {
        nas_common_info.sig_config.lte_rsrp_delta = QMI_RIL_NAS_RSRP_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_rsrq_delta",&nas_common_info.sig_config.lte_rsrq_delta) ||
        nas_common_info.sig_config.lte_rsrq_delta == 0 )
    {
        nas_common_info.sig_config.lte_rsrq_delta = QMI_RIL_NAS_RSRQ_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_rssi_delta",&nas_common_info.sig_config.lte_rssi_delta) ||
        nas_common_info.sig_config.lte_rssi_delta == 0 )
    {
        nas_common_info.sig_config.lte_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_snr_delta",&nas_common_info.sig_config.lte_snr_delta) ||
        nas_common_info.sig_config.lte_snr_delta == 0 )
    {
        nas_common_info.sig_config.lte_snr_delta = QMI_RIL_NAS_SNR_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_rpt_rate",&nas_common_info.sig_config.lte_rpt_rate) ||
        nas_common_info.sig_config.lte_rpt_rate == 0 )
    {
        nas_common_info.sig_config.lte_rpt_rate = NAS_LTE_SIG_RPT_RATE_3_SEC_V01;
    }
    if ( qcril_db_query_sig_config("lte_avg_period",&nas_common_info.sig_config.lte_avg_period) ||
        nas_common_info.sig_config.lte_avg_period == 0 )
    {
        nas_common_info.sig_config.lte_avg_period = NAS_LTE_SIG_AVG_PRD_5_SEC_V01;
    }
    if ( qcril_db_query_sig_config("tdscdma_ecio_delta",&nas_common_info.sig_config.tdscdma_ecio_delta) ||
        nas_common_info.sig_config.tdscdma_ecio_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_ecio_delta = QMI_RIL_NAS_TDS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("tdscdma_rscp_delta",&nas_common_info.sig_config.tdscdma_rscp_delta) ||
        nas_common_info.sig_config.tdscdma_rscp_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_rscp_delta = QMI_RIL_NAS_RSCP_DELTA;
    }
    if ( qcril_db_query_sig_config("tdscdma_rssi_delta",&nas_common_info.sig_config.tdscdma_rssi_delta) ||
        nas_common_info.sig_config.tdscdma_rssi_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_rssi_delta = QMI_RIL_NAS_TDS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("tdscdma_sinr_delta",&nas_common_info.sig_config.tdscdma_sinr_delta) ||
        nas_common_info.sig_config.tdscdma_sinr_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_sinr_delta = QMI_RIL_NAS_SINR_DELTA;
    }
    if ( qcril_db_query_sig_config("wcdma_ecio_delta",&nas_common_info.sig_config.wcdma_ecio_delta) ||
        nas_common_info.sig_config.wcdma_ecio_delta == 0 )
    {
        nas_common_info.sig_config.wcdma_ecio_delta = QMI_RIL_NAS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("wcdma_rssi_delta",&nas_common_info.sig_config.wcdma_rssi_delta) ||
        nas_common_info.sig_config.wcdma_rssi_delta == 0 )
    {
        nas_common_info.sig_config.wcdma_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }

    // 5G
    if (qcril_db_query_sig_config("nr5g_rsrp_delta", &nas_common_info.sig_config.nr5g_rsrp_delta) ||
        nas_common_info.sig_config.nr5g_rsrp_delta == 0)
    {
        nas_common_info.sig_config.nr5g_rsrp_delta = QMI_RIL_NAS_RSRP_DELTA;
    }

    if (qcril_db_query_sig_config("nr5g_snr_delta", &nas_common_info.sig_config.nr5g_snr_delta) ||
        nas_common_info.sig_config.nr5g_snr_delta == 0)
    {
        nas_common_info.sig_config.nr5g_snr_delta = QMI_RIL_NAS_SNR_DELTA;
    }

    if (qcril_db_query_sig_config("nr5g_rpt_rate", &nas_common_info.sig_config.nr5g_rpt_rate) ||
        nas_common_info.sig_config.nr5g_rpt_rate == 0 )
    {
        nas_common_info.sig_config.nr5g_rpt_rate = NR5G_COMMON_RSSI_REPORTING_RATE_3_SEC_V01;
    }

    if (qcril_db_query_sig_config("nr5g_avg_period", &nas_common_info.sig_config.nr5g_avg_period) ||
        nas_common_info.sig_config.nr5g_avg_period == 0 )
    {
        nas_common_info.sig_config.nr5g_avg_period = NR5G_COMMON_RSSI_AVERAGING_PERIOD_5_SEC_V01;
    }

    QCRIL_LOG_FUNC_RETURN();
    return;
}

/*===========================================================================
  qcril_qmi_nas_configure_sig_info2
============================================================================*/
RIL_Errno qcril_qmi_nas_configure_sig_info2()
{
    RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_transport_error;

    QCRIL_LOG_FUNC_ENTRY();

    nas_config_sig_info2_req_msg_v01 *light_indications_sig_info2_qmi_request;
    nas_config_sig_info2_resp_msg_v01 light_indications_sig_info2_qmi_response;

    light_indications_sig_info2_qmi_request = (nas_config_sig_info2_req_msg_v01 *) qcril_malloc( sizeof( *light_indications_sig_info2_qmi_request ) );

    if( light_indications_sig_info2_qmi_request )
    {
        memset( light_indications_sig_info2_qmi_request, 0, sizeof( *light_indications_sig_info2_qmi_request ) );

        light_indications_sig_info2_qmi_request->cdma_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->cdma_ecio_delta = nas_common_info.sig_config.cdma_ecio_delta;

        light_indications_sig_info2_qmi_request->cdma_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->cdma_rssi_delta = nas_common_info.sig_config.cdma_rssi_delta;

        light_indications_sig_info2_qmi_request->gsm_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->gsm_rssi_delta = nas_common_info.sig_config.gsm_rssi_delta;

        light_indications_sig_info2_qmi_request->hdr_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->hdr_ecio_delta = nas_common_info.sig_config.hdr_ecio_delta;

        light_indications_sig_info2_qmi_request->hdr_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->hdr_rssi_delta = nas_common_info.sig_config.hdr_rssi_delta;

        light_indications_sig_info2_qmi_request->hdr_sinr_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->hdr_sinr_delta = nas_common_info.sig_config.hdr_sinr_delta;

        light_indications_sig_info2_qmi_request->lte_rsrp_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_rsrp_delta = nas_common_info.sig_config.lte_rsrp_delta;

        light_indications_sig_info2_qmi_request->lte_rsrq_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_rsrq_delta = nas_common_info.sig_config.lte_rsrq_delta;

        light_indications_sig_info2_qmi_request->lte_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_rssi_delta = nas_common_info.sig_config.lte_rssi_delta;

        light_indications_sig_info2_qmi_request->lte_snr_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_snr_delta = nas_common_info.sig_config.lte_snr_delta;

        light_indications_sig_info2_qmi_request->lte_sig_rpt_config_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_sig_rpt_config.rpt_rate = (nas_lte_sig_rpt_rate_enum_type_v01)nas_common_info.sig_config.lte_rpt_rate;
        light_indications_sig_info2_qmi_request->lte_sig_rpt_config.avg_period = (nas_lte_sig_avg_prd_enum_type_v01)nas_common_info.sig_config.lte_avg_period;

        light_indications_sig_info2_qmi_request->tdscdma_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_ecio_delta = (float)nas_common_info.sig_config.tdscdma_ecio_delta;

        light_indications_sig_info2_qmi_request->tdscdma_rscp_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_rscp_delta = nas_common_info.sig_config.tdscdma_rscp_delta;

        light_indications_sig_info2_qmi_request->tdscdma_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_rssi_delta = (float)nas_common_info.sig_config.tdscdma_rssi_delta;

        light_indications_sig_info2_qmi_request->tdscdma_sinr_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_sinr_delta = (float)nas_common_info.sig_config.tdscdma_sinr_delta;

        light_indications_sig_info2_qmi_request->wcdma_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->wcdma_ecio_delta = nas_common_info.sig_config.wcdma_ecio_delta;

        light_indications_sig_info2_qmi_request->wcdma_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->wcdma_rssi_delta = nas_common_info.sig_config.wcdma_rssi_delta;

        light_indications_sig_info2_qmi_request->nr5g_rsrp_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->nr5g_rsrp_delta = nas_common_info.sig_config.nr5g_rsrp_delta;

        light_indications_sig_info2_qmi_request->nr5g_snr_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->nr5g_snr_delta = nas_common_info.sig_config.nr5g_snr_delta;

        light_indications_sig_info2_qmi_request->nr5g_sig_rpt_config_valid = TRUE;
        light_indications_sig_info2_qmi_request->nr5g_sig_rpt_config.rpt_rate = (nas_nr5g_common_rssi_reporting_rate_enum_type_v01)
            nas_common_info.sig_config.nr5g_rpt_rate;
        light_indications_sig_info2_qmi_request->nr5g_sig_rpt_config.avg_period = (nas_nr5g_common_rssi_averaging_period_enum_type_v01)
            nas_common_info.sig_config.nr5g_avg_period;

        qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_CONFIG_SIG_INFO2_REQ_MSG_V01,
                                                         (void*) light_indications_sig_info2_qmi_request,
                                                         sizeof( *light_indications_sig_info2_qmi_request ),
                                                         (void*) &light_indications_sig_info2_qmi_response,
                                                         sizeof( light_indications_sig_info2_qmi_response ),
                                                         ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);


        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &light_indications_sig_info2_qmi_response.resp );
        QCRIL_LOG_INFO( ".. requested nas config info %d, %d", (int)qmi_transport_error, (int)ril_err );
        qcril_free(light_indications_sig_info2_qmi_request);
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_err);
    return ril_err;
}


//===========================================================================
//qcril_qmi_util_enable_networking_indications
//===========================================================================
RIL_Errno qcril_qmi_util_enable_networking_indications( int enable_nwreg, int enable_signal_strength, int force_update )
{
    nas_set_event_report_req_msg_v01 light_indications_qmi_request;
    nas_set_event_report_resp_msg_v01 light_indications_qmi_response;
    nas_indication_register_req_msg_v01 nwreg_indications_qmi_request;
    nas_indication_register_resp_msg_v01 nwreg_indications_qmi_response;
    nas_limit_sys_info_ind_reporting_req_msg_v01 limit_sys_info_qmi_request;
    nas_limit_sys_info_ind_reporting_resp_msg_v01 limit_sys_info_qmi_response;
    nas_config_plmn_name_ind_reporting_req_msg_v01 config_plmn_name_qmi_request;
    nas_config_plmn_name_ind_reporting_resp_msg_v01 config_plmn_name_qmi_response;

    uint8_t enable_nwreg_indications;
    uint8_t enable_signal_strength_indications;

    qmi_client_error_type qmi_transport_error;

    RIL_Errno                        ril_err = RIL_E_GENERIC_FAILURE;
    RIL_Errno                        ril_err_fallback;

    qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
    qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
    int                              any_rte_change;

    int                              is_currently_online;
    uint8_t                          always_enable_action;

    nas_sms_status_enum_type_v01 old_lte_sms_status;
    uint8_t old_lte_sms_status_valid;

    nas_lte_voice_status_enum_type_v01 old_lte_voice_status;
    uint8_t old_lte_voice_status_valid;

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
        always_enable_action = is_currently_online;
    }
    else
    {
        is_currently_online  = TRUE; // assumed
        always_enable_action = TRUE;
    }
    NAS_CACHE_UNLOCK();

    enable_nwreg_indications = ( enable_nwreg && is_currently_online ) ? NAS_REQ_REPORT : NAS_REQ_DO_NOT_REPORT;
    enable_signal_strength_indications = ( enable_signal_strength && is_currently_online ) ? NAS_REQ_REPORT : NAS_REQ_DO_NOT_REPORT;

    QCRIL_LOG_INFO( "%s nwreg indications, %s signal strength indications, action always_enable: %d",
                    enable_nwreg_indications ? "enable" : "disable",
                    enable_signal_strength_indications ? "enable" : "disable",
                    (int) always_enable_action );

#ifndef QMI_RIL_UTF
    if(getNasModule().getSetSignalStrengthCriteriaSupported()) {
        // Do not clobber user settings
        ril_err = RIL_E_SUCCESS;
    } else {
#endif
        ril_err = qcril_qmi_nas_configure_sig_info2();
#ifndef QMI_RIL_UTF
    }
#endif

    // fallback support for reg reject over event_report
    memset( &light_indications_qmi_request, 0, sizeof( light_indications_qmi_request ) );
    light_indications_qmi_request.report_reg_reject_valid = TRUE;
    light_indications_qmi_request.report_reg_reject = TRUE;

    qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_SET_EVENT_REPORT_REQ_MSG_V01,
                                                   (void*) &light_indications_qmi_request,
                                                   sizeof( light_indications_qmi_request ),
                                                   (void*) &light_indications_qmi_response,
                                                   sizeof( light_indications_qmi_response ));

    ril_err_fallback = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &light_indications_qmi_response.resp );
    QCRIL_LOG_INFO( ".. requested nas event report fallback %d, %d", (int)qmi_transport_error, (int)ril_err_fallback ); // fallback err is ignored only logged

    if ( RIL_E_SUCCESS == ril_err )
    {
        // request other inds
        memset( &config_plmn_name_qmi_request, 0, sizeof( config_plmn_name_qmi_request ) );
        memset( &nwreg_indications_qmi_request, 0, sizeof( nwreg_indications_qmi_request ) );

        nwreg_indications_qmi_request.reg_sys_sel_pref_valid  = TRUE;
        nwreg_indications_qmi_request.reg_sys_sel_pref        = TRUE;  // always receive sys sel preference - esp. emergency callback mode change updates

        nwreg_indications_qmi_request.dual_standby_pref_valid = TRUE;
        nwreg_indications_qmi_request.dual_standby_pref       = TRUE; // always receive DSDS indications

        nwreg_indications_qmi_request.subscription_info_valid = TRUE;
        nwreg_indications_qmi_request.subscription_info       = TRUE;

        nwreg_indications_qmi_request.reg_network_time_valid  = TRUE;
        nwreg_indications_qmi_request.reg_network_time        = always_enable_action;  // receive network time update unless in LPM

        nwreg_indications_qmi_request.reg_rtre_cfg_valid      = TRUE;
        nwreg_indications_qmi_request.reg_rtre_cfg            = TRUE;

        nwreg_indications_qmi_request.reg_embms_status_valid  = TRUE;
        nwreg_indications_qmi_request.reg_lte_sib16_network_time_valid = TRUE;

        if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
        {
            nwreg_indications_qmi_request.reg_embms_status           = always_enable_action;
            nwreg_indications_qmi_request.reg_lte_sib16_network_time = always_enable_action;
        }
        else
        {
            nwreg_indications_qmi_request.reg_embms_status            = FALSE;
            nwreg_indications_qmi_request.reg_lte_sib16_network_time  = FALSE;
        }

        nwreg_indications_qmi_request.sig_info_valid = TRUE;
        nwreg_indications_qmi_request.sig_info       = enable_signal_strength_indications;

        nwreg_indications_qmi_request.err_rate_valid = TRUE;
        nwreg_indications_qmi_request.err_rate       = enable_signal_strength_indications;

        nwreg_indications_qmi_request.req_serving_system_valid = TRUE;
        nwreg_indications_qmi_request.req_serving_system       = FALSE;       // always suppress serving system inds when sys_info available

        nwreg_indications_qmi_request.reg_operator_name_data_valid = TRUE;
        nwreg_indications_qmi_request.reg_operator_name_data       = FALSE;   // always suppress operator name data inds when sys_info available

        nwreg_indications_qmi_request.reg_current_plmn_name_valid = TRUE;
        nwreg_indications_qmi_request.reg_current_plmn_name       = enable_nwreg_indications;
        config_plmn_name_qmi_request.send_all_information = TRUE;

        // Enable SSAC indication
        nwreg_indications_qmi_request.reg_ssac_change_info_valid = TRUE;
        nwreg_indications_qmi_request.reg_ssac_change_info = enable_nwreg_indications;

        nwreg_indications_qmi_request.nas_sub_blocked_status_ind_valid = TRUE;
        nwreg_indications_qmi_request.nas_sub_blocked_status_ind = TRUE;

        if ( nas_common_info.add_power_save_enabled )
        {
            nwreg_indications_qmi_request.sys_info_valid = TRUE;
            nwreg_indications_qmi_request.sys_info       = enable_nwreg_indications;
        }
        else if ( is_currently_online )
        {
            nwreg_indications_qmi_request.sys_info_valid = TRUE;
            nwreg_indications_qmi_request.sys_info       = TRUE;

            memset( &limit_sys_info_qmi_request, 0, sizeof( limit_sys_info_qmi_request ) );
            memset( &limit_sys_info_qmi_response, 0, sizeof( limit_sys_info_qmi_response ) );
            limit_sys_info_qmi_request.limit_sys_info_chg_rpt = enable_nwreg_indications ? 0 : NAS_LIMIT_BY_SRV_STATUS_V01 | NAS_LIMIT_BY_SRV_DOMAIN_V01 | NAS_LIMIT_BY_LTE_EMBMS_COVERAGE_V01;

            if(nas_common_info.is_limit_by_rac_change && !enable_nwreg_indications)
            {
                limit_sys_info_qmi_request.limit_sys_info_chg_rpt |= NAS_LIMIT_BY_RAC_V01;
            }

            QCRIL_LOG_INFO( "Requesting nas limit sys info ind reporting [%d].. enable [%d]", limit_sys_info_qmi_request.limit_sys_info_chg_rpt, enable_nwreg_indications );
            qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_LIMIT_SYS_INFO_IND_REPORTING_REQ_MSG_V01,
                                                           &limit_sys_info_qmi_request,
                                                           sizeof( limit_sys_info_qmi_request ),
                                                           (void*) &limit_sys_info_qmi_response,
                                                           sizeof( limit_sys_info_qmi_response ),
                                                           ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
            ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &limit_sys_info_qmi_response.resp );
            QCRIL_LOG_INFO( ".. requested nas limit sys info ind %d, %d", (int)qmi_transport_error, (int)ril_err );

        }

        if( nas_common_info.bar_fake_gcell )
        {
            nwreg_indications_qmi_request.reg_gcell_info_ind_valid = TRUE;
            nwreg_indications_qmi_request.reg_gcell_info_ind = TRUE;
        }

        qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_INDICATION_REGISTER_REQ_MSG_V01,
                                                         (void*) &nwreg_indications_qmi_request,
                                                         sizeof( nwreg_indications_qmi_request ),
                                                         (void*) &nwreg_indications_qmi_response,
                                                         sizeof( nwreg_indications_qmi_response ),
                                                         ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &nwreg_indications_qmi_response.resp );

        QCRIL_LOG_INFO( ".. requested nas indication reports %d, %d", (int)qmi_transport_error, (int)ril_err );

        qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_CONFIG_PLMN_NAME_IND_REPORTING_REQ_MSG_V01,
                                                       (void*) &config_plmn_name_qmi_request,
                                                       sizeof( config_plmn_name_qmi_request ),
                                                       (void*) &config_plmn_name_qmi_response,
                                                       sizeof( config_plmn_name_qmi_response ),
                                                       ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &config_plmn_name_qmi_response.resp );
    }

    if ( ( enable_nwreg_indications || enable_signal_strength_indications ) && RIL_E_SUCCESS == ril_err )
    {
        qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
        qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );
        qcril_qmi_nas_fetch_lte_voice_status( &old_lte_voice_status_valid, &old_lte_voice_status );
        qcril_qmi_nas_fetch_lte_sms_status( &old_lte_sms_status_valid, &old_lte_sms_status);

        // invalidate cache
        NAS_CACHE_LOCK();
        qcril_qmi_nas_drop_nw_info_cache();
        NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_blocked);
        NAS_CACHE_UNLOCK();

        //fetch sub blocked status
        qcril_qmi_nas_fetch_sub_blocked_status();

        // refetch what we can refetch
        qcril_qmi_nas_fetch_sys_info();

        qcril_qmi_nas_drop_sig_info_cache_if_not_extrapolating();
        qcril_qmi_nas_fetch_signal_strength_observations();
        qcril_qmi_nas_embms_fetch_embms_status();

        // force update ?
        if ( force_update &&
             ((QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING == qmi_ril_get_operational_status()) ||
              (QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED == qmi_ril_get_operational_status()) ||
              (QMI_RIL_GEN_OPERATIONAL_STATUS_RESUMING == qmi_ril_get_operational_status()))
           )
        {
            qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
            qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
            qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
            any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
            QCRIL_LOG_INFO( "any rte change %d", any_rte_change);

            if( FALSE == any_rte_change )
            {
                if( qcril_qmi_nas_lte_sms_status_compare( old_lte_sms_status_valid, old_lte_sms_status ) ||
                    qcril_qmi_nas_lte_voice_status_compare( old_lte_voice_status_valid, old_lte_voice_status )
                  )
                {
                    any_rte_change = TRUE;
                }
            }

            if ( any_rte_change )
            {
                qcril_qmi_nas_initiate_voice_rte_change_propagation();
            }

            qcril_qmi_nas_wave_voice_data_status();

            // restrict status
            NAS_CACHE_LOCK();
            qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );
            NAS_CACHE_UNLOCK();

            qcril_qmi_nas_send_known_signal_strength();
        }
    }
    QCRIL_LOG_INFO( "completed with %d", (int) ril_err );

    return ril_err;

} // qcril_qmi_util_enable_networking_indications

//===========================================================================
//qcril_qmi_nas_drop_sig_info_cache_if_not_extrapolating
//===========================================================================
void qcril_qmi_nas_drop_sig_info_cache_if_not_extrapolating()
{
    qcril_arb_pref_data_type pref_data;
    int extrapolation_is_under = FALSE;
    int extrapolation_is_roaming = FALSE;

    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);

    NAS_CACHE_LOCK();
    qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, &extrapolation_is_under, &extrapolation_is_roaming );
    // Invalidate sig info cache if pref data tech is invalid or not extrapolating if device continue to in_Service over same RAT but signal got varied.
    if ( !extrapolation_is_under )
    {
        qcril_qmi_drop_sig_info_cache();
    }
    NAS_CACHE_UNLOCK();
}

//===========================================================================
//RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE
//===========================================================================
void qcril_qmi_nas_exit_emergency_callback_mode_msg
(
  std::shared_ptr<RilRequestExitEmergencyCallbackMessage> msg
)
{
  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_set_system_selection_preference_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;


  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  nas_cached_info.nas_enter_ecbm_propagation_pending = FALSE;
  if (nas_cached_info.eme_call_end_recently)
  {
    nas_cached_info.eme_call_end_recently = FALSE;
    qcril_cancel_timed_callback((void *)(uintptr_t)nas_cached_info.eme_call_end_recently_tcb_id);
  }
  NAS_CACHE_UNLOCK();

  // ** prepare qmi req and exec
  memset( &qmi_request, 0, sizeof( qmi_request ) );

  qmi_request.emergency_mode_valid = TRUE;
  qmi_request.emergency_mode       = NAS_CMN_EMERGENCY_MODE_OFF;

  auto qmi_client_error =  qmi_client_nas_send_sync(QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                 &qmi_request,
                                                 sizeof( qmi_request ),
                                                 (void*) &qmi_response,
                                                 sizeof( qmi_response ),
                                                 ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO("qmi_client_error %d, ril_req_res %d", (int) qmi_client_error, (int) ril_req_res );

  // ** respond
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_exit_emergency_callback_mode_msg

//===========================================================================
//qcril_qmi_nas_control_signal_nas_on_current_calls_change
//===========================================================================
void qcril_qmi_nas_control_signal_nas_on_current_calls_change()
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qcril_qmi_nas_reevaluate_vrte_helper,
                                        NULL,
                                        NULL, // immediate
                                        NULL );

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_control_signal_nas_on_current_calls_change

//===========================================================================
//qcril_qmi_nas_reevaluate_vrte_helper
//===========================================================================
void qcril_qmi_nas_reevaluate_vrte_helper (qcril_timed_callback_handler_params_type *param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(param);

    qcril_qmi_nas_evaluate_voice_rte_propagation();

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_reevaluate_vrte_helper

//===========================================================================
//qcril_qmi_nas_evaluate_voice_rte_propagation
//===========================================================================
void qcril_qmi_nas_evaluate_voice_rte_propagation()
{
    unsigned int reported_voice_radio_tech;
    unsigned int calculated_voice_radio_tech;
    unsigned int reported_voice_radio_tech_family;
    unsigned int calculated_voice_radio_tech_family;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    calculated_voice_radio_tech = qcril_qmi_get_voice_radio_technology();
    reported_voice_radio_tech = qcril_qmi_nas_get_reported_voice_radio_tech();
    reported_voice_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(reported_voice_radio_tech);
    calculated_voice_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(calculated_voice_radio_tech);
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("reported tech %d, family %d - calculated tech %d, family %d",
                   (int)reported_voice_radio_tech,
                   (int)reported_voice_radio_tech_family,
                   (int)calculated_voice_radio_tech,
                   (int)calculated_voice_radio_tech_family);

    if (reported_voice_radio_tech != calculated_voice_radio_tech)
    {
        // logistics of propagation
        qcril_qmi_nas_set_reported_voice_radio_tech( (RIL_RadioTechnology) calculated_voice_radio_tech );
        auto msg = std::make_shared<RilUnsolVoiceRadioTechChangedMessage>(calculated_voice_radio_tech);
        Dispatcher::getInstance().dispatchSync(msg);

        // defered call updates check initiate
        qcril_setup_timed_callback(
                                  QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  (RIL_TimedCallback) qcril_qmi_voice_nas_control_process_calls_pending_for_right_voice_rte,
                                  NULL,   // immediate
                                  NULL
                                  );

        // Send the known signal strength on Voice RTE Change
        if(calculated_voice_radio_tech != RADIO_TECH_UNKNOWN)
        {
            qcril_qmi_nas_send_known_signal_strength();
        }
    }

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_evaluate_voice_rte_propagation

//===========================================================================
//RIL_REQUEST_VOICE_RADIO_TECH
//===========================================================================
void qcril_qmi_nas_request_radio_tech
(
  std::shared_ptr<RilRequestGetVoiceRadioTechMessage> msg
)
{
  QCRIL_LOG_FUNC_ENTRY();

  int ril_response = qcril_qmi_get_voice_radio_technology();
  qcril_qmi_nas_set_reported_voice_radio_tech( (RIL_RadioTechnology) ril_response );

  qcril_setup_timed_callback(
                          QCRIL_DEFAULT_INSTANCE_ID,
                          QCRIL_DEFAULT_MODEM_ID,
                          (RIL_TimedCallback) qcril_qmi_voice_nas_control_process_calls_pending_for_right_voice_rte,
                          NULL,   // immediate
                          NULL
                          );


  // ** respond
  auto payload = std::make_shared<qcril::interfaces::RilGetVoiceTechResult_t>(ril_response);
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_SUCCESS, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  QCRIL_LOG_INFO("completed with rt %d ", (int) ril_response );

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_request_radio_tech

//===========================================================================
//qcril_qmi_nas_set_reported_voice_radio_tech
//===========================================================================
void qcril_qmi_nas_set_reported_voice_radio_tech(RIL_RadioTechnology voice_radio_tech)
{
    QCRIL_LOG_INFO("entered voice_radio_tech %d", voice_radio_tech);

    NAS_CACHE_LOCK();
    nas_cached_info.reported_voice_radio_tech = voice_radio_tech;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_set_reported_voice_radio_tech

//===========================================================================
//qcril_qmi_nas_get_reported_voice_radio_tech
//===========================================================================
RIL_RadioTechnology qcril_qmi_nas_get_reported_voice_radio_tech()
{
    RIL_RadioTechnology voice_radio_tech;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    voice_radio_tech = nas_cached_info.reported_voice_radio_tech;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("completed with voice_radio_tech %d", voice_radio_tech);
    return voice_radio_tech;
} //qcril_qmi_nas_get_reported_voice_radio_tech

//===========================================================================
//qcril_qmi_nas_initiate_voice_rte_change_propagation
//===========================================================================
void qcril_qmi_nas_initiate_voice_rte_change_propagation( void )
{
    QCRIL_LOG_FUNC_ENTRY();

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_RIL_POST_VOICE_RTE_CHANGE_IND,
                   NULL,
                   NAS_NIL,
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_initiate_voice_rte_change_propagation

//===========================================================================
//QCRIL_EVT_QMI_RIL_POST_VOICE_RTE_CHANGE_IND
//===========================================================================
void qcril_qmi_nas_post_voice_rte_change_ind_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno                    ril_req_res;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(ret_ptr);
    QCRIL_NOTUSED(params_ptr);

    qcril_suppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());

    ril_req_res = RIL_E_GENERIC_FAILURE;

    NAS_CACHE_LOCK();
    if( TRUE == qcril_qmi_nas_check_power_save_and_screen_off_status() )
    {
      ril_req_res = qcril_qmi_nas_fetch_system_info_helper();
    }
    else
    {
      ril_req_res = RIL_E_SUCCESS;
    }
    NAS_CACHE_UNLOCK();

    if( RIL_E_SUCCESS == ril_req_res )
    {
       qcril_qmi_nas_evaluate_voice_rte_propagation();
    }

    qcril_unsuppress_unsol_msg(RilUnsolNetworkStateChangedMessage::get_class_message_id());

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_post_voice_rte_change_ind

//===========================================================================
//qcril_qmi_nas_is_atel_rat_3gpp
//===========================================================================
inline int qcril_qmi_nas_is_atel_rat_3gpp(RIL_RadioTechnology atel_rat)
{
    int res;

    res = FALSE;

    switch( atel_rat )
    {
        case RADIO_TECH_TD_SCDMA:
        case RADIO_TECH_UMTS:
        case RADIO_TECH_GSM:
        case RADIO_TECH_EDGE:
        case RADIO_TECH_GPRS:
        case RADIO_TECH_HSDPA:
        case RADIO_TECH_HSUPA:
        case RADIO_TECH_HSPA:
        case RADIO_TECH_HSPAP:
            res = TRUE;
            break;

        default:
            //no action
            break;
    }

    return res;
} //qcril_qmi_nas_is_atel_rat_3gpp

//===========================================================================
//qcril_qmi_nas_is_atel_rat_3gpp2
//===========================================================================
inline int qcril_qmi_nas_is_atel_rat_3gpp2(RIL_RadioTechnology atel_rat)
{
    int res;

    res = FALSE;

    switch( atel_rat )
    {
        case RADIO_TECH_IS95A:
        case RADIO_TECH_IS95B:
        case RADIO_TECH_1xRTT:
        case RADIO_TECH_EVDO_0:
        case RADIO_TECH_EVDO_A:
        case RADIO_TECH_EVDO_B:
        case RADIO_TECH_EHRPD:
            res = TRUE;
            break;

        default:
            //no action
            break;
    }

    return res;
} //qcril_qmi_nas_is_atel_rat_3gpp2

//===========================================================================
//process_3gpp_radio_technology
//===========================================================================
inline RIL_RadioTechnology process_3gpp_radio_technology(RIL_RadioTechnology reported_radio_technology, uint16_t mode_pref)
{
  RIL_RadioTechnology radio_technology;
  radio_technology = RADIO_TECH_UNKNOWN;
  if (TRUE == qcril_qmi_nas_is_atel_rat_3gpp(reported_radio_technology))
  {
    radio_technology = reported_radio_technology; //to avoid ping pong between 3gpp technologies in no service
  }
  else
  {
      if( QMI_NAS_RAT_MODE_PREF_UMTS & mode_pref )
      {
          radio_technology = RADIO_TECH_UMTS;
      }
      else if( QMI_NAS_RAT_MODE_PREF_GSM & mode_pref )
      {
          radio_technology = RADIO_TECH_GSM;
      }
      else if( QMI_NAS_RAT_MODE_PREF_TDSCDMA & mode_pref )
      {
          radio_technology = RADIO_TECH_TD_SCDMA;
      }
      else
      {
          radio_technology = RADIO_TECH_UMTS;
      }
  }
  return radio_technology;
}//process_3gpp_radio_technology

//===========================================================================
//process_3gpp2_radio_technology
//===========================================================================
inline RIL_RadioTechnology process_3gpp2_radio_technology(RIL_RadioTechnology reported_radio_technology,uint16_t mode_pref)
{
  RIL_RadioTechnology radio_technology;
  radio_technology = RADIO_TECH_UNKNOWN;

  QCRIL_NOTUSED(mode_pref);
  if( TRUE == qcril_qmi_nas_is_atel_rat_3gpp2(reported_radio_technology) )
  {
      radio_technology = reported_radio_technology; //to avoid ping pong between 3gpp2 technologies in no service
  }
  else
  {
      radio_technology = RADIO_TECH_IS95A;
  }
  return radio_technology;
}//process_3gpp2_radio_technology

//===========================================================================
//qcril_qmi_nas_is_3gpp2_roaming
//===========================================================================
inline int qcril_qmi_nas_is_3gpp2_roaming(uint8_t reg_state_valid,
                                          int reg_state,
                                          uint8_t reg_tech_valid,
                                          int reg_tech)
{
    int res;

    res = FALSE;

    if( TRUE == reg_state_valid &&
        RIL_VAL_REG_REGISTERED_ROAMING == reg_state &&
        TRUE == reg_tech_valid &&
        TRUE == qcril_qmi_nas_is_atel_rat_3gpp2((RIL_RadioTechnology) reg_tech)
        )
    {
        res = TRUE;
    }

    return res;
}//qcril_qmi_nas_is_3gpp2_roaming

//===========================================================================
//qcril_qmi_nas_fetch_mode_pref
//===========================================================================
int qcril_qmi_nas_fetch_mode_pref(mode_pref_mask_type_v01 *mode_pref)
{
    int mode_pref_available;
    RIL_Errno ril_req_res;
    nas_get_mode_pref_resp_msg_v01 nas_get_mode_pref_resp_msg;
    qmi_client_error_type qmi_error = QMI_ERR_NONE_V01;

    mode_pref_available = FALSE;
    ril_req_res = RIL_E_GENERIC_FAILURE;
    memset(&nas_get_mode_pref_resp_msg, NAS_NIL, sizeof(nas_get_mode_pref_resp_msg));

    if( mode_pref )
    {
        if(FALSE == qcril_qmi_nas_get_mode_pref(mode_pref))
        {
            qcril_qmi_fetch_system_selection_preference();
            if(FALSE == qcril_qmi_nas_get_mode_pref(mode_pref))
            {
                qmi_error = qmi_client_nas_send_sync (QMI_NAS_GET_MODE_PREF_REQ_MSG_V01,
                                                        NULL,
                                                        NAS_NIL,
                                                        (void*)&nas_get_mode_pref_resp_msg,
                                                        sizeof( nas_get_mode_pref_resp_msg ),
                                                        ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
                ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error,
                    &nas_get_mode_pref_resp_msg.resp);
                if ( RIL_E_SUCCESS == ril_req_res )
                {
                    if ( nas_get_mode_pref_resp_msg.idx0_mode_pref_valid &&
                         (QCRIL_DEFAULT_MODEM_STACK_ID == qcril_qmi_get_modem_stack_id()) )
                    {
                        *mode_pref = nas_get_mode_pref_resp_msg.idx0_mode_pref;
                        mode_pref_available = TRUE;
                    }
                    else if ( nas_get_mode_pref_resp_msg.idx1_mode_pref_valid &&
                             (QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_get_modem_stack_id()) )
                    {
                        *mode_pref = nas_get_mode_pref_resp_msg.idx1_mode_pref;
                        mode_pref_available = TRUE;
                    }
                    else if ( nas_get_mode_pref_resp_msg.idx2_mode_pref_valid &&
                              (QCRIL_MODEM_TERTIARY_STACK_ID == qcril_qmi_get_modem_stack_id()) )
                    {
                        *mode_pref = nas_get_mode_pref_resp_msg.idx2_mode_pref;
                        mode_pref_available = TRUE;
                    }
                }
            }
            else
            {
                mode_pref_available = TRUE;
            }
        }
        else
        {
            mode_pref_available = TRUE;
        }
    }

    if( mode_pref_available )
    {
        QCRIL_LOG_DEBUG("mode preference %d", *mode_pref );
    }
    else
    {
        QCRIL_LOG_DEBUG("mode preference unavailable");
    }

    return mode_pref_available;
} //qcril_qmi_nas_fetch_mode_pref

//===========================================================================
//qcril_qmi_convert_rte_to_radio_technology
//===========================================================================
RIL_RadioTechnology qcril_qmi_convert_rte_to_radio_technology(qmi_ril_nw_reg_rte_type rte)
{
    RIL_RadioTechnology radio_technology;
    nas_cdma_only_sys_info_type_v01 *cdma_only_sys_info;
    nas_hdr_only_sys_info_type_v01  *hdr_only_sys_info;

    radio_technology = RADIO_TECH_UNKNOWN;
    cdma_only_sys_info = NULL;

    switch ( rte )
    {
        case QMI_RIL_RTE_1x:
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
            {
              cdma_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_specific_sys_info;
            }
            else
            {
              cdma_only_sys_info = NULL;
            }
            radio_technology = (RIL_RadioTechnology) qcril_qmi_nas_util_determine_cdma_rev( cdma_only_sys_info );
            break;

        case QMI_RIL_RTE_SUB_DO:
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
            {
              hdr_only_sys_info = &nas_cached_info.hdr_sys_info->hdr_specific_sys_info;
            }
            else
            {
              hdr_only_sys_info = NULL;
            }
            radio_technology = (RIL_RadioTechnology) qcril_qmi_nas_util_determine_hdr_rev( hdr_only_sys_info );
            break;

        case QMI_RIL_RTE_GSM:
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                 nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp_valid &&
                 NAS_SYS_EGPRS_SUPPORT_AVAIL == nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp )
            {
                radio_technology = RADIO_TECH_EDGE; // edge
            }
            else
            {
                radio_technology = RADIO_TECH_GPRS; // conclude  -  gprs
            }
            break;

        case QMI_RIL_RTE_WCDMA:
            radio_technology = RADIO_TECH_UMTS;
            break;

        case QMI_RIL_RTE_TDSCDMA:
            radio_technology = RADIO_TECH_TD_SCDMA;
            break;

        case QMI_RIL_RTE_SUB_LTE:
            radio_technology = RADIO_TECH_LTE;
            break;

        case QMI_RIL_RTE_SUB_NR5G:
            radio_technology = RADIO_TECH_5G;
            break;

        default:
            radio_technology = RADIO_TECH_UNKNOWN;
            break;
    }

    QCRIL_LOG_DEBUG("radio technlogy %d for rte %d", radio_technology, rte);
    return radio_technology;
} //qcril_qmi_convert_rte_to_radio_technology

/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_sim_app

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from current current sim app type

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_sim_app
(
    void
)
{
    int                   radio_tech_family = NAS_VAL_RADIO_TECH_UNKNOWN;
    int                   index;
    nas_rtre_cfg_enum_v01 rtre_cfg;

    do {
        auto card_status = std::make_shared<UimGetCardStatusRequestSyncMsg>(qmi_ril_get_process_instance_id());
        std::shared_ptr<RIL_UIM_CardStatus> ril_card_status = nullptr;

        /* retrieve card status info */
        if (card_status == nullptr ||
            card_status->dispatchSync(ril_card_status) != Message::Callback::Status::SUCCESS ||
            ril_card_status == nullptr ||
            ril_card_status->err != RIL_UIM_E_SUCCESS)
        {
            break;
        }

        QCRIL_LOG_INFO("card status : %d", ril_card_status->card_state);
        QCRIL_LOG_INFO("gsm index : %d", ril_card_status->gsm_umts_subscription_app_index);
        QCRIL_LOG_INFO("cdma index : %d", ril_card_status->cdma_subscription_app_index);


        NAS_CACHE_LOCK();
        rtre_cfg = nas_common_info.nas_rtre_cfg;
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("rtre_cfg : %d", rtre_cfg);

        /* convert operator type to corresponding radio tech */
        if (ril_card_status->card_state == RIL_UIM_CARDSTATE_PRESENT)
        {
            if (ril_card_status->gsm_umts_subscription_app_index != -1)
            {
                index = ril_card_status->gsm_umts_subscription_app_index;
                if(index < RIL_UIM_CARD_MAX_APPS)
                {
                    QCRIL_LOG_INFO("gsm app state : %d",
                               ril_card_status->applications[index].app_state);
                    if (ril_card_status->applications[index].app_state !=
                                                        RIL_UIM_APPSTATE_UNKNOWN)
                    {
                        radio_tech_family = NAS_VAL_RADIO_TECH_3GPP;
                    }
                }
            }

            if (ril_card_status->cdma_subscription_app_index != -1)
            {
                if (radio_tech_family != NAS_VAL_RADIO_TECH_UNKNOWN)
                {
                    radio_tech_family = NAS_VAL_RADIO_TECH_UNKNOWN;
                }
                else
                {
                    index = ril_card_status->cdma_subscription_app_index;
                    if(index < RIL_UIM_CARD_MAX_APPS)
                    {
                        QCRIL_LOG_INFO("cdma app state : %d",
                                   ril_card_status->applications[index].app_state);
                        if (ril_card_status->applications[index].app_state !=
                                                        RIL_UIM_APPSTATE_UNKNOWN)
                        {
                            radio_tech_family = NAS_VAL_RADIO_TECH_3GPP2;
                        }
                    }
                }
            }

            /* If subscription source is NV, then use 3GPP app type only if
             * pin is locked */
            if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
            {
                if (NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01 == rtre_cfg)
                {
                    if ((ril_card_status->applications[index].app_state !=
                                                            RIL_UIM_APPSTATE_PIN) &&
                        (ril_card_status->applications[index].app_state !=
                                                             RIL_UIM_APPSTATE_PUK))
                    {
                        QCRIL_LOG_INFO("resetting radio tech family source is nv and"
                                        "app state is not locked");
                        radio_tech_family = NAS_VAL_RADIO_TECH_UNKNOWN;
                    }
                }
            }
        }
        else if (ril_card_status->card_state == RIL_UIM_CARDSTATE_ABSENT)
        {
            if (NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01 == rtre_cfg)
            {
                radio_tech_family = NAS_VAL_RADIO_TECH_3GPP2;
            }
        }
    } while (0);

    QCRIL_LOG_INFO( "radio tech family: %d", radio_tech_family);

    return radio_tech_family;
}

/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_mcc_mnc

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from mcc and mnc

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_mcc_mnc
(
    char mcc_str[NAS_MCC_MNC_MAX_SIZE],
    char mnc_str[NAS_MCC_MNC_MAX_SIZE]
)
{
    char operator_type[QCRIL_DB_MAX_OPERATOR_TYPE_LEN] = {0};

    int radio_tech_family  = NAS_VAL_RADIO_TECH_UNKNOWN;

    do {

        if (!mcc_str || !mnc_str)
        {
            break;
        }

        /* retrieve operator type using mcc and mnc */
        qcril_db_query_operator_type(mcc_str, mnc_str, operator_type);

        /* convert operator type to corresponding radio tech */
        if (!strcmp(operator_type, "3gpp"))
        {
            radio_tech_family = NAS_VAL_RADIO_TECH_3GPP;
        }
        else if (!strcmp(operator_type, "3gpp2"))
        {
            radio_tech_family = NAS_VAL_RADIO_TECH_3GPP2;
        }

        QCRIL_LOG_INFO( "mcc : %s, mnc: %s",
                        mcc_str, mnc_str);
        QCRIL_LOG_INFO( "radio tech family: %d, operator: %s",
                        radio_tech_family, operator_type);

    } while (0);

    return radio_tech_family;
}

/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_current_operator_info

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from current operator info like mcc and mnc

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_current_operator_info
(
    uint8_t is_3gpp
)
{
    char current_mcc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char current_mnc_str[NAS_MCC_MNC_MAX_SIZE] = {0};

    int radio_tech_family  = NAS_VAL_RADIO_TECH_UNKNOWN;

    do {

        /* get mcc and mnc of current operator */
        if (!qcril_qmi_nas_fetch_mcc_mnc_of_current_system(current_mcc_str,
                                                           current_mnc_str, is_3gpp, FALSE))
        {
            break;
        }

        /* retrieve rte family type using current mcc and mnc */
        radio_tech_family = qcril_qmi_retrieve_rte_family_from_mcc_mnc(
                                                current_mcc_str,
                                                current_mnc_str);

    } while (0);

    return radio_tech_family;
}
/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_card_mcc_mnc

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from card mcc and mnc

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_card_mcc_mnc
(
    void
)
{
    char card_mcc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char card_mnc_str[NAS_MCC_MNC_MAX_SIZE] = {0};

    int radio_tech_family  = NAS_VAL_RADIO_TECH_UNKNOWN;

    do {

        /* get mcc and mnc of card */
        if (qcril_qmi_nas_get_sim_mcc_mnc(card_mcc_str,
                                          card_mnc_str))
        {
            break;
        }

        /* retrieve rte family type using card mcc and mnc */
        radio_tech_family = qcril_qmi_retrieve_rte_family_from_mcc_mnc(
                                                        card_mcc_str,
                                                        card_mnc_str);

    } while (0);

    return radio_tech_family;
}

/*===========================================================================

  FUNCTION  qcril_qmi_store_learnt_rte_family_type

===========================================================================*/
/*!
    @brief
    Store learnt rte family type to persistent memory.

    @return
    E_SUCCESS for success
    E_FAILURE for failure
*/
/*=========================================================================*/
void qcril_qmi_store_learnt_rte_family_type
(
    RIL_RadioTechnology radio_technology,
    uint8_t is_lte_rat
)
{
    char    current_mcc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char    current_mnc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char    operator_type[QCRIL_DB_MAX_OPERATOR_TYPE_LEN] = {0};
    boolean is_update = FALSE;
    uint8_t is_3gpp = FALSE;
    uint8_t is_3gpp2 = FALSE;

    do {

        /* check if voice radio tech learning is disabled */
        if (!nas_common_info.is_ril_vrte_learning_enabled)
        {
            break;
        }

        if(TRUE == is_lte_rat)
        {
            is_3gpp = TRUE;
        }
        else
        {
            is_3gpp = qcril_qmi_nas_is_atel_rat_3gpp(radio_technology);
            is_3gpp2 = qcril_qmi_nas_is_atel_rat_3gpp2(radio_technology);
        }

        QCRIL_LOG_INFO( "is_lte_rat: %d, radio_technology: %d, is_3gpp: %d, is_3gpp2: %d", is_lte_rat, radio_technology, is_3gpp, is_3gpp2);

        /* get mcc and mnc of current operator */
        if (!qcril_qmi_nas_fetch_mcc_mnc_of_current_system(current_mcc_str,
                                                           current_mnc_str, is_3gpp, is_3gpp2))
        {
            break;
        }

        /* retrieve operator type using mcc and mnc */
        qcril_db_query_operator_type(current_mcc_str, current_mnc_str, operator_type);

        /* retrieve operator type from rat */
        if (qcril_qmi_nas_is_atel_rat_3gpp2(radio_technology))
        {
            if (!strlen(operator_type))
            {
                strlcpy(operator_type, "3gpp2", sizeof(operator_type));
            }
            else if (!strcmp(operator_type, "3gpp"))
            {
                strlcpy(operator_type, "both", sizeof(operator_type));
                is_update = TRUE;
            }

            /* if there exist an entry, do not proceed */
            else
            {
                break;
            }
        }
        else if (qcril_qmi_nas_is_atel_rat_3gpp(radio_technology))
        {
            if (!strlen(operator_type))
            {
                strlcpy(operator_type, "3gpp", sizeof(operator_type));
            }
            else if (!strcmp(operator_type, "3gpp2"))
            {
                strlcpy(operator_type, "both", sizeof(operator_type));
                is_update = TRUE;
            }

            /* if there exist an entry, do not proceed */
            else
            {
                break;
            }
        }
        else
        {
            /* non modem rat */
            break;
        }

        if (is_update)
        {
            /* update entry in db */
            qcril_db_update_operator_type(current_mcc_str,
                                          current_mnc_str,
                                          operator_type);
        }
        else
        {
            /* insert entry to db */
            qcril_db_insert_operator_type(current_mcc_str,
                                          current_mnc_str,
                                          operator_type);
        }

        QCRIL_LOG_INFO( "mcc: %s, mnc: %s, operator: %s",
                        current_mcc_str, current_mnc_str, operator_type);

    } while (0);


    return;
}

/*===========================================================================

 qcril_qmi_get_voice_radio_technology

============================================================================*/
/*!
    @brief
    Calculate voice radio technology

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_RadioTechnology qcril_qmi_get_voice_radio_technology
(
    void
)
{
    /* radio tachnology to be calculated  */
    RIL_RadioTechnology      radio_technology = RADIO_TECH_UNKNOWN;

    /* current mode preference */
    uint16_t                 mode_pref        = NAS_NIL;

    /* is mode preference info available */
    int                      mode_pref_info_available;

    /* Previously reported voice radio  technology */
    RIL_RadioTechnology      reported_radio_technology;

    /* indicates whether radio tech is of 3gpp or 3gpp2 family */
    int                      radio_tech_family;

    /* cached voice rte */
    qmi_ril_nw_reg_rte_type  voice_rte;

    /* cached data rte */
    qmi_ril_nw_reg_rte_type  data_rte;

    /* voice rte confidence level */
    qmi_ril_nw_reg_rat_confidence_tag_type voice_rte_confidence;

    /* data rte confidence level */
    qmi_ril_nw_reg_rat_confidence_tag_type data_rte_confidence;

    /* lte sms status, indicating sms csfb type or ims availability */
    nas_sms_status_enum_type_v01       lte_sms_status;

    /* indicated if lte sms status is valid */
    uint8_t                            lte_sms_status_valid;

    /* lte voice status, indicating voice csfb type or ims availability */
    nas_lte_voice_status_enum_type_v01 lte_voice_status;

    /* indicated if lte voice status is valid */
    uint8_t                            lte_voice_status_valid;

    /* preferred data information */
    qcril_arb_pref_data_type           pref_data;

    /* is in 3gpp service */
    int is_service_in_3gpp;

    /* is in 3gpp2 service */
    int is_service_in_3gpp2;

    /* fetch current mode preference */
    mode_pref_info_available  = qcril_qmi_nas_fetch_mode_pref(&mode_pref);

    /* fetch previously reported voice radio technology */
    reported_radio_technology = qcril_qmi_nas_get_reported_voice_radio_tech();

    NAS_CACHE_LOCK();

    /* fetch cached voice rte and data rte */
    voice_rte            = nas_cached_info.voice_rte;
    voice_rte_confidence = nas_cached_info.voice_rte_confidence_tag;
    data_rte             = nas_cached_info.data_rte;
    data_rte_confidence  = nas_cached_info.data_rte_confidence_tag;

    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);

    /* fetch cached lte sms and voice status */
    qcril_qmi_nas_fetch_lte_voice_status(&lte_voice_status_valid,
                                         &lte_voice_status);
    qcril_qmi_nas_fetch_lte_sms_status(&lte_sms_status_valid, &lte_sms_status);

    /* Get the service information */
    is_service_in_3gpp =
         qcril_qmi_nas_is_in_service_of_technology(NAS_SELECTED_NETWORK_3GPP_V01);
    is_service_in_3gpp2 =
         qcril_qmi_nas_is_in_service_of_technology(NAS_SELECTED_NETWORK_3GPP2_V01);

    /* Proceed if mode pref is available, if it is not available that indicates
     * system is not in a valid state */
    if (mode_pref_info_available)
    {
        QCRIL_LOG_INFO("mode preference %d, last reported rte %d",
                        mode_pref, reported_radio_technology);
        QCRIL_LOG_INFO("voice rte %d - confidence %d",
                        voice_rte, voice_rte_confidence);
        QCRIL_LOG_INFO("data rte %d - confidence %d",
                       data_rte, data_rte_confidence);

        do
        {
            /* In case of LTE only mode or LTE_NR5G mode, the only possible rat is LTE and
             * only possible voice call is through IMS. */
            if ((QMI_NAS_RAT_MODE_PREF_LTE == mode_pref) || (QMI_NAS_RAT_MODE_PREF_LTE_NR5G == mode_pref))
            {
                radio_technology = RADIO_TECH_LTE;
                QCRIL_LOG_INFO("mode pref is LTE, hence the radio technology is set to LTE");
                break;
            }

            // In 5G SA mode, voice call is only possible through IMS.
            if (QMI_NAS_RAT_MODE_PREF_NR5G == mode_pref)
            {
                radio_technology = RADIO_TECH_5G;
                QCRIL_LOG_INFO("mode pref is 5G, hence the radio technology is set to 5G");
                break;
            }

            if (QMI_RIL_RTE_NONE != voice_rte &&
                (QMI_RIL_RAT_CONFIDENCE_FULL_SVC == voice_rte_confidence ||
                 QMI_RIL_RAT_CONFIDENCE_LTD_SVC == voice_rte_confidence))
            {
                QCRIL_LOG_INFO("calculating radio technology from voice rte");
                radio_technology =
                        qcril_qmi_convert_rte_to_radio_technology(voice_rte);

                if (RADIO_TECH_UNKNOWN != radio_technology)
                {
                    nas_cached_info.is_calculated_vrte_used = 1;
                }

                if (RADIO_TECH_UNKNOWN != radio_technology && RADIO_TECH_LTE != radio_technology
                        && RADIO_TECH_5G != radio_technology)
                {
                    /* Add entry to peristent memory, to remember the operator.
                     * this helps in resolving the scenario
                     * where family information is not available */
                    qcril_qmi_store_learnt_rte_family_type(radio_technology, FALSE);

                    /* current radio technology -
                     * No further calculations needed */
                    break;
                }
            }

            if ((RADIO_TECH_UNKNOWN == radio_technology) &&
                QMI_RIL_RTE_NONE != data_rte &&
               ((QMI_RIL_RAT_CONFIDENCE_FULL_SVC == data_rte_confidence) ||
                (QMI_RIL_RAT_CONFIDENCE_LTD_SVC == data_rte_confidence)) &&
                (QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data.pref_data_tech) &&
                (pref_data.is_extrapolation != TRUE))
            {
                QCRIL_LOG_INFO("calculating radio technology from data rte");
                radio_technology =
                        qcril_qmi_convert_rte_to_radio_technology(data_rte);

                if (RADIO_TECH_UNKNOWN != radio_technology)
                {
                    nas_cached_info.is_calculated_vrte_used = 1;
                }

                if (RADIO_TECH_UNKNOWN != radio_technology && RADIO_TECH_LTE != radio_technology
                        && RADIO_TECH_5G != radio_technology)
                {
                    /* Add entry to peristent memory, to remember the operator.
                     * This helps in resolving the scenario where
                     * family information is not available */
                    qcril_qmi_store_learnt_rte_family_type(radio_technology, FALSE);

                    /* current radio technology -
                     * No further calculations needed */
                    break;
                }
            }

            /* Check if only 3gpp2 rats are in mode pref */
            if (FALSE == (QMI_NAS_RAT_MODE_PREF_GSM_UMTS_TDSCDMA & mode_pref))
            {
                QCRIL_LOG_INFO("mode pref has only 3gpp2 rats hence converting to 3gpp2 based");
                radio_technology = process_3gpp2_radio_technology(
                                            reported_radio_technology,
                                            mode_pref);
                break;
            }

            /* check if only 3gpp rats are in mode pref */
            if (FALSE == (QMI_NAS_RAT_MODE_PREF_CDMA_HRPD & mode_pref))
            {
                QCRIL_LOG_INFO("mode pref has only 3gpp rats hence converting to 3gpp based");
                radio_technology = process_3gpp_radio_technology(
                                            reported_radio_technology,
                                            mode_pref);
                break;
            }

            /* If the radio_technology is reported as LTE, the LTE voice TLV of
             * QMI_NAS_SYS_INFO_IND and QMI_GET_SYS_INFO response messages,
             * are checked to determine whether it is 3GPP or 3GPP2 technology. */
            if (RADIO_TECH_LTE == radio_technology && lte_voice_status_valid)
            {
                QCRIL_LOG_INFO("lte_voice_status reported in sys info: %d", lte_voice_status);
                if (NAS_LTE_VOICE_STATUS_3GPP_V01 == lte_voice_status)
                {
                    radio_technology = process_3gpp_radio_technology(reported_radio_technology, mode_pref);

                    /* Add entry to peristent memory, to remember the operator.
                     * This helps in resolving the scenario where
                     * family information is not available. */
                    qcril_qmi_store_learnt_rte_family_type(radio_technology, TRUE);

                    break;
                }
                else if (NAS_LTE_VOICE_STATUS_1X_V01 == lte_voice_status)
                {
                    radio_technology = process_3gpp2_radio_technology(reported_radio_technology, mode_pref);

                    /* Add entry to peristent memory, to remember the operator.
                     * This helps in resolving the scenario where
                     * family information is not available. */
                    qcril_qmi_store_learnt_rte_family_type(radio_technology, TRUE);

                    break;
                }
                else if (NAS_LTE_VOICE_STATUS_IMS_V01 == lte_voice_status)
                {
                    /* If VoLTE is possible, report 3GPP voice radio tech. */
                    radio_technology = process_3gpp_radio_technology(reported_radio_technology, mode_pref);
                    break;
                }
            }

            if (RADIO_TECH_LTE == radio_technology || RADIO_TECH_5G == radio_technology)
            {
                /* check if the operator is a 3gpp operator or 3gpp2 */
                radio_tech_family = qcril_qmi_retrieve_rte_family_from_current_operator_info(TRUE);
                QCRIL_LOG_INFO("radio_tech_family retrieved from operator table using current mcc,mnc: %d",
                                radio_tech_family);

                if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
                {
                    radio_technology = process_3gpp_radio_technology(reported_radio_technology, mode_pref);
                    break;
                }
                else if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP2)
                {
                    radio_technology = process_3gpp2_radio_technology(reported_radio_technology, mode_pref);
                    break;
                }
            }

            /* If the radio_technology is reported as LTE, the LTE SMS TLV of
             * QMI_NAS_SYS_INFO_IND and QMI_GET_SYS_INFO response messages,
             * are checked to determine whether it's 3GPP or 3GPP2 technology. */
            if (RADIO_TECH_LTE == radio_technology && lte_sms_status_valid)
            {
                QCRIL_LOG_INFO("lte_sms_status reported in sys info: %d", lte_sms_status);
                if (NAS_SMS_STATUS_3GPP_V01 == lte_sms_status)
                {
                    radio_technology = process_3gpp_radio_technology(reported_radio_technology, mode_pref);
                    break;
                }
                else if (NAS_SMS_STATUS_1X_V01 == lte_sms_status)
                {
                    radio_technology = process_3gpp2_radio_technology(reported_radio_technology, mode_pref);
                    break;
                }
            }

            if (RADIO_TECH_LTE == radio_technology || RADIO_TECH_5G == radio_technology)
            {
                 /* This block will prevent us from reporting LTE or 5G, without
                  * having any knowledge about the network we are camped on.
                  * If calculated rte is LTE or 5G and we are OOS, use previously
                  * reported radio technology. */
                 if(!is_service_in_3gpp && !is_service_in_3gpp2)
                 {
                     QCRIL_LOG_INFO("calculated RTE is %s even though we are out of service. Reporting previously reported RTE.",
                            RADIO_TECH_LTE == radio_technology ? "LTE" : "5G");
                     radio_technology = reported_radio_technology;
                     break;
                 }
            }

            if (RADIO_TECH_UNKNOWN == radio_technology)
            {
                /* check if active sim app type can be used
                 * to predict radio technology */
                radio_tech_family = qcril_qmi_retrieve_rte_family_from_sim_app();
                QCRIL_LOG_INFO("radio_tech_family retrieved from sim app: %d", radio_tech_family);
                if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
                {
                    radio_technology = process_3gpp_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                    break;
                }
                else if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP2)
                {
                    radio_technology = process_3gpp2_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                    break;
                }

                /* check if the operator is a 3gpp operator or 3gpp2
                 * using card mcc and mnc if we don't have any previously
                 * reported voice radio tech */
                if (!nas_cached_info.is_calculated_vrte_used)
                {
                    radio_tech_family =
                        qcril_qmi_retrieve_rte_family_from_card_mcc_mnc();
                    QCRIL_LOG_INFO("radio_tech_family retrieved from operator table using card mcc,mnc: %d",
                                    radio_tech_family);

                    if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
                    {
                        radio_technology = process_3gpp_radio_technology(
                                                    reported_radio_technology,
                                                    mode_pref);
                        break;
                    }
                    else if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP2)
                    {
                        radio_technology = process_3gpp2_radio_technology(
                                                    reported_radio_technology,
                                                    mode_pref);
                        break;
                    }
                }
            }
        } while(0);
    }
    else
    {
        QCRIL_LOG_INFO( "mode preference info unavailable");
    }

    /* Could not resolve or predict voice radio technology
     * Report default voice radio tech or previously reported
     * radio technology or default radio technology */
    if (RADIO_TECH_UNKNOWN == radio_technology)
    {
        QCRIL_LOG_INFO("retrieving reported radio technology");
        radio_technology = reported_radio_technology;
    }

    QCRIL_LOG_INFO( "radio technology %d", radio_technology );

    NAS_CACHE_UNLOCK();

    return radio_technology;
} // qcril_qmi_get_voice_radio_technology

//===========================================================================
//qmi_ril_nw_reg_voice_is_voice_call_mode_reasonable_against_dev_cfg
//===========================================================================
int qmi_ril_nw_reg_voice_is_voice_call_mode_reasonable_against_dev_cfg( call_mode_enum_v02 call_mode )
{
    int                                   res;
    uint16_t                              mode_pref;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    QCRIL_LOG_INFO( ".. mode_pref valid %d", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref ) );

    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref ) )
    {
      mode_pref = nas_cached_info.mode_pref;
    }
    else
    {
      mode_pref = NAS_NIL;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO( ".. mode_pref %d", (int) mode_pref );

    if ( NAS_NIL == mode_pref )
    { // whatever fits
        res = TRUE;
    }
    else
    {
        switch ( call_mode )
        {
          case CALL_MODE_CDMA_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_CDMA ) ? TRUE : FALSE;
              break;

          case CALL_MODE_GSM_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_GSM ) ? TRUE : FALSE;
              break;

          case CALL_MODE_UMTS_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS ) ? TRUE : FALSE;
              break;

          case CALL_MODE_TDS_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_TDSCDMA ) ? TRUE : FALSE;
              break;

          case CALL_MODE_LTE_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE ) ? TRUE : FALSE;
              break;

          case CALL_MODE_NR5G_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE_NR5G ) ? TRUE : FALSE;
              break;

          default:
              res = TRUE;
              break;
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );

    return res;
} // qmi_ril_nw_reg_voice_is_voice_call_mode_reasonable_against_dev_cfg

//===========================================================================
//qcril_qmi_voice_technology_updated
//===========================================================================
void qcril_qmi_voice_technology_updated()
{
    qcril_radio_tech_e_type voice_technology = QCRIL_RADIO_TECH_NONE;
    qmi_ril_nw_reg_rte_type considered_rte = QMI_RIL_RTE_NONE;

    QCRIL_LOG_FUNC_ENTRY();

    if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
    {
        considered_rte = nas_cached_info.ims_rte;
    }
    else if ( QMI_RIL_RTE_NONE != nas_cached_info.voice_rte )
    {
        considered_rte = nas_cached_info.voice_rte;
    }
    else
    {
        considered_rte = nas_cached_info.data_rte;
    }

    QCRIL_LOG_INFO( "..nas_cached_info.voice_rte %d, nas_cached_info.data_rte %d, nas_cached_info.ims_rte %d, will be considered %d",
                    (int) nas_cached_info.voice_rte,
                    (int) nas_cached_info.data_rte,
                    (int) nas_cached_info.ims_rte,
                    (int) considered_rte );

    switch ( considered_rte )
    {
        case QMI_RIL_RTE_1x: // fallthrough
        case QMI_RIL_RTE_SUB_DO:
            voice_technology = QCRIL_RADIO_TECH_3GPP2;
            break;

        case QMI_RIL_RTE_GSM:      // fallthrough
        case QMI_RIL_RTE_WCDMA:    // fallthrough
        case QMI_RIL_RTE_TDSCDMA:  // fallthrough
        case QMI_RIL_RTE_SUB_LTE:  // fallthrough
        case QMI_RIL_RTE_SUB_NR5G: // fallthrough
            voice_technology = QCRIL_RADIO_TECH_3GPP;
            break;

        default:
            voice_technology = QCRIL_RADIO_TECH_NONE;
            break;
    }

    qcril_qmi_mgr_voice_technology_updated( voice_technology );

    QCRIL_LOG_FUNC_RETURN_WITH_RET( (int) voice_technology );

} // qcril_qmi_voice_technology_updated
//===========================================================================
//RIL_REQUEST_GET_NEIGHBORING_CELL_IDS
//===========================================================================
void qcril_qmi_nas_get_neighboring_cell_ids
(
  std::shared_ptr<RilRequestGetNeighborCellIdsMessage> msg
)
{
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  auto ret = getNasModule().getPendingMessageList().insert(msg);
  if (!ret.second)
  {
    ril_req_res = RIL_E_INTERNAL_ERR;
  }
  else
  {
    uint16_t token = ret.first;
    uint32_t user_data = QCRIL_COMPOSE_USER_DATA(QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID, token);

    auto qmi_client_error =  qmi_client_nas_send_async(QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                       NULL,
                                                       NAS_ZERO,
                                                       sizeof(nas_get_cell_location_info_resp_msg_v01),
                                                       qcril_qmi_nas_get_neighboring_cells_cb,
                                                       (void *)(uintptr_t) user_data);

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(
                  qmi_client_error,
                  nullptr,
                  QCRIL_QMI_ERR_CTX_CELL_LOCATION_TXN, nullptr );
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {
      auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr);
      msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  }

  QCRIL_LOG_ESSENTIAL( "completed with %d", ril_req_res);
} // qcril_qmi_nas_get_neighboring_cell_ids


//===========================================================================
// qcril_qmi_nas_get_neighboring_cells_cb
//===========================================================================
void qcril_qmi_nas_get_neighboring_cells_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    QCRIL_NOTUSED(msg_id);
    QCRIL_NOTUSED(resp_c_struct_len);

    auto qmi_response = (nas_get_cell_location_info_resp_msg_v01 *) resp_c_struct.get();
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

    unsigned int iter=0,iter_j=0,iter_k=0;

    uint16_t token = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA((uint32_t)(uintptr_t)resp_cb_data);
    auto msg = getNasModule().getPendingMessageList().extract(token);

    std::vector<qcril::interfaces::RilNeighboringCell_t> cell_list;
    if (qmi_response && (msg != nullptr))
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( transp_err, &qmi_response->resp, QCRIL_QMI_ERR_CTX_CELL_LOCATION_TXN, NULL );
        QCRIL_LOG_ESSENTIAL(".. qmi error %d, resultqmi  %d, qmi transp_err %d, ril res %d",
                            (int)qmi_response->resp.error,
                            (int)qmi_response->resp.result,
                            (int)transp_err,
                            (int)ril_req_res );
        if ( RIL_E_SUCCESS == ril_req_res )
        {
            QCRIL_LOG_INFO("gsm resp %d/%d, wcdma resp %d/%d, lte intra resp %d/%d, lte inter resp %d/%d",
                           qmi_response->geran_info_valid, qmi_response->geran_info.nmr_cell_info_len,
                           qmi_response->umts_info_valid, qmi_response->umts_info.umts_monitored_cell_len,
                           qmi_response->lte_intra_valid, qmi_response->lte_intra.cells_len,
                           qmi_response->lte_inter_valid, qmi_response->lte_inter.freqs_len
                           );

            if (qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_GSM ))
            {
                QCRIL_LOG_INFO( ".. in GSM");
                ril_req_res = RIL_E_SUCCESS;
                if ( qmi_response->geran_info_valid && qmi_response->geran_info.nmr_cell_info_len <= NAS_NMR_MAX_NUM_V01)
                {
                    cell_list.reserve(qmi_response->geran_info.nmr_cell_info_len);
                    for (iter=0; iter < qmi_response->geran_info.nmr_cell_info_len; iter++)
                    {
                        qcril::interfaces::RilNeighboringCell_t item;
                        // TODO: use ostringstream instead
                        char str[NAS_CID_ASCII_MAX_LEN];
                        QCRIL_SNPRINTF(str, NAS_CID_ASCII_MAX_LEN, "%04x%04x",
                                (uint)qmi_response->geran_info.nmr_cell_info[iter].nmr_lac,
                                (uint) qmi_response->geran_info.nmr_cell_info[iter].nmr_cell_id);

                        item.cid = str;
                        item.rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(
                                qmi_response ->geran_info.nmr_cell_info[iter].nmr_rx_lev);
                        cell_list.push_back(item);
                    }
                }
            }
            else if ( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_UMTS ) )
            {
                QCRIL_LOG_INFO( ".. in UMTS");
                ril_req_res = RIL_E_SUCCESS;
                if ( qmi_response->umts_info_valid && qmi_response->umts_info.umts_monitored_cell_len <= NAS_UMTS_MAX_MONITORED_CELL_SET_NUM_V01)
                {
                    cell_list.reserve(qmi_response->umts_info.umts_monitored_cell_len);
                    for (iter=0; iter < qmi_response->umts_info.umts_monitored_cell_len; iter++)
                    {
                        qcril::interfaces::RilNeighboringCell_t item;

                        // TODO: use ostringstream instead
                        char str[NAS_CID_ASCII_MAX_LEN];
                        QCRIL_SNPRINTF(str, NAS_CID_ASCII_MAX_LEN, "%08x",
                                (uint) qmi_response->umts_info.umts_monitored_cell[iter].umts_psc);
                        item.cid = str;
                        item.rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(
                                qmi_response->umts_info.umts_monitored_cell[iter].umts_rscp);
                        cell_list.push_back(item);
                    }
                }
            }
            else if ( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_LTE ) )
            {
                QCRIL_LOG_INFO( ".. in LTE");
                ril_req_res = RIL_E_SUCCESS;

                if ( qmi_response->lte_intra_valid && qmi_response->lte_intra.cells_len <= NAS_MAX_LTE_NGBR_NUM_CELLS_V01)
                {
                    for (iter_j=0; iter_j < qmi_response->lte_intra.cells_len; iter_j++ )
                    {
                        qcril::interfaces::RilNeighboringCell_t item;

                        // TODO: use ostringstream instead
                        char str[NAS_CID_ASCII_MAX_LEN];
                        QCRIL_SNPRINTF(str, NAS_CID_ASCII_MAX_LEN, "%08x",
                                (uint)qmi_response->lte_intra.cells[iter_j].pci);
                        item.cid = str;
                        item.rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(
                                qmi_response->lte_intra.cells[iter_j].rssi);
                        cell_list.push_back(item);
                    }
                }
                if ( qmi_response->lte_inter_valid && qmi_response->lte_inter.freqs_len <= NAS_MAX_LTE_NGBR_NUM_FREQS_V01)
                {
                    for (iter_j=0; iter_j < qmi_response->lte_inter.freqs_len; iter_j++)
                    {
                        if ( qmi_response->lte_inter.freqs[iter_j].cells_len <= NAS_MAX_LTE_NGBR_NUM_CELLS_V01)
                        {
                            for ( iter_k=0; iter_k < qmi_response->lte_inter.freqs[iter_j].cells_len; iter_k++ )
                            {
                                qcril::interfaces::RilNeighboringCell_t item;

                                // TODO: use ostringstream instead
                                char str[NAS_CID_ASCII_MAX_LEN];
                                QCRIL_SNPRINTF(str, NAS_CID_ASCII_MAX_LEN, "%08x",
                                        (uint)qmi_response->lte_inter.freqs[iter_j].cells[iter_k].pci );
                                item.cid = str;
                                item.rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(
                                        qmi_response->lte_inter.freqs[iter_j].cells[iter_k].rssi);
                                cell_list.push_back(item);
                            }
                        }
                    }
                }
            }
            else
            {
                QCRIL_LOG_INFO( ".. no active 3gpp RATs");
                ril_req_res     = RIL_E_SUCCESS;
            }
        }
        else
        { // some error code from QMI NAS
            if ( QMI_RESULT_FAILURE_V01 == qmi_response->resp.result && QMI_ERR_NO_NETWORK_FOUND_V01 == qmi_response->resp.error )
            {   // report empty payload
                QCRIL_LOG_INFO( ".. no network found");
                ril_req_res     = RIL_E_SUCCESS;
            }
        }

        std::shared_ptr<qcril::interfaces::RilGetNeighborCellIdResult_t> payload;
        if (RIL_E_SUCCESS == ril_req_res)
        {
            payload = std::make_shared<qcril::interfaces::RilGetNeighborCellIdResult_t>(
                    std::move(cell_list));
        }
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
        auto cellMsg = std::static_pointer_cast<RilRequestGetNeighborCellIdsMessage>(msg);
        cellMsg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    }

    QCRIL_LOG_ESSENTIAL("completed with %d with %d entries", (int)ril_req_res, cell_list.size());
} // qcril_qmi_nas_get_neighboring_cells_cb

//===========================================================================
//qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache
//===========================================================================
int qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(int cell_value, int radioif)
{
  int rssi = 0, dbm =0;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_LOG_DEBUG("cell_value: %d. radioif: 0x%x", cell_value, radioif);

  switch(radioif)
  {
    case NAS_RADIO_IF_GSM:
    {
      /**<   Serving cell Rx measurement. Values range between 0 and 63, which is
           mapped to a measured signal level:

           - cell_value 0 is a signal strength less than -110 dBm
           - cell_value 1 is -110 dBm to -109 dBm
           - cell_value 2 is -109 dBm to -108 dBm
           - ...
           - cell_value is -49 dBm to -48 dBm
           - cell_value is greater than -48 dBm
       */

      //For GSM, rssi ranges from 0 to 31 (dBm = -113 + 2*rssi) 0 means "-113 dBm or less" and 31 means "-51 dBm or greater"

      dbm = 111 - cell_value;
      if( dbm > 110 )
      {
        rssi = 0;
      }
      else if( dbm < 51 )
      {
        rssi = 31;
      }
      else
      {
        rssi = (int) ((113 - dbm) / 2);
      }
      break;
    }
    case NAS_RADIO_IF_UMTS:
    {
      // For UMTS, rssi is the Level index of CPICH RSCP (cell_value)
      rssi = cell_value;
      break;
    }
    case NAS_RADIO_IF_LTE:
    {
      /**<   Absolute power level (in 1/10 dBm) of the common pilot channel as
        received by the UE. Range: -1200 to -250 (e.g., -250 means -25.0 dBm).
        Defined in [S14].  */

      rssi = (cell_value * -1) / 10;
      break;
    }
    default:
    {
      QCRIL_LOG_INFO("Unsupported RAT");
      rssi = 0;
      break;
    }
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(rssi);
  return rssi;
} //qcril_qmi_nas_util_calculate_neighbor_cell_rssi

//===========================================================================
//qcril_qmi_nas_util_calculate_neighbor_cell_rssi
//===========================================================================
int qcril_qmi_nas_util_calculate_neighbor_cell_rssi(int cell_value)
{
  int rssi = 0;

  QCRIL_LOG_FUNC_ENTRY();

  if( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_GSM ) )
  {
    rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(cell_value, NAS_RADIO_IF_GSM);
  }
  else if( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_UMTS ) )
  {
    rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(cell_value, NAS_RADIO_IF_UMTS);
  }
  else if( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_LTE ) )
  {
    rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(cell_value, NAS_RADIO_IF_LTE);
  }
  else
  {
    QCRIL_LOG_INFO("Unsupported RAT");
    rssi = 0;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(rssi);
  return rssi;
} //qcril_qmi_nas_util_calculate_neighbor_cell_rssi

//===========================================================================
//RIL_REQUEST_SET_LOCATION_UPDATES
//===========================================================================
void qcril_qmi_nas_set_location_updates
(
  std::shared_ptr<RilRequestSetLocationUpdateMessage> msg
)
{
  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  nas_common_info.location_updates_enabled = (msg->getEnableStatus()) ?
        TRUE : FALSE;
  NAS_CACHE_UNLOCK();

  // ** respond
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_SUCCESS, nullptr));

  QCRIL_LOG_INFO("completed with %d", RIL_E_SUCCESS);
} // qcril_qmi_nas_set_location_updates

//===========================================================================
// qcril_qmi_nas_is_cell_location_changed_cl
//===========================================================================
boolean qcril_qmi_nas_is_cell_location_changed_cl
(
  RIL_CELL_INFO_LIST_TYPE *resp,
  unsigned ncells
)
{
    boolean changed = FALSE;
    unsigned i = 0;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_DEBUG("Prev ncells: %u. current: %u", nas_cached_info.cell_info_list_cells, ncells);
    if (ncells != nas_cached_info.cell_info_list_cells)
    {
        changed = TRUE;
    }
    else
    {
        for (i = 0; i < ncells; i++)
        {
            changed = changed || !qcril_qmi_nas_is_cell_info_equal(resp+i, nas_cached_info.cell_info_list+i);
            if (changed) break;
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(changed);
    return changed;
} // qcril_qmi_nas_is_cell_location_changed_cl

//===========================================================================
// qcril_qmi_nas_cell_location_unsol_if_needed_cl
//===========================================================================
uint8_t qcril_qmi_nas_cell_location_unsol_if_needed_cl
(
  nas_get_cell_location_info_resp_msg_v01 *cell_location_info
)
{
  qcril_unsol_resp_params_type unsol_resp_params;
  RIL_CELL_INFO_LIST_TYPE *results = NULL;
  unsigned size = 0;
  unsigned ncells = 0;
  uint8_t needed = FALSE;

  if (cell_location_info)
  {
    QCRIL_LOG_DEBUG("cli: %x, nci.time: %x, &results: %x, len: %x",
            cell_location_info,
            &nas_cached_info.cell_location_info_time,
            &results,
            &unsol_resp_params.resp_len);
    qcril_cell_info_process(
            cell_location_info,
            &nas_cached_info.cell_location_info_time,
            (void **)&results,
            &size,
            &ncells);

    if (qcril_qmi_nas_is_cell_location_changed_cl(results, ncells))
    {
      needed = TRUE;
      qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_CELL_INFO_LIST, &unsol_resp_params );
      unsol_resp_params.resp_pkt = results;
      unsol_resp_params.resp_len = size;
      QCRIL_LOG_DEBUG("After. cli: %x, nci.time: %x, &results: %x, len: %x",
                cell_location_info,
                &nas_cached_info.cell_location_info_time,
                &results,
                &size);
      QCRIL_LOG_DEBUG("Output. results: %x, len: %d",
                results,
                size);
      qcril_send_unsol_response( &unsol_resp_params );
    }
    nas_cached_info.cell_info_list_cells = 0;
    auto cellinfolist = nas_cached_info.cell_info_list;
    nas_cached_info.cell_info_list = results;
    if (cellinfolist) {
        qcril_free(cellinfolist);
    }
    nas_cached_info.cell_info_list_cells = ncells;
  }

  return needed;
} // qcril_qmi_nas_cell_location_unsol_if_needed_cl

//===========================================================================
// qcril_qmi_nas_cell_info_list_changed
//===========================================================================
void qcril_qmi_nas_cell_info_list_changed
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    QCRIL_NOTUSED(ret_ptr);
    QCRIL_NOTUSED(params_ptr);
} // qcril_qmi_nas_cell_info_list_changed


void qcril_qmi_nas_cell_location_update_timer_cl
(
  qmi_ril_cell_location_period_action action
)
{
  int conf_rate = nas_common_info.unsol_cell_info_rate;
  int max_period = nas_common_info.unsol_cell_info_rate_sweep_limit;
  int rate = nas_common_info.unsol_cell_info_current_rate;

  if (INT_MAX == conf_rate)
  {
    rate = conf_rate;
  }
  else
  {
    switch(action)
    {
      case QCRIL_CELL_LOCATION_INCREASE_PERIOD:
        rate = (rate << 1) | 0x7f;
        if (rate < 0 || rate > max_period)
        {
          rate = max_period;
        }
        break;
      case QCRIL_CELL_LOCATION_REDUCE_PERIOD:
        rate = rate >> 1;
        if (rate < conf_rate)
        {
          rate = conf_rate;
        }
        break;
      case QCRIL_CELL_LOCATION_RESET_PERIOD:
        rate = nas_common_info.unsol_cell_info_rate;
        break;
    }
  }
  nas_common_info.unsol_cell_info_current_rate = rate;
}

//===========================================================================
// qcril_qmi_nas_queue_cell_info_poll
//
// Queue an event to perform a poll for cell location info. This function
// can be called from any context
//
//
//===========================================================================
void
qcril_qmi_nas_queue_cell_info_poll
(
)
{
  qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
             QCRIL_DEFAULT_MODEM_ID,
             QCRIL_DATA_ON_STACK,
             QCRIL_EVT_QMI_RIL_POLL_CELL_INFO_LIST,
             NULL,
             0,
             (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
} // qcril_qmi_nas_queue_cell_info_poll


//===========================================================================
// qcril_qmi_nas_cell_info_timer_cb
//===========================================================================
void qcril_qmi_nas_cell_info_timer_cb
(
  void *param
)
{
    uint32 timer_id = (uint32)(uintptr_t) param;

    NAS_CACHE_LOCK();
    if (nas_common_info.cell_info_poll_timer_id_valid &&
        timer_id == nas_common_info.cell_info_poll_timer_id)
    {
      nas_common_info.cell_info_poll_timer_id_valid = FALSE;
      qcril_qmi_nas_queue_cell_info_poll();
    }
    else
    {
        QCRIL_LOG_DEBUG( "Timer was already canceled. Not polling %d\n", timer_id);
    }
    NAS_CACHE_UNLOCK();
} // qcril_qmi_nas_cell_info_timer_cb
//===========================================================================
// qcril_qmi_nas_cell_info_schedule_polling_cl
//===========================================================================
RIL_Errno qcril_qmi_nas_cell_info_schedule_polling_cl
(
  void
)
{
  struct timeval time;
  uint32_t ms;
  RIL_Errno ret = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  if ( INT_MAX != nas_common_info.unsol_cell_info_current_rate )
  {
    if ( nas_common_info.cell_info_poll_timer_id_valid )
    {
      qcril_cancel_timed_callback( (void *)(uintptr_t) nas_common_info.cell_info_poll_timer_id );
      nas_common_info.cell_info_poll_timer_id_valid = FALSE;
    }
    // Convert the time provided as milliseconds into seconds and useconds for timeval
    ms = nas_common_info.unsol_cell_info_current_rate;
    QCRIL_MS_TO_TIMEVAL( &time, ms );

    ret = (RIL_Errno) qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                QCRIL_DEFAULT_MODEM_ID,
                                qcril_qmi_nas_cell_info_timer_cb,
                                &time,
                                &nas_common_info.cell_info_poll_timer_id );
    if ( RIL_E_SUCCESS == ret)
    {
      nas_common_info.cell_info_poll_timer_id_valid = TRUE;
    }
  }
  else
  {
    QCRIL_LOG_DEBUG("Current rate set to INT_MAX. Not polling");
  }

  return ret;
} // qcril_qmi_nas_cell_info_schedule_polling_cl

//===========================================================================
// qcril_qmi_nas_poll_cell_info_list
//
// Handler function for QCRIL_EVT_QMI_RIL_POLL_CELL_INFO_LIST.
// This function will be called when a timer expires or after an explicit
// poll of cell info is requested.
//
// Should only be called in the context of the event thread.
//===========================================================================
void qcril_qmi_nas_poll_cell_info_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    RIL_Errno rc = RIL_E_GENERIC_FAILURE;
    nas_get_cell_location_info_resp_msg_v01 *get_cell_location_info_resp = NULL;
    uint64_t timestamp;

    QCRIL_NOTUSED(ret_ptr);
    QCRIL_NOTUSED(params_ptr);

    get_cell_location_info_resp = (nas_get_cell_location_info_resp_msg_v01 *) qcril_malloc(sizeof(*get_cell_location_info_resp));
    if (get_cell_location_info_resp)
    {
        // Fetch Cell Location info
        rc = qcril_qmi_nas_get_cell_location_data_sync(get_cell_location_info_resp,
                                                      &timestamp, QCRIL_QMI_ERR_CTX_NONE);
    }

    if (RIL_E_SUCCESS == rc)
    {
        NAS_CACHE_LOCK();
        nas_cached_info.cell_location_info_time = timestamp;
        if ( qcril_qmi_nas_cell_location_unsol_if_needed_cl(get_cell_location_info_resp) )
        {
            // Update timer for sweep operation
            qcril_qmi_nas_cell_location_update_timer_cl(QCRIL_CELL_LOCATION_REDUCE_PERIOD);
            // Schedule next poll.
            qcril_qmi_nas_cell_info_schedule_polling_cl();
        }
        else
        {
            qcril_qmi_nas_cell_location_update_timer_cl(QCRIL_CELL_LOCATION_INCREASE_PERIOD);
        }
        NAS_CACHE_UNLOCK();
    }

    if (get_cell_location_info_resp)
    {
        qcril_free( get_cell_location_info_resp );
        get_cell_location_info_resp = NULL;
    }
} // qcril_qmi_nas_poll_cell_info_list

//===========================================================================
// RIL_REQUEST_GET_CELL_INFO_LIST
//===========================================================================
void qcril_qmi_nas_get_cell_info_list_ncl
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  nas_get_cell_location_info_resp_msg_v01 get_cell_location_info_resp;
  RIL_CELL_INFO_LIST_TYPE *results = NULL;
  uint64_t timestamp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  unsigned size = 0;
  unsigned ncells = 0;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  memset(&get_cell_location_info_resp, 0, sizeof(get_cell_location_info_resp));


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( params_ptr );
  QCRIL_NOTUSED(ret_ptr);

  ril_req_res = qcril_qmi_nas_get_cell_location_data_sync(&get_cell_location_info_resp, &timestamp, QCRIL_QMI_ERR_CTX_CELL_LOCATION_TXN);

  if (RIL_E_SUCCESS == ril_req_res &&
          get_cell_location_info_resp.resp.error != QMI_ERR_NO_NETWORK_FOUND_V01)
  {
    NAS_CACHE_LOCK();

    nas_cached_info.cell_location_info_time = timestamp;

    NAS_CACHE_UNLOCK();

    qcril_cell_info_process(
            &get_cell_location_info_resp,
            &nas_cached_info.cell_location_info_time,
            (void **) &results,
            &size,
            &ncells);
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if (RIL_E_SUCCESS == ril_req_res)
  {
    resp.resp_pkt = results;
    resp.resp_len = size;
  }
  qcril_send_request_response( &resp );
  qcril_ril_cellinfo_free(results);
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_get_cell_info_list_ncl


//===========================================================================
// RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE
//===========================================================================
void qcril_qmi_nas_set_cell_info_list_rate
(
 const int32_t rate
)
{
  NAS_CACHE_LOCK();
  nas_common_info.unsol_cell_info_rate = rate;
  nas_common_info.unsol_cell_info_current_rate = rate;
  qcril_qmi_nas_cell_info_schedule_polling_cl();
  NAS_CACHE_UNLOCK();
} // qcril_qmi_nas_set_cell_info_list_rate


//===========================================================================
//RIL_REQUEST_CDMA_SUBSCRIPTION
//===========================================================================
void qcril_qmi_nas_request_cdma_subscription
(
  std::shared_ptr<RilRequestCdmaSubscriptionMessage> msg
)
{
  nas_get_3gpp2_subscription_info_req_msg_v01 qmi_request;
  nas_get_3gpp2_subscription_info_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  RIL_Errno   prl_fetch_ril_req_res = RIL_E_GENERIC_FAILURE;
  RIL_Errno   sub_info_fetch_ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_client_error_type qmi_client_error = QMI_INTERNAL_ERR;
  uint16_t       prl_version;
  uint32_t       iter = 0;
  char home_sid[NAS_SID_NID_STR_MAX_SIZE] = "";
  char home_nid[NAS_SID_NID_STR_MAX_SIZE] = "";
  char min_s[ NAS_IMSI_MIN1_LEN_V01 + NAS_IMSI_MIN2_LEN_V01 + 1 ];
  int sid_ptr=0,nid_ptr=0;
  std::string mdn, h_sid, h_nid, min, prl_ver;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_request, 0, sizeof(qmi_request));
  memset(&qmi_response, 0, sizeof(qmi_response));

  // get the prl_version
  prl_fetch_ril_req_res = qcril_qmi_nas_dms_fetch_cur_prl_version( &prl_version );
  if ( RIL_E_SUCCESS == prl_fetch_ril_req_res )
  {
      prl_ver = std::to_string((int)prl_version);
      QCRIL_LOG_INFO("qmi PRL version %s", prl_ver.c_str());
      qcril_qmi_dms_save_prl_info(TRUE, prl_version);
  }
  else
  {
      QCRIL_LOG_INFO("fetch current PRL version failed %d", prl_fetch_ril_req_res);
  }

  // get the others
  qmi_request.nam_id = 0xFF; // current NAM
  qmi_request.get_3gpp2_info_mask_valid = TRUE;
  qmi_request.get_3gpp2_info_mask = QMI_NAS_GET_3GPP2_SUBS_INFO_MDN_V01 | QMI_NAS_GET_3GPP2_SUBS_INFO_HOME_SID_IND_V01
                                    | QMI_NAS_GET_3GPP2_SUBS_INFO_MIN_BASED_IMSI_V01;

  //TODO **TIMER** use customized value
  qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_REQ_MSG_V01,
                                                (void*) &qmi_request,
                                                sizeof( qmi_request ),
                                                (void*) &qmi_response,
                                                sizeof( qmi_response ));

  sub_info_fetch_ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error, &qmi_response.resp, QCRIL_QMI_ERR_TOLERATE_NOT_FOUND, NULL );

  QCRIL_LOG_INFO("3gpp2_sub  %d, %d, %d", (int)qmi_client_error, (int) sub_info_fetch_ril_req_res, qmi_response.resp.error );

  if( RIL_E_SUCCESS == sub_info_fetch_ril_req_res )
  {
      if( qmi_response.mdn_valid )
      {
          mdn = std::string(qmi_response.mdn, MDN_MAX_LEN_V01);
      }

      if( qmi_response.cdma_sys_id_valid )
      {
          for( iter=0; iter < qmi_response.cdma_sys_id_len; iter++ )
          {
              sid_ptr += snprintf(&home_sid[sid_ptr],NAS_SID_NID_ELEMENT_MAX_SIZE+1,
                    "%u,", (unsigned int)qmi_response.cdma_sys_id[iter].sid );
              nid_ptr += snprintf(&home_nid[nid_ptr],NAS_SID_NID_ELEMENT_MAX_SIZE+1,
                    "%u,", (unsigned int)qmi_response.cdma_sys_id[iter].nid );
          }
          if( sid_ptr > 0 )
          {
              home_sid[sid_ptr-1]='\0';
          }
          if( nid_ptr > 0 )
          {
              home_nid[nid_ptr-1]='\0';
          }
          h_sid = home_sid;
          h_nid = home_nid;
      }

      if( qmi_response.min_based_info_valid )
      {
          strlcpy(min_s, qmi_response.min_based_info.imsi_m_s2, NAS_IMSI_MIN2_LEN_V01 + 1);
          strlcpy(&min_s[NAS_IMSI_MIN2_LEN_V01], qmi_response.min_based_info.imsi_m_s1, NAS_IMSI_MIN1_LEN_V01 + 1 );
          min = min_s;
      }

      QCRIL_LOG_INFO("qmi MDN %s", mdn.c_str());
      QCRIL_LOG_INFO("qmi SID %s", h_sid.c_str());
      QCRIL_LOG_INFO("qmi NID %s", h_nid.c_str());
      QCRIL_LOG_INFO("qmi MIN %s", min.c_str());
  }
  else
  {
      QCRIL_LOG_INFO("fetch 3gpp2 sub info failed %d", sub_info_fetch_ril_req_res);
  }

  if( RIL_E_SUCCESS == prl_fetch_ril_req_res || RIL_E_SUCCESS == sub_info_fetch_ril_req_res )
  {
      ril_req_res = RIL_E_SUCCESS;
  }
  else if(sub_info_fetch_ril_req_res != RIL_E_SUCCESS)
  {
    //using the error from sub info fecth ril(if its failure)
    ril_req_res = sub_info_fetch_ril_req_res;
  }
  else
  {
    ril_req_res = prl_fetch_ril_req_res;
  }

  auto payload = std::make_shared<qcril::interfaces::RilGetCdmaSubscriptionResult_t>(
      std::move(mdn), std::move(h_sid), std::move(h_nid), std::move(min), std::move(prl_ver));
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_request_cdma_subscription

//===========================================================================
//QCRIL_EVT_HOOK_SET_CDMA_SUB_SRC_WITH_SPC
//===========================================================================
void qcril_qmi_nas_set_subscription_source_with_spc
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_qmi_nas_set_subscription_source_generic(params_ptr, TRUE, ret_ptr);
}

//===========================================================================
//RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE
//===========================================================================
void qcril_qmi_nas_set_subscription_source
(
  std::shared_ptr<RilRequestSetCdmaSubscriptionSourceMessage> msg
)
{

  nas_set_rtre_config_req_v01 qmi_request;
  nas_set_rtre_config_resp_v01 qmi_response;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  memset( &qmi_request, 0, sizeof( qmi_request ) );

  NAS_CACHE_LOCK();
  auto operating_mode          = nas_dms_cached_info.operating_mode;
  auto operating_mode_valid    = nas_dms_cached_info.operating_mode_valid;
  NAS_CACHE_UNLOCK();

  if ( !(qmi_ril_is_multi_sim_feature_supported() ||
         qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDA2 )) ||
       ( operating_mode_valid && DMS_OP_MODE_ONLINE_V01 == operating_mode ) )
  {
      switch (msg->getSubcriptionSource()) {
      case RilRequestSetCdmaSubscriptionSourceMessage::SubscriptionSource::SIM:
          qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_RUIM_ONLY_V01;
          ril_req_res = RIL_E_SUCCESS;
          break;
      case RilRequestSetCdmaSubscriptionSourceMessage::SubscriptionSource::NV:
          qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01;
          ril_req_res = RIL_E_SUCCESS;
          break;
      default: // invalid or unsupported value
          ril_req_res = RIL_E_INVALID_ARGUMENTS;
          break;
      }
  }
  else
  { // modem not ONLINE, failing request
      ril_req_res = RIL_E_RADIO_NOT_AVAILABLE;
  }

  if ( RIL_E_SUCCESS == ril_req_res )
  {
      auto qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_SET_RTRE_CONFIG_REQ_MSG_V01,
                                                    (void*)&qmi_request,
                                                    sizeof( qmi_request ),
                                                    (void*) &qmi_response,
                                                    sizeof( qmi_response ),
                                                    ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);


      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
      QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);
  }

  // ** respond
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
}

static void qcril_qmi_nas_set_subscription_source_generic
(
  const qcril_request_params_type *const params_ptr,
  int spc_present,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  nas_set_rtre_config_req_v01 qmi_request;
  nas_set_rtre_config_resp_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  int *in_data_ptr;
  char *data_ptr;
  boolean result = FALSE;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  dms_operating_mode_enum_v01 operating_mode;
  int                         operating_mode_valid;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_LOG_INFO("spc_present %d", spc_present);

  QCRIL_NOTUSED( ret_ptr );


  memset( &qmi_request, 0, sizeof( qmi_request ) );

  if ( params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
      NAS_CACHE_LOCK();
      operating_mode          = nas_dms_cached_info.operating_mode;
      operating_mode_valid    = nas_dms_cached_info.operating_mode_valid;
      NAS_CACHE_UNLOCK();

      if ( !(qmi_ril_is_multi_sim_feature_supported() ||
             qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDA2 )) ||
           ( operating_mode_valid && DMS_OP_MODE_ONLINE_V01 == operating_mode ) )
      {

          if ( spc_present == TRUE )
          {
              // SPC is prsent. This is OEM_HOOK request with SPC information.
              data_ptr = (char *)params_ptr->data;
              QCRIL_LOG_INFO("subscription source value %d", (int) (data_ptr[0]));

              switch ( (oem_hook_cdma_subscription_source_e_type)(data_ptr[0]) )
              {
                  case SUBSCRIPTION_SOURCE_RUIM_SIM:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_RUIM_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  case SUBSCRIPTION_SOURCE_NV:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  case SUBSCRIPTION_SOURCE_RUIM_IF_AVAIL:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_RUIM_IF_AVAIL_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  default: // invalid or unsupported value
                      QCRIL_LOG_ERROR("Invalid source value %d", (int) (data_ptr[0]));
                      ril_req_res = RIL_E_INVALID_ARGUMENTS;
                      break;
              }

              if ( ril_req_res == RIL_E_SUCCESS )
              {
                  if ((params_ptr->datalen - 1) > NAS_SPC_MAX_V01 ||
                      (params_ptr->datalen - 1) < 1 )
                  {
                      QCRIL_LOG_ERROR("Invalid SPC len %d", params_ptr->datalen - 1);
                      ril_req_res = RIL_E_INVALID_ARGUMENTS;
                  }
                  else
                  {
                      qmi_request.spc_valid = TRUE;
                      memcpy(qmi_request.spc, &data_ptr[1], params_ptr->datalen - 1);
                  }
              }
          }
          else
          {
              // SPC is not prsent. This is normal RIL request with out SPC information.
              in_data_ptr = (int *)params_ptr->data;
              switch ( (RIL_CdmaSubscriptionSource)(*in_data_ptr) )
              {
                  case CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_RUIM_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  case CDMA_SUBSCRIPTION_SOURCE_NV:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  default: // invalid or unsupported value
                      ril_req_res = RIL_E_INVALID_ARGUMENTS;
                      break;
              }
          }
      }
      else
      { // modem not ONLINE, failing request
          ril_req_res = RIL_E_RADIO_NOT_AVAILABLE;
      }
  }
  else
  {
    ril_req_res = RIL_E_INVALID_ARGUMENTS;
  }
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_SET_RTRE_CONFIG_REQ_MSG_V01,
                                                    (void*)&qmi_request,
                                                    sizeof( qmi_request ),
                                                    (void*) &qmi_response,
                                                    sizeof( qmi_response ),
                                                    ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);


      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
      QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);

      if ( (spc_present == TRUE) && (ril_req_res == RIL_E_SUCCESS) )
      {
          result = TRUE;
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( spc_present == TRUE )
  {
      // This is QCRIL_EVT_HOOK_SET_CDMA_SUB_SRC_WITH_SPC request. Need to send result.
      resp.resp_pkt = &result;
      resp.resp_len = sizeof(result);
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_set_subscription_source

//===========================================================================
//RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE
//===========================================================================
void qcril_qmi_nas_get_subscription_source
(
  std::shared_ptr<RilRequestGetCdmaSubscriptionSourceMessage> msg
)
{
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_get_rtre_config_resp_v01 qmi_response;
  RIL_CdmaSubscriptionSource res_val = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_response,0,sizeof(qmi_response));
  qmi_client_error_type qmi_client_error = qmi_client_nas_send_sync(
                                                QMI_NAS_GET_RTRE_CONFIG_REQ_MSG_V01,
                                                NULL,
                                                NAS_NIL,  // empty request payload
                                                (void*) &qmi_response,
                                                sizeof( qmi_response ),
                                                ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
  QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);

  if( RIL_E_SUCCESS == ril_req_res )
  {
      if ( qmi_response.rtre_cfg_valid )
      {
          switch ( qmi_response.rtre_cfg )
          {
              case NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01:
                  res_val = CDMA_SUBSCRIPTION_SOURCE_NV;
                  break;

              case NAS_RTRE_CFG_RUIM_ONLY_V01:
                  res_val = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
                  break;

              default: // unsupported value
                  ril_req_res = RIL_E_MODEM_ERR;
                  res_val = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM; // as value will be logged
                  break;
          }
          QCRIL_LOG_INFO("rtre_cfg = %d", (int) res_val);
      }
      else
      {
          ril_req_res = RIL_E_MODEM_ERR;
      }
  }

  std::shared_ptr<qcril::interfaces::RilGetCdmaSubscriptionSourceResult_t> payload = nullptr;
  if (RIL_E_SUCCESS == ril_req_res) {
      payload = std::make_shared<qcril::interfaces::RilGetCdmaSubscriptionSourceResult_t>(res_val);
  }
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_get_subscription_source

//===========================================================================
//RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY
//===========================================================================
void qcril_qmi_nas_cdma_validate_and_write_key
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  nas_update_akey_req_msg_v01 akey_req_msg;
  nas_update_akey_resp_msg_v01 akey_resp_msg;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );


  if(  params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
  memset(&akey_req_msg, 0, sizeof(akey_req_msg));
  memset(&akey_resp_msg, 0, sizeof(akey_resp_msg));

  strlcpy((char*) akey_req_msg.akey, (const char*) params_ptr->data, sizeof(akey_req_msg.akey));

  qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_UPDATE_AKEY_REQ_MSG_V01,
                                                &akey_req_msg,
                                                sizeof(akey_req_msg),
                                                &akey_resp_msg,
                                                sizeof( akey_resp_msg ),
                                                ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &akey_resp_msg.resp );

  QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);
  }
  else
  {
    QCRIL_LOG_ERROR("Invalid arguments..null params");
    ril_req_res = RIL_E_INVALID_ARGUMENTS;
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_cdma_validate_and_write_key

//===========================================================================
//RIL_REQUEST_DEVICE_IDENTITY
//===========================================================================
void qcril_qmi_nas_dms_request_device_identity
(
  std::shared_ptr<RilRequestGetDeviceIdentityMessage> msg
)
{
  qcril_instance_id_e_type instance_id;

  dms_get_device_serial_numbers_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  qcril_nas_dms_device_identity_type ril_response_data;

  qmi_client_error_type qmi_client_error;

  int imeisv_value;
  int error;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  memset( &ril_response_data, 0, sizeof( ril_response_data ) );
  memset( &qmi_response, 0, sizeof( qmi_response ) );

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_DEVICE_SERIAL_NUMBERS_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);

  // ** prepare response
  if ( RIL_E_SUCCESS == ril_req_res )
  {

      ril_response_data.device_identity[NAS_DMS_DEVICE_ID_IMEI] = ril_response_data.imei;
      ril_response_data.device_identity[ NAS_DMS_DEVICE_ID_IMEISV ] = ril_response_data.imeisv;
      ril_response_data.device_identity[NAS_DMS_DEVICE_ID_ESN] = ril_response_data.esn;
      ril_response_data.device_identity[NAS_DMS_DEVICE_ID_MEID] = ril_response_data.meid;

      QCRIL_SNPRINTF( ril_response_data.imei, NAS_DMS_IMEI_MAX_STR_SIZE, "%d", 0 );
      QCRIL_SNPRINTF( ril_response_data.imeisv, NAS_DMS_IMEISV_MAX_STR_SIZE, "%02d", 0 );
      QCRIL_SNPRINTF( ril_response_data.esn, NAS_DMS_ESN_MAX_STR_SIZE, "%08lx", (unsigned long)0 );
      QCRIL_SNPRINTF( ril_response_data.meid, NAS_DMS_MEID_MAX_STR_SIZE, "%014lx", (unsigned long)0 );

      if ( qmi_response.imei_valid )
      {
          memcpy(ril_response_data.imei,qmi_response.imei,NAS_DMS_IMEI_MAX_STR_SIZE-1);
      }
      if( qmi_response.imeisv_svn_valid && (strlen(qmi_response.imeisv_svn)<NAS_DMS_IMEISV_MAX_STR_SIZE))
      {
          error = qcril_other_hex_to_int(qmi_response.imeisv_svn, &imeisv_value);
          if( NAS_NIL == error && imeisv_value <= QMI_DMS_IMEISV_MAX_VALUE )
          {
              qcril_other_int_to_ascii(ril_response_data.imeisv,NAS_DMS_IMEISV_MAX_STR_SIZE-1,imeisv_value);
          }
      }
      if ( qmi_response.esn_valid && (strlen(qmi_response.esn)<NAS_DMS_ESN_MAX_STR_SIZE))
      {
          memcpy(&ril_response_data.esn[NAS_DMS_ESN_MAX_STR_SIZE-1-strlen(qmi_response.esn)],qmi_response.esn
                 ,strlen(qmi_response.esn));
      }
      if ( qmi_response.meid_valid && (strlen(qmi_response.meid)<NAS_DMS_MEID_MAX_STR_SIZE) )
      {
          memcpy(&ril_response_data.meid[NAS_DMS_MEID_MAX_STR_SIZE-1-strlen(qmi_response.meid)],qmi_response.meid
                 ,strlen(qmi_response.meid));
      }
  }

  // ** respond
  std::string imei(ril_response_data.imei);
  std::string imeisv(ril_response_data.imeisv);
  std::string esn(ril_response_data.esn);
  std::string meid(ril_response_data.meid);
  auto payload = std::make_shared<qcril::interfaces::RilDeviceIdentityResult_t>(
        std::move(imei), std::move(imeisv), std::move(esn), std::move(meid));
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_device_identity

//===========================================================================
//RIL_REQUEST_BASEBAND_VERSION
//===========================================================================
void qcril_qmi_nas_dms_request_baseband_version
(
  std::shared_ptr<RilRequestGetBaseBandVersionMessage> msg
)
{
  qcril_instance_id_e_type instance_id;

  dms_get_sw_version_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  memset(&qmi_response,0,sizeof(qmi_response));
  QCRIL_LOG_FUNC_ENTRY();

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_SW_VERSION_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO("qmi %d, %d", (int) ril_req_res, qmi_client_error);

  // ** respond
  std::string ver(qmi_response.sw_version);
  auto payload = std::make_shared<qcril::interfaces::RilGetBaseBandResult_t>(
        std::move(ver));
  auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, payload);
  msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_baseband_version

//===========================================================================
// qcril_qmi_nas_check_power_save_and_screen_off_status
//===========================================================================
int  qcril_qmi_nas_check_power_save_and_screen_off_status()
{
  int ret;

  QCRIL_LOG_FUNC_ENTRY();
  ret = ( TRUE == qcril_qmi_ril_domestic_service_is_screen_off() && TRUE == qcril_qmi_ril_domestic_service_is_power_save_enabled() );
  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
} //qcril_qmi_nas_check_power_save_and_screen_off_status

//===========================================================================
// qcril_qmi_ril_domestic_service_is_screen_off
//===========================================================================
int qcril_qmi_ril_domestic_service_is_screen_off()
{
    int res;

    NAS_CACHE_LOCK();
#if (QCRIL_RIL_VERSION < 15)
    res = nas_common_info.is_screen_off;
#else
    res = (nas_common_info.unsol_response_filter.full_network_state_notification_enabled == TRUE)?FALSE:TRUE;
#endif
    NAS_CACHE_UNLOCK();

    return res;
} // qcril_qmi_ril_domestic_service_is_screen_off

//===========================================================================
// qcril_qmi_ril_domestic_service_is_power_save_enabled
//===========================================================================
int qcril_qmi_ril_domestic_service_is_power_save_enabled()
{
    return nas_common_info.add_power_save_enabled;
} // qcril_qmi_ril_domestic_service_is_power_save_enabled

//===========================================================================
// QCRIL_EVT_CM_UPDATE_FDN_STATUS
//===========================================================================
void qcril_qmi_nas_dms_event_update_fdn_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED(ret_ptr);
  QCRIL_NOTUSED(params_ptr);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_event_update_fdn_status

//===========================================================================
// qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch
//===========================================================================
void qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch
(
  qcril_instance_id_e_type instance_id,
  uint8 slot,
  boolean pwr_oprt_in_progress,
  qcril_uim_card_status_e_type card_status
)
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_nas_dms_update_card_status(instance_id, slot, pwr_oprt_in_progress, card_status);
  qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch

//===========================================================================
// qcril_qmi_nas_dms_update_card_status
//===========================================================================
void qcril_qmi_nas_dms_update_card_status
(
  qcril_instance_id_e_type instance_id,
  uint8 slot,
  boolean pwr_oprt_in_progress,
  qcril_uim_card_status_e_type card_status
)
{
    int                          must_post_dsds_local_deactivate;

    QCRIL_LOG_FUNC_ENTRY();

    must_post_dsds_local_deactivate = FALSE;
    NAS_CACHE_LOCK();

    nas_common_info.card_info[ slot ].pwr_oprt_in_progress = pwr_oprt_in_progress;

    if ( ( card_status != QCRIL_CARD_STATUS_POWERUP_FAILED ) && ( card_status != QCRIL_CARD_STATUS_POWERDOWN_FAILED ) )
    {
        nas_common_info.card_info[ slot ].status = card_status;
        switch ( card_status )
        {
            case QCRIL_CARD_STATUS_DOWN:
            case QCRIL_CARD_STATUS_UP:
            case QCRIL_CARD_STATUS_REFRESH:
                nas_common_info.card_info[ slot ].card_ever_present = TRUE;
                break;

            case QCRIL_CARD_STATUS_ABSENT:
                QCRIL_LOG_INFO( " card absent DSDS check: dsds status valid %d, dsds act_status %d, dsds is active %d/%d",
                                 nas_common_info.dsds.valid,
                                 (int)nas_common_info.dsds.cur_info.act_status,
                                 nas_cached_info.dsds_is_active_valid,
                                 nas_cached_info.dsds_is_active );
                // Unsol sub deactivated status shall be sent when SUBS indication is received.
                break;

            default:
                break;
        }
    }

    QCRIL_LOG_INFO( " qmi_ril: RID %d Slot %d, Pwr oprt in progress %d, Card status %s[%d]",
                     instance_id, slot, nas_common_info.card_info[ slot ].pwr_oprt_in_progress,
                     card_status_name[ nas_common_info.card_info[ slot ].status ], nas_common_info.card_info[ slot ].status );
    NAS_CACHE_UNLOCK();

    if ( must_post_dsds_local_deactivate )
    {
        auto msg = std::make_shared<RilUnsolUiccSubsStatusChangedMessage>(false);
        Dispatcher::getInstance().dispatchSync(msg);
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_dms_update_card_status

//===========================================================================
// qcril_qmi_nas_cleanup
//===========================================================================
void qcril_qmi_nas_cleanup()
{
    NAS_CACHE_LOCK();
    nas_common_info.dsds.is_default_data_set = FALSE;
    nas_common_info.dsds.default_data_reason = NONE;
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.current_plmn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rf_band_info_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.registration_reject_reason);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rssi);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.ecio);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.error_rate);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rsrq);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tac);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.def_roam_ind);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roaming_indicator);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.call_barring_status);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.mnc_includes_pcs_digit);

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nr5g_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nr5g_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info3);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info3);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_cell_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.voice_support_on_lte);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_is_eb_supported);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.emergency_access_barred);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_embms_coverage);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sim_rej_info);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.hs_call_status);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_bit_err_rate);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_block_err_rate);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_rscp);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.rscp);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tdscdma_block_err_rate);

    if ( NULL != nas_cached_info.cell_info_list)
    {
        qcril_free(nas_cached_info.cell_info_list);
    }
    nas_cached_info.cell_info_list = NULL;
    nas_cached_info.cell_info_list_cells = 0;
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.reported_data_reg_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.reported_data_technology);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.reported_pref_data_technology);
    nas_cached_info.is_calculated_vrte_used = 0;

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.dsds_is_active);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.dsds_is_priority_subs);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_default_data_subs);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.dds_type);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.voice_system_id);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_voice_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_sms_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_rac);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_rac);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_disable_cause);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.rat_disabled_mask);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.voice_domain_pref);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_csg_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_csg_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_ims_voice_avail);
    nas_cached_info.old_lte_ims_voice_avail = NAS_INVALID_VOPS;

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.endc_available);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.restrict_dcnr);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available);

    nas_common_info.prev_srv_domain_valid = FALSE;
    nas_common_info.prev_srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;
    nas_common_info.sim_provisioned = FALSE;

    memset( &nas_common_info.card_info, 0, RIL_UIM_MAX_CARD_COUNT * sizeof( qcril_qmi_nas_dms_card_info_type ) );

    nas_common_info.dsds.fm_status = QCRIL_FLEXI_MAP_STATUS_NONE;
    nas_common_info.prov_in_progress = FALSE;
    nas_common_info.prov_status = RIL_E_SUCCESS;
    nas_common_info.card_prov_pending = FALSE;
    qcril_qmi_prov_reset_prov_pref_info(TRUE);

    NAS_CACHE_UNLOCK();

    NAS_EMBMS_CACHE_LOCK();
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.embms_coverage_status);
    NAS_EMBMS_CACHE_UNLOCK();

    qmi_ril_nwr_set_eme_cbm(QMI_RIL_EME_CBM_NOT_ACTIVE);

    //qcril_qmi_nas_data_control_deregister_for_call_activity();
    nas_cached_info.voice_roam_status_reported = FALSE;

    qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
    qcril_qmi_arb_reset_pref_data_snapshot();

    if( TRUE == nas_common_info.custom_emergency_numbers_enabled )
    {
        qcril_qmi_nas_cleanup_custom_emergency_numbers();
    }

    NAS_CACHE_LOCK();
    nas_common_info.location_updates_enabled        = TRUE;
    nas_cached_info.is_registered_on_ims = FALSE;
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_default_data_subs);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.dds_type);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_blocked);

    nas_cached_info.voice_rte                       = QMI_RIL_RTE_NONE;
    nas_cached_info.data_rte                        = QMI_RIL_RTE_NONE;
    nas_cached_info.ims_rte                         = QMI_RIL_RTE_NONE;

    nas_common_info.unsol_cell_info_rate = INT_MAX;
    nas_common_info.unsol_cell_info_current_rate = nas_common_info.unsol_cell_info_rate;
    nas_common_info.cell_info_poll_timer_id = 0;
    nas_common_info.cell_info_poll_timer_id_valid = FALSE;

    // initialize the unsol response filter
    nas_common_info.unsol_response_filter.signal_strength_notification_enabled    = true;
    nas_common_info.unsol_response_filter.full_network_state_notification_enabled = true;
    nas_common_info.unsol_response_filter.data_call_dormancy_notification_enabled = true;

    nas_cached_info.voice_rte_confidence_tag        = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.data_rte_confidence_tag         = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.ims_rte_confidence_tag          = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.voice_roam_status_reported      = FALSE;

    nas_cached_info.data_reg_report_expiry          = NAS_NIL;
    nas_cached_info.extrapolation_ban_expiry        = NAS_NIL;

    nas_cached_info.dds_timeout_watch               = NAS_NIL;
    nas_cached_info.attch_timeout_watch        = NAS_NIL;
    nas_cached_info.active_subs_timeout_watch  = NAS_NIL;

    nas_common_info.data_dormancy_ind_enabled               = FALSE;
    nas_cached_info.common_indications_is_subscribed        = TRUE;     // because of subsequent qcril_qmi_util_enable_networking_indications() call

    memset( &nas_common_info.card_info, 0, RIL_UIM_MAX_CARD_COUNT * sizeof( qcril_qmi_nas_dms_card_info_type ) );

    nas_cached_info.deferred_mode_pref_set_valid         = FALSE;
    nas_cached_info.deferred_mode_pref_set_android_param = NAS_NIL;

    nas_cached_info.deferred_acq_order_valid = FALSE;
    nas_cached_info.deferred_acq_order_len   = 0;
    nas_cached_info.deferred_acq_order_map   = QCRIL_QMI_ACQ_ORDER_NONE;
    memset(nas_cached_info.deferred_acq_order, 0, sizeof(nas_cached_info.deferred_acq_order));

    nas_dms_cached_info.card_shutdown_initiated     = FALSE;

    nas_cached_info.data_reg_roaming_status_latest          = NAS_NIL;
    nas_cached_info.data_reg_roaming_status_latest_val      = FALSE;
    nas_cached_info.data_reg_roaming_status_latest_expiry   = NAS_NIL;

    nas_cached_info.prev_reported_csg_id_valid = FALSE;
    nas_cached_info.prev_reported_csg_id = QCRIL_CSG_ID_INVALID;

    nas_cached_info.is_in_apm_leave_window = 0;
    nas_cached_info.apm_timer_id = 0;

    nas_cached_info.is_indication_received = FALSE;
    if( NAS_ZERO != nas_cached_info.sys_sel_pref_tmr )
    {
        qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.sys_sel_pref_tmr);
        nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
    }

    nas_cached_info.designated_number_added_for_designated_country_status = QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NONE;
    memset(nas_cached_info.mcc_from_imsi_cache, NAS_NIL, sizeof(nas_cached_info.mcc_from_imsi_cache));

    NAS_CACHE_INVALIDATE_ENTRY_FIXED_LEN_ARR(nas_cached_info.band_priority_list);

    nas_cached_info.modem_shutdown_state = QMI_RIL_NAS_MODEM_SHUTDOWN_STATE_END;
    nas_cached_info.modem_shutdown_ims_shutdown_timer = NAS_NIL;
    NAS_CACHE_UNLOCK();
} // qcril_qmi_nas_cleanup

//===========================================================================
//QCRIL_EVT_HOOK_GET_MODEM_CAPABILITY
//===========================================================================
void qcril_qmi_nas_get_modem_capability
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_SUCCESS;
  uint8_t * modem_capability = NULL;
  int len = 0;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  if ( nas_dms_cached_info.current_sub_capability_valid != TRUE )
  {
      ril_req_res = qcril_qmi_nas_get_device_capability(FALSE, FALSE, TRUE, FALSE);
  }
  if ( ril_req_res == RIL_E_SUCCESS )
  {
      modem_capability = (uint8_t *) qcril_malloc(sizeof(uint32)+3);
      if ( modem_capability != NULL)
      {
        memset(modem_capability,0,sizeof(uint32)+3);
        if ( nas_dms_cached_info.current_sub_capability_valid == TRUE )
        {
          len = qcril_qmi_dms_construct_modem_cap_response(modem_capability);
          qcril_qmi_nas_notify_embms_status();
          QCRIL_LOG_DEBUG( "len %d", len);
        }
        else
        {
          ril_req_res = RIL_E_GENERIC_FAILURE;
        }
      }
      else
      {
        ril_req_res = RIL_E_GENERIC_FAILURE;
      }
  }
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( ril_req_res == RIL_E_SUCCESS )
  {
      resp.resp_pkt = (void *) modem_capability;
      resp.resp_len = len;
  }
  qcril_send_request_response( &resp );

  if (modem_capability)
  {
    qcril_free(modem_capability);
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_dms_construct_modem_cap_response
//===========================================================================
int qcril_qmi_dms_construct_modem_cap_response
(
uint8_t * resp_byte_stream
)
{
  int len = 0;
  uint8_t * resp_ptr = NULL;
  resp_ptr = resp_byte_stream;
  uint32_t sub_capability;
  uint8_t sub_voice_data_capability = 0, max_active_data_subs = 1;
  uint8_t modem_stack_id = (uint8_t) qcril_qmi_get_modem_stack_id();

  QCRIL_LOG_FUNC_ENTRY();

  if ( resp_byte_stream != NULL )
  {
    sub_capability = qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();
    QCRIL_LOG_DEBUG( "[MSIM] Sub capability %x", sub_capability);
    QCRIL_LOG_DEBUG( "[MSIM] Modem stack id %d", (int) modem_stack_id);

    // Modem stack id -  1 byte
    memcpy(resp_ptr, &modem_stack_id, sizeof(uint8_t));
    resp_ptr = resp_ptr + sizeof(uint8_t);
    len = sizeof(uint8_t);

    // Stack RAT capability - 4 bytes
    memcpy(resp_ptr, &sub_capability, sizeof(uint32));
    resp_ptr = resp_ptr + sizeof(uint32);
    len += sizeof(uint32);

    // Stack voice data capability -  1 byte
    if (nas_dms_cached_info.subs_voice_data_capability_valid)
    {
      sub_voice_data_capability = nas_dms_cached_info.subs_voice_data_capability;
      QCRIL_LOG_DEBUG( "[MSIM] sub_voice_data_capability %d", (int) sub_voice_data_capability);
    }
    memcpy(resp_ptr, &sub_voice_data_capability, sizeof(uint8_t));
    len += sizeof(uint8_t);
    resp_ptr += sizeof(uint8_t);

    // Max active data subs supported - 1 byte
    if (nas_dms_cached_info.max_active_data_subs_valid)
    {
      max_active_data_subs = nas_dms_cached_info.max_active_data_subs;
      QCRIL_LOG_DEBUG( "[MSIM] max_active_data_subs %d", (int) max_active_data_subs);
    }
    memcpy(resp_ptr, &max_active_data_subs, sizeof(uint8_t));
    len += sizeof(uint8_t);
    resp_ptr += sizeof(uint8_t);
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(len);
  return len;
}

//===========================================================================
// qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech
//===========================================================================
uint32_t qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech()
{
    uint32_t sub_capability = 0;

    QCRIL_LOG_FUNC_ENTRY();

    if ( nas_dms_cached_info.current_sub_capability_valid == TRUE )
    {
        QCRIL_LOG_DEBUG( "[MSIM] Current sub capability %x", nas_dms_cached_info.current_sub_capability);
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_CDMA_V01 )
        {
            sub_capability |= RAF_1xRTT;
            sub_capability |= RAF_IS95A;
            sub_capability |= RAF_IS95B;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_HDR_V01 )
        {
            sub_capability |= RAF_EVDO_0;
            sub_capability |= RAF_EVDO_A;
            sub_capability |= RAF_EVDO_B;
            sub_capability |= RAF_EHRPD;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_GSM_V01 )
        {
            sub_capability |= RAF_GSM;
            sub_capability |= RAF_GPRS;
            sub_capability |= RAF_EDGE;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_WCDMA_V01 )
        {
            sub_capability |= RAF_UMTS;
            sub_capability |= RAF_HSUPA;
            sub_capability |= RAF_HSDPA;
            sub_capability |= RAF_HSPA;
            sub_capability |= RAF_HSPAP;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_LTE_V01 )
        {
            sub_capability |= RAF_LTE;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_TDS_V01 )
        {
            sub_capability |= RAF_TD_SCDMA;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_NR5G_V01 )
        {
            sub_capability |= RAF_5G;
        }
   }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(sub_capability);
    return sub_capability;
}

//===========================================================================
// qcril_qmi_nas_send_unsol_modem_capability
//===========================================================================
void qcril_qmi_nas_send_unsol_modem_capability()
{
  int len = 0;
  uint8_t * modem_capability = NULL;
  modem_capability = (uint8_t *) qcril_malloc(sizeof(uint32)+3);
  if ( modem_capability != NULL)
  {
    memset(modem_capability,0,sizeof(uint32)+3);
    len = qcril_qmi_dms_construct_modem_cap_response(modem_capability);
    qcril_qmi_nas_notify_embms_status();
    QCRIL_LOG_DEBUG("[MSIM] len %d", len);
    if ( len > 0 )
    {
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_MODEM_CAPABILITY, (char*)modem_capability, len);
    }
  }
  if ( modem_capability )
  {
    qcril_free(modem_capability);
  }
}

void qcril_qmi_nas_update_sub_binding
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_request_resp_params_type resp;
  uint8_t * bind_info;
  uint8_t bind_enable = 1;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  if (!qmi_ril_is_multi_sim_feature_supported())
  {
    ril_req_res = RIL_E_SUCCESS;
  }
  else if(  params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
    bind_info = (uint8_t *) params_ptr->data;
    qcril_modem_stack_id_e_type stack_id = (qcril_modem_stack_id_e_type) bind_info[0];
    bind_enable = bind_info[1];
    QCRIL_LOG_DEBUG("[MSIM] Stack id %d bind enable %d", stack_id, bind_enable);

    if ( bind_enable == TRUE )
    {
      ril_req_res = qcril_qmi_nas_perform_bind_operation(stack_id);
      qcril_qmi_nas_get_device_capability(FALSE, FALSE, TRUE, FALSE);
      qcril_qmi_nas_send_unsol_modem_capability();
    }
    else
    {
      ril_req_res = RIL_E_SUCCESS;
      qcril_qmi_nas_nw_select_handle_total_cleanup();
      qcril_qmi_nas_perform_unbind_operation();
    }
  }

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );
}

//===========================================================================
// RIL_REQUEST_GET_RADIO_CAPABILITY
//===========================================================================
void qcril_qmi_nas_get_radio_capability
(
  std::shared_ptr<RilRequestGetRadioCapMessage> msg
)
{
  RIL_Errno   ril_req_res = RIL_E_SUCCESS;
  // RIL_RadioCapability * radio_cap_req;

  QCRIL_LOG_FUNC_ENTRY();

  auto payload = new qcril::interfaces::RilRadioCapResult_t();
  if (payload == nullptr) {
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_NO_MEMORY, nullptr));
    return;
  }
  auto& radio_cap_resp = payload->respData;

  if ( nas_dms_cached_info.current_sub_capability_valid != TRUE )
  {
    ril_req_res = qcril_qmi_nas_get_device_capability(FALSE, FALSE, TRUE, FALSE);
  }
  if ( ril_req_res == RIL_E_SUCCESS )
  {
    memset(&radio_cap_resp, 0, sizeof(radio_cap_resp));
    qcril_qmi_nas_fill_radio_cap_resp( TRUE, RC_STATUS_SUCCESS, &radio_cap_resp);
#if 0
    // XXX: in which case do we have input from ATEL?
    if( params_ptr->datalen > 0 && params_ptr->data != NULL )
    {
        radio_cap_req = (RIL_RadioCapability *) params_ptr->data;
        radio_cap_resp.version = radio_cap_req->version;
        radio_cap_resp.session = radio_cap_req->session;
    }
#endif
  }

  // ** respond
  if (RIL_E_SUCCESS == ril_req_res) {
    std::shared_ptr<qcril::interfaces::RilRadioCapResult_t> shared_resp(payload);
    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, shared_resp);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  } else {
    delete payload;
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, nullptr));
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_dms_convert_sub_capability_to_ril_radio_family
//===========================================================================
uint32_t qcril_qmi_dms_convert_sub_capability_to_ril_radio_family()
{
    uint32_t sub_capability = 0;

    QCRIL_LOG_FUNC_ENTRY();

    if ( nas_dms_cached_info.current_sub_capability_valid == TRUE )
    {
        QCRIL_LOG_DEBUG( "[MSIM] Current sub capability %x", nas_dms_cached_info.current_sub_capability);
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_CDMA_V01 )
        {
            sub_capability = sub_capability | RAF_1xRTT;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_HDR_V01 )
        {
            sub_capability = sub_capability | RAF_EVDO_A;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_GSM_V01 )
        {
            sub_capability = sub_capability | RAF_GSM;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_WCDMA_V01 )
        {
            sub_capability = sub_capability | RAF_UMTS;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_LTE_V01 )
        {
            sub_capability = sub_capability | RAF_LTE;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_TDS_V01 )
        {
            sub_capability = sub_capability | RAF_TD_SCDMA;
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_NR5G_V01 )
        {
            sub_capability = sub_capability | RAF_5G;
        }
   }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(sub_capability);
    return sub_capability;
}


//===========================================================================
//RIL_REQUEST_SET_RADIO_CAPABILITY
//===========================================================================
void qcril_qmi_nas_set_radio_capability
(
  std::shared_ptr<RilRequestSetRadioCapMessage> msg
)
{
  int                   process_request = TRUE;
  int                   is_ssr_progress = FALSE;
  int modem_stack_id = 0;
  RIL_Errno   ril_req_res = RIL_E_SUCCESS;
  char *end_ptr = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  auto& radio_cap = msg->getRadioCap();
  modem_stack_id = strtoul(radio_cap.logicalModemUuid, &end_ptr, 0 );

  // sanity check for received input
  if ( radio_cap.rat == 0 ||
       errno == ERANGE ||
       errno == EINVAL ||
       modem_stack_id < QCRIL_MODEM_PRIMARY_STACK_ID ||
       modem_stack_id > QCRIL_MODEM_MAX_STACK_ID )
  {
    QCRIL_LOG_ERROR("Invalid arguments received..");
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_INVALID_ARGUMENTS, nullptr));
  }
  else if (!qmi_ril_is_multi_sim_feature_supported())
  {
    QCRIL_LOG_ERROR("Flexmap request received in single sim configuration");
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_REQUEST_NOT_SUPPORTED, nullptr));
  }
  else
  {
    qcril_qmi_nas_set_fm_req_resp_info(radio_cap.version, radio_cap.session, radio_cap.phase);

    is_ssr_progress = qmi_ril_ssr_in_progress();
    if ( is_ssr_progress  || TRUE == qmi_ril_voice_is_under_any_voice_calls() )
    {
      if ( radio_cap.phase == RC_PHASE_FINISH )
      {
        process_request = TRUE;
      }
      else
      {
        process_request = FALSE;
      }
    }

    if ( process_request )
    {
      QCRIL_LOG_DEBUG("[MSIM] Modem stack id %d phase %d", modem_stack_id, radio_cap.phase);
      switch ( radio_cap.phase )
      {
        case RC_PHASE_START:
        qcril_qmi_nas_fm_handle_start_cmd(modem_stack_id, msg);
        break;

        case RC_PHASE_APPLY:
        qcril_qmi_nas_fm_handle_apply_cmd(modem_stack_id, msg);
        break;

        case RC_PHASE_FINISH:
        qcril_qmi_nas_fm_handle_finish_cmd(modem_stack_id, radio_cap.status, msg);
        break;

        default:
        QCRIL_LOG_DEBUG("[MSIM] Invalid phase!");
        QCRIL_LOG_ERROR("Invalid arguments..[MSIM] Invalid phase");
        ril_req_res = RIL_E_INVALID_ARGUMENTS;
        break;
      }
    }
    else
    {
      QCRIL_LOG_DEBUG("[MSIM] SSR/Voice call in progress, return failure!");
      QCRIL_LOG_ERROR("Invalid state..[MSIM]SSR/Voice call in progress");
      ril_req_res = RIL_E_INVALID_STATE;
    }
  }

  if ( ril_req_res != RIL_E_SUCCESS )
  {
    qcril_qmi_nas_send_set_radio_cap_resp(msg, RC_STATUS_FAIL, ril_req_res);
    // UNSOL response need to be sent for APPLY success/failure.
    // Telephony waits for 30 seconds to receive UNSOL to proceed further.
    if (radio_cap.phase == RC_PHASE_APPLY )
    {
      qcril_qmi_nas_send_unsol_radio_cap_resp(RC_STATUS_FAIL);
    }
  }
  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_fm_handle_start_cmd
//===========================================================================
void qcril_qmi_nas_fm_handle_start_cmd
(
  int modem_stack_id,
  std::shared_ptr<RilRequestSetRadioCapMessage> msg
)
{
  int                               slot = qmi_ril_get_sim_slot();
  RIL_Errno                         result = RIL_E_SUCCESS;
  int                               status = RC_STATUS_SUCCESS;
  uint8_t                           curr_stack_id;
  int                               send_resp = FALSE;
  int                               pending_prov = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  // START:
  // Set fm status as START_DEACTIVATE
  // Send request to prov module for deactivation
  // Set fm status as START_UNBIND
  // Perform unbind - set the internal state as unbind
  // Return failure in case of
  // - telephony not sending current/old stack id
  // - invalid state transition
  // - deactivation failure

  // Return failure if the stack id is not same as current stack id
  // Telephony is expected to send current modem id in start request.
  curr_stack_id = (uint8_t) qcril_qmi_get_modem_stack_id();
  if ( curr_stack_id != modem_stack_id)
  {
    QCRIL_LOG_DEBUG("Expecting same stack id in START request! ril stack: %d tel stack: %d",
                     curr_stack_id, (RIL_SubscriptionType)modem_stack_id);
  }

  qcril_qmi_nas_info_flexmap_status(NasFlexmapState::NAS_FLEXMAP_STATE_START);

  // Deactivate sub as required
  if (qmi_ril_is_multi_sim_feature_supported())
  {
    if (RIL_E_GENERIC_FAILURE == qcril_qmi_nas_set_flexi_map_status(QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE))
    {
      QCRIL_LOG_DEBUG("Failed to set state %d", QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE);
      result = RIL_E_GENERIC_FAILURE;
    }
    // Deactivate the apps
    else
    {
        NAS_CACHE_LOCK();
        pending_prov = nas_common_info.prov_in_progress;

        /* Provisioning request only if card status is UP */
        if ( nas_common_info.card_info[slot].status == QCRIL_CARD_STATUS_UP )
        {
            auto ret = getNasModule().getPendingMessageList().insert(msg);
            if (ret.second) {
                QCRIL_LOG_INFO("pending provisioning - %d", pending_prov);
                if ( pending_prov == FALSE )
                {
                    QCRIL_LOG_INFO("Start provisioning as part of flex_mapping...");
                    qcril_qmi_prov_handle_prov_state_change(QCRIL_QMI_PROV_STATE_FM_START);
                }
            }
            else
            {
                result = RIL_E_INTERNAL_ERR;
            }
        }
        else
        {
            NAS_CACHE_UNLOCK();
            QCRIL_LOG_INFO("Card status is not up.. start unbind");
            /* If card status is not up, unbind here.*/
            result = qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_START_UNBIND );
            if ( result == RIL_E_SUCCESS )
            {
                qcril_qmi_nas_perform_unbind_operation();
                status = RC_STATUS_SUCCESS;
            }
            else
            {
                status = RC_STATUS_FAIL;
            }
            send_resp = TRUE;
            NAS_CACHE_LOCK();
        }
        NAS_CACHE_UNLOCK();
    }
  }
  else
  {
    QCRIL_LOG_DEBUG("RIL does not need to provision!");
    result = qcril_qmi_nas_set_flexi_map_status(QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE);
    if (RIL_E_GENERIC_FAILURE == result)
    {
      QCRIL_LOG_DEBUG("Failed to set state %d", QCRIL_FLEXI_MAP_STATUS_START_DEACTIVATE);
    }
  }

  if (RIL_E_GENERIC_FAILURE == result || send_resp == TRUE )
  {
    if ( result == RIL_E_GENERIC_FAILURE )
    {
        status = RC_STATUS_FAIL;
    }
    qcril_qmi_nas_send_set_radio_cap_resp(msg, status, result);
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_fm_handle_apply_cmd
//===========================================================================
void qcril_qmi_nas_fm_handle_apply_cmd
(
  int modem_stack_id,
  std::shared_ptr<RilRequestSetRadioCapMessage> msg
)
{
  uint8_t                           curr_stack_id;
  int                               slot = qmi_ril_get_sim_slot();
  RIL_Errno                         result = RIL_E_SUCCESS;
  int                               status = RC_STATUS_SUCCESS;
  int                               send_resp = FALSE;
  int                               pending_prov = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  // APLLY:
  // Set fm status as APPLY_BIND
  // Perform bind
  // - bind to new stack
  // - set the internal state to INIT_ONGOING (from UNBIND)
  // - inform data for stack switch
  // - update stack specific info like capability, vsid etc.
  // Set fm status as APPLY_ACTIVATE
  // Do activation as required
  // Wait for UIM response if activation initiated from RIL.
  // Return failure in case of
  // - bind failure
  // - invalid state transition
  // - activation failure

  curr_stack_id = (uint8_t) qcril_qmi_get_modem_stack_id();
  result = qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_APPLY_BIND );
  if (RIL_E_GENERIC_FAILURE == result)
  {
    QCRIL_LOG_DEBUG("[MSIM] Failed to set state %d", QCRIL_FLEXI_MAP_STATUS_APPLY_BIND);
  }
  else
  {
    // Perform BIND
    result = qcril_qmi_nas_perform_bind_operation((RIL_SubscriptionType)modem_stack_id);
  }
  // Do activation as required
  if ( result == RIL_E_SUCCESS )
  {
    if (qmi_ril_is_multi_sim_feature_supported())
    {
      result = qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_APPLY_ACTIVATE );
      if ( RIL_E_GENERIC_FAILURE == result )
      {
        QCRIL_LOG_DEBUG("Failed to set state %d", QCRIL_FLEXI_MAP_STATUS_APPLY_ACTIVATE);
      }
      else
      {
        NAS_CACHE_LOCK();

        pending_prov = nas_common_info.prov_in_progress;
        QCRIL_LOG_INFO("pending provisioning - %d", pending_prov);
        /* Provisioning request only if card status is UP */
        if( nas_common_info.card_info[slot].status == QCRIL_CARD_STATUS_UP )
        {
          auto ret = getNasModule().getPendingMessageList().insert(msg);
          if (ret.second) {
            QCRIL_LOG_INFO("pending provisioning - %d", pending_prov);
            if ( pending_prov == FALSE )
            {
              nas_common_info.card_prov_pending = FALSE;
              qcril_qmi_prov_handle_prov_state_change(QCRIL_QMI_PROV_STATE_FM_APPLY);
            }
          }
          else
          {
            result = RIL_E_INTERNAL_ERR;
          }
        }
        else
        {
          QCRIL_LOG_DEBUG("Reset provisioning state... ");
          qcril_qmi_prov_handle_prov_state_change(QCRIL_QMI_PROV_STATE_NONE);

          /* If card status is not up, send response right away. */
          send_resp = TRUE;
        }

        //Hold lock till event is posted so that CARD_UP should not go before this.
        NAS_CACHE_UNLOCK();
      }
    }
    else
    {
      QCRIL_LOG_DEBUG("RIL does not need to provision!");
      result = qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_APPLY_ACTIVATE );
      if ( result == RIL_E_GENERIC_FAILURE )
      {
        QCRIL_LOG_DEBUG("Failed to set state %d", QCRIL_FLEXI_MAP_STATUS_APPLY_ACTIVATE);
      }
    }

  }
  else
  {
    // Return failure for bind failure
    QCRIL_LOG_DEBUG("RIL bind failed!!");
    qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_APPLY_BIND_FAIL );
    result = RIL_E_GENERIC_FAILURE;
  }

  if ( result == RIL_E_GENERIC_FAILURE || send_resp == TRUE )
  {
    if ( RIL_E_GENERIC_FAILURE == result )
    {
        status = RC_STATUS_FAIL;
    }
    qcril_qmi_nas_send_set_radio_cap_resp(msg, status, result);
    qcril_qmi_nas_send_unsol_radio_cap_resp(status);
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_fm_handle_finish_cmd
//===========================================================================
void qcril_qmi_nas_fm_handle_finish_cmd
(
  int modem_stack_id,
  int status,
  std::shared_ptr<RilRequestSetRadioCapMessage> msg
)
{
  RIL_Errno result = RIL_E_SUCCESS;
  int       prov_progress = FALSE;
  int       slot = qmi_ril_get_sim_slot();

  QCRIL_LOG_FUNC_ENTRY();

  result = qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_FINISH );

  QCRIL_LOG_DEBUG("stack id - %d, status - %d", modem_stack_id, status);

  /* In case of flexmap success, telephony sends new modem stack id and status as RC_STATUS_SUCCESS.
     In case of flexmap failure, telephony sends old modem stack id and status as RC_STATUS_FAIL */
  if ( status == RC_STATUS_SUCCESS )
  {
    QCRIL_LOG_DEBUG("Flexmap completed with SUCCESS");
  }
  else
  {
    QCRIL_LOG_DEBUG("Flexmap failed");
    NAS_CACHE_LOCK();
    prov_progress = nas_common_info.prov_in_progress;
    NAS_CACHE_UNLOCK();

    /* if current provisioning is not in progress, reset prov state
       to ensure that further flex map requests are handled properly */
    if ( prov_progress == FALSE )
    {
        QCRIL_LOG_DEBUG("Reset provisioning state...");
        qcril_qmi_prov_handle_prov_state_change(QCRIL_QMI_PROV_STATE_NONE);
    }
  }

  qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_NONE);
  qcril_qmi_nas_send_set_radio_cap_resp(msg, status, result);
  qcril_qmi_nas_wave_voice_data_status();

  NAS_CACHE_LOCK();
  if((TRUE == nas_common_info.card_prov_pending) &&
     (nas_common_info.card_info[slot].status == QCRIL_CARD_STATUS_UP))
  {
    QCRIL_LOG_INFO( "Card status up... Start provisioning..." );
    nas_common_info.prov_in_progress = TRUE;
    qcril_qmi_prov_handle_prov_state_change(QCRIL_QMI_PROV_STATE_CARD_UP);
  }

  nas_common_info.card_prov_pending = FALSE;
  NAS_CACHE_UNLOCK();
  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//QCRIL_EVT_QMI_PROV_FM_APPLY_STATUS
//===========================================================================
void qcril_qmi_nas_prov_fm_apply_status_hndlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    int res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type req_info;
    int status = RC_STATUS_FAIL;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    memset(&req_info, 0, sizeof(req_info));
    if ( params_ptr->data != NULL && params_ptr->datalen > 0 )
    {
        auto& msgList = getNasModule().getPendingMessageList();
        auto msg = msgList.find(RilRequestSetRadioCapMessage::get_class_message_id());
        if (msg != nullptr)
        {
          auto setCapMsg = std::static_pointer_cast<RilRequestSetRadioCapMessage>(msg);
          if (setCapMsg->getRadioCap().phase == RC_PHASE_APPLY)
          {
            res = *(int*) params_ptr->data;

            if ( res == RIL_E_SUCCESS )
            {
                status = RC_STATUS_SUCCESS;
                qmi_ril_enable_ril_operational_status();
            }

            nas_common_info.prov_status = res;
            qcril_qmi_nas_send_set_radio_cap_resp(setCapMsg,
                                                  status,
                                                  (RIL_Errno) res);
            qcril_qmi_nas_send_unsol_radio_cap_resp(res);
            qcril_qmi_prov_send_unsol_sub_pref_change();
          }
        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_prov_main_threaded_unbind
//===========================================================================
void qcril_qmi_nas_prov_main_threaded_unbind (void *parm)
{
    int                       res = RIL_E_GENERIC_FAILURE;
    int                       status = RC_STATUS_FAIL;
    QCRIL_NOTUSED(parm);

    QCRIL_LOG_FUNC_ENTRY();

    auto& msgList = getNasModule().getPendingMessageList();
    auto msg = msgList.find(RilRequestSetRadioCapMessage::get_class_message_id());
    if (msg != nullptr)
    {
      auto setCapMsg = std::static_pointer_cast<RilRequestSetRadioCapMessage>(msg);
      if (setCapMsg->getRadioCap().phase == RC_PHASE_START)
      {
        msgList.erase(msg);
        res = qcril_qmi_nas_set_flexi_map_status( QCRIL_FLEXI_MAP_STATUS_START_UNBIND );
        if ( res == RIL_E_SUCCESS )
        {
            qcril_qmi_nas_perform_unbind_operation();
            status = RC_STATUS_SUCCESS;
        }
        qcril_qmi_nas_send_set_radio_cap_resp(setCapMsg,
                                              status,
                                              (RIL_Errno) res);
        qcril_qmi_nas_reset_fm_req_resp_info();
      }
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//QCRIL_EVT_QMI_PROV_FM_START_STATUS
//===========================================================================
void qcril_qmi_nas_prov_fm_start_status_hndlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    int res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type req_info;
    int status = RC_STATUS_FAIL;
    uint32_t   slot = 0;
    qcril_uim_card_status_e_type  card_status = QCRIL_CARD_STATUS_UNKNOWN;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    memset(&req_info, 0, sizeof(req_info));
    if ( params_ptr->data != NULL && params_ptr->datalen > 0 )
    {
        auto& msgList = getNasModule().getPendingMessageList();
        auto msg = msgList.find(RilRequestSetRadioCapMessage::get_class_message_id());
        if (msg != nullptr)
        {
          auto setCapMsg = std::static_pointer_cast<RilRequestSetRadioCapMessage>(msg);
          if (setCapMsg->getRadioCap().phase == RC_PHASE_START)
          {
            res = *(int*) params_ptr->data;
            slot = qmi_ril_get_sim_slot();
            NAS_CACHE_LOCK();
            card_status  = nas_common_info.card_info[slot].status;
            NAS_CACHE_UNLOCK();

            //Reset SIM info so that MBN process will be restarted
            //when the SUB is activated again after flex mapping.
            qcril_qmi_pdc_set_sim_info(NULL, NULL, NULL);

            if ( res == RIL_E_SUCCESS  || card_status == QCRIL_CARD_STATUS_ABSENT )
            {
                qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                            QCRIL_DEFAULT_MODEM_ID,
                                            qcril_qmi_nas_prov_main_threaded_unbind,
                                            NULL,  // immediate
                                            NULL );

            }
            else
            {
                msgList.erase(msg);
                qcril_qmi_nas_send_set_radio_cap_resp(setCapMsg,
                                                      status,
                                                      (RIL_Errno) res);
            }
          }
        }
    }
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_prov_process_deferred_request
//===========================================================================
int qcril_qmi_prov_process_deferred_request(void)
{
    int                            any_deferred_req = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    auto& msgList = getNasModule().getPendingMessageList();
    auto msg = msgList.find(RilRequestSetRadioCapMessage::get_class_message_id());
    if (msg != nullptr)
    {
        auto setCapMsg = std::static_pointer_cast<RilRequestSetRadioCapMessage>(msg);
        /* check if QCRIL_EVT_QMI_PROV_FM_START_STATUS is in queue.
        ** This request might have been deferred, need to process it now. */
        if (setCapMsg->getRadioCap().phase == RC_PHASE_START)
        {   // event pending
            QCRIL_LOG_INFO("pending flex map start request.. process it now");
            qcril_qmi_prov_handle_prov_state_change(QCRIL_QMI_PROV_STATE_FM_START);
            any_deferred_req = TRUE;
        }
        else if (setCapMsg->getRadioCap().phase == RC_PHASE_APPLY)
        {   // event pending
            QCRIL_LOG_INFO("pending flex map apply request.. process it now");
            qcril_qmi_prov_handle_prov_state_change(QCRIL_QMI_PROV_STATE_FM_APPLY);
            any_deferred_req = TRUE;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(any_deferred_req);
    return any_deferred_req;
}


//===========================================================================
//RIL_REQUEST_SET_UICC_SUBSCRIPTION
//===========================================================================
void qcril_qmi_nas_set_uicc_subscription
(
  std::shared_ptr<RilRequestSetUiccSubsMessage> msg
)
{
  QCRIL_LOG_FUNC_ENTRY();

  msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
        std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_REQUEST_NOT_SUPPORTED, nullptr));

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_set_uicc_subscription

//===========================================================================
//qcril_qmi_nas_conv_nas_mode_pref_to_qcril
//===========================================================================
qcril_uim_subs_mode_pref qcril_qmi_nas_conv_nas_mode_pref_to_qcril(uint8_t info_valid,
                                                                   uint16_t qmi_nas_mode_pref,
                                                                   RIL_UIM_SelectUiccSub* master_request_ref )
{
    qcril_uim_subs_mode_pref res;
    RIL_UIM_AppType          card_app_type;
    auto card_status = std::make_shared<UimGetCardStatusRequestSyncMsg>(qmi_ril_get_process_instance_id());
    std::shared_ptr<RIL_UIM_CardStatus> ril_card_status = nullptr;

    if ( info_valid )
    {
        switch ( qmi_nas_mode_pref )
        {
            case QMI_NAS_RAT_MODE_PREF_CDMA:
            case QMI_NAS_RAT_MODE_PREF_HRPD:
            case QMI_NAS_RAT_MODE_PREF_CDMA_HRPD:
                res = QCRIL_SUBS_MODE_1X;
                break;

            case QMI_NAS_RAT_MODE_PREF_GSM:
            case QMI_NAS_RAT_MODE_PREF_UMTS:
            case QMI_NAS_RAT_MODE_PREF_TDSCDMA:
            case QMI_NAS_RAT_MODE_PREF_GSM_UMTS:
            case QMI_NAS_RAT_MODE_PREF_GSM_UMTS_TDSCDMA:
            default:
                res = QCRIL_SUBS_MODE_GW;
                break;
        }
    }
    else
    {
        QCRIL_LOG_INFO( "invalid mode pref");
        res = QCRIL_SUBS_MODE_GW;
    }

    /* retrieve card status info */
    if (card_status != nullptr &&
        card_status->dispatchSync(ril_card_status) == Message::Callback::Status::SUCCESS &&
        ril_card_status != nullptr &&
        ril_card_status->err == RIL_UIM_E_SUCCESS)
    {
        if ((RIL_UIM_CARD_MAX_APPS > master_request_ref->app_index) &&
             (master_request_ref->app_index >= 0))

        {
            card_app_type = ril_card_status->applications[ master_request_ref->app_index ].app_type;
            QCRIL_LOG_INFO( ".. card app type %d", (int)card_app_type );
            switch ( card_app_type )
            {
                case RIL_UIM_APPTYPE_SIM:
                case RIL_UIM_APPTYPE_USIM:
                    if ( QCRIL_SUBS_MODE_1X == res )
                    {
                        res = QCRIL_SUBS_MODE_GW;
                        QCRIL_LOG_INFO( "changed sub mode pref to GW as card app is 3ggp");
                    }
                    break;

                case RIL_UIM_APPTYPE_RUIM:
                case RIL_UIM_APPTYPE_CSIM:
                    if ( QCRIL_SUBS_MODE_GW == res )
                    {
                        res = QCRIL_SUBS_MODE_1X;
                        QCRIL_LOG_INFO( "changed sub mode pref to 1x as card app is 3ggp");
                    }
                    break;

                default:
                    // no change
                    break;
            }
        }
    }
    return res;
} // qcril_qmi_nas_conv_nas_mode_pref_to_qcril

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_prov_status_hndlr

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_PROV_STATUS_CHANGED

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_nas_prov_status_hndlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    int                              res = RIL_E_GENERIC_FAILURE;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    if ( params_ptr->data != NULL && params_ptr->datalen > 0 )
    {
        res = *(int*) params_ptr->data;

        /* If success we can consider as bootup manual provisioning
        ** is done. We can go ahead and move RIL state to unrestricted.*/
        if ( res == RIL_E_SUCCESS )
        {
            /* Change RIL state to unrestricted */
            QCRIL_LOG_INFO( "!QMI RIL! 2nd phase init for MULTI SIM" );
            qmi_ril_enable_ril_operational_status();
        }

        /* check if any request deferred. Process it now. Don't send
        ** send unsol if there are any requests deferred as this might
        ** cause race conditions on telephony side.
        ** If there are no prov requests deferred, send unsol right away. */
        if ( !qcril_qmi_prov_process_deferred_request() )
        {
            if ( res == RIL_E_SUCCESS )
            {
                qcril_qmi_prov_send_unsol_sub_pref_change();
            }
        }
    }

    QCRIL_LOG_INFO( "Reset prov_in_progress..." );
    nas_common_info.prov_in_progress = FALSE;
    nas_common_info.prov_status = res;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_dsds_dual_standby_pref_ind_handler
//===========================================================================
void qcril_qmi_nas_dsds_dual_standby_pref_ind_handler( nas_dual_standby_pref_ind_msg_v01* ind_msg )
{
    bool enable = false;
    bool send_resp_to_atel = false;
    bool reevaluate_stack_status = false;
    uint64_t sub_mask = 0;
    RIL_Errno res = RIL_E_SUCCESS;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int result;

    QCRIL_LOG_FUNC_ENTRY();

    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.find(
            RilRequestEnableModemMessage::get_class_message_id());

    NAS_CACHE_LOCK();

    memset(property_name, 0, sizeof(property_name));
    memset(property_value, 0, sizeof(property_value));

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_standby_pref, ind_msg->standby_pref  );
    QCRIL_LOG_INFO( ".. valid %d", ind_msg->standby_pref_valid );
    if ( ind_msg->standby_pref_valid )
    {
        QCRIL_LOG_INFO( ".. standby pref %d", ind_msg->standby_pref.standby_pref );
        QCRIL_LOG_INFO( ".. priority subs %d", ind_msg->standby_pref.priority_subs );
        QCRIL_LOG_INFO( ".. active subs %d", ind_msg->standby_pref.active_subs );
        QCRIL_LOG_INFO( ".. default data subs %d", ind_msg->standby_pref.default_data_subs );

        // TODO_TSTS: Check if need to add TSTS related tune away emums after NAS
        // team adds them to IDL.
        if( ( ind_msg->standby_pref.standby_pref == NAS_DUAL_STANDBY_WITH_TUNE_AWAY_V01 ) ||
            ( ind_msg->standby_pref.standby_pref == NAS_AUTOMATIC_WITH_TUNE_AWAY_V01 ) )
        {
           nas_common_info.dsds.is_tune_away = TRUE;
           QCRIL_LOG_INFO( ".. tuneaway = %d", ind_msg->standby_pref.standby_pref );
        }
        nas_common_info.dsds.paging_priority = ind_msg->standby_pref.priority_subs;
        nas_common_info.dsds.standby_pref = ind_msg->standby_pref.standby_pref;
        nas_common_info.dsds.default_data_sub = ind_msg->standby_pref.default_data_subs;
    }
    if ( ind_msg->default_voice_subs_valid)
    {
        QCRIL_LOG_INFO( ".. default voice subs %d", ind_msg->default_voice_subs );
        nas_common_info.dsds.default_voice_sub = ind_msg->default_voice_subs;
    }

    if ( ind_msg->active_subs_mask_valid )
    {
        QCRIL_LOG_INFO( ".. active subs mask %d", ind_msg->active_subs_mask);
        nas_common_info.dsds.active_subs_mask = ind_msg->active_subs_mask;

        if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_get_modem_stack_id() ) {
            sub_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
        } else if ( QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_get_modem_stack_id() ) {
            sub_mask = QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
        } else {
            sub_mask = QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
        }


        if (pendingMsg != nullptr) {
            auto msg(std::static_pointer_cast<RilRequestEnableModemMessage>(pendingMsg));
            enable = msg->getEnableModem();

            // This logic make sure indications due to different triggers no impact.
            if (enable) {
                if (ind_msg->active_subs_mask & sub_mask) {
                    send_resp_to_atel = true;
                    res = RIL_E_SUCCESS;
                }
            } else {
                if (!(ind_msg->active_subs_mask & sub_mask)) {
                    send_resp_to_atel = true;
                    res = RIL_E_SUCCESS;
                }
            }
        } else {
           if (ind_msg->active_subs_mask & sub_mask) {
                QCRIL_LOG_INFO( ".. current stack is enabled");
                reevaluate_stack_status = true;
            }
        }
    }

    NAS_CACHE_UNLOCK();

    if (send_resp_to_atel) {
        // Cancel timer
        if (nas_cached_info.active_subs_timeout_watch) {
            qcril_cancel_timed_callback(
                    (void *)(intptr_t)nas_cached_info.active_subs_timeout_watch);
            NAS_CACHE_LOCK();
            nas_cached_info.active_subs_timeout_watch = NAS_NIL;
            NAS_CACHE_UNLOCK();
        }

        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                res, nullptr);
        auto msg(std::static_pointer_cast<RilRequestEnableModemMessage>(pendingMsg));
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
        msgList.erase(pendingMsg);

        // Set property to store stack status
        // We might end up not updating this property if there is timeout waiting for indication.
        if(res == RIL_E_SUCCESS) {
            QCRIL_SNPRINTF( property_name,
                    sizeof(property_name),
                    "%s%d",
                    QMI_RIL_STACK_STATUS,
                    qmi_ril_get_process_instance_id() );
            QCRIL_SNPRINTF( property_value, sizeof(property_value), "%d", (int)  msg->getEnableModem());
            result = property_set(property_name, property_value);
            QCRIL_LOG_INFO( ".. stack status property %s - %s, %d", property_name, property_value, (int) result );
            if ( E_SUCCESS != result) {
                QCRIL_LOG_ERROR( "Failed to set stack status prop!");
            }
        }
    }

    // Unsol from modem without trigger from telephony
    // Reevaluate stack status and take appropriate action
    // This logic is required to make sure modem and apps are in sync
    // with respect to stack staus.
    if (reevaluate_stack_status) {
        qcril_qmi_nas_enforce_modem_stack_status();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dsds_dual_standby_pref_ind_handler

//===========================================================================
//qcril_qmi_nas_subscription_info_ind_handler
//===========================================================================
void qcril_qmi_nas_subscription_info_ind_handler( nas_subscription_info_ind_msg_v01* ind_msg )
{
    uint32 vsid = 0;

    QCRIL_LOG_FUNC_ENTRY();

    if ( ind_msg->voice_system_id_valid )
    {
        vsid = ind_msg->voice_system_id;
        QCRIL_LOG_DEBUG ("Voice System ID %x\n", vsid);
        // make sure low layer will not send vsid as 0 before update
        if ( vsid )
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_system_id, ind_msg->voice_system_id );
            // Send QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID response
            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID, (char *)&vsid, sizeof(vsid));
            qcril_am_set_vsid(QCRIL_AM_VS_VOICE, vsid);
            NAS_CACHE_UNLOCK();
        }
    }

    if ( ind_msg->lte_voice_system_id_valid )
    {
        vsid = ind_msg->lte_voice_system_id;
        QCRIL_LOG_DEBUG ("LTE Voice System ID %x\n", vsid);
        if ( vsid )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS, vsid);
        }
    }

    if ( ind_msg->wlan_voice_system_id_valid )
    {
        vsid = ind_msg->wlan_voice_system_id;
        QCRIL_LOG_DEBUG ("WLAN Voice System ID %x\n", vsid);
        if ( vsid )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS_WLAN, vsid);
        }
    }

    if ( qmi_ril_is_multi_sim_feature_supported() )
    {
        qcril_qmi_nas_dsds_subscription_info_ind_handle_helper(ind_msg);
    }
}

//===========================================================================
//qcril_qmi_nas_dsds_subscription_info_ind_handle_helper
//===========================================================================
void qcril_qmi_nas_dsds_subscription_info_ind_handle_helper( nas_subscription_info_ind_msg_v01* ind_msg )
{
    bool                         subs_activate_status;
    int                          was_active_valid;
    int                          was_active;
    int                          operating_mode_valid;
    dms_operating_mode_enum_v01  operating_mode;
    int                          dsds_status_valid;
    int                          dsds_act_status;
    qcril_uim_card_status_e_type card_status;
    int                          card_ever_present;
    uint32_t                     slot = 0;
    int                          send_unsol_sub_status = TRUE;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    was_active_valid       = (int)nas_cached_info.dsds_is_active_valid;
    was_active             = (int)nas_cached_info.dsds_is_active;
    operating_mode         = nas_dms_cached_info.operating_mode;
    operating_mode_valid   = (int)nas_dms_cached_info.operating_mode_valid;
    dsds_act_status        = (int)nas_common_info.dsds.cur_info.act_status;
    dsds_status_valid      = (int)nas_common_info.dsds.valid;

    slot               = qmi_ril_get_sim_slot();
    card_status        = nas_common_info.card_info[slot].status;
    card_ever_present  = nas_common_info.card_info[slot].card_ever_present;

    if (ind_msg->is_priority_subs_valid)
    {
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_priority_subs, ind_msg->is_priority_subs  );
    }

    if (ind_msg->is_default_data_subs_valid)
    {
      QCRIL_LOG_INFO( "[MSIM] Default Data Subs status %d", (int)ind_msg->is_default_data_subs );
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.is_default_data_subs, ind_msg->is_default_data_subs  );
      qcril_qmi_nas_send_response_for_dds_request();
    }

    if (ind_msg->dds_type_valid)
    {
      QCRIL_LOG_INFO( "[MSIM] DDS Type %d", (int)ind_msg->dds_type );
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dds_type, ind_msg->dds_type  );
    }

    if (ind_msg->is_active_valid)
    {
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_active, ind_msg->is_active  );

      if ( !ind_msg->is_active )
      {
        nas_common_info.dsds.cur_info.act_status = RIL_UICC_SUBSCRIPTION_DEACTIVATE;
        subs_activate_status = false;
      }
      // Send unsol sub status only after first SET_UICC activate request.
      else if ( ind_msg->is_active && dsds_status_valid )
      {
        subs_activate_status = true;
      }
      // Do not send unsol sub status for first activated ind without SET_UICC request.
      else
      {
        send_unsol_sub_status = FALSE;
      }
      if ( send_unsol_sub_status == TRUE )
      {
        auto msg = std::make_shared<RilUnsolUiccSubsStatusChangedMessage>(subs_activate_status);
        Dispatcher::getInstance().dispatchSync(msg);
      }
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO( ".. priority subs %d / %d", (int)ind_msg->is_priority_subs_valid, (int)ind_msg->is_priority_subs );
    QCRIL_LOG_INFO( "[MSIM] .. is active subs %d / %d, was active %d / %d, oprt %d / %d, dsds valid %d, act_status %d, card status %d, card ever present %d",
                            (int)ind_msg->is_active_valid,
                            (int)ind_msg->is_active,
                                 was_active_valid,
                                 was_active,
                                 operating_mode_valid,
                                 operating_mode,
                                 dsds_status_valid,
                                 dsds_act_status,
                            (int)card_status,
                                 card_ever_present);

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dsds_subscription_info_ind_handler

//===========================================================================
//qcril_qmi_nas_network_time_ind_conv_qmi2ril
//===========================================================================
static void qcril_qmi_nas_network_time_ind_conv_qmi2ril
(
    nas_network_time_ind_msg_v01* ind_msg,
    char *ril_nitz_time_msg,
    int *nitz_updated
)
{
    QCRIL_LOG_FUNC_ENTRY();

    int sib16_support;
    uint8 sib16_acquired;
    uint8 sntp_available;

    NAS_CACHE_LOCK();

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired))
    {
        /* Whenever there's a change in RAT from LTE to another RAT, invalidate
         * nas_cached_info.lte_sib16_acquired to make sure time indications
         * after the RAT change are processed. */
        if (!(qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_VOICE) ||
              qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_DATA) ||
              qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_IMS)))
        {
            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired);
            sib16_acquired = FALSE;
        }
        else
        {
            sib16_acquired = (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired);
        }
    }
    else
    {
        sib16_acquired = FALSE;
    }

    sib16_support = nas_common_info.sib16_support;
    sntp_available = (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.sntp_available) &&
                     (TRUE == nas_cached_info.sntp_available));

    QCRIL_LOG_INFO("sib16 support %d, acquired %d, sntp available %d",
                   sib16_support,
                   sib16_acquired,
                   sntp_available);

    /* In the case of LTE, this indication carries the contents of the
     * EMM INFORMATION message sent by the network, which according to
     * carrier requirements should be used when TZ and/or DST
     * information is missing in SIB16 broadcasts.
     *
     * If the last SIB16 network time indication had missing time zone
     * and/or day light saving information, and the time zone and DST
     * information in this indication are valid:
     *  (1) Query for the current SIB16 time.
     *  (2) If the time zone and DST information in the response
     *      to (1) are still invalid, combine the absolute time
     *      reported in the response to (1) with the time zone and DST
     *      information in this indication to arrive at the time string
     *      reported as part of RIL_UNSOL_NITZ_TIME_RECEIVED. */
    if (sib16_support && sib16_acquired)
    {
       if (ind_msg->radio_if == NAS_RADIO_IF_LTE_V01 &&
             ind_msg->daylt_sav_adj_valid && ind_msg->time_zone_valid &&
             (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset) ||
              !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving)))
       {
          qcril_qmi_nas_fetch_sib16_network_time(true, ind_msg->time_zone,
                                                 true, ind_msg->daylt_sav_adj);
       }
       else
       {
          QCRIL_LOG_INFO("ignore nas_network_time_ind_msg_v01 as sib16_support is set and we are in sib16 coverage");
       }
    }
    else
    {
       if (ind_msg->time_zone_valid)
       {
           int time_zone = ind_msg->time_zone, time_zone_west = FALSE, daylight = 0;
           *nitz_updated = TRUE;

           if (0 > time_zone)
           {
               time_zone *= -1;
               time_zone_west = TRUE;
           }

           // In 1xEVDO mode, ignore daylight saving adjustment and use cached value
           if (ind_msg->radio_if_valid && ind_msg->radio_if == NAS_RADIO_IF_CDMA_1XEVDO_V01)
           {
               if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving))
               {
                   daylight = nas_cached_info.day_light_saving;
               }
           }
           else if (ind_msg->daylt_sav_adj_valid)
           {
               daylight = ind_msg->daylt_sav_adj;
           }

           // according to ril.h the NITZ time string is in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
           QCRIL_SNPRINTF(ril_nitz_time_msg, NAS_NITZ_STR_BUF_MAX, "%02d/%02d/%02d,%02d:%02d:%02d%c%02d,%02d",
                          (int) ind_msg->universal_time.year%100,
                          (int) ind_msg->universal_time.month,
                          (int) ind_msg->universal_time.day,
                          (int) ind_msg->universal_time.hour,
                          (int) ind_msg->universal_time.minute,
                          (int) ind_msg->universal_time.second,
                          time_zone_west ? '-' : '+',
                          (int) time_zone,
                                daylight);
           QCRIL_LOG_INFO("ril_nitz_time_msg is: %s", ril_nitz_time_msg);
       }

       if(FALSE == sib16_acquired)
       {
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

          if(FALSE == sntp_available)
          {
             NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                        ind_msg->daylt_sav_adj);
             NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                        ind_msg->time_zone);

             uint64_t abs_time = qcril_qmi_nas_convert_julian_time_to_abs_time( ind_msg->universal_time.year,
                                                                                ind_msg->universal_time.month,
                                                                                ind_msg->universal_time.day,
                                                                                ind_msg->universal_time.hour,
                                                                                ind_msg->universal_time.minute,
                                                                                ind_msg->universal_time.second,
                                                                                0
                                                                              );
             int ret_code = 0;
             time_genoff_info_type time_set;

             if(sib16_support)
             {
                 memset(&time_set, 0, sizeof(time_set));
                 time_set.base = ATS_UTC;
                 time_set.unit = TIME_MSEC;
                 time_set.operation = T_SET;
                 time_set.ts_val = &abs_time;
                 ret_code = time_genoff_operation(&time_set);
                 if(!ret_code)
                 {
                     QCRIL_LOG_INFO("set UTC successfully using 3gpp nw time, abs time (%x, %x)",
                                    (uint32) (abs_time >> 32),
                                    (uint32) abs_time);
                 }
                 else
                 {
                     QCRIL_LOG_ESSENTIAL("QCRIL_WARNING:SET_TIME: unable to set UTC "
                                    "using 3gpp nw time, error %d", ret_code);
                 }
             }

             memset(&time_set, 0, sizeof(time_set));
             time_set.base = ATS_MODEM;
             time_set.unit = TIME_MSEC;
             time_set.operation = T_SET;
             time_set.ts_val = &abs_time;
             ret_code = time_genoff_operation(&time_set);
             if(!ret_code)
             {
                 QCRIL_LOG_INFO("set MODEM successfully using 3gpp nw time, abs time (%x, %x)",
                                (uint32) (abs_time >> 32),
                                (uint32) abs_time);
             }
             else
             {
                 QCRIL_LOG_ESSENTIAL("QCRIL_WARNING:SET_TIME: unable to set MODEM "
                                "using 3gpp nw time, error %d", ret_code);
             }
          }
       }
    }

    NAS_CACHE_UNLOCK();
} //qcril_qmi_nas_network_time_ind_conv_qmi2ril

//===========================================================================
//qcril_qmi_nas_rtre_config_ind_conv_qmi2ril
//===========================================================================
void qcril_qmi_nas_rtre_config_ind_conv_qmi2ril
(
    nas_rtre_cfg_ind_msg_v01* ind_msg,
    RIL_CdmaSubscriptionSource *sub_source,
    int *sub_source_updated
)
{
    QCRIL_LOG_FUNC_ENTRY();

    if( ind_msg->rtre_cfg_valid )
    {
        QCRIL_LOG_INFO( "nas rtre cfg %d", ind_msg->rtre_cfg);
        switch ( ind_msg->rtre_cfg )
        {
            case NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01:
                *sub_source_updated = TRUE;
                *sub_source = CDMA_SUBSCRIPTION_SOURCE_NV;
                break;

            case NAS_RTRE_CFG_RUIM_ONLY_V01:
                *sub_source_updated = TRUE;
                *sub_source = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
                break;

            default: // unsupported value
                *sub_source_updated = FALSE;
                break;
        }

        NAS_CACHE_LOCK();
        nas_common_info.nas_rtre_cfg = ind_msg->rtre_cfg;
        NAS_CACHE_UNLOCK();
    }
    else
    {
        QCRIL_LOG_INFO( "NO change in nas rtre cfg");
        *sub_source_updated = FALSE;
    }

    QCRIL_LOG_INFO( "sub_source updated %d", *sub_source_updated);
    if( *sub_source_updated )
    {
        QCRIL_LOG_INFO( "sub_source %d", *sub_source);
    }
} //qcril_qmi_nas_rtre_config_ind_conv_qmi2ril

//===========================================================================
//qcril_qmi_nas_dsds_util_request_set_subscription_mode
//===========================================================================
RIL_Errno qcril_qmi_nas_dsds_util_request_set_subscription_mode( nas_standby_pref_enum_v01 *standby_pref,
                                                                 dds_sub_pref_cause * data_sub_cause,
                                                                 nas_subs_type_enum_v01 *priority_subs,
                                                                 nas_subs_type_enum_v01 *voice_subs,
                                                                 nas_active_subs_mask_type_v01 *active_subs_mask,
                                                                 qcril_qmi_cb_func_ptr  standby_pref_res_cb )
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_error = QMI_NO_ERR;

    nas_set_dual_standby_pref_req_msg_v01 qmi_req_msg;
    nas_set_dual_standby_pref_resp_msg_v01 * qmi_resp_msg = NULL;

    memset( &qmi_req_msg, 0, sizeof( qmi_req_msg ) );
    if( standby_pref )
    {
        qmi_req_msg.standby_pref_valid = TRUE;
        qmi_req_msg.standby_pref = *standby_pref;
    }
    if ( data_sub_cause )
    {
        qmi_req_msg.default_data_subs_valid = TRUE;
        qmi_req_msg.default_data_subs = data_sub_cause->dds_sub;
        qmi_req_msg.dds_duration_valid = TRUE;
        qmi_req_msg.dds_duration = data_sub_cause->dds_duration;
    }
    if ( priority_subs )
    {
        qmi_req_msg.priority_subs_valid = TRUE;
        qmi_req_msg.priority_subs = *priority_subs;
    }
    if ( voice_subs )
    {
        qmi_req_msg.default_voice_subs_valid = TRUE;
        qmi_req_msg.default_voice_subs = *voice_subs;
    }
    if ( active_subs_mask )
    {
        qmi_req_msg.active_subs_mask_valid = TRUE;
        qmi_req_msg.active_subs_mask = *active_subs_mask;
    }

    QCRIL_LOG_INFO( "preps:" );
    QCRIL_LOG_INFO( ".. standby_pref %d", (int) qmi_req_msg.standby_pref );
    QCRIL_LOG_INFO( ".. priority_subs %d", (int) qmi_req_msg.priority_subs );
    QCRIL_LOG_INFO( ".. default_data_subs %d", (int) qmi_req_msg.default_data_subs );
    QCRIL_LOG_INFO( ".. default_voice_subs %d", (int) qmi_req_msg.default_voice_subs );
    QCRIL_LOG_INFO( ".. active_subs_mask %d", (int) qmi_req_msg.active_subs_mask);

    qmi_error = qmi_client_nas_send_async(QMI_NAS_DUAL_STANDBY_PREF_REQ_MSG_V01,
                                            &qmi_req_msg,
                                            sizeof(qmi_req_msg),
                                            sizeof(*qmi_resp_msg),
                                            qcril_qmi_nas_minority_command_cb_ex,
                                            (void*)standby_pref_res_cb );

    if (QMI_NO_ERR == qmi_error)
    {
        res = RIL_E_SUCCESS;
    }

    return res;
} // qcril_qmi_nas_dsds_util_request_set_subscription_mode

//===========================================================================
//RIL_REQUEST_SET_DATA_SUBSCRIPTION
//===========================================================================
void qcril_qmi_nas_dsds_request_set_data_subscription
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int data_sub = -1;
  int default_data_reason = -1;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  if( params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
    if(params_ptr->datalen < 2*sizeof(int))
    {
        memcpy(&data_sub, params_ptr->data, sizeof(int));
    }
    else
    {
        memcpy(&data_sub, params_ptr->data, sizeof(int));
        memcpy(&default_data_reason, (((int*)params_ptr->data)+1), sizeof(int));
    }

    if((data_sub < 0) || (data_sub >= QCRIL_MAX_INSTANCE_ID))
    {
        QCRIL_LOG_DEBUG("Invalid DDS Sub id");
        ril_req_res = RIL_E_INVALID_ARGUMENTS;
    }
    else
    {
        NAS_CACHE_LOCK();
        nas_common_info.dsds.default_data_instance_id = (qcril_instance_id_e_type)data_sub;
        nas_common_info.dsds.default_data_reason = default_data_reason;
        nas_common_info.dsds.is_default_data_set = TRUE;
        NAS_CACHE_UNLOCK();
        QCRIL_LOG_DEBUG("Default Data Sub = %d", (int) nas_common_info.dsds.default_data_instance_id);
        QCRIL_LOG_DEBUG("Default Data Sub reason = %d", (int) nas_common_info.dsds.default_data_reason);
        ril_req_res = RIL_E_SUCCESS;
    }
  }

  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );
  qcril_send_request_response( &resp );

  if(ril_req_res == RIL_E_SUCCESS)
  {
    qcril_qmi_nas_notify_embms_status();
  }
}

RIL_Errno qcril_qmi_nas_send_data_subscription_request(nas_dds_duration_enum_v01 dds_duration)
{
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  dds_sub_pref_cause dds_pref_data;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&dds_pref_data, 0, sizeof(dds_pref_data));

  NAS_CACHE_LOCK();

  if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_get_modem_stack_id() )
  { // primary
    dds_pref_data.dds_sub = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else if ( QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_get_modem_stack_id() )
  { // secondary
    dds_pref_data.dds_sub = NAS_SECONDARY_SUBSCRIPTION_V01;
  }
  else
  { // tertiary
    dds_pref_data.dds_sub = NAS_TERTIARY_SUBSCRIPTION_V01;
  }

  dds_pref_data.dds_duration = dds_duration;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO( ".. dds_sub %d, dds_duration %d", (int)dds_pref_data.dds_sub, (int)dds_pref_data.dds_duration );

  ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( NULL,
                                                                       &dds_pref_data,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       qcril_qmi_dsds_set_pref_ril_req_cb );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

  return ril_req_res;
}// qcril_qmi_nas_send_data_subscription_request


//===========================================================================
//RIL_REQUEST_SET_SUBSCRIPTION_MODE
//===========================================================================
void qcril_qmi_nas_dsds_request_set_subscription_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  int *subscription_mode_ptr;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );
  if( params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
      subscription_mode_ptr = (int *) params_ptr->data;
      QCRIL_LOG_INFO( "pre-entry %p", subscription_mode_ptr );
      ril_req_res = RIL_E_SUCCESS;
      QCRIL_LOG_INFO( "entry %d", (int) *subscription_mode_ptr );
  }

  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

}// qcril_qmi_nas_dsds_request_set_subscription_mode

//===========================================================================
//QCRIL_EVT_HOOK_SET_TUNE_AWAY
//===========================================================================
void qcril_qmi_nas_dsds_request_set_tune_away
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  boolean     tune_away;
  nas_standby_pref_enum_v01 param_standby_pref;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  do
  {
  memcpy(&tune_away, params_ptr->data, sizeof(tune_away));
  QCRIL_LOG_INFO( "tune_away: %d", (int) tune_away );

  if( (tune_away != TRUE) && (tune_away != FALSE) )
  {
      qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );
      break;
  }

  NAS_CACHE_LOCK();
  if ( nas_common_info.dsds.is_tune_away == tune_away )
  {
    ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_DEBUG( "RID %d, is already in requested tune_away settings i.e. %d", instance_id, tune_away);
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );

    NAS_CACHE_UNLOCK();
        break;
  }
  NAS_CACHE_UNLOCK();

  if ( tune_away )
  {
    param_standby_pref = NAS_AUTOMATIC_WITH_TUNE_AWAY_V01;
  }
  else
  {
    param_standby_pref = NAS_AUTOMATIC_WITHOUT_TUNE_AWAY_V01;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               modem_id,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                               NULL,
                               &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
  {
      ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( &param_standby_pref, NULL, NULL, NULL, NULL, qcril_qmi_dsds_set_pref_ril_req_cb );
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {  // rollback
      qcril_default_request_resp_params( instance_id,
                                         reqlist_entry.t,
                                         reqlist_entry.request,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );

  }
  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
  }while(0);

}// qcril_qmi_nas_dsds_request_set_tune_away

//===========================================================================
//QCRIL_EVT_HOOK_GET_TUNE_AWAY
//===========================================================================
void qcril_qmi_nas_dsds_request_get_tune_away
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  boolean tune_away;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;


  NAS_CACHE_LOCK();
  tune_away = nas_common_info.dsds.is_tune_away;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_DEBUG( "RID %d stored tune away preferences = %d", instance_id, tune_away);

  if( nas_common_info.dsds.is_tune_away != NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE )
  {
    ril_req_res = RIL_E_SUCCESS;
  }

  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );

  if( ril_req_res == RIL_E_SUCCESS )
  {
    resp.resp_pkt = &tune_away;
    resp.resp_len = sizeof(tune_away);
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

}// qcril_qmi_nas_dsds_request_set_tune_away

//===========================================================================
//QCRIL_EVT_HOOK_SET_PAGING_PRIORITY
//===========================================================================
void qcril_qmi_nas_dsds_request_set_paging_priority
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int paging_priority = 0;
  nas_subs_type_enum_v01 param_paging_priority;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  do
  {
  memcpy(&paging_priority, params_ptr->data, sizeof(paging_priority));
  QCRIL_LOG_INFO( "paging_priority: %d", (int) paging_priority );

  if( (paging_priority < RIL_SUBSCRIPTION_1) || (paging_priority > RIL_SUBSCRIPTION_3) )
  {
      qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );
      break;
  }

  NAS_CACHE_LOCK();
  if ( nas_common_info.dsds.paging_priority == (nas_subs_type_enum_v01)qcril_qmi_get_modem_stack_id() )
  {
    ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_DEBUG( "RID %d, is already in requested paging_priority settings i.e. %d", instance_id, paging_priority);
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );

    NAS_CACHE_UNLOCK();
    break;
  }
  NAS_CACHE_UNLOCK();

  if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_get_modem_stack_id() )
  {
    param_paging_priority = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else if ( QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_get_modem_stack_id() )
  {
    param_paging_priority = NAS_SECONDARY_SUBSCRIPTION_V01;
  }
  else
  {
    param_paging_priority = NAS_TERTIARY_SUBSCRIPTION_V01;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               modem_id,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                               NULL,
                               &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
  {
      ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( NULL, NULL, &param_paging_priority, NULL, NULL, qcril_qmi_dsds_set_pref_ril_req_cb );
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {  // rollback
      qcril_default_request_resp_params( instance_id,
                                         reqlist_entry.t,
                                         reqlist_entry.request,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );

  }
  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
  }while(0);

}// qcril_qmi_nas_dsds_request_set_paging_priority

//===========================================================================
//QCRIL_EVT_HOOK_GET_PAGING_PRIORITY
//===========================================================================
void qcril_qmi_nas_dsds_request_get_paging_priority
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  boolean paging_priority;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(ret_ptr);


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;


  NAS_CACHE_LOCK();
  paging_priority = nas_common_info.dsds.paging_priority;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_DEBUG( "RID %d stored paging priority preferences = %d", instance_id, paging_priority);

  if( paging_priority != NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE )
  {
      ril_req_res = RIL_E_SUCCESS;
  }
  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );

  if( ril_req_res == RIL_E_SUCCESS )
  {
      resp.resp_pkt = &paging_priority;
      resp.resp_len = sizeof(paging_priority);
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

}// qcril_qmi_nas_dsds_request_get_paging_priority

//===========================================================================
//QCRIL_EVT_HOOK_SET_DEFAULT_VOICE_SUB
//===========================================================================
void qcril_qmi_nas_dsds_request_set_default_voice_sub
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int default_voice_sub = 0;
  nas_subs_type_enum_v01 param_default_voice_subs;

  QCRIL_LOG_FUNC_ENTRY();

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  do
  {
  memcpy(&default_voice_sub, params_ptr->data, params_ptr->datalen);
  QCRIL_LOG_INFO( "default_voice_sub: %d", (int) default_voice_sub );

  if( (default_voice_sub < RIL_SUBSCRIPTION_1) || (default_voice_sub > RIL_SUBSCRIPTION_3) )
  {
      qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );
      break;
  }

  NAS_CACHE_LOCK();
  if ( nas_common_info.dsds.default_voice_sub == default_voice_sub )
  {
    ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_DEBUG( "RID %d, is already in requested default_voice_sub settings i.e. %d", instance_id, default_voice_sub);
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );

    NAS_CACHE_UNLOCK();
    break;
  }
  NAS_CACHE_UNLOCK();

  if ( default_voice_sub == RIL_SUBSCRIPTION_1 )
  {
    param_default_voice_subs = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else if ( default_voice_sub == RIL_SUBSCRIPTION_2 )
  {
    param_default_voice_subs = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else
  {
    param_default_voice_subs = NAS_TERTIARY_SUBSCRIPTION_V01;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               modem_id,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                               NULL,
                               &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
  {
      ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( NULL, NULL, NULL, &param_default_voice_subs, NULL, qcril_qmi_dsds_set_pref_ril_req_cb );
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {  // rollback
      qcril_default_request_resp_params( instance_id,
                                         reqlist_entry.t,
                                         reqlist_entry.request,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );

  }
  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
  }while(0);

  QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_dsds_request_set_default_voice_sub

//===========================================================================
//qcril_qmi_dsds_set_pref_ril_req_cb
//===========================================================================
void qcril_qmi_dsds_set_pref_ril_req_cb ( RIL_Errno resp_res )
{
    qcril_reqlist_public_type             qcril_req_info;
    qcril_request_resp_params_type        resp;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;
    int send_resp_to_atel = TRUE;
    uint32      new_timeout_watch = 0;
    int         new_timeout_set_res;
    const struct timeval dds_timeout = {17 , 0}; //wait for 17sec

    auto found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                          QCRIL_DEFAULT_MODEM_ID,
                                                          QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                                                          &qcril_req_info );

    QCRIL_LOG_INFO("res %d, fnd %d ", (int) resp_res, (int) found_qcril_request );

    if ( E_SUCCESS == found_qcril_request )
    {

        if( qcril_req_info.request == QCRIL_EVT_HOOK_SET_TUNE_AWAY )
        {
           nas_common_info.dsds.is_tune_away = ( !nas_common_info.dsds.is_tune_away ) ;

           moniker = (int)qmi_ril_get_process_instance_id();
           snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_TUNE_AWAY, moniker );
           snprintf( property_value, sizeof(property_value), "%d", nas_common_info.dsds.is_tune_away);
           if ( property_set( property_name, property_value ) != E_SUCCESS )
           {
               QCRIL_LOG_ERROR( "fail to save %s to system property", QMI_RIL_TUNE_AWAY );
           }
        }

        if( qcril_req_info.request == QCRIL_EVT_HOOK_SET_PAGING_PRIORITY )
        {
           nas_common_info.dsds.paging_priority = ( (nas_subs_type_enum_v01) !nas_common_info.dsds.paging_priority ) ;

           moniker = (int)qmi_ril_get_process_instance_id();
           snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_PAGING_PRIORITY, moniker );
           snprintf( property_value, sizeof(property_value), "%d", (int) nas_common_info.dsds.paging_priority );
           if ( property_set( property_name, property_value ) != E_SUCCESS )
           {
               QCRIL_LOG_ERROR( "fail to save %s to system property", QMI_RIL_PAGING_PRIORITY );
           }
        }
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           qcril_req_info.t,
                                           qcril_req_info.request,
                                           resp_res ,
                                           &resp );
        qcril_send_request_response( &resp );
    }
    else
    {
      // Send resp to ALLOW_DATA request right away if failure
      // Else, wait for PS attach to be successful.
      auto& msgList = getNasModule().getPendingMessageList();
      auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
      found_qcril_request = (msg != nullptr) ? E_SUCCESS : E_FAILURE;
      QCRIL_LOG_INFO("Default data sub request fnd %d res %d", found_qcril_request, (int)resp_res);
      if (msg != nullptr)
      {
        if(RIL_E_SUCCESS == resp_res)
        {
            // start timer
            new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                          QCRIL_DEFAULT_MODEM_ID,
                                                          qcril_qmi_nas_set_dds_timeout_handler,
                                                          &dds_timeout, &new_timeout_watch );
            QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );

            if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
            {
                if(new_timeout_set_res == E_SUCCESS)
                {
                    QCRIL_LOG_ERROR("Internal error..timed callback failed to set timer_id");
                    resp_res = RIL_E_INTERNAL_ERR;
                }
                else
                {
                    resp_res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err((IxErrnoType)new_timeout_set_res);
                }
                qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
                send_resp_to_atel = TRUE;
            }
            else
            {
                send_resp_to_atel = FALSE;
                NAS_CACHE_LOCK();
                nas_cached_info.dds_timeout_watch = new_timeout_watch;
                NAS_CACHE_UNLOCK();
            }
        }
        else
        {
            qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
            send_resp_to_atel = TRUE;
        }

        if (send_resp_to_atel == TRUE)
        {
            msgList.erase(msg);
            auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(resp_res, nullptr);
            allowDataMsg->sendResponse(allowDataMsg, Message::Callback::Status::SUCCESS, respData);
        }
      }
    }
} // qcril_qmi_dsds_set_pref_ril_req_cb

//===========================================================================
//QCRIL_EVT_HOOK_SET_LTE_TUNE_AWAY
//===========================================================================
void qcril_qmi_nas_dsds_request_set_lte_tune_away
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type *const ret_ptr
)
{
    qcril_instance_id_e_type instance_id;
    qcril_modem_id_e_type modem_id;
    qcril_reqlist_public_type reqlist_entry;
    qcril_request_resp_params_type resp;
    qmi_client_error_type qmi_error = QMI_NO_ERR;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    boolean     lte_tune_away;
    nas_avoid_tuneaway_req_msg_v01 qmi_req_msg;
    nas_avoid_tuneaway_resp_msg_v01 * qmi_resp_msg = NULL;

    instance_id = QCRIL_DEFAULT_INSTANCE_ID;

    modem_id = params_ptr->modem_id;

    QCRIL_NOTUSED( ret_ptr );

    do
    {
        memcpy(&lte_tune_away, params_ptr->data, sizeof(lte_tune_away));
        QCRIL_LOG_INFO( "lte_tune_away: %d", (int) lte_tune_away );

        if( (lte_tune_away != TRUE) && (lte_tune_away != FALSE) )
        {
            qcril_default_request_resp_params( instance_id,
                                        params_ptr->t,
                                        params_ptr->event_id,
                                        ril_req_res,
                                        &resp );
            qcril_send_request_response( &resp );
            break;
        }

        if ( nas_common_info.dsds.is_lte_tune_away == lte_tune_away )
        {
            ril_req_res = RIL_E_SUCCESS;

            QCRIL_LOG_DEBUG( "RID %d, is already in requested lte_tune_away settings i.e. %d", instance_id, lte_tune_away);
            qcril_default_request_resp_params( instance_id,
                                        params_ptr->t,
                                        params_ptr->event_id,
                                        ril_req_res,
                                        &resp );
            qcril_send_request_response( &resp );
            break;
        }

        if ( lte_tune_away )
        {
            qcril_reqlist_default_entry( params_ptr->t,
                                    params_ptr->event_id,
                                    modem_id,
                                    QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                    QCRIL_EVT_QMI_REQUEST_ENABLE_LTE_TUNE_AWAY,
                                    NULL,
                                    &reqlist_entry );
            if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
            {
                qmi_req_msg.trm_priority = 0;
                qmi_error = qmi_client_nas_send_async(QMI_NAS_AVOID_TUNEAWAY_REQ_MSG_V01,
                                                        &qmi_req_msg,
                                                        sizeof(qmi_req_msg),
                                                        sizeof(*qmi_resp_msg),
                                                        qcril_qmi_nas_minority_command_cb_ex,
                                                        (void *) &qcril_qmi_dsds_enable_lte_tune_away_cb );
                if(QMI_NO_ERR != qmi_error)
                {
                    ril_req_res = RIL_E_GENERIC_FAILURE;
                }
            }

        }
        else
        {
            qcril_reqlist_default_entry( params_ptr->t,
                                    params_ptr->event_id,
                                    modem_id,
                                    QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                    QCRIL_EVT_QMI_REQUEST_DISABLE_LTE_TUNE_AWAY,
                                    NULL,
                                    &reqlist_entry );
            if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
            {
                qmi_req_msg.trm_priority = 1;
                qmi_error = qmi_client_nas_send_async(QMI_NAS_AVOID_TUNEAWAY_REQ_MSG_V01,
                                                        &qmi_req_msg,
                                                        sizeof(qmi_req_msg),
                                                        sizeof(*qmi_resp_msg),
                                                        qcril_qmi_nas_minority_command_cb_ex,
                                                        (void *) &qcril_qmi_dsds_disable_lte_tune_away_cb );
                if(QMI_NO_ERR != qmi_error)
                {
                    ril_req_res = RIL_E_GENERIC_FAILURE;
                }
            }
        }

        if ( RIL_E_SUCCESS != ril_req_res )
        {  // rollback
            qcril_default_request_resp_params( instance_id,
                                               reqlist_entry.t,
                                               reqlist_entry.request,
                                               ril_req_res,
                                               &resp );
            qcril_send_request_response( &resp );
        }
        QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
    }while(0);

}// qcril_qmi_nas_dsds_request_set_lte_tune_away

//===========================================================================
//qcril_qmi_dsds_enable_lte_tune_away_cb
//===========================================================================
void qcril_qmi_dsds_enable_lte_tune_away_cb ( RIL_Errno resp_res )
{
    int found_qcril_request;
    qcril_reqlist_public_type             qcril_req_info;
    qcril_request_resp_params_type        resp;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;

    QCRIL_LOG_FUNC_ENTRY();

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                        QCRIL_DEFAULT_MODEM_ID,
                                                        QCRIL_EVT_QMI_REQUEST_ENABLE_LTE_TUNE_AWAY,
                                                        &qcril_req_info );

    QCRIL_LOG_INFO("res %d, fnd %d ", (int) resp_res, (int) found_qcril_request );

    if ( (E_SUCCESS == found_qcril_request) )
    {
        if ( resp_res == RIL_E_SUCCESS )
        {
            nas_common_info.dsds.is_lte_tune_away = TRUE ;
            moniker = (int)qmi_ril_get_process_instance_id();
            snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_LTE_TUNE_AWAY, moniker );
            snprintf( property_value, sizeof(property_value), "%d", nas_common_info.dsds.is_lte_tune_away);

            if ( property_set( property_name, property_value ) != E_SUCCESS )
            {
                QCRIL_LOG_ERROR( "fail to save %s to system property", QMI_RIL_LTE_TUNE_AWAY );
            }
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           qcril_req_info.t,
                                           qcril_req_info.request,
                                           resp_res ,
                                           &resp );

        qcril_send_request_response( &resp );
    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_dsds_enable_lte_tune_away_cb

//===========================================================================
//qcril_qmi_dsds_disable_lte_tune_away_cb
//===========================================================================
void qcril_qmi_dsds_disable_lte_tune_away_cb ( RIL_Errno resp_res )
{
    int found_qcril_request;
    qcril_reqlist_public_type             qcril_req_info;
    qcril_request_resp_params_type        resp;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;

    QCRIL_LOG_FUNC_ENTRY();

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                        QCRIL_DEFAULT_MODEM_ID,
                                                        QCRIL_EVT_QMI_REQUEST_DISABLE_LTE_TUNE_AWAY,
                                                        &qcril_req_info );

    QCRIL_LOG_INFO("res %d, fnd %d ", (int) resp_res, (int) found_qcril_request );

    if ( (E_SUCCESS == found_qcril_request) )
    {
        if ( resp_res == RIL_E_SUCCESS )
        {
            nas_common_info.dsds.is_lte_tune_away = FALSE ;
            moniker = (int)qmi_ril_get_process_instance_id();
            snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_LTE_TUNE_AWAY, moniker );
            snprintf( property_value, sizeof(property_value), "%d", nas_common_info.dsds.is_lte_tune_away);

            if ( property_set( property_name, property_value ) != E_SUCCESS )
            {
                QCRIL_LOG_ERROR( "fail to save %s to system property", QMI_RIL_LTE_TUNE_AWAY );
            }
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           qcril_req_info.t,
                                           qcril_req_info.request,
                                           resp_res ,
                                           &resp );

        qcril_send_request_response( &resp );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_dsds_disable_lte_tune_away_cb


//
//===========================================================================
//qcril_qmi_nas_minority_command_cb_ex
//===========================================================================
void qcril_qmi_nas_minority_command_cb_ex
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   /*resp_c_struct_len*/,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    RIL_Errno                               ril_req_res = RIL_E_GENERIC_FAILURE;
    void                                    *qmi_resp = (void *) resp_c_struct.get();
    nas_avoid_tuneaway_resp_msg_v01         *tune_away_resp;
    nas_set_dual_standby_pref_resp_msg_v01  *dual_standby_resp;
    qcril_qmi_cb_func_ptr                   async_cb_func_ptr;
    qcril_request_params_type req_data;

    QCRIL_LOG_FUNC_ENTRY();

    if (qmi_resp)
    {
        async_cb_func_ptr = (qcril_qmi_cb_func_ptr)resp_cb_data;
        memset(&req_data, 0, sizeof(req_data));

        switch(msg_id)
        {
            case QMI_NAS_DUAL_STANDBY_PREF_RESP_MSG_V01:
                dual_standby_resp = (nas_set_dual_standby_pref_resp_msg_v01*)qmi_resp;
                if (dual_standby_resp)
                {
                    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                                                transp_err, &dual_standby_resp->resp );
                    if( async_cb_func_ptr )
                    {
                        (async_cb_func_ptr)(ril_req_res);
                    }
                }
                break;

            case QMI_NAS_AVOID_TUNEAWAY_RESP_MSG_V01:
                tune_away_resp = (nas_avoid_tuneaway_resp_msg_v01*)qmi_resp;
                if (tune_away_resp)
                {
                    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                                                transp_err, &tune_away_resp->resp );
                    if( async_cb_func_ptr )
                    {
                        (async_cb_func_ptr)(ril_req_res);
                    }
                }
                break;
        }

    }

    QCRIL_LOG_FUNC_RETURN();
}

/*
 * Function does the following -
 * - checks the request list
 * - if id exists, packs the response with corresponding values
 */
RIL_Errno pack_request_data
(
    unsigned int               msg_id,
    void                      *resp_c_struct,
    unsigned int               resp_c_struct_len,
    void                      *resp_cb_data,
    qmi_client_error_type      transp_err,
    qcril_request_params_type *req_data
)
{
    qcril_instance_id_e_type instance_id;
    uint32 user_data;
    uint16 req_id;
    qcril_reqlist_public_type req_info;
    RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;

    QCRIL_NOTUSED(msg_id);

    QCRIL_ASSERT( resp_c_struct != NULL );
    user_data = ( uint32 )(uintptr_t) resp_cb_data;
    instance_id = (qcril_instance_id_e_type) QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
    req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );

    if( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
    {
        if( transp_err != QMI_NO_ERR )
        {
            QCRIL_LOG_ERROR("Transp error (%d) recieved from QMI for RIL request %d",
            transp_err, req_info.request);
            /* Send GENERIC_FAILURE response */
            qcril_send_empty_payload_request_response( instance_id,
                    req_info.t,
                    req_info.request,
                    RIL_E_GENERIC_FAILURE );
            }
            else
            {
                req_data->t = req_info.t;
                req_data->event_id = req_info.request;
                req_data->modem_id = QCRIL_DEFAULT_MODEM_ID;
                req_data->instance_id = instance_id;
                req_data->datalen = resp_c_struct_len;
                req_data->data = resp_c_struct;
                ril_err = RIL_E_SUCCESS;
        }
    }
    else
    {
        QCRIL_LOG_ERROR("Req id: %d not for QMI_NAS_GET_SSAC_INFO_RESP_MSG_V01", req_id);
    }
    return ril_err;
}
//===========================================================================
//qcril_qmi_dms_command_cb
//===========================================================================
void qcril_qmi_dms_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                        *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                        *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    qmi_resp_callback_type                   qmi_resp_callback;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_resp_callback,0,sizeof(qmi_resp_callback));
    qmi_resp_callback.user_handle = user_handle;
    qmi_resp_callback.msg_id = msg_id;
    qmi_resp_callback.data_buf = (void*) resp_c_struct;
    qmi_resp_callback.data_buf_len = resp_c_struct_len;
    qmi_resp_callback.cb_data = resp_cb_data;
    qmi_resp_callback.transp_err = transp_err;

    QCRIL_LOG_INFO( "entered msg %d, transp_err %d", (int) msg_id, (int) transp_err);

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_DMS_HANDLE_ASYNC_CB,
                   (void*) &qmi_resp_callback,
                   sizeof(qmi_resp_callback),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_dms_command_cb

/*=========================================================================
  FUNCTION:  qcril_qmi_dms_async_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_DMS_HANDLE_ASYNC_CB

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_dms_async_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_instance_id_e_type instance_id;
    uint32 user_data;
    uint16 req_id;
    qcril_reqlist_public_type req_info;
    qcril_request_params_type req_data;
    qmi_resp_callback_type * qmi_resp_callback;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    qmi_resp_callback = (qmi_resp_callback_type *) params_ptr->data;
    if( qmi_resp_callback )
    {
        /*-----------------------------------------------------------------------*/
        QCRIL_ASSERT( qmi_resp_callback->data_buf != NULL );
        user_data = ( uint32 )(uintptr_t) qmi_resp_callback->cb_data;
        instance_id = (qcril_instance_id_e_type) QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
        req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );
        req_data.modem_id = QCRIL_DEFAULT_MODEM_ID;
        req_data.instance_id = instance_id;
        req_data.datalen = qmi_resp_callback->data_buf_len;
        req_data.data = qmi_resp_callback->data_buf;
        /*-----------------------------------------------------------------------*/

        QCRIL_LOG_INFO("QMI DMS cb:msg_id %.2x", qmi_resp_callback->msg_id);

        if( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
        {
            if( qmi_resp_callback->transp_err != QMI_NO_ERR )
            {
                QCRIL_LOG_ERROR("Transp error (%d) recieved from QMI for RIL request %d",
                        qmi_resp_callback->transp_err, req_info.request);
                /* Send GENERIC_FAILURE response */
                qcril_send_empty_payload_request_response( instance_id,
                                                           req_info.t,
                                                           req_info.request,
                                                           RIL_E_GENERIC_FAILURE );
            }
            else
            {
                req_data.t = req_info.t;
                req_data.event_id = req_info.request;
                switch( qmi_resp_callback->msg_id )
                {
                    case QMI_DMS_GET_MSISDN_RESP_V01:
                        qcril_qmi_dms_get_msisdn_resp_hldr(&req_data);
                        break;

                    default:
                        QCRIL_LOG_ERROR("Unsupported QMI DMS message %d",
                                qmi_resp_callback->msg_id);
                        break;
                }
            }

        }
        else
        {
            QCRIL_LOG_ERROR("Req id: %d not for QMI DMS async cb", req_id);
        }
        if( qmi_resp_callback->data_buf )
        {
            qcril_free( qmi_resp_callback->data_buf );
        }
    }
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_drop_nw_info_cache
//===========================================================================
void qcril_qmi_nas_drop_nw_info_cache(void)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.current_plmn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rf_band_info_list);
    //NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.registration_reject_reason); - as currently there is no method to refetch reg reject cause
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rssi);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.ecio);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rsrq);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.hdr_personality);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_dms_cached_info.band_capability);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tac);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roaming_indicator);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.def_roam_ind);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.call_barring_status);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.mnc_includes_pcs_digit);




    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nr5g_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nr5g_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info3);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info3);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_cell_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.voice_support_on_lte);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_is_eb_supported);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.emergency_access_barred);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_embms_coverage);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.embms_coverage_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.hs_call_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sim_rej_info);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_bit_err_rate);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_block_err_rate);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_rscp);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.rscp);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tdscdma_block_err_rate);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_voice_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_sms_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_rac);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_rac);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_csg_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_csg_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_ims_voice_avail);
    nas_cached_info.old_lte_ims_voice_avail = NAS_INVALID_VOPS;

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.endc_available);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.restrict_dcnr);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available);

    nas_cached_info.voice_roam_status_reported = FALSE;

    nas_cached_info.voice_rte = QMI_RIL_RTE_NONE;
    nas_cached_info.data_rte = QMI_RIL_RTE_NONE;

    nas_cached_info.voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;

    nas_cached_info.sglte_current_eons_rte = QMI_RIL_RTE_NONE;

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_drop_nw_info_cache

//===========================================================================
//qcril_qmi_drop_sig_info_cache
//===========================================================================
void qcril_qmi_drop_sig_info_cache(void)
{
    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_sig_info);

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nr5g_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.nr5g_rsrq);

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.error_rate);
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_drop_sig_info_cache

//===========================================================================
//qmi_ril_nw_reg_data_pref_changed_action
//===========================================================================
void qmi_ril_nw_reg_data_pref_changed_action()
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                          QCRIL_DEFAULT_MODEM_ID,
                          qmi_ril_nw_reg_refresh_cache_main_thrd,
                          NULL,  // immediate
                          NULL );

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_pref_changed_action

//===========================================================================
// qmi_ril_nw_reg_refresh_cache_main_thrd
//===========================================================================
void qmi_ril_nw_reg_refresh_cache_main_thrd(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.data_reg_roaming_status_latest      = NAS_NIL;
    nas_cached_info.data_reg_roaming_status_latest_val  = FALSE;

    qcril_qmi_nas_drop_nw_info_cache();
    qcril_qmi_nas_fetch_system_info_helper();
    qcril_qmi_nas_send_known_signal_strength();
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_initiate_voice_rte_change_propagation();
    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_refresh_cache_main_thrd


//===========================================================================
//qcril_qmi_sys_info_roll_details
//===========================================================================
void qcril_qmi_sys_info_roll_details(int * rte_reg_status,
                                     int is_data,
                                     qcril_qmi_nas_srv_status_convertion_extra_results_type* extra_results_vector_param )
{
    nas_sys_info_helper_type sys_info_helper;
    int data_mask = is_data ? NAS_SYS_INFO_IS_DATA : NAS_SYS_INFO_IS_EMPTY;

    QCRIL_LOG_INFO( " .. prep CDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_1x ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_1x ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep GSM" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_GSM ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep WCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_WCDMA ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_WCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep TDSCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_TDSCDMA ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep LTE" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
        sys_info_helper.lte_is_eb_supported = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_is_eb_supported ) ? &nas_cached_info.lte_is_eb_supported : NULL;
        sys_info_helper.emergency_access_barred = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_access_barred ) ? &nas_cached_info.emergency_access_barred : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_SUB_LTE ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep EVDO" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.hdr_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
        sys_info_helper.hdr_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->hdr_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_SUB_DO ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_SUB_DO ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_HDR,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep NR5G" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.nr5g_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_SUB_NR5G ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_SUB_NR5G ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_5G,
                                                                                                             &sys_info_helper);
    }
} // qcril_qmi_sys_info_roll_details
//===========================================================================
//qcril_qmi_nas_is_considered_registered
//===========================================================================
int qcril_qmi_nas_is_considered_registered
(
    qmi_ril_nw_reg_rte_type registered_rtes[QMI_RIL_RTE_LAST]
)
{
    int                     rte_reg_status[ QMI_RIL_RTE_CAP ];
    int idx_rte;

    int                     res                = FALSE;
    int registered_rte_idx = 0;
    qmi_ril_nw_reg_rte_type tmp_registered_rtes[QMI_RIL_RTE_LAST] = {QMI_RIL_RTE_NONE};

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO( ".. cache valid %d", nas_cached_info.is_considered_registered_cached_result_valid );
    if ( nas_cached_info.is_considered_registered_cached_result_valid )
    {
        res = nas_cached_info.is_considered_registered_cached_result;
        if (registered_rtes)
        {
            memcpy(registered_rtes,
                   nas_cached_info.registered_cached_rtes,
                   sizeof(nas_cached_info.registered_cached_rtes));
        }
    }
    else
    {
        memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
        qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );

        QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
        QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
        QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
        QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
        QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
        QCRIL_LOG_INFO(".. 5G reg %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);
        QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

        for ( idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST; idx_rte++)
        {
            if ( RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ idx_rte ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ idx_rte ] )
            {
                res = TRUE;
                tmp_registered_rtes[registered_rte_idx] = (qmi_ril_nw_reg_rte_type) idx_rte;
                registered_rte_idx++;
            }
        }

        // check if data only reg
        memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
        qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );

        QCRIL_LOG_INFO( ".. 1x reg data %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
        QCRIL_LOG_INFO( ".. gsm reg data %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
        QCRIL_LOG_INFO( ".. wcdma reg data %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
        QCRIL_LOG_INFO( ".. tdscdma reg data %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
        QCRIL_LOG_INFO( ".. lte reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
        QCRIL_LOG_INFO(".. 5G reg data %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);
        QCRIL_LOG_INFO( ".. hdr reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

        for ( idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST; idx_rte++)
        {
            if ((RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ idx_rte ] ||
                  RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ idx_rte ]) &&
                  (registered_rte_idx < QMI_RIL_RTE_LAST))
            {
                res = TRUE;
                // FIXME: This could result in truncation
                tmp_registered_rtes[registered_rte_idx] = (qmi_ril_nw_reg_rte_type) idx_rte;
                registered_rte_idx++;
            }
        }

        nas_cached_info.is_considered_registered_cached_result       = res;
        nas_cached_info.is_considered_registered_cached_result_valid = TRUE;
        memcpy(nas_cached_info.registered_cached_rtes,
               tmp_registered_rtes,
               sizeof(nas_cached_info.registered_cached_rtes));

        if (registered_rtes)
        {
            memcpy(registered_rtes,
                   tmp_registered_rtes,
                   sizeof(tmp_registered_rtes));
        }

    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} // qcril_qmi_nas_is_considered_registered

/*===========================================================================

  FUNCTION  qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name

===========================================================================*/
/*!
    @brief
    check if in full service and retrieve rte satisfying the filter.

    @return
    true is in full service.
    false if not in full service
*/
/*=========================================================================*/
qmi_ril_nw_reg_rte_type qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name_info
(
    qmi_ril_nw_reg_rte_type  registered_rtes[QMI_RIL_RTE_LAST]
)
{

    qmi_ril_nw_reg_rte_type chosen_registered_rte = QMI_RIL_RTE_NONE;
    int idx_rte;

    QCRIL_LOG_FUNC_ENTRY();

    do {

        if ( (qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) ||
             qcril_qmi_nas_is_sglte3() ||
             qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SVLTE2 )) &&
             !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ))
        {
            qcril_qmi_nas_evaluate_sglte_current_eons_rte();
            chosen_registered_rte = nas_cached_info.sglte_current_eons_rte;
            QCRIL_LOG_INFO("choosing SGLTE rte");
            break;
        }

        if (!registered_rtes)
        {
            QCRIL_LOG_INFO("invalid input");
            break;
        }


        for (idx_rte = 0;
                ((idx_rte < QMI_RIL_RTE_LAST) &&
                (registered_rtes[idx_rte] != QMI_RIL_RTE_NONE) &&
                (chosen_registered_rte == QMI_RIL_RTE_NONE));
                 idx_rte++)
        {
            QCRIL_LOG_INFO("..rte %d", (int) registered_rtes[idx_rte]);
            switch (registered_rtes[idx_rte])
            {
                case QMI_RIL_RTE_GSM:
                case QMI_RIL_RTE_WCDMA:
                case QMI_RIL_RTE_TDSCDMA:
                case QMI_RIL_RTE_SUB_LTE:
                case QMI_RIL_RTE_SUB_NR5G:
                {
                    chosen_registered_rte = registered_rtes[idx_rte];
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
    } while(0);

    QCRIL_LOG_INFO("completed with %d", (int) chosen_registered_rte);
    return chosen_registered_rte;
}

//===========================================================================
//RIL_REQUEST_GET_IMEI
//===========================================================================
void qcril_qmi_nas_dms_request_imei
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  dms_get_device_serial_numbers_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  char ril_resp_data_imei[NAS_DMS_IMEI_MAX_STR_SIZE];

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  memset(ril_resp_data_imei,0,sizeof(ril_resp_data_imei));
  memset(&qmi_response, 0, sizeof(qmi_response));

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_DEVICE_SERIAL_NUMBERS_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO(".. qmi %d, %d", (int) ril_req_res, qmi_client_error);

  // ** prepare response
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      QCRIL_SNPRINTF( ril_resp_data_imei, NAS_DMS_IMEI_MAX_STR_SIZE, "%d", 0 );

      if ( qmi_response.imei_valid )
      {
          memcpy(ril_resp_data_imei,qmi_response.imei,NAS_DMS_IMEI_MAX_STR_SIZE-1);
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = ril_resp_data_imei;
      resp.resp_len = sizeof( ril_resp_data_imei );
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_imei

//===========================================================================
//RIL_REQUEST_GET_IMEISV
//===========================================================================
void qcril_qmi_nas_dms_request_imeisv
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;
  int error;

  dms_get_device_serial_numbers_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  char ril_resp_data_imeisv[NAS_DMS_IMEISV_MAX_STR_SIZE];

  qmi_client_error_type qmi_client_error;

  int imeisv_value;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  memset(ril_resp_data_imeisv,0,sizeof(ril_resp_data_imeisv));
  memset(&qmi_response, 0, sizeof(qmi_response));

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_DEVICE_SERIAL_NUMBERS_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO(".. qmi %d, %d", (int) ril_req_res, qmi_client_error);

  // ** prepare response
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      QCRIL_SNPRINTF( ril_resp_data_imeisv, NAS_DMS_IMEISV_MAX_STR_SIZE, "%02d", 0 );
      if( qmi_response.imeisv_svn_valid && (strlen(qmi_response.imeisv_svn)<NAS_DMS_IMEISV_MAX_STR_SIZE))
      {
          error = qcril_other_hex_to_int(qmi_response.imeisv_svn, &imeisv_value);
          if( NAS_NIL == error && imeisv_value <= QMI_DMS_IMEISV_MAX_VALUE )
          {
              QCRIL_SNPRINTF( ril_resp_data_imeisv, NAS_DMS_IMEISV_MAX_STR_SIZE, "%02d", imeisv_value );
          }
          else
          {
            QCRIL_LOG_ERROR("Invalid data received in the response..");
            ril_req_res = RIL_E_MODEM_ERR;
          }
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = ril_resp_data_imeisv;
      resp.resp_len = sizeof( ril_resp_data_imeisv );
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_imeisv

//===========================================================================
//qmi_ril_is_rat_tlv_support_available
//===========================================================================
int qmi_ril_is_rat_tlv_support_available(void)
{
    // return TRUE as all latest PLs support this.
    return TRUE;
} // qmi_ril_is_rat_tlv_support_available

//===========================================================================
//qcril_qmi_nas_util_adjust_hdr_ril_reg_state
//===========================================================================
int qcril_qmi_nas_util_adjust_hdr_ril_reg_state
(
     int reg_state,
     nas_hdr_only_sys_info_type_v01 *hdr_only_sys_info
)
{
    int res = reg_state;

    if( RIL_VAL_REG_REGISTERED_HOME_NET == reg_state ||
            RIL_VAL_REG_REGISTERED_ROAMING == reg_state ||
            RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == reg_state )
    {
        if( NULL != hdr_only_sys_info )
        {
            QCRIL_LOG_INFO("... hdr_active_prot_valid, hdr_personality_valid %d, %d",
                           (int) hdr_only_sys_info->hdr_active_prot_valid, (int) hdr_only_sys_info->hdr_personality_valid );
            if( FALSE == hdr_only_sys_info->hdr_active_prot_valid || FALSE == hdr_only_sys_info->hdr_personality_valid )
            {
                res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
        }
        else
        {
            res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
        }
    }
    return res;
} // qcril_qmi_nas_util_adjust_hdr_ril_reg_state

//===========================================================================
//qcril_qmi_nas_update_voice_rte
//===========================================================================
void qcril_qmi_nas_update_voice_rte(void)
{
    int voice_rtes_reg_status[ QMI_RIL_RTE_CAP ];
    nas_sys_info_helper_type sys_info_helper;
    qmi_ril_nw_reg_rat_confidence_tag_type updated_voice_rte_confidence_tag;
    qmi_ril_nw_reg_rat_confidence_tag_type prev_voice_rte_confidence_tag;
    qmi_ril_nw_reg_rte_type updated_voice_rte;
    nas_common_sys_info_type_v01 *common_sys_info = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &voice_rtes_reg_status, 0, sizeof( voice_rtes_reg_status ) );

    QCRIL_LOG_INFO( " .. prep CDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_1x ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_EMPTY,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep HDR" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
    {
        nas_hdr_sys_info_type_v01 *hdr_sys_info =
            NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ?
            nas_cached_info.hdr_sys_info : NULL;

        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.hdr_srv_status_info;

        common_sys_info = sys_info_helper.common_sys_info =
            hdr_sys_info ? &hdr_sys_info->common_sys_info : NULL;

        voice_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] =
            qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status_direct(
                    sys_info_helper.threegpp2_srv_status->srv_status,
                    common_sys_info, FALSE
                    );

        voice_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] =
            qcril_qmi_nas_util_adjust_hdr_ril_reg_state(
                    voice_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ],
                    hdr_sys_info ? &hdr_sys_info->hdr_specific_sys_info : NULL
                    );

    }

    QCRIL_LOG_INFO( " .. prep GSM" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep WCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep TDSCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep LTE" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
        sys_info_helper.lte_is_eb_supported = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_is_eb_supported ) ? &nas_cached_info.lte_is_eb_supported : NULL;
        sys_info_helper.emergency_access_barred = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_access_barred ) ? &nas_cached_info.emergency_access_barred : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO(" .. prep 5G");
    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info))
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.nr5g_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info) ? &nas_cached_info.nr5g_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info) ? &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info : NULL;
        voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_5G, &sys_info_helper);
    }

    QCRIL_LOG_INFO( ".. 1x reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. hdr reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] );
    QCRIL_LOG_INFO( ".. gsm reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO(".. 5G reg %d", voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G]);

    if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] )
    {
        updated_voice_rte = QMI_RIL_RTE_1x;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if (RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G])
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_NR5G;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] &&
              ( TRUE == nas_common_info.consider_lte_ltd_srv_vrte_update ) )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if (RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G])
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_NR5G;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] &&
              ( TRUE == nas_common_info.consider_lte_ltd_srv_vrte_update ) )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if (RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G])
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_NR5G;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] )
    {
        /** HDR is not a voice technology, so we give it lower priority than limited
         * service than other voice RATs, to prevent reporting HDR when other RAT
         * could be used for emergency calls
         */
        updated_voice_rte = QMI_RIL_RTE_SUB_DO;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
        if (common_sys_info && common_sys_info->srv_domain_valid) {
            if (common_sys_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY_V01 ||
                    common_sys_info->srv_domain == SYS_SRV_DOMAIN_NO_SRV_V01 ||
                    common_sys_info->srv_domain == SYS_SRV_DOMAIN_CAMPED_V01 ) {
                updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
            }
        }
    }

    else if ( RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if (  RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if (  RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] &&
               ( TRUE == nas_common_info.consider_lte_ltd_srv_vrte_update ) )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if (RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G])
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_NR5G;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] )
    {
        updated_voice_rte = QMI_RIL_RTE_1x;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if (RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G])
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_NR5G;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] )
    {
        updated_voice_rte = QMI_RIL_RTE_1x;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if (RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G])
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_NR5G;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else
    {
        updated_voice_rte = QMI_RIL_RTE_NONE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }

    prev_voice_rte_confidence_tag = nas_cached_info.voice_rte_confidence_tag;
    // update nas cached info
    nas_cached_info.voice_rte = updated_voice_rte;
    nas_cached_info.voice_rte_confidence_tag = updated_voice_rte_confidence_tag;
    QCRIL_LOG_INFO( "completed, new vrte %d with confidence %d", (int) nas_cached_info.voice_rte, (int) nas_cached_info.voice_rte_confidence_tag );

    // if service state changed between NO_SVC, FULL, LIMITTED, re-evaluate ecc list
    if ( updated_voice_rte_confidence_tag != prev_voice_rte_confidence_tag )
    {
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                QCRIL_DEFAULT_MODEM_ID,
                QCRIL_DATA_ON_STACK,
                QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                NULL,
                QMI_RIL_ZERO,
                (RIL_Token) QCRIL_CUSTOM_ECC_INTERNAL_TOKEN );
    }

    if (qcril_qmi_nas_has_normal_voice_call_capability())
      qcril_qmi_voice_trigger_possible_pending_emergency_call();
} // qcril_qmi_nas_update_voice_rte

int qcril_qmi_nas_has_normal_voice_call_capability()
{
    int res;
    uint8_t is_ims_registered = qcril_qmi_nas_ims_is_ims_registered_for_voip_vt_service();

    NAS_CACHE_LOCK();
    if(is_ims_registered) /*When IMS registered over WIFI*/
    {
        res = TRUE;
    }
    else if (nas_cached_info.voice_rte_confidence_tag != QMI_RIL_RAT_CONFIDENCE_FULL_SVC)
    {
      res = FALSE;
    }
    else
    {
      if (QMI_RIL_RTE_SUB_LTE == nas_cached_info.voice_rte)
      {
        res = (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.voice_support_on_lte) && nas_cached_info.voice_support_on_lte);
      }
      else if (QMI_RIL_RTE_SUB_NR5G == nas_cached_info.voice_rte)
      {
        res = is_voice_supported_on_5g();
      }
      else
      {
        res = TRUE;
      }
    }
    NAS_CACHE_UNLOCK();

    return res;
}

//===========================================================================
//qcril_qmi_nas_update_data_rte
//===========================================================================
void qcril_qmi_nas_update_data_rte(void)
{
    int data_rtes_reg_status[ QMI_RIL_RTE_CAP ];
    qcril_arb_pref_data_tech_e_type pref_data_tech;
    qcril_arb_pref_data_type pref_data;
    int is_current;
    int is_data_rte_calculated;
    nas_sys_info_helper_type sys_info_helper;
    qmi_ril_nw_reg_rat_confidence_tag_type prev_data_rte_confidence_tag;
    QCRIL_LOG_FUNC_ENTRY();

    memset( &data_rtes_reg_status, 0, sizeof( data_rtes_reg_status ) );
    memset( &pref_data, 0, sizeof( pref_data ) );
    is_data_rte_calculated = FALSE;

    prev_data_rte_confidence_tag = nas_cached_info.data_rte_confidence_tag;
    qcril_qmi_get_pref_data_tech(&pref_data);
    qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, NULL, NULL );

    pref_data_tech = pref_data.pref_data_tech;
    is_current = pref_data.is_current;
    QCRIL_LOG_INFO(".. pref data tech %s, is current %d", qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech), is_current );

    QCRIL_LOG_INFO( " .. prep CDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_1x ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep GSM" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep WCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep TDSCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep LTE" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_LTE,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep EVDO" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.hdr_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
        sys_info_helper.hdr_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->hdr_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_HDR | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep 5G" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.nr5g_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_SUB_NR5G ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_5G,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( ".. 1x reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO( ".. hdr reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] );
    QCRIL_LOG_INFO( ".. 5G reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_SUB_NR5G ] );

    if( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data_tech ) //preferred data system indication availability; Reset all technologies except the pref tech system
    {
        QCRIL_LOG_INFO("CnE module available");
        if( TRUE == is_current )
        {
          QCRIL_LOG_INFO("with current status");
          if( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data_tech )
          {
            nas_cached_info.data_rte = qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(pref_data_tech);
            nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;

            is_data_rte_calculated = TRUE;
            QCRIL_LOG_INFO("data rte calculated");
          }
        }
        else
        {
          QCRIL_LOG_INFO("with legacy status");
        }

        QCRIL_LOG_INFO("preferred data tech available %s", qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech) );
        if( QCRIL_ARB_PREF_DATA_TECH_CDMA != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_1x ] )
        {
            QCRIL_LOG_INFO("resetting CDMA data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
            data_rtes_reg_status[ QMI_RIL_RTE_1x ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
        }
        if( QCRIL_ARB_PREF_DATA_TECH_EVDO != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] )
        {
            QCRIL_LOG_INFO("resetting EVDO data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
            data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
        }

        //Do not reset in case if the 3GPP limited service flag is set
        if( TRUE != nas_common_info.consider_3gpp_ltd_srv_drte_update )
        {
            if( QCRIL_ARB_PREF_DATA_TECH_GSM != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
            {
                QCRIL_LOG_INFO("resetting GSM data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_GSM ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
            if( QCRIL_ARB_PREF_DATA_TECH_UMTS != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
            {
                QCRIL_LOG_INFO("resetting UMTS data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
            if( QCRIL_ARB_PREF_DATA_TECH_TDSCDMA != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
            {
                QCRIL_LOG_INFO("resetting TDSCDMA data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
            if( QCRIL_ARB_PREF_DATA_TECH_LTE != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
            {
                QCRIL_LOG_INFO("resetting LTE data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }

            if (QCRIL_ARB_PREF_DATA_TECH_5G != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G])
            {
                QCRIL_LOG_INFO("resetting 5G data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[QMI_RIL_RTE_SUB_NR5G] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
        }
    }

    if( FALSE == is_data_rte_calculated )
    {
      qmi_ril_nw_reg_rte_type prev_data_rte = nas_cached_info.data_rte;

      if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_LTE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_SUB_NR5G ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_SUB_NR5G ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_NR5G;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_DO;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_WCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_TDSCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_GSM;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_1x ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_1x;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_LTE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_NR5G ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_SUB_NR5G ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_NR5G;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_WCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_TDSCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_GSM;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_LTE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_NR5G ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_NR5G;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_DO;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_WCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_TDSCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_GSM;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_1x ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_1x;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_NONE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
      }

      QCRIL_LOG_DEBUG("Previous data RTE: %d | Current data RTE:  %d | Previous data RTE confidence: %d | Current data RTE confidence: %d",
                      (int) prev_data_rte, (int) nas_cached_info.data_rte, (int) prev_data_rte_confidence_tag, (int) nas_cached_info.data_rte_confidence_tag);

      if (prev_data_rte != nas_cached_info.data_rte ||
          prev_data_rte_confidence_tag != nas_cached_info.data_rte_confidence_tag)
      {
          getNasModule().reportCurrentPhysChanConfig();
      }
    }

    // if service state FULL only when IMS registered
    if ( ( prev_data_rte_confidence_tag != nas_cached_info.data_rte_confidence_tag ) &&
          (QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag) )
    {
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                QCRIL_DEFAULT_MODEM_ID,
                QCRIL_DATA_ON_STACK,
                QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                NULL,
                QMI_RIL_ZERO,
                (RIL_Token) QCRIL_CUSTOM_ECC_INTERNAL_TOKEN);
    }

    QCRIL_LOG_DEBUG( "completed, new drte %d with confidence %d", (int) nas_cached_info.data_rte, (int) nas_cached_info.data_rte_confidence_tag  );

} // qcril_qmi_nas_update_data_rte

//===========================================================================
// qcril_qmi_nas_get_embms_status
//===========================================================================
uint8_t qcril_qmi_nas_get_embms_status(void)
{
    uint8_t is_available;

    QCRIL_LOG_FUNC_ENTRY();
    NAS_EMBMS_CACHE_LOCK();
    is_available = nas_cached_info.is_embms_available;
    NAS_EMBMS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(is_available);
    return is_available;
}

//===========================================================================
// qcril_qmi_nas_update_embms_status
//===========================================================================
void qcril_qmi_nas_update_embms_status(void)
{
    uint8_t is_available = 0;
    uint32_t sub_capability = 0;
    qcril_instance_id_e_type instance_id = qmi_ril_get_process_instance_id();;

    QCRIL_LOG_FUNC_ENTRY();
    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        NAS_CACHE_LOCK();
        sub_capability = qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();

        if (sub_capability & (1 << RADIO_TECH_LTE))
        {
          is_available = 1;
        }

        if (is_available && (nas_common_info.dsds.is_default_data_set == TRUE) &&
             ((nas_common_info.dsds.default_data_instance_id != instance_id)||
              (USER != nas_common_info.dsds.default_data_reason)))
        {
          is_available = 0;
        }
        NAS_CACHE_UNLOCK();

        NAS_EMBMS_CACHE_LOCK();
        nas_cached_info.is_embms_available = is_available;
        NAS_EMBMS_CACHE_UNLOCK();
        QCRIL_LOG_DEBUG("is_available %d", is_available);
    }
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_update_ims_rte
//===========================================================================
void qcril_qmi_nas_update_ims_rte(void)
{
    QCRIL_LOG_FUNC_ENTRY();

    if ( nas_cached_info.is_registered_on_ims )
    {
        nas_cached_info.ims_rte = QMI_RIL_RTE_WCDMA;
        nas_cached_info.ims_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else
    {
        nas_cached_info.ims_rte = QMI_RIL_RTE_NONE;
        nas_cached_info.ims_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }

    QCRIL_LOG_INFO( "completed, new irte %d with confidence %d", (int) nas_cached_info.ims_rte, (int) nas_cached_info.ims_rte_confidence_tag );

} // qcril_qmi_nas_update_ims_rte

//===========================================================================
//qcril_qmi_nas_util_map_pref_data_tech_to_data_rte
//===========================================================================
qmi_ril_nw_reg_rte_type qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(qcril_arb_pref_data_tech_e_type pref_data_tech)
{
    qmi_ril_nw_reg_rte_type drte;

    QCRIL_LOG_INFO("entered, pref data tech is %s",qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech));

    switch( pref_data_tech )
    {
      case QCRIL_ARB_PREF_DATA_TECH_CDMA:
        drte = QMI_RIL_RTE_1x;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_EVDO:
      case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
        drte = QMI_RIL_RTE_SUB_DO;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_GSM:
        drte = QMI_RIL_RTE_GSM;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_UMTS:
        drte = QMI_RIL_RTE_WCDMA;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
        drte = QMI_RIL_RTE_TDSCDMA;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_LTE:
        drte = QMI_RIL_RTE_SUB_LTE;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_5G:
        drte = QMI_RIL_RTE_SUB_NR5G;
        break;

      default:
        drte = QMI_RIL_RTE_NONE;
        break;
    }

    QCRIL_LOG_INFO( "completed, data rte is %d", drte );
    return drte;
} // qcril_qmi_nas_util_map_pref_data_tech_to_data_rte

//===========================================================================
//qmi_ril_nwr_get_eme_cbm
//===========================================================================
qmi_ril_emergency_callback_mode_state_type qmi_ril_nwr_get_eme_cbm()
{
    qmi_ril_emergency_callback_mode_state_type res;

    NAS_CACHE_LOCK();
    res = nas_cached_info.eme_cbm;
    NAS_CACHE_UNLOCK();

    return res;
} // qmi_ril_nwr_get_eme_cbm
//===========================================================================
//qmi_ril_nwr_set_eme_cbm
//===========================================================================
void qmi_ril_nwr_set_eme_cbm(qmi_ril_emergency_callback_mode_state_type new_mode)
{
    qmi_ril_emergency_callback_mode_state_type cur;
    qmi_ril_emergency_callback_mode_state_type rule;
    int go_on;
    int evt;

    QCRIL_LOG_INFO( "entered, mode requested %d", (int) new_mode );

    NAS_CACHE_LOCK();
    cur = nas_cached_info.eme_cbm;
    NAS_CACHE_UNLOCK();
    rule = cur;
    QCRIL_LOG_INFO( ".. cur %d", (int) cur );

    evt = NAS_NIL;
    if ( new_mode != cur )
    {
        switch ( new_mode )
        {
            case QMI_RIL_EME_CBM_NOT_ACTIVE:
                rule    = QMI_RIL_EME_CBM_NOT_ACTIVE;
                go_on   = TRUE;
                if ( QMI_RIL_EME_CBM_ACTIVE == cur )
                {
                    evt     = RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE;
                }
                break;

            case QMI_RIL_EME_CBM_ACTIVE:
                rule    = QMI_RIL_EME_CBM_ACTIVE;
                go_on   = TRUE;
                evt     = RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE;
                break;

            default:
                go_on = FALSE;
                break;
        }
    }
    else
    {
        go_on = FALSE;
    }

    QCRIL_LOG_INFO( ".. go_on, rule %d, %d", (int) go_on, (int) rule );
    if ( go_on )
    {
        boolean is_eme_ip;
        NAS_CACHE_LOCK();
        nas_cached_info.eme_cbm = rule;
        is_eme_ip = nas_cached_info.is_eme_ip_call;
        NAS_CACHE_UNLOCK();
        if ( NAS_NIL != evt )
        {
            if (!is_eme_ip)
            {
                RilUnsolEmergencyCallbackModeMessage::EmergencyCallbackMode mode =
                    (evt == RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE) ?
                    RilUnsolEmergencyCallbackModeMessage::EmergencyCallbackMode::LEAVE :
                    RilUnsolEmergencyCallbackModeMessage::EmergencyCallbackMode::ENTER;
                auto msg = std::make_shared<RilUnsolEmergencyCallbackModeMessage>(mode);
                Dispatcher::getInstance().dispatchSync(msg);
            }
            else
            {
                if (RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE == evt)
                {
                    auto msg = std::make_shared<QcRilUnsolImsExitEcbmIndication>();
                    if (msg != nullptr)
                    {
                        Dispatcher::getInstance().dispatchSync(msg);
                    }
                }
                else
                {
                    auto msg = std::make_shared<QcRilUnsolImsEnterEcbmIndication>();
                    if (msg != nullptr)
                    {
                        Dispatcher::getInstance().dispatchSync(msg);
                    }
                }
            }
        }

        if( RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE == evt)
        {
            if ( !qcril_qmi_voice_nas_control_is_any_calls_present() )
            {
                qcril_setup_timed_callback (QCRIL_DEFAULT_INSTANCE_ID,
                                            QCRIL_DEFAULT_MODEM_ID,
                                            qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally_cb,
                                            NULL,
                                            NULL);
            }
        }
    }

    QCRIL_LOG_INFO( "completed, new mode %d", (int) rule );
} // qmi_ril_nwr_set_eme_cbm
//===========================================================================
//qmi_ril_nwr_update_reg_rej_from_sys_info
//===========================================================================
void qmi_ril_nwr_update_reg_rej_from_sys_info(void)
{
    int rte_reg_status[ QMI_RIL_RTE_CAP ];
    int rte_idx;
    nas_3gpp_only_sys_info_type_v01*  sys_info_3gpp_only;
    nas_3gpp_srv_status_info_type_v01 *srv_status_3gpp;
    qcril_qmi_nas_srv_status_convertion_extra_results_type rte_srv_status_extras[ QMI_RIL_RTE_CAP ];
    int nof_cs_reg_reject;
    int do_switch_rte;

    QCRIL_LOG_FUNC_ENTRY();

    // voice
    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
    memset( &rte_srv_status_extras, 0, sizeof(rte_srv_status_extras) );
    qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, rte_srv_status_extras );
    QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO(".. 5G reg %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);
    QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );
    QCRIL_LOG_INFO( ".. nr5g reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_NR5G ] );

    nof_cs_reg_reject = NAS_NIL;
    for ( rte_idx = QMI_RIL_RTE_FIRST; rte_idx < QMI_RIL_RTE_CAP; rte_idx++ )
    {
      if ( nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected )
      {
        nof_cs_reg_reject++;
      }
    }
    QCRIL_LOG_INFO( ".. nof cs reg reject %d, cs reg reject for direct inj %d",
                    nof_cs_reg_reject,
                    nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected );
    if ( nof_cs_reg_reject > QMI_RIL_SINGLE &&
         nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected &&
         nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected_assumed
         )
    {
      QCRIL_LOG_INFO( ".. clear assumed");
      qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED );
    }

    for ( rte_idx = QMI_RIL_RTE_FIRST; rte_idx < QMI_RIL_RTE_CAP; rte_idx++ )
    {
        sys_info_3gpp_only = NULL;
        srv_status_3gpp    = NULL;
        switch ( rte_idx )
        {
            case QMI_RIL_RTE_GSM:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.gsm_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                }
                break;

            case QMI_RIL_RTE_WCDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.wcdma_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                }
                break;

            case QMI_RIL_RTE_TDSCDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.tdscdma_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                }
                break;

            case QMI_RIL_RTE_SUB_LTE:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.lte_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                }
                break;

            case QMI_RIL_RTE_SUB_NR5G:
                if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info))
                {
                    srv_status_3gpp = nas_cached_info.nr5g_srv_status_info;
                }

                if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info))
                {
                    sys_info_3gpp_only = &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info;
                }
                break;

            default:
                // nothing for 3gpp2
                break;
        }

        QCRIL_LOG_INFO( ".. ext info is_reject_case %d, is_managed_roaming %d, reject_cause %d",
                        (int)rte_srv_status_extras[rte_idx].is_reject_case,
                        (int)rte_srv_status_extras[rte_idx].is_managed_roaming,
                        (int)rte_srv_status_extras[rte_idx].reject_cause);
        if ( rte_srv_status_extras[rte_idx].is_reject_case && rte_srv_status_extras[rte_idx].is_managed_roaming )
        {
            qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
            nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause             = rte_srv_status_extras[rte_idx].reject_cause;
            nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected_managed_roaming = TRUE;
            if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
            { // attach mcc/mnc
                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
            }
        }
        else
        {
            switch ( rte_reg_status[rte_idx] )
            {
                case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                case RIL_VAL_REG_REGISTRATION_DENIED:
                    if(nas_cached_info.is_blocked_valid && nas_cached_info.is_blocked)
                    {
                        qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                        nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause = rte_srv_status_extras[rte_idx].reject_cause;
                        if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
                        { // attach mcc/mnc
                            memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                            memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                        }
                    }
                    else if ( sys_info_3gpp_only && sys_info_3gpp_only->reg_reject_info_valid )
                    {
                        switch ( sys_info_3gpp_only->reg_reject_info.reject_srv_domain )
                        {
                            case SYS_SRV_DOMAIN_CS_ONLY_V01:    // fallthrough
                            case SYS_SRV_DOMAIN_CS_PS_V01:
                                qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                                nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause            = sys_info_3gpp_only->reg_reject_info.rej_cause;
                                if ( sys_info_3gpp_only->network_id_valid )
                                { // attach mcc/mnc cause
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                                }
                                break;

                            default:
                                // skip PS etc
                                break;
                        }
                    }
                    break;

                case RIL_VAL_REG_REGISTERED_HOME_NET:
                case RIL_VAL_REG_REGISTERED_ROAMING:
                    if ( !nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected || nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause_relayed )
                    {
                        // reset if full service
                        QCRIL_LOG_INFO( ".. abandoning cs_rejected as full service" );
                        qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
                    }
                    break;

                default:
                    if ( nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected  )
                    {
                        QCRIL_LOG_INFO( ".. cs reject follow up on re-reg to ltd" );
                        do
                        {
                            // mcc/mnc to refetch?
                            if (
                                qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc )
                                ||
                                qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc )
                                )
                            {
                                QCRIL_LOG_INFO( ".. cached mcc/mnc are empty, need re-fetch" );
                                if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
                                {
                                    QCRIL_LOG_INFO( ".. re-fetching" );
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                                    qmi_ril_nwr_util_log_mccmnc_str(".. refetched mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc);
                                    qmi_ril_nwr_util_log_mccmnc_str(".. refetched mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc);

                                    break;
                                }
                            }

                            // cell changed?
                            if (
                                 sys_info_3gpp_only
                                 &&
                                 sys_info_3gpp_only->network_id_valid
                                 &&
                                 ( NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01 )
                                   ||
                                   NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01 )
                                 )
                                 &&
                                 nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause_relayed
                                )
                            { // jumped to another cell
                                QCRIL_LOG_INFO( ".. abandoning cs_rejected as switched cell" );
                                qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                                break;
                            }

                            // no longer in any service
                            if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == rte_reg_status[ rte_idx ] ||
                                 RIL_VAL_REG_UNKNOWN == rte_reg_status[ rte_idx ] ||
                                 RIL_VAL_REG_NOT_REGISTERED_SEARCHING  == rte_reg_status[ rte_idx ] )
                            {
                              QCRIL_LOG_INFO( ".. lost ltd svc on rejected rat cs" );
                              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                              break;
                            }

                            // changed because of full or limited srv on another RAT
                            if ( QMI_RIL_RTE_NONE != nas_cached_info.voice_rte &&
                                 rte_idx != nas_cached_info.voice_rte &&
                                 ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag ||
                                   QMI_RIL_RAT_CONFIDENCE_LTD_SVC  == nas_cached_info.voice_rte_confidence_tag
                                 )
                                )
                            {
                              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED );
                              QCRIL_LOG_INFO( ".. abandoning because another RAT in full svc (%d) ", (int)nas_cached_info.voice_rte);
                              // no break here
                            }

                            // enforce report
                            if ( QMI_RIL_RTE_NONE != nas_cached_info.voice_rte && nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected )
                            {
                              do_switch_rte = FALSE;
                              if ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC != nas_cached_info.voice_rte_confidence_tag )
                              {
                                switch ( rte_reg_status[ nas_cached_info.voice_rte ] )
                                {
                                    case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:
                                    case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:
                                    case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                                    case RIL_VAL_REG_UNKNOWN:
                                        do_switch_rte = TRUE;
                                        break;

                                    default:
                                        // no change
                                        break;
                                }
                                if ( do_switch_rte &&
                                     ( nas_cached_info.voice_rte != rte_idx ) &&
                                     !( rte_idx == QMI_RIL_RTE_SUB_LTE && QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag )
                                     // TODO: Should similar handling be done for 5G?
                                    )
                                {
                                  nas_cached_info.voice_rte                = (qmi_ril_nw_reg_rte_type) rte_idx;
                                  nas_cached_info.voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
                                  QCRIL_LOG_INFO(  ".. adjusted voice rte to %d", (int) nas_cached_info.voice_rte );
                                }
                              }
                            }
                        } while ( FALSE );
                    }
                    break;
            }
        }

        QCRIL_LOG_INFO( ".. rte %d reje CS cs_rejected %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected );
        QCRIL_LOG_INFO( ".. rte %d reje CS cs_reject_cause %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause );
        qmi_ril_nwr_util_log_mccmnc_str(".. reje mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc);
        qmi_ril_nwr_util_log_mccmnc_str(".. reje mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc);

    }

    // data
    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
    qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );
    QCRIL_LOG_INFO( ".. 1x reg data %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg data %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg data  %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg data  %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO(".. 5G reg data %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);
    QCRIL_LOG_INFO( ".. hdr reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

    for ( rte_idx = QMI_RIL_RTE_FIRST; rte_idx < QMI_RIL_RTE_CAP; rte_idx++ )
    {
        switch ( rte_reg_status[rte_idx] )
        {
            case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
            case RIL_VAL_REG_REGISTRATION_DENIED:
                sys_info_3gpp_only = NULL;
                switch ( rte_idx )
                {
                    case QMI_RIL_RTE_GSM:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    case QMI_RIL_RTE_WCDMA:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    case QMI_RIL_RTE_TDSCDMA:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    case QMI_RIL_RTE_SUB_LTE:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    case QMI_RIL_RTE_SUB_NR5G:
                        if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info))
                        {
                            sys_info_3gpp_only = &nas_cached_info.nr5g_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    default:
                        // nothing for 3gpp2
                        break;
                }
                if(nas_cached_info.is_blocked_valid && nas_cached_info.is_blocked)
                {
                    qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                    nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_reject_cause = ILLEGAL_ME;
                    if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
                    { // attach mcc/mnc
                        memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                        memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                    }
                }
                else if ( sys_info_3gpp_only && sys_info_3gpp_only->reg_reject_info_valid )
                {
                    switch ( sys_info_3gpp_only->reg_reject_info.reject_srv_domain )
                    {
                        case SYS_SRV_DOMAIN_PS_ONLY_V01:    // fallthrough
                        case SYS_SRV_DOMAIN_CS_PS_V01:
                            qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                            nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_reject_cause            = sys_info_3gpp_only->reg_reject_info.rej_cause;
                            if ( sys_info_3gpp_only->network_id_valid )
                            { // attach mcc/mnc
                                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                            }
                            break;

                        default:
                            // skip PS etc
                            break;
                    }
                }
                break;

            case RIL_VAL_REG_REGISTERED_HOME_NET:
            case RIL_VAL_REG_REGISTERED_ROAMING:
                // reset unconditionally if full service
                QCRIL_LOG_INFO( ".. drop as full svc" );
                qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
                break;

            default:
                // reset if relayed
                if ( nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_rejected  )
                {
                    QCRIL_LOG_INFO( ".. ps reject follow up on re-reg to ltd" );
                    do
                    {

                        // re-fetch mcc/mnc
                        if (
                                 qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc )
                                 ||
                                 qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc )
                            )
                        {
                            QCRIL_LOG_INFO( ".. data cached mcc/mnc are empty, need re-fetch" );
                            if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
                            {
                                     QCRIL_LOG_INFO( ".. data re-fetching" );
                                     memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                     memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                                     qmi_ril_nwr_util_log_mccmnc_str(".. data refetched mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc);
                                     qmi_ril_nwr_util_log_mccmnc_str(".. data refetched mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc);

                                     break;
                            }
                        }

                        // mcc/mnc changed ?
                        if (
                             sys_info_3gpp_only
                             &&
                             sys_info_3gpp_only->network_id_valid
                             &&
                             ( NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01 )
                               ||
                               NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01 )
                             )
                             &&
                             nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_reject_cause_relayed
                            )
                        { // jumped to another cell
                            QCRIL_LOG_INFO( ".. drop as jumped cell" );
                            qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                            break;
                        }

                        // no longer in any service
                        if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == rte_reg_status[ rte_idx ] ||
                             RIL_VAL_REG_UNKNOWN == rte_reg_status[ rte_idx ] ||
                             RIL_VAL_REG_NOT_REGISTERED_SEARCHING  == rte_reg_status[ rte_idx ] )
                        {
                          QCRIL_LOG_INFO( ".. lost ltd svc on rejected rat ps" );
                          qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                          break;
                        }

                        // changed because of full or limited srv on another RAT
                        if ( QMI_RIL_RTE_NONE != nas_cached_info.data_rte &&
                             rte_idx != nas_cached_info.data_rte &&
                             ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag ||
                               QMI_RIL_RAT_CONFIDENCE_LTD_SVC  == nas_cached_info.data_rte_confidence_tag
                             )
                            )
                        {
                          qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, (qmi_ril_nw_reg_rte_type) rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED );
                          // no break here
                        }

                        // not relayed - shift data RTE if not full service
                        if ( QMI_RIL_RTE_NONE != nas_cached_info.data_rte && nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_rejected )
                        {
                          do_switch_rte = FALSE;
                          if ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC != nas_cached_info.data_rte_confidence_tag )
                          {
                            switch ( rte_reg_status[ nas_cached_info.data_rte ] )
                            {
                                case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:
                                case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:
                                case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                                case RIL_VAL_REG_UNKNOWN:
                                    do_switch_rte = TRUE;
                                    break;

                                default:
                                    // no change
                                    do_switch_rte = FALSE;
                                    break;
                            }
                          }
                          if ( do_switch_rte && ( rte_idx != nas_cached_info.data_rte ) )
                          {
                            nas_cached_info.data_rte                = (qmi_ril_nw_reg_rte_type) rte_idx;
                            nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
                            QCRIL_LOG_INFO(  ".. adjusted data rte to %d", (int) nas_cached_info.data_rte );
                          }
                        }
                    } while (FALSE);
                }
                break;
        }

        QCRIL_LOG_INFO( ".. rte %d reje PS ps_rejected %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_rejected );
        QCRIL_LOG_INFO( ".. rte %d reje PS ps_reject_cause %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_reject_cause );
        qmi_ril_nwr_util_log_mccmnc_str(".. data reje mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc);
        qmi_ril_nwr_util_log_mccmnc_str(".. data reje mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc);

    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwr_update_reg_rej_from_sys_info

//===========================================================================
//qmi_ril_nwr_util_log_mccmnc_str
//===========================================================================
void qmi_ril_nwr_util_log_mccmnc_str(const char * ctx, char *mcc_or_mnc_arr)
{
    char mccmnc_str[NAS_MCC_MNC_MAX_V01 + 2];
    char outcome[ QCRIL_MAX_LOG_MSG_SIZE ];

    if ( ctx && mcc_or_mnc_arr)
    {
        memcpy( mccmnc_str, mcc_or_mnc_arr, NAS_MCC_MNC_MAX_V01  );
        mccmnc_str[NAS_MCC_MNC_MAX_V01] = 0;

        snprintf(outcome, sizeof(outcome), "%s - %s", ctx, mccmnc_str );

        QCRIL_LOG_INFO("%s", outcome);
    }
} // qmi_ril_nwr_util_log_mccmnc_str
//=========================================================================
//qmi_ril_nwr_is_mcc_or_mnc_empty
//===========================================================================
int qmi_ril_nwr_is_mcc_or_mnc_empty(char * mcc_or_mnc_str)
{
    int res;

    if (mcc_or_mnc_str)
    {
        res = (NAS_NIL == mcc_or_mnc_str[0] || NAS_NIL == mcc_or_mnc_str[1]);
    }
    else
    {
        res = TRUE;
    }
    return res;
} // qmi_ril_nwr_is_mcc_or_mnc_empty
//=========================================================================
//qmi_ril_nwr_reg_reject_init
//===========================================================================
void qmi_ril_nwr_reg_reject_init(void)
{
  NAS_CACHE_LOCK();

  memset( nas_cached_info.reg_reject_sys_info, 0, sizeof( qmi_ril_reg_reject_cached_summary_type ) * QMI_RIL_RTE_CAP  );
  memset( &nas_cached_info.reg_reject_legacy, 0, sizeof( qmi_ril_reg_reject_cached_summary_type ) );

  memset( &nas_cached_info.reg_reject_expiry_tmr_id, 0, sizeof( uint32 ) * QMI_RIL_RTE_KIND_CAP );

  NAS_CACHE_UNLOCK();
} // qmi_ril_nwr_reg_reject_init
//=========================================================================
//qmi_ril_nwr_reg_reject_handle_event
//===========================================================================
void qmi_ril_nwr_reg_reject_handle_event_cl( qmi_ril_nw_reg_rte_kind_type rte_kind, qmi_ril_nw_reg_rte_type rte, qmi_ril_reg_reject_perception_event_e_type evt ) // cache must be locked
{
  qmi_ril_reg_reject_cached_summary_type * summary;
  int                                      must_clear_tmr;
  int                                      must_clear;
  int                                      must_start_tmr;
  int                                      must_check_for_clear;
  int                                      must_schedule_refresh;
  uint32*                                  tmr_id;
  static const struct timeval              tmr_expity_value = { 1, 0 }; // 1 second
  qmi_ril_reg_reject_tmr_expry_passover_type *
                                           passover;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_LOG_INFO( ".. rte_kind %d, rte %d, evt %d", (int) rte_kind, (int) rte,(int)evt );

  summary = &nas_cached_info.reg_reject_sys_info[ rte ];

  tmr_id = &nas_cached_info.reg_reject_expiry_tmr_id[ rte_kind ];

  must_clear_tmr        = FALSE;
  must_clear            = FALSE;
  must_start_tmr        = FALSE;
  must_check_for_clear  = FALSE;
  must_schedule_refresh = FALSE;

  switch ( evt )
  {
    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED:
      switch ( rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:
           if ( !summary->cs_rejected )
           {
              summary->cs_rejected             = TRUE;
              summary->cs_reject_cause_relayed = FALSE;
              memset( summary->org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
              memset( summary->org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
              must_clear_tmr = TRUE;
              must_start_tmr = TRUE;
          }
          break;

        case QMI_RIL_RTE_KIND_DATA:
           if ( !summary->ps_rejected )
           {
              summary->ps_rejected             = TRUE;
              summary->ps_reject_cause_relayed = FALSE;
              memset( summary->data_org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
              memset( summary->data_org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
              must_clear_tmr = TRUE;
              must_start_tmr = TRUE;
           }
          break;

        default: // nothing
          break;
      }
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED:
      switch ( rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:
          if ( summary->cs_rejected )
          {
            summary->cs_reject_cause_relayed = TRUE;
          }
          break;

        case QMI_RIL_RTE_KIND_DATA:
          if ( summary->ps_rejected )
          {
            summary->ps_reject_cause_relayed = TRUE;
          }
          break;

        default: // nothing
          break;
      }
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_EXPIRED:
      *tmr_id = NAS_NIL;
      must_schedule_refresh = TRUE;
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED:
      must_clear = TRUE;
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED:
      must_clear = TRUE;
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED:
      switch ( rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:
          if ( summary->cs_rejected && summary->cs_reject_cause_relayed && NAS_NIL == *tmr_id )
          {
            must_clear            = TRUE;
          }
          break;

        case QMI_RIL_RTE_KIND_DATA:
          if ( summary->ps_rejected && summary->ps_reject_cause_relayed && NAS_NIL == *tmr_id )
          {
            must_clear            = TRUE;
          }
          break;

        default: // nothing
          break;
      }
      break;

    default:
      break;
  }

  if ( must_check_for_clear )
  {
    switch ( rte_kind )
    {
      case QMI_RIL_RTE_KIND_VOICE:
        if ( summary->cs_rejected && summary->cs_reject_cause_relayed && NAS_NIL == *tmr_id )
        {
          must_clear            = TRUE;
          must_schedule_refresh = TRUE;
        }
        break;

      case QMI_RIL_RTE_KIND_DATA:
        if ( summary->ps_rejected && summary->ps_reject_cause_relayed && NAS_NIL == *tmr_id )
        {
          must_clear            = TRUE;
          must_schedule_refresh = TRUE;
        }
        break;

      default: // nothing
        break;
    }
  }

  if ( must_schedule_refresh )
  {
    passover = (qmi_ril_reg_reject_tmr_expry_passover_type *) qcril_malloc( sizeof( *passover ) );
    if ( NULL != passover )
    {
      passover->rte_kind = rte_kind;
      passover->rte      = rte;

      qcril_setup_timed_callback_ex_params_adv(
                                    QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qmi_ril_nwr_reg_reject_post_refresher,
                                    (void*)passover,
                                    TRUE,
                                    NULL,   // immediate
                                    NULL );
    }
  }

  if ( must_clear )
  {
    switch ( rte_kind )
    {
      case QMI_RIL_RTE_KIND_VOICE:
        summary->cs_rejected             = FALSE;
        summary->cs_reject_cause_relayed = FALSE;
        summary->cs_reject_cause         = NAS_NIL;
        memset( summary->org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
        memset( summary->org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
        break;

      case QMI_RIL_RTE_KIND_DATA:
        summary->ps_rejected = FALSE;
        summary->ps_reject_cause_relayed = FALSE;
        summary->ps_reject_cause         = NAS_NIL;
        memset( summary->data_org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
        memset( summary->data_org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
        break;

      default: // nothing
        break;
    }
    must_clear_tmr = TRUE;
  }

  if ( must_clear_tmr )
  {
    if ( NAS_NIL != *tmr_id )
    {
      qcril_cancel_timed_callback( (void*)(intptr_t)*tmr_id );
      *tmr_id = NAS_NIL;
    }
  }

  if ( must_start_tmr )
  {
    passover = (qmi_ril_reg_reject_tmr_expry_passover_type *) qcril_malloc( sizeof( *passover ) );
    if ( NULL != passover )
    {
      passover->rte_kind = rte_kind;
      passover->rte      = rte;

      qcril_setup_timed_callback_ex_params_adv(
                                    QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qmi_ril_nwr_reg_reject_tmr_expiry,
                                    (void*)passover,
                                    TRUE,
                                    &tmr_expity_value,
                                    tmr_id );

    }
  }

  QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// qmi_ril_nwr_reg_reject_tmr_expiry
//===========================================================================
void qmi_ril_nwr_reg_reject_tmr_expiry(qcril_timed_callback_handler_params_type * handler_params)
{
    qmi_ril_reg_reject_tmr_expry_passover_type * passover;
    QCRIL_LOG_FUNC_ENTRY();

    passover = (qmi_ril_reg_reject_tmr_expry_passover_type*) handler_params->custom_param;

    if ( NULL != passover )
    {
      NAS_CACHE_LOCK();

      qmi_ril_nwr_reg_reject_handle_event_cl( passover->rte_kind, passover->rte, QMI_RIL_REG_REJECT_PERCEPTION_EVT_EXPIRED );

      NAS_CACHE_UNLOCK();
    }

    qcril_free( passover );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwr_reg_reject_tmr_expiry
//===========================================================================
// qmi_ril_nwr_reg_reject_post_refresher
//===========================================================================
void qmi_ril_nwr_reg_reject_post_refresher(qcril_timed_callback_handler_params_type * handler_params)
{
    qmi_ril_reg_reject_tmr_expry_passover_type * passover;

    QCRIL_LOG_FUNC_ENTRY();
    passover = (qmi_ril_reg_reject_tmr_expry_passover_type*) handler_params->custom_param;

    if ( NULL != passover )
    {
      NAS_CACHE_LOCK();

      switch( passover->rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:        // fallthrough
        case QMI_RIL_RTE_KIND_DATA:
          qcril_qmi_nas_wave_voice_data_status();
          break;

        default: // nothing
          break;
      }

      NAS_CACHE_UNLOCK();
    }

    qcril_free( passover );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwr_reg_reject_post_refresher

//=========================================================================
//qmi_ril_nw_reg_get_status_overview
//===========================================================================
uint32_t qmi_ril_nw_reg_get_status_overview( void )
{
    uint32_t res = NAS_NIL;
    int rte_reg_status[ QMI_RIL_RTE_CAP ];
    int idx_rte;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
    NAS_CACHE_LOCK();
    qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO( ".. 5G reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_NR5G ] );
    QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

    for ( idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST ; idx_rte++)
    {
        switch ( rte_reg_status[ idx_rte ] )
        {
            case RIL_VAL_REG_REGISTERED_HOME_NET:
            case RIL_VAL_REG_REGISTERED_ROAMING:
                res |= QMI_RIL_NW_REG_FULL_SERVICE;
                switch ( idx_rte )
                {
                    case QMI_RIL_RTE_GSM:
                    case QMI_RIL_RTE_WCDMA:
                    case QMI_RIL_RTE_TDSCDMA:
                        res |= QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE;
                        break;

                    case QMI_RIL_RTE_SUB_LTE:
                    case QMI_RIL_RTE_SUB_NR5G: //fall through
                        res |= QMI_RIL_NW_REG_VOIP_CALLS_AVAILABLE;
                        break;

                    default:
                        // nothing
                        break;
                }
                break;

            case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
            case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                res |= QMI_RIL_NW_REG_LIMITED_SERVICE | QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE;
                break;

            default:
                // nothing
                break;
        }
        if ( RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ idx_rte ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ idx_rte ] )
        {
            res = TRUE;
        }
    }

    if ( NAS_NIL == res )
    { // voice calls available by default
        res |= QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);
    return res;
}

//=========================================================================
//qmi_ril_nw_reg_get_current_rte_of_kind
//===========================================================================
qmi_ril_nw_reg_rte_type qmi_ril_nw_reg_get_current_rte_of_kind( qmi_ril_nw_reg_rte_kind_type rte_kind )
{
    qmi_ril_nw_reg_rte_type res;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    switch ( rte_kind )
    {
        case QMI_RIL_RTE_KIND_VOICE:
            res = nas_cached_info.voice_rte;
            break;

        case QMI_RIL_RTE_KIND_DATA:
            res = nas_cached_info.data_rte;
            break;

        case QMI_RIL_RTE_KIND_IMS:
            res = nas_cached_info.ims_rte;
            break;

        default:
            res = QMI_RIL_RTE_NONE;
            break;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);
    return res;
} // qmi_ril_nw_reg_get_current_rte_of_kind

//=========================================================================
//qcril_qmi_nas_is_voip_enabled
//===========================================================================
uint8 qcril_qmi_nas_is_voip_enabled()
{
    int res;
    int is_voip_enabled_len;
    unsigned long ret_val;
    char property_name[ PROPERTY_NAME_MAX ];
    char args[ PROPERTY_VALUE_MAX ];
    char *end_ptr;

    QCRIL_LOG_FUNC_ENTRY();

    res = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_IS_VOIP_ENABLED );
    property_get( property_name, args, "" );
    is_voip_enabled_len = strlen( args );
    if ( is_voip_enabled_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert QCRIL_VOIP_ENABLED %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved QCRIL_IS_VOIP_ENABLED %ld, use default", ret_val );
      }
      else
      {
        res = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);

    return res;
} //qcril_qmi_nas_is_voip_enabled

//=========================================================================
//qmi_ril_nw_reg_snapshot_init
//===========================================================================
void qmi_ril_nw_reg_snapshot_init( qmi_ril_nw_reg_rte_snapshot_type* snapshot )
{
    if ( snapshot )
    {
        memset( snapshot, 0, sizeof(*snapshot ) );
    }
} // qmi_ril_nw_reg_snapshot_init

//=========================================================================
//qmi_ril_nw_reg_snapshot_cur_rte
//===========================================================================
void qmi_ril_nw_reg_snapshot_cur_rte( qmi_ril_nw_reg_rte_snapshot_type* snapshot )
{
    if ( snapshot )
    {
        NAS_CACHE_LOCK();
        snapshot->voice_rte     = nas_cached_info.voice_rte;
        snapshot->data_rte      = nas_cached_info.data_rte;
        snapshot->ims_rte       = nas_cached_info.ims_rte;
        snapshot->voice_rte_confidence_tag  = nas_cached_info.voice_rte_confidence_tag;
        snapshot->data_rte_confidence_tag   = nas_cached_info.data_rte_confidence_tag;
        snapshot->ims_rte_confidence_tag    = nas_cached_info.ims_rte_confidence_tag;
        NAS_CACHE_UNLOCK();
    }
} // qmi_ril_nw_reg_snapshot_cur_rte

//=========================================================================
//qmi_ril_nw_reg_snapshot_is_same_as
//===========================================================================
int qmi_ril_nw_reg_snapshot_is_same_as( qmi_ril_nw_reg_rte_snapshot_type* snapshot1, qmi_ril_nw_reg_rte_snapshot_type* snapshot2 )
{
    int res = FALSE;

    if ( NULL != snapshot1 && NULL != snapshot2 )
    {
        res = ( snapshot1->voice_rte                == snapshot2->voice_rte ) &&
              ( snapshot1->data_rte                 == snapshot2->data_rte ) &&
              ( snapshot1->ims_rte                  == snapshot2->ims_rte ) &&
              ( snapshot1->voice_rte_confidence_tag == snapshot2->voice_rte_confidence_tag ) &&
              ( snapshot1->data_rte_confidence_tag  == snapshot2->data_rte_confidence_tag ) &&
              ( snapshot1->ims_rte_confidence_tag   == snapshot2->ims_rte_confidence_tag );
    }

    return res;
} // qmi_ril_nw_reg_snapshot_is_same_as

//=========================================================================
//qmi_ril_nw_reg_snapshot_dump_log
//===========================================================================
void qmi_ril_nw_reg_snapshot_dump_log( qmi_ril_nw_reg_rte_snapshot_type* snapshot )
{
    if ( snapshot )
    {
        QCRIL_LOG_INFO( "in snapshot voice_rte %d, data_rte %d, ims_rte %d", snapshot->voice_rte, snapshot->data_rte, snapshot->ims_rte );
    }
} // qmi_ril_nw_reg_snapshot_dump_log
//qcril_qmi_nas_set_registered_on_ims
//===========================================================================
void qcril_qmi_nas_set_registered_on_ims( int registered )
{
    qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
    qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
    int                              any_rte_change;

    QCRIL_LOG_INFO( "registered: %d", registered );

    if( TRUE == qcril_qmi_nas_is_voip_enabled() )
    {
        qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
        qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );


        NAS_CACHE_LOCK();
        nas_cached_info.is_registered_on_ims = registered;
        qcril_qmi_nas_update_ims_rte();
        NAS_CACHE_UNLOCK();
        qcril_qmi_voice_technology_updated();
        qcril_qmi_nas_initiate_radio_state_changed_ind();

        qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
        qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
        qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
        any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
        QCRIL_LOG_INFO( "any rte change from ims %d", any_rte_change);

        if ( any_rte_change )
        {
            qcril_qmi_nas_initiate_voice_rte_change_propagation();
        }
        qcril_qmi_nas_wave_voice_data_status();
    }
}

//===========================================================================
//qmi_ril_nwreg_mode_pref_is_pending_deferred_enforcement_ncl
//===========================================================================
int qmi_ril_nwreg_mode_pref_is_pending_deferred_enforcement_ncl ( int * android_mode_pref )
{
    int res;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( nas_cached_info.deferred_mode_pref_set_valid )
    {
        res = TRUE;
        if ( NULL != android_mode_pref )
        {
            *android_mode_pref = nas_cached_info.deferred_mode_pref_set_android_param;
        }
    }
    else
    {
        res = FALSE;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );
    return res;
} // qmi_ril_nwreg_mode_pref_is_pending_deferred_enforcement_ncl

//===========================================================================
//qmi_ril_nwreg_mode_pref_enforcement_deferred_ncl
//===========================================================================
int qmi_ril_nwreg_mode_pref_enforcement_deferred_ncl( int android_mode_pref )
{
    int res;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) && DMS_OP_MODE_ONLINE_V01 != nas_dms_cached_info.operating_mode && nas_common_info.dfr_mode_pref_set_until_online )
    { // not online
        nas_cached_info.deferred_mode_pref_set_valid         = TRUE;
        nas_cached_info.deferred_mode_pref_set_android_param = android_mode_pref;
        res = TRUE;
    }
    else
    { // online
        res = FALSE;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );
    return res;
} // qmi_ril_nwreg_mode_pref_enforcement_deferred_ncl

//===========================================================================
// QCRIL_EVT_QMI_RIL_ENFORCE_DEFERRED_MODE_PREF_SET
//===========================================================================
void qmi_ril_nwreg_mode_pref_enforce_deferred_op_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  int is_valid;
  int deferred_param;
  uint8 mode_pref_changed = FALSE;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );
  QCRIL_NOTUSED(params_ptr);

  NAS_CACHE_LOCK();
  is_valid       = nas_cached_info.deferred_mode_pref_set_valid;
  deferred_param = nas_cached_info.deferred_mode_pref_set_android_param;
  nas_cached_info.deferred_mode_pref_set_valid         = FALSE;
  nas_cached_info.deferred_mode_pref_set_android_param = NAS_NIL;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO( "valid %d, deferred param %d", (int)is_valid, (int)deferred_param );
  if ( is_valid )
  {
      if (qmi_ril_nwreg_request_mode_pref(deferred_param, &mode_pref_changed) == RIL_E_SUCCESS
              && (mode_pref_changed == TRUE || !nas_common_info.last_android_mode_pref_valid))
      {
          qcril_qmi_nas_save_android_mode_pref(deferred_param);
      }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwreg_mode_pref_enforce_deferred_op_handler

//===========================================================================
// qmi_ril_nwreg_common_ind_subscribe_consider_action_handler
//===========================================================================
void qmi_ril_nwreg_common_ind_subscribe_consider_action_handler()
{
  QCRIL_LOG_FUNC_ENTRY();

  qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search();

  qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl();
  qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl();

  qmi_ril_nwreg_enforce_voice_ind_as_applicable_ncl();

#ifndef QMI_RIL_UTF
  /* Send the screen state to qcril_data for further processing */
  std::shared_ptr<rildata::ProcessScreenStateChangeMessage> msg =
      std::make_shared<rildata::ProcessScreenStateChangeMessage>(
#if (QCRIL_RIL_VERSION < 15)
      !nas_common_info.is_screen_off
#else
      nas_common_info.unsol_response_filter.data_call_dormancy_notification_enabled
#endif
  );
  if(msg)
  {
    msg->dispatch();
  }
#endif
  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwreg_common_ind_subscribe_consider_action_handler

//===========================================================================
// QCRIL_EVT_QMI_RIL_POST_OPRT_ONLINE_ACTION
//===========================================================================
void qmi_ril_nwreg_post_oprt_online_action_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  int                                                   is_currently_online;
  nas_get_system_selection_preference_resp_msg_v01      get_system_sel_pref_resp;
  nas_set_system_selection_preference_req_msg_v01       set_system_sel_pref_req;
  nas_set_system_selection_preference_resp_msg_v01      set_system_sel_pref_resp;
  RIL_Errno                                             ril_err;
  qmi_client_error_type                                  qmi_error = QMI_ERR_NONE_V01;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);
  QCRIL_NOTUSED(params_ptr);

  if ( qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) && qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ) )
  {
    is_currently_online = FALSE;
    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
    }
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. currently online %d", is_currently_online );

    if ( is_currently_online )
    {
        do
        {
            qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                   NULL,           // empty req payload
                                                   NAS_NIL,
                                                   &get_system_sel_pref_resp,
                                                   sizeof( get_system_sel_pref_resp ),
                                                   ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
            ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error,
                &get_system_sel_pref_resp.resp);
            if ( RIL_E_SUCCESS != ril_err )
                break;

            QCRIL_LOG_INFO( ".. cur restriction %d/%d", (int) get_system_sel_pref_resp.srv_reg_restriction_valid, (int) get_system_sel_pref_resp.srv_reg_restriction );

            // provision unrestricted
            memset( &set_system_sel_pref_req, 0, sizeof( set_system_sel_pref_req ) );
            set_system_sel_pref_req.srv_reg_restriction_valid = TRUE;
            set_system_sel_pref_req.srv_reg_restriction       = NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;

            set_system_sel_pref_req.srv_domain_pref_valid = TRUE;
            set_system_sel_pref_req.srv_domain_pref       = QMI_SRV_DOMAIN_PREF_CS_PS_V01;

            qmi_error = qmi_client_nas_send_sync(QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                   &set_system_sel_pref_req,
                                                   sizeof( set_system_sel_pref_req ),
                                                   &set_system_sel_pref_resp,
                                                   sizeof( set_system_sel_pref_resp ),
                                                   ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
            ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error,
                &set_system_sel_pref_resp.resp);
            QCRIL_LOG_INFO( ".. completion %d", (int) ril_err );

        } while (FALSE);
    }

  }

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwreg_post_oprt_online_action_handler

// qcril_qmi_nas_get_mode_pref
//===========================================================================
uint8_t qcril_qmi_nas_get_mode_pref(uint16_t *mode_pref)
{
    uint8_t ret = FALSE;

    if ( NULL != mode_pref )
    {
        NAS_CACHE_LOCK();
        if ( nas_cached_info.prev_mode_pref_valid )
        {
            *mode_pref = nas_cached_info.prev_mode_pref;
            ret = TRUE;
        }
        else if ( nas_cached_info.mode_pref_valid )
        {
            *mode_pref = nas_cached_info.mode_pref;
            ret = TRUE;
        }
        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_mode_pref

//===========================================================================
// qmi_ril_nas_cache_deferred_acq_order
//===========================================================================
void qmi_ril_nas_cache_deferred_acq_order
(
    uint32_t acq_order_len,
    qcril_qmi_acq_order_e_type acq_order_map,
    nas_radio_if_enum_v01 *acq_order
)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( acq_order_len > 0 && acq_order_len < NAS_ACQ_ORDER_LIST_MAX_V01 )
    {
        nas_cached_info.deferred_acq_order_valid = TRUE;
        nas_cached_info.deferred_acq_order_len = acq_order_len;
        nas_cached_info.deferred_acq_order_map = acq_order_map;
        memcpy( nas_cached_info.deferred_acq_order, acq_order, acq_order_len*sizeof(nas_radio_if_enum_v01) );
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nas_cache_deferred_acq_order

//===========================================================================
// qmi_ril_nas_get_deferred_acq_order
//===========================================================================
uint8_t qmi_ril_nas_get_deferred_acq_order( uint32_t *acq_order_len, nas_radio_if_enum_v01 *acq_order )
{
    uint8_t ret = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    if ( NULL != acq_order_len && NULL != acq_order )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.deferred_acq_order_valid;
        *acq_order_len = nas_cached_info.deferred_acq_order_len;

        if ( ret && (*acq_order_len) > 0 && (*acq_order_len) < NAS_ACQ_ORDER_LIST_MAX_V01 )
        {
            memcpy( acq_order, nas_cached_info.deferred_acq_order,
                            (*acq_order_len) * sizeof(nas_radio_if_enum_v01) );
        }

        nas_cached_info.deferred_acq_order_valid = FALSE;
        nas_cached_info.deferred_acq_order_len = 0;
        nas_cached_info.deferred_acq_order_map = QCRIL_QMI_ACQ_ORDER_NONE;
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret;
} // qmi_ril_nas_get_deferred_acq_order

//===========================================================================
// qmi_ril_nas_get_deferred_acq_order_map
//===========================================================================
uint8_t qmi_ril_nas_get_deferred_acq_order_map( qcril_qmi_acq_order_e_type *acq_order_map )
{
    uint8_t ret = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    if ( NULL != acq_order_map )
    {
        NAS_CACHE_LOCK();
        if ( nas_cached_info.deferred_acq_order_len > 0 &&
             nas_cached_info.deferred_acq_order_len < NAS_ACQ_ORDER_LIST_MAX_V01 )
        {
            *acq_order_map = nas_cached_info.deferred_acq_order_map;
            ret = nas_cached_info.deferred_acq_order_valid;
        }
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret;

} // qmi_ril_nas_get_deferred_acq_order_map

//===========================================================================
// qcril_qmi_nas_get_acq_order
//===========================================================================
uint8_t qcril_qmi_nas_get_acq_order(uint32_t *acq_order_len, nas_radio_if_enum_v01 *acq_order)
{
    uint8_t ret = FALSE;

    if ( NULL != acq_order_len && NULL != acq_order )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.acq_order_valid;
        *acq_order_len = nas_cached_info.acq_order_len;

        if ( ret && (*acq_order_len) > 0 && (*acq_order_len) < NAS_ACQ_ORDER_LIST_MAX_V01 )
        {
            memcpy( acq_order, nas_cached_info.acq_order->arr,
                            NAS_ACQ_ORDER_LIST_MAX_V01*sizeof(nas_radio_if_enum_v01) );
        }

        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_acq_order

//===========================================================================
// qcril_qmi_nas_get_band_pref_map
//===========================================================================
uint8_t qcril_qmi_nas_get_band_pref_map
(
    qcril_qmi_rat_band_e_type band_type,
    qcril_qmi_band_pref_e_type *band_pref_map
)
{
    uint8_t ret = FALSE;

    if ( band_pref_map != NULL)
    {
        if ( band_type == QCRIL_QMI_LTE_BAND )
        {
            NAS_CACHE_LOCK();
            ret = nas_cached_info.deferred_lte_band_pref_valid;
            *band_pref_map = nas_cached_info.deferred_lte_band_pref_map;
            NAS_CACHE_UNLOCK();
        }
    }

    return ret;
} // qcril_qmi_nas_get_band_pref_map

//===========================================================================
// qcril_qmi_nas_get_band_pref
//===========================================================================
uint8_t qcril_qmi_nas_get_band_pref
(
    qcril_qmi_rat_band_e_type band_type,
    uint64_t *band_pref
)
{
    uint8_t ret = FALSE;

    if ( band_pref != NULL)
    {
        if ( band_type == QCRIL_QMI_LTE_BAND )
        {
            NAS_CACHE_LOCK();
            ret = nas_cached_info.deferred_lte_band_pref_valid;
            *band_pref = nas_cached_info.deferred_lte_band_pref;

            // clear, just one shot
            nas_cached_info.deferred_lte_band_pref_valid = FALSE;
            nas_cached_info.deferred_lte_band_pref_map = QCRIL_QMI_BAND_PREF_NONE;
            nas_cached_info.deferred_lte_band_pref = 0;
            NAS_CACHE_UNLOCK();
        }
    }

    return ret;
} // qcril_qmi_nas_get_band_pref

//===========================================================================
// qmi_ril_nas_cache_deferred_band_pref
//===========================================================================
uint8_t qmi_ril_nas_cache_deferred_band_pref
(
    qcril_qmi_rat_band_e_type band_type,
    qcril_qmi_band_pref_e_type band_pref_map
)
{
    uint8_t ret = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    if (band_type == QCRIL_QMI_LTE_BAND) {
        NAS_CACHE_LOCK();
        if ( nas_common_info.permanent_lte_band_pref_valid )
        {
            ret = TRUE;
            switch ( band_pref_map )
            {
                case QCRIL_QMI_BAND_PREF_LTE_FULL:
                    nas_cached_info.deferred_lte_band_pref =
                        nas_common_info.permanent_lte_band_pref;
                    nas_cached_info.deferred_lte_band_pref_valid = TRUE;
                    nas_cached_info.deferred_lte_band_pref_map = band_pref_map;
                    break;
                case QCRIL_QMI_BAND_PREF_TDD_LTE:
                    // clear bit0 ~ bit31
                    nas_cached_info.deferred_lte_band_pref =
                        nas_common_info.permanent_lte_band_pref & NAS_VAL_TDD_LTE_BAND_MASK;
                    nas_cached_info.deferred_lte_band_pref_map = band_pref_map;
                    nas_cached_info.deferred_lte_band_pref_valid = TRUE;
                    break;
                case QCRIL_QMI_BAND_PREF_FDD_LTE:
                    // clear bit32 ~ bit63
                    nas_cached_info.deferred_lte_band_pref =
                        nas_common_info.permanent_lte_band_pref & NAS_VAL_FDD_LTE_BAND_MASK;
                    nas_cached_info.deferred_lte_band_pref_map = band_pref_map;
                    nas_cached_info.deferred_lte_band_pref_valid = TRUE;
                    break;
                default:
                    ret = FALSE;
                    break;
            }
        }
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret;
} // qmi_ril_nas_cache_deferred_band_pref

//===========================================================================
// qcril_qmi_nas_get_gw_acq_order_pref
//===========================================================================
uint8_t qcril_qmi_nas_get_gw_acq_order_pref (uint16_t *gw_acq_order_pref)
{
    uint8_t ret = FALSE;

    if ( NULL != gw_acq_order_pref )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.gw_acq_order_pref_valid;
        *gw_acq_order_pref = nas_cached_info.gw_acq_order_pref;
        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_gw_acq_order_pref

//===========================================================================
// qcril_qmi_nas_get_lte_disable_cause
//===========================================================================
uint8_t qcril_qmi_nas_get_lte_disable_cause(nas_lte_disable_cause_enum_type_v01 *lte_disable_cause)
{
    uint8_t ret = FALSE;

    if ( NULL != lte_disable_cause )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.lte_disable_cause_valid;
        *lte_disable_cause = nas_cached_info.lte_disable_cause;
        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_lte_disable_cause

//===========================================================================
// qcril_qmi_nas_get_rat_disabled_mask
//===========================================================================
uint8_t qcril_qmi_nas_get_rat_disabled_mask
(
    mode_pref_mask_type_v01 *rat_disabled_mask
)
{
    uint8_t ret = FALSE;

    if (NULL != rat_disabled_mask)
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.rat_disabled_mask_valid;
        *rat_disabled_mask = nas_cached_info.rat_disabled_mask;
        NAS_CACHE_UNLOCK();

        if (!ret)
        {
            *rat_disabled_mask = 0;
        }
    }

    return ret;
} // qcril_qmi_nas_get_rat_disabled_mask

//===========================================================================
//qcril_qmi_nas_process_custom_emergency_numbers
//
// function to process properties having prefix
// persist.vendor.radio.ecc_hard values and
// store them for further use
//===========================================================================
void qcril_qmi_nas_process_custom_emergency_numbers()
{
    QCRIL_LOG_FUNC_ENTRY();

    //preparing the hardcoded_emergency_numbers_list from persist.vendor.radio.ecc_hard value
    //format of the input - "<NUM_1>,<NUM_2>,<NUM_3>,<NUM_4>,<NUM_5>,<NUM_6>,<NUM_7>,<..>,<more numbers>"
    nas_common_info.custom_hardcoded_emergency_numbers_list =
             (char *) qcril_qmi_nas_process_custom_emergency_numbers_helper(
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD, NULL);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_process_custom_emergency_numbers

//===========================================================================
//qcril_qmi_nas_retrieve_number_of_tuples
//
// function to retrieve number of tuples present in a list
// returns number of tuples present in passed emergency_list
//===========================================================================
int qcril_qmi_nas_retrieve_number_of_tuples(char *emergency_list)
{
    int num_of_tuples;
    char *tuple_start_ptr;
    char *tuple_end_ptr;
    char *tuple_iter_ptr;


    QCRIL_LOG_FUNC_ENTRY();

    num_of_tuples = 0;
    tuple_iter_ptr = emergency_list;
    do
    {
        tuple_start_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_START_DELIMITER); //to find the start of a tuple
        tuple_end_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_END_DELIMITER); //to find the end of a tuple
        if( tuple_start_ptr && tuple_end_ptr )
        {
            tuple_iter_ptr = tuple_end_ptr + sizeof(char);
            num_of_tuples++;
        }
    }while( tuple_start_ptr && tuple_end_ptr );

    QCRIL_LOG_FUNC_RETURN_WITH_RET(num_of_tuples);
    return num_of_tuples;
} //qcril_qmi_nas_retrieve_number_of_tuples

//===========================================================================
// qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value
//
// helper function to retrieve the values configured through properties
// having prefixes of one of the following
// persist.vendor.radio.custom_ecc_hard_ returns the concatenated list of values of
// all properties configured using a specific property_prefix
//===========================================================================
char* qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value
(
    char *property_prefix,
    char *fallback_property_prefix
)
{
    char *configured_value_ptr;
    int iter_i;
    int err;
    int properties_count;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int temp_len;
    int temp_properties_value_length;
    char **temp_properties_value_table;
    char *property_prefix_tmp = property_prefix;

    QCRIL_LOG_FUNC_ENTRY();

    err = FALSE;
    properties_count = 0;
    temp_properties_value_length = 0;
    configured_value_ptr = NULL;
    int ret;

    if (property_prefix_tmp)
    {
        snprintf( property_name, sizeof( property_name ),
                  "%s%s", property_prefix_tmp,
                  QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_COUNT_PROPERTY_SUFFFIX );

        ret = (IxErrnoType)property_get( property_name, property_value, "" );
        if ((ret <= 0) && fallback_property_prefix)
        {
            QCRIL_LOG_DEBUG("check fallback property");
            snprintf( property_name, sizeof( property_name ), "%s%s",
                      fallback_property_prefix,
                      QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_COUNT_PROPERTY_SUFFFIX );
            property_get( property_name, property_value, "" );
            property_prefix_tmp = fallback_property_prefix;
        }

        temp_len = strlen( property_value );
        if ( temp_len > 0 )
        {
            properties_count = strtoul( property_value, NULL, 0 );
        }

        QCRIL_LOG_DEBUG( "property_name %s, properties_count %d", property_name, properties_count);

        if( properties_count > NAS_NIL && properties_count <= QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_MAX_COUNT)
        {
            temp_properties_value_table = (char **) qcril_malloc(sizeof(char*) * properties_count);
            if( temp_properties_value_table )
            {
                for( iter_i = 1; iter_i <= properties_count; iter_i++ )
                {
                    memset(property_value, 0, sizeof(property_value));
                    snprintf( property_name, sizeof(property_name), "%s%d", property_prefix_tmp, iter_i);
                    property_get( property_name, property_value, "" );
                    temp_len = strlen( property_value );
                    if ( temp_len > 0 )
                    {
                      QCRIL_LOG_DEBUG( "property_name %s, property_value %s", property_name, property_value);
                      temp_properties_value_table[iter_i-1] = (char*) qcril_malloc(sizeof(char) * (temp_len+1));
                      if( temp_properties_value_table[iter_i-1] )
                      {
                          memcpy(temp_properties_value_table[iter_i-1], property_value, temp_len);
                          temp_properties_value_length += temp_len;
                      }
                      else
                      {
                          QCRIL_LOG_FATAL("Fail to allocate memory for a row in temp_properties_value_table");
                          err = TRUE;
                          break;
                      }
                    }
                    else
                    {
                        err = TRUE;
                        break;
                    }
                }

                if( FALSE == err )
                {
                    temp_properties_value_length += properties_count;
                    QCRIL_LOG_INFO("configured_value's length %d", temp_properties_value_length);
                    configured_value_ptr = (char*) qcril_malloc(sizeof(char) * temp_properties_value_length);
                    if( configured_value_ptr )
                    {
                        strlcpy(configured_value_ptr, temp_properties_value_table[NAS_NIL], temp_properties_value_length);
                        for( iter_i = 1; iter_i < properties_count; iter_i++ )
                        {
                            strlcat(configured_value_ptr, QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_PROPERTIES_DELIMITER, temp_properties_value_length);
                            strlcat(configured_value_ptr, temp_properties_value_table[iter_i], temp_properties_value_length);
                        }
                        QCRIL_LOG_ESSENTIAL("configured_value %s", configured_value_ptr);
                    }
                    else
                    {
                        QCRIL_LOG_FATAL("Fail to allocate memory for configured_value_ptr");
                    }
                }

                for( iter_i = 1; iter_i <= properties_count; iter_i++ )
                {
                    if( temp_properties_value_table[iter_i-1] )
                    {
                        qcril_free(temp_properties_value_table[iter_i-1]);
                    }
                    else
                    {
                        break;
                    }
                }
                qcril_free(temp_properties_value_table);
            }
            else
            {
                QCRIL_LOG_FATAL("Fail to allocate memory for temp_properties_value_table");
            }
        }
        else
        {
            QCRIL_LOG_FATAL("Invalid value for properties count %d", properties_count);
        }
    }
    else
    {
        QCRIL_LOG_FATAL("NULL Pointer passed");
    }



    QCRIL_LOG_FUNC_RETURN();
    return configured_value_ptr;
} //qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value

//===========================================================================
//qcril_qmi_nas_process_custom_emergency_numbers_helper
//
// helper function for qcril_qmi_nas_process_custom_emergency_numbers
// returns the pointer to table or list depending on the source
//===========================================================================
void* qcril_qmi_nas_process_custom_emergency_numbers_helper(qmi_ril_custom_emergency_numbers_source_type source, int *number_of_tuples)
{
    char **emergency_numbers_table;
    char *emergency_numbers_list;
    char *property_prefix_to_be_used;
    char *fallback_property_prefix_to_be_used;
    void *ret_ptr;
    int is_prepare_table;
    int valid_case;
    int temp_len;
    char *tuple_start_ptr;
    char *tuple_end_ptr;
    char *tuple_iter_ptr;
    int err;
    int iter_emergency_numbers_table;
    int temp_num_of_tuples;
    char *complete_configured_value;

    QCRIL_LOG_FUNC_ENTRY();

    iter_emergency_numbers_table = 0;
    emergency_numbers_table = NULL;
    emergency_numbers_list = NULL;
    err = FALSE;
    ret_ptr = NULL;
    is_prepare_table = FALSE;
    valid_case = TRUE;

    switch( source )
    {
        case QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD:
            QCRIL_LOG_INFO("source is HARD");
            property_prefix_to_be_used = (char *)QMI_RIL_CUSTOM_HARDCODED_EMERGENCY_NUMBERS_LIST_PREFIX;
            fallback_property_prefix_to_be_used = (char *) QMI_RIL_CUSTOM_HARDCODED_EMERGENCY_NUMBERS_LIST_FALLBACK_PREFIX;
            is_prepare_table = FALSE;
            break;

        default:
            QCRIL_LOG_INFO("Invalid scenario");
            valid_case = FALSE;
            break;
    }

    if( valid_case )
    {
        complete_configured_value =
                qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value(
                                        property_prefix_to_be_used,
                                        fallback_property_prefix_to_be_used);
        if( complete_configured_value )
        {
            temp_len = strlen( complete_configured_value );
            if(temp_len > 0)
            {
                if( is_prepare_table )
                {
                    temp_num_of_tuples = qcril_qmi_nas_retrieve_number_of_tuples(complete_configured_value);
                    if( number_of_tuples )
                    {
                        *number_of_tuples = temp_num_of_tuples;
                    }

                    emergency_numbers_table = (char **) qcril_malloc(sizeof(char*) * temp_num_of_tuples);
                    if( emergency_numbers_table )
                    {
                        tuple_iter_ptr = complete_configured_value;
                        do
                        {
                            tuple_start_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_START_DELIMITER); //to find the start of a tuple
                            tuple_end_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_END_DELIMITER); //to find the end of a tuple
                            if( tuple_start_ptr && tuple_end_ptr )
                            {
                                emergency_numbers_table[iter_emergency_numbers_table] = (char*) qcril_malloc(sizeof(char) * (tuple_end_ptr-tuple_start_ptr));
                                if( emergency_numbers_table[iter_emergency_numbers_table] )
                                {
                                    memcpy(emergency_numbers_table[iter_emergency_numbers_table], (tuple_start_ptr+1), (tuple_end_ptr-tuple_start_ptr-1));

                                    tuple_iter_ptr = tuple_end_ptr + sizeof(char);
                                    iter_emergency_numbers_table++;
                                }
                                else
                                {
                                    err = TRUE;
                                    QCRIL_LOG_FATAL("Fail to allocate memory for emergency_numbers_table_row");
                                }
                            }
                        }while( tuple_start_ptr && tuple_end_ptr && !err);
                    }
                    else
                    {
                        err = TRUE;
                        QCRIL_LOG_FATAL("Fail to allocate memory for emergency_numbers_table");
                    }

                    if( !err )
                    {
                        ret_ptr = (void*) emergency_numbers_table;
                    }
                }
                else
                {
                    emergency_numbers_list = (char*) qcril_malloc(sizeof(char) * (temp_len + 1));
                    if( emergency_numbers_list )
                    {
                        memcpy(emergency_numbers_list, complete_configured_value, temp_len);
                    }
                    else
                    {
                        err = TRUE;
                        QCRIL_LOG_FATAL("Fail to allocate memory for emergency_numbers_list");
                    }

                    if( !err )
                    {
                        ret_ptr = (void*) emergency_numbers_list;
                    }
                }
            }
            qcril_free(complete_configured_value);
        }
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret_ptr;
} //qcril_qmi_nas_process_custom_emergency_numbers_helper

//===========================================================================
//qcril_qmi_nas_cleanup_custom_emergency_numbers
//
//function to cleanup the storage that was
//created in qcril_qmi_nas_process_custom_emergency_numbers()
//===========================================================================
void qcril_qmi_nas_cleanup_custom_emergency_numbers()
{
   QCRIL_LOG_FUNC_ENTRY();

   qcril_qmi_nas_cleanup_custom_emergency_numbers_helper(&nas_common_info.custom_hardcoded_emergency_numbers_list, FALSE, NULL);

   QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_cleanup_custom_emergency_numbers

//===========================================================================
//qcril_qmi_nas_cleanup_custom_emergency_numbers_helper
//
// helper function for qcril_qmi_nas_cleanup_custom_emergency_numbers
//===========================================================================
void qcril_qmi_nas_cleanup_custom_emergency_numbers_helper(void * emergency_numbers, int is_cleanup_table, int *number_of_tuples)
{
    char ***emergency_numbers_table_ptr;
    char **emergency_numbers_list_ptr;
    int iter_i;

    QCRIL_LOG_FUNC_ENTRY();

    if( emergency_numbers )
    {
        if( TRUE == is_cleanup_table )
        {
            if( number_of_tuples )
            {
                emergency_numbers_table_ptr = (char***) emergency_numbers;
                if( *emergency_numbers_table_ptr )
                {
                    for( iter_i = 0; iter_i < *number_of_tuples; iter_i++ )
                    {
                        if( (*emergency_numbers_table_ptr)[iter_i] )
                        {
                            qcril_free((*emergency_numbers_table_ptr)[iter_i]);
                            (*emergency_numbers_table_ptr)[iter_i] = NULL;
                        }
                    }
                    qcril_free(*emergency_numbers_table_ptr);
                    (*emergency_numbers_table_ptr) = NULL;
                    *number_of_tuples = NAS_NIL;
                }
            }
            else
            {
                QCRIL_LOG_FATAL("NULL Pointer passed");
            }
        }
        else
        {
            emergency_numbers_list_ptr = (char**) emergency_numbers;
            if( *emergency_numbers_list_ptr )
            {
                qcril_free(*emergency_numbers_list_ptr);
                (*emergency_numbers_list_ptr) = NULL;
            }
        }
    }
    else
    {
        QCRIL_LOG_FATAL("NULL Pointer passed");
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_cleanup_custom_emergency_numbers_helper

//===========================================================================
//qcril_qmi_nas_is_number_part_of_custom_mcc_mnc_emergency_numbers
//===========================================================================
int qcril_qmi_nas_is_number_part_of_custom_mcc_mnc_emergency_numbers
(
    char *number,
    char *mcc,
    char *mnc,
    qmi_ril_custom_emergency_numbers_source_type source
)
{
    int ret = FALSE;

    QCRIL_LOG_INFO("number %s", number);

    ret = qcril_db_is_number_mcc_part_of_emergency_numbers_table(number, TRUE, mcc, TRUE, mnc, source);

    QCRIL_LOG_ESSENTIAL("completed with %d", ret);
    return ret;
} //qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers


//===========================================================================
//qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers
//
//function to check If the passed number is part of the custom emergency numbers
// persist.vendor.radio.ecc_hard_ prefixed properties
//
//tuple_id of -1 indicates that the check is being made for HARD source
//returns TRUE If the number is part of the emergency numbers list
//of the passed source & tuple (tuple_id), FALSE otherwise
//===========================================================================
int qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers
(
    char *number,
    char *mcc,
    qmi_ril_custom_emergency_numbers_source_type source
)
{
    int ret = FALSE;

    QCRIL_LOG_INFO("number %s", number);

    if( QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD == source  )
    {
        QCRIL_LOG_ESSENTIAL("card absent scenario");
        if(  nas_common_info.custom_hardcoded_emergency_numbers_list )
        {
            ret = qcril_other_is_number_found(number,
                                  nas_common_info.custom_hardcoded_emergency_numbers_list);
        }
    }
    else
    {
        do
        {
            // check for number without any service limitation
            ret = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(number, mcc, source, "");
            if ( ret )
            {
                QCRIL_LOG_INFO("number = %s matches with source = %d with no service limitation %d", number, source, ret);
                break;
            }

            // if number not available without service limitation, check for full service,limited service
            if ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag )
            {
                ret = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(
                            number, mcc, source, "full");
                QCRIL_LOG_INFO("number = %s matches with source = %d with full service %d", number, source, ret);
            }
            else if ( QMI_RIL_RAT_CONFIDENCE_LTD_SVC == nas_cached_info.voice_rte_confidence_tag )
            {
                ret = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(
                            number, mcc, source, "limited");
                QCRIL_LOG_INFO("number = %s matches with source = %d, with limited serivce %d", number, source, ret);
            }
        }while(0);

    }

    QCRIL_LOG_ESSENTIAL("completed with %d", ret);
    return ret;
} //qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers

//===========================================================================
//qcril_qmi_nas_assess_emergency_number_list_handler - QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY
//===========================================================================
void qcril_qmi_nas_assess_emergency_number_list_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    boolean ensure_fresh_check = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(ret_ptr);

    if (params_ptr && params_ptr->data)
    {
      ensure_fresh_check = *((boolean *)params_ptr->data);
    }

    QCRIL_LOG_INFO( "custom emergency numbers enabled %d", nas_common_info.custom_emergency_numbers_enabled );

    if ( nas_common_info.custom_emergency_numbers_enabled )
    {
        QCRIL_LOG_INFO( "for nw %d", nas_common_info.custom_emergency_numbers_enabled_for_nw );
        if( nas_common_info.custom_emergency_numbers_enabled_for_nw )
        {
            qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw(ensure_fresh_check);
        }
        else
        {
            qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card(params_ptr, ensure_fresh_check);
        }
    }
    else
    {
        /* Set the property directly if custom emergency numbers is disabled
         * In this case, RIL will only append numbers recevied from PBM IND
         */
        qmi_ril_send_ecc_list_indication();
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_get_escv_type
//===========================================================================
int qcril_qmi_nas_get_escv_type
(
    char *emergency_number
)
{
    int     escv_type           = 0;
    char   *roam                = NULL;
    char   *mcc_from_iccid_ptr  = NULL;
    char   *iccid               = NULL;

    int     res;
    int     slot;
    int     i;
    char    current_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char    current_mnc_str[NAS_MCC_MNC_MAX_SIZE];

#define QCRIL_IIN_MIN_LENGTH (4)

    QCRIL_LOG_FUNC_ENTRY();


    QCRIL_LOG_INFO( "custom emergency numbers enabled %d", nas_common_info.custom_emergency_numbers_enabled );
    if ( nas_common_info.custom_emergency_numbers_enabled && emergency_number )
    {
        NAS_CACHE_LOCK();
        res = qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, FALSE, NULL);
        slot = qmi_ril_get_sim_slot();
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO( "slot %d, iccid_from_uim %s", slot, nas_common_info.card_info[slot].iccid_from_uim[0]? nas_common_info.card_info[slot].iccid_from_uim : "null" );
        if (nas_common_info.card_info[slot].iccid_len_from_uim > 0)
        {
            if (res)
            {

                mcc_from_iccid_ptr = qcril_qmi_nas2_retrieve_mcc_from_iccid(nas_common_info.card_info[slot].iccid_from_uim);
                if (mcc_from_iccid_ptr)
                {
                    QCRIL_LOG_INFO( "current mcc %s iccid mcc %s",
                                     current_mcc_str, mcc_from_iccid_ptr);
                    if (!strcmp(mcc_from_iccid_ptr, current_mcc_str))
                    {
                        roam = (char *) "home";
                    }
                    else
                    {
                        roam = (char *) "roam";
                    }
                }
            }
            else
            {
                roam = (char *) "roam";
            }

            iccid = (char *) malloc(nas_common_info.card_info[slot].iccid_len_from_uim + 1);

            if(iccid!=NULL)
            {
              strlcpy(iccid, nas_common_info.card_info[slot].iccid_from_uim,
                             nas_common_info.card_info[slot].iccid_len_from_uim + 1);
              escv_type = -1;
              for (i = nas_common_info.card_info[slot].iccid_len_from_uim;
                   (i > QCRIL_IIN_MIN_LENGTH) && (escv_type == -1);
                   i--)
              {
                  iccid[i] = '\0';
                  escv_type = qcril_db_query_escv_type(emergency_number,
                                                       iccid,
                                                       NULL,
                                                       NULL,
                                                       roam);
              }

              /* escv_type is -1 when there is no match from the db */
              if (escv_type == -1)
              {
                  escv_type = 0;
              }

              qcril_free(iccid);
            }
            else
            {
              QCRIL_LOG_ERROR("Malloc failed for iccid");
            }
        }
        else if (res)
        {
            escv_type = qcril_db_query_escv_type(emergency_number,
                                     NULL,
                                     current_mcc_str,
                                     current_mnc_str,
                                     NULL);
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(escv_type);
    return escv_type;
}

//===========================================================================
//qcril_check_mcc_part_of_emergency_numbers_table_with_service_state
//===========================================================================
int qcril_check_mcc_part_of_emergency_numbers_table_with_service_state
(
    qmi_ril_custom_emergency_numbers_source_type source,
    int  is_mcc_valid,
    char *mcc,
    int  is_mnc_valid,
    char *mnc,
    char *emergency_nums
)
{
    int         ret_val = FALSE;

    NAS_CACHE_LOCK();

    do
    {
        // case 1: check the no service limitation case
        ret_val = qcril_db_is_mcc_part_of_emergency_numbers_table(
                    source, is_mcc_valid, mcc, is_mnc_valid, mnc, emergency_nums);
        QCRIL_LOG_INFO("source = %d, is matched with no service limit %d", source, ret_val);
        if ( ret_val )
        {
            break;
        }
        // none-APM case 2: check the full service case
        if ( ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag ) ||
             ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag ) )
        {
            ret_val = qcril_db_is_mcc_part_of_emergency_numbers_table_with_service_state(
                        source, is_mcc_valid, mcc, is_mnc_valid, mnc, "full", emergency_nums);
            QCRIL_LOG_INFO("source = %d, is matched with full service %d", source, ret_val);
        }
        // none-APM case 3: check the limit service case
        else if ( QMI_RIL_RAT_CONFIDENCE_LTD_SVC == nas_cached_info.voice_rte_confidence_tag )
        {
            ret_val = qcril_db_is_mcc_part_of_emergency_numbers_table_with_service_state(
                    source, is_mcc_valid, mcc, is_mnc_valid, mnc, "limited", emergency_nums);
            QCRIL_LOG_INFO("source = %d, is matched with limited serivce %d", source, ret_val);
        }
    } while (0);

    NAS_CACHE_UNLOCK();

    return ret_val;
}


//===========================================================================
//qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw
//===========================================================================
void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw(boolean ensure_fresh_check)
{
    int need_update_cur_status;
    uint32 cur_status;

    QCRIL_LOG_FUNC_ENTRY();

    need_update_cur_status = FALSE;
    char emergency_nums[200] = {0};
    int     res = FALSE;
    qcril::interfaces::RIL_EccMapType ecc_map;


    NAS_CACHE_LOCK();

    cur_status = nas_cached_info.designated_number_added_for_designated_country_status;
    if (ensure_fresh_check)
    {
        cur_status &= ~(
            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED |
            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED |
            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED);
    }

    QCRIL_LOG_ESSENTIAL( "cur_status %d", (int) cur_status);

    if ( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED )
    {
        res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW,
                        TRUE,
                        nas_cached_info.mcc_from_device_reg,
                        FALSE,
                        NULL,
                        emergency_nums);
        if( res )
        {
            cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH);
            strlcpy(nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                    nas_cached_info.mcc_from_device_reg,
                    NAS_MCC_MNC_MAX_V01 + 1);
        }
    }

    if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED ) )
    {
        if( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
        {
            res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW,
                                TRUE,
                                nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                FALSE,
                                NULL,
                                emergency_nums);
            if(res)
            {
                cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED;
                need_update_cur_status = TRUE;
                qmi_ril_fill_ecc_map(emergency_nums,
                    ecc_map,
                    RIL_EccNumberSourceMask::MODEM_CONFIG,
                    nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                    nullptr);
            }
        }
    }

    if ( need_update_cur_status )
    {
        nas_cached_info.designated_number_added_for_designated_country_status = cur_status;
        nas_cached_info.ril_ecc_map = ecc_map;
    }

    QCRIL_LOG_ESSENTIAL( "cur_status after evaluating nw numbers %d", (int) cur_status);

    NAS_CACHE_UNLOCK();

    qmi_ril_send_ecc_list_indication();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw


int qcril_qmi_nas_fetch_imsi_from_cache_or_iccid(uint32 *cur_status)
{
    uint32_t                            slot = 0;
    std::shared_ptr<string>             iccid_str = NULL;
    char                                home_mcc_for_consideration[ NAS_MCC_MNC_MAX_V01 + 1 ];
    char                                *mcc_from_iccid_ptr = NULL;
    char                                is_mcc_from_imsi_cache_valid = FALSE;
    int                                 process_ecc_now = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    slot = qmi_ril_get_sim_slot();

    NAS_CACHE_LOCK();
    is_mcc_from_imsi_cache_valid = *nas_cached_info.mcc_from_imsi_cache;
    NAS_CACHE_UNLOCK();

    if ( is_mcc_from_imsi_cache_valid ) // cache from GET_IMSI available
    {
        NAS_CACHE_LOCK();
        memset( &home_mcc_for_consideration, 0, sizeof( home_mcc_for_consideration ));
        memcpy( &home_mcc_for_consideration, nas_cached_info.mcc_from_imsi_cache, NAS_MCC_MNC_MAX_V01 );
        strlcpy(nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                home_mcc_for_consideration,
                NAS_MCC_MNC_MAX_V01 + 1);

        QCRIL_LOG_DEBUG( "known cached imsi %c%c%c", (char)nas_cached_info.mcc_from_imsi_cache[0],
                                                     (char)nas_cached_info.mcc_from_imsi_cache[1],
                                                     (char)nas_cached_info.mcc_from_imsi_cache[2]  );
        NAS_CACHE_UNLOCK();

        if ( cur_status )
        {
            *cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
            *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
            *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
            *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
        }
        process_ecc_now = TRUE;
    }
    else
    {
        auto iccid_msg = std::make_shared<UimGetIccIdRequestSyncMsg>(slot);

        if (iccid_msg != NULL &&
            iccid_msg->dispatchSync(iccid_str) == Message::Callback::Status::SUCCESS &&
            iccid_str != NULL )
        {
            QCRIL_LOG_DEBUG( "iccid %s", iccid_str->c_str() );

            mcc_from_iccid_ptr = qcril_qmi_nas2_retrieve_mcc_from_iccid((char *)iccid_str->c_str());
            if( NULL != mcc_from_iccid_ptr )
            {
                if ( cur_status )
                {
                    *cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
                    *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
                    *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
                    *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
                }
                process_ecc_now = TRUE;

                QCRIL_LOG_ESSENTIAL( "known mcc %s", mcc_from_iccid_ptr );

                memset( &home_mcc_for_consideration, 0, sizeof( home_mcc_for_consideration ));
                memcpy( &home_mcc_for_consideration, mcc_from_iccid_ptr, NAS_MCC_MNC_MAX_V01 );
                NAS_CACHE_LOCK();
                strlcpy(nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                        home_mcc_for_consideration,
                        NAS_MCC_MNC_MAX_V01 + 1);
                NAS_CACHE_UNLOCK();
            } // if( NULL != mcc_from_iccid_ptr )
            else
            {
                QCRIL_LOG_ESSENTIAL( "Failed to retrieve mcc from iccid" );
            }
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(process_ecc_now);
    return process_ecc_now;
}


//===========================================================================
//qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card
//===========================================================================
void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card
(
    const qcril_request_params_type *const params_ptr,
    boolean ensure_fresh_check
)
{
    RIL_Errno                           ril_err = RIL_E_GENERIC_FAILURE;
    uint32_t                            cur_status =
                                            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NONE;
    char                                card_mcc[NAS_MCC_MNC_MAX_V01 + 1];
    char                                card_mnc[NAS_MCC_MNC_MAX_V01 + 1];
    char                                emergency_nums[200] = {0};
    char                                nw_emergency_nums[200] = {0};
    dms_get_msisdn_resp_msg_v01*        get_msisdn_resp;
    int                                 process_ecc_now = TRUE;
    qcril_uim_card_status_e_type        card_status;
    int                                 need_update_cur_status = TRUE;
    uint32_t                            slot = 0;
    int                                 res        = FALSE;
    uint32_t                            user_data;
    qcril_reqlist_public_type           reqlist_entry;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( nas_common_info.custom_emergency_numbers_enabled )
    {
        cur_status = nas_cached_info.designated_number_added_for_designated_country_status;
        if (ensure_fresh_check)
        {
            cur_status &= ~(
                QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED |
                QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED |
                QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED);
        }

        slot = qmi_ril_get_sim_slot();
        card_status = nas_common_info.card_info[slot].status;

        need_update_cur_status = FALSE;

        QCRIL_LOG_ESSENTIAL( "cur_status %d, card_state %d", (int) cur_status, (int) card_status  );

        // card present, check if home PLMN fetch & match could be done
        if ( QCRIL_CARD_STATUS_UP == card_status )
        {
            memset(card_mcc, 0, sizeof(card_mcc));
            memset(card_mnc, 0, sizeof(card_mnc));

            // first check whether we can retrieve mcc, mnc info
            if ( E_SUCCESS == qcril_qmi_nas_get_sim_mcc_mnc (card_mcc, card_mnc) )
            {
                QCRIL_LOG_ESSENTIAL( "card_mcc %s, card_mnc %s", card_mcc, card_mnc);

                cur_status &= ~ ( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH |
                                  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH );

                cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_FETCHED;

                strlcpy(nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                        card_mcc,
                        NAS_MCC_MNC_MAX_V01 + 1);

                strlcpy(nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX],
                        card_mnc,
                        NAS_MCC_MNC_MAX_V01 + 1);

                // check MCC_MNC table with voice service state
                res = qcril_check_mcc_part_of_emergency_numbers_table_with_service_state(
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC_MNC,
                                TRUE,
                                nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                                TRUE,
                                nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX],
                                emergency_nums);
                if ( res )
                {
                    QCRIL_LOG_ESSENTIAL( "matched with source mcc mnc table");
                    need_update_cur_status = TRUE;
                    cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH;
                }

                // secondly, check SOURCE_VOICE_MCC_MNC table with voice service state
                res = qcril_check_mcc_part_of_emergency_numbers_table_with_service_state(
                            QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC_MNC,
                            TRUE,
                            nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                            TRUE,
                            nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX],
                            emergency_nums);
                if ( res )
                {
                    QCRIL_LOG_ESSENTIAL("matched with source voice mcc mnc table");
                    cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH;
                    need_update_cur_status = TRUE;
                }


                if ( need_update_cur_status )
                {
                    // as mcc_mnc table present, clear other flags
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
                }
                else
                {
                    // mcc_mnc table not available. Reset mcc_mnc flags
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_FETCHED;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH;
                }

            }
            else
            {
                // reset mcc_mnc_fetch, match status
                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_FETCHED;
                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH;
                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH;
            }

            // if mcc mnc fetch fails and mcc_mnc table is not present
            // and IMSI has not been fetched.
            if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH ) &&
                 !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH ) &&
                 !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED ) &&
                  (params_ptr != NULL))
            {

                qcril_reqlist_default_entry( params_ptr->t,
                                             params_ptr->event_id,
                                             params_ptr->modem_id,
                                             QCRIL_REQ_AWAITING_CALLBACK,
                                             QCRIL_EVT_NONE,
                                             NULL,
                                            &reqlist_entry );

                if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) == E_SUCCESS )
                {
                    ril_err = RIL_E_SUCCESS;
                    get_msisdn_resp = (dms_get_msisdn_resp_msg_v01 *) qcril_malloc(sizeof(dms_get_msisdn_resp_msg_v01));

                    if(get_msisdn_resp != NULL)
                    {
                        user_data = QCRIL_COMPOSE_USER_DATA(
                                               QCRIL_DEFAULT_INSTANCE_ID,
                                               QCRIL_DEFAULT_MODEM_ID,
                                               reqlist_entry.req_id);

                        ril_err = qcril_qmi_client_send_msg_async_ex(
                                QCRIL_QMI_CLIENT_DMS,
                                QMI_DMS_GET_MSISDN_REQ_V01,
                                NULL,
                                NAS_NIL,
                                get_msisdn_resp,
                                sizeof(*get_msisdn_resp),
                                (void*)(uintptr_t)user_data);
                        if (ril_err == RIL_E_SUCCESS)
                        {
                            process_ecc_now = FALSE;
                            need_update_cur_status = FALSE;
                        }
                    }
                    else
                    {
                        QCRIL_LOG_ERROR("malloc failed on get_msisdn_resp");
                        ril_err = RIL_E_GENERIC_FAILURE;
                    }

                    if (ril_err != RIL_E_SUCCESS)
                    {
                        qcril_reqlist_free(QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t);
                    }
                    QCRIL_LOG_ESSENTIAL( "imsi fetch attempt ril %d", (int)ril_err );
                }

                if( RIL_E_SUCCESS != ril_err )
                {
                    process_ecc_now = qcril_qmi_nas_fetch_imsi_from_cache_or_iccid((uint32 *)&cur_status);
                    need_update_cur_status = TRUE;
                }

            } // if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED ) ) - fetch consider

            if ( process_ecc_now )
            {
                memset(emergency_nums, 0, sizeof(emergency_nums));
                qcril_qmi_nas_add_emergency_numbers(&cur_status,
                                                    &res,
                                                    &need_update_cur_status,
                                                    emergency_nums
                                                    );
            }

        } // if ( QCRIL_CARD_STATUS_UP == card_status )
        else
        { // card absent case
            qcril::interfaces::RIL_EccMapType  ecc_map;
            if ( cur_status &
                 ( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH
                 )
               )
            {
                cur_status &= ~( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH_IDX_MASK
                              );
                need_update_cur_status = TRUE;
            }

            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED;
            if (nas_common_info.custom_hardcoded_emergency_numbers_list)
            {
                strlcpy(emergency_nums, nas_common_info.custom_hardcoded_emergency_numbers_list, QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED;
                need_update_cur_status = TRUE;

                qmi_ril_fill_ecc_map(emergency_nums,
                    ecc_map,
                    RIL_EccNumberSourceMask::DEFAULT,
                    nullptr,
                    nullptr);
            }

            if ( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED )
            {
                res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                                    QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD_MCC,
                                    TRUE,
                                    nas_cached_info.mcc_from_device_reg,
                                    FALSE,
                                    NULL,
                                    nw_emergency_nums);
                if( res )
                {
                    cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH);
                    need_update_cur_status = TRUE;
                    strlcpy(nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                            nas_cached_info.mcc_from_device_reg,
                            NAS_MCC_MNC_MAX_V01 + 1);
                }
            }

            if( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
            {
                memset(nw_emergency_nums, 0, sizeof(nw_emergency_nums));
                res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD_MCC,
                                TRUE,
                                nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                FALSE,
                                NULL,
                                nw_emergency_nums);
                if ( res )
                {
                    if (cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED)
                    {
                        strlcat(emergency_nums, ",", QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                    }
                    strlcat(emergency_nums, nw_emergency_nums, QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                    cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED;
                    need_update_cur_status = TRUE;

                    qmi_ril_fill_ecc_map(nw_emergency_nums,
                        ecc_map,
                        RIL_EccNumberSourceMask::MODEM_CONFIG,
                        nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                        nullptr);
                }
            }

            if (need_update_cur_status) {
                nas_cached_info.ril_ecc_map = std::move(ecc_map);
            }
        }

    }

    if (need_update_cur_status)
    {
        nas_cached_info.designated_number_added_for_designated_country_status = cur_status;
    }
    NAS_CACHE_UNLOCK();

    // Irrespective of any new numbers added from DB or not,
    // update ecclist to telephony. This will make sure  PBM received list is sent to telephony.
    qmi_ril_send_ecc_list_indication();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card


//===========================================================================
//qmi_ril_nwreg_is_designated_number_enforcable
//===========================================================================
int qmi_ril_nwreg_is_designated_number_enforcable_ncl(char * emergency_number)
{
    int      res = FALSE;
    int      is_pbm_num = FALSE;
    int      centralized_pbm_ecc = FALSE;

    NAS_CACHE_LOCK();

    if ( NULL != emergency_number )
    {
        is_pbm_num = qmi_ril_number_received_from_pbm(emergency_number);
        centralized_pbm_ecc = qcril_qmi_pbm_centralized_ecc_support_available();

        QCRIL_LOG_INFO("is_pbm_num - %d, centralized pbm ecc - %d", is_pbm_num, centralized_pbm_ecc);

        if (TRUE == is_pbm_num && TRUE == centralized_pbm_ecc)
        {
            /* If number is received from PBM and centralized PBM feature supported,
               do not enforce. PBM will take care of handling ecc. */
            res = FALSE;
            QCRIL_LOG_INFO("Do not enforce as number received from QMI PBM");
        }
        else if ( TRUE == nas_common_info.custom_emergency_numbers_enabled_for_nw &&
             (nas_cached_info.designated_number_added_for_designated_country_status &
              QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED) )
        {
            if( nas_cached_info.designated_number_added_for_designated_country_status &
                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
            {
                res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                        nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW);
            }
        }
        else if ( nas_cached_info.designated_number_added_for_designated_country_status &
                QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED )
        {
            if( nas_cached_info.designated_number_added_for_designated_country_status &
               QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH )
            {
                res = qcril_qmi_nas_is_number_part_of_custom_mcc_mnc_emergency_numbers(
                            emergency_number,
                            nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                            nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX],
                            QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC_MNC);
            }
            else if( nas_cached_info.designated_number_added_for_designated_country_status &
               QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH )
            {
                res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(
                            emergency_number,
                            nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                            QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC);

                // As RIL will populate NW MCC based numbers when card mcc, nw mcc differs check
                // for MCC tables with NW MCC as well.
                if (!res &&
                    (nas_cached_info.designated_number_added_for_designated_country_status &
                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED))
                {
                  res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(
                              emergency_number,
                              nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                              QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC);
                }
            }
        }
        else
        {
            if ( FALSE == nas_common_info.custom_emergency_numbers_enabled_for_nw &&
                     (nas_cached_info.designated_number_added_for_designated_country_status &
                      QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED) )
            {
                if( nas_cached_info.designated_number_added_for_designated_country_status &
                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
                {
                    res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                         nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                         QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD_MCC);
                }
            }

            if ( FALSE == res && (nas_cached_info.designated_number_added_for_designated_country_status &
                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED) )
            { // this is more "formality" for integrity checking as overwrote entire ecc list and we already matched given number against the emergeny number list
                res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                         NULL,
                                         QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD);
            }
        }
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );
    return res;
} // qmi_ril_nwreg_is_designated_number_enforcable

//===========================================================================
//qmi_ril_nwreg_convert_emergency_number_to_ims_address
//===========================================================================
int qmi_ril_nwreg_convert_emergency_number_to_ims_address(char* emergency_number)
{
    char ims_address[QCRIL_MAX_IMS_ADDRESS_LEN];
    int res;

    NAS_CACHE_LOCK();

    memset(ims_address, 0, sizeof(ims_address));
    res = FALSE;

    if ( NULL != emergency_number )
    {
        QCRIL_LOG_INFO("emergency number %s", emergency_number);
        if ( nas_cached_info.designated_number_added_for_designated_country_status &
                QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED )
        {
            if( nas_cached_info.designated_number_added_for_designated_country_status &
               QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH )
            {
                res =
                    qcril_db_is_ims_address_for_mcc_emergency_number_part_of_emergency_numbers_table
                    (
                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC,
                        TRUE,
                        nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                        FALSE,
                        NULL,
                        emergency_number,
                        ims_address
                    );

                if(res)
                {
                    strlcpy(emergency_number,
                            ims_address,
                            QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
                }
            }
        }

        if(res)
        {
            QCRIL_LOG_INFO("emergency number has been changed to %s", emergency_number);
        }
        else
        {
            QCRIL_LOG_INFO("emergency number is unchanged");
        }
    }
    NAS_CACHE_UNLOCK();

    return res;
} // qmi_ril_nwreg_convert_emergency_number_to_ims_address

//===========================================================================
//qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only
//===========================================================================
int qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only(char * emergency_number)
{
    int      res = FALSE;

    NAS_CACHE_LOCK();

    if ( NULL != emergency_number )
    {
        if ( nas_cached_info.designated_number_added_for_designated_country_status &
             QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED )
        {
            if (qmi_ril_in_apm_leave_window())
            {
                /* check if the number is in voice table */
                int in_mcc_voice_table = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(emergency_number,
                                                nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC, "full");

                // For handling card mcc, nw mcc mismatch cases
                if (!in_mcc_voice_table &&
                    (nas_cached_info.designated_number_added_for_designated_country_status &
                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED))
                {
                    in_mcc_voice_table = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(emergency_number,
                                                nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC, "full");
                }

                int in_mcc_mnc_voice_table = qcril_db_is_number_mcc_part_of_emergency_numbers_table(emergency_number,
                                                TRUE, nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                                                TRUE, nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX],
                                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC_MNC);

                res = (in_mcc_voice_table || in_mcc_mnc_voice_table);
            }
            else
            {
                if( nas_cached_info.designated_number_added_for_designated_country_status &
                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH )
                {
                    res = qcril_qmi_nas_is_number_part_of_custom_mcc_mnc_emergency_numbers(emergency_number,
                                        nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                                        nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX],
                                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC_MNC);
                }
                else if( nas_cached_info.designated_number_added_for_designated_country_status &
                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH )
                {
                    res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                        nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC);
                    if(!res &&
                       (nas_cached_info.designated_number_added_for_designated_country_status &
                       QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED))
                    {
                        res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC);
                    }
                }
            }
        }
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_ESSENTIAL( "completed with %d", res );
    return res;
} // qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only

//===========================================================================
//qmi_ril_is_designated_number_nw_mcc_roaming_emergency
//===========================================================================
int qmi_ril_is_designated_number_nw_mcc_roaming_emergency(char * emergency_number)
{
    int res = FALSE;

    NAS_CACHE_LOCK();

    if ( NULL != emergency_number )
    {
        // True if number is populated using nw mcc due to mismatch in network mcc, card mcc.
        if ( nas_cached_info.designated_number_added_for_designated_country_status &
             QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED )
        {
            if ( (nas_cached_info.designated_number_added_for_designated_country_status &
                  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED) &&
                  (nas_cached_info.designated_number_added_for_designated_country_status &
                  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH))
            {
                if( nas_cached_info.designated_number_added_for_designated_country_status &
                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
                {
                    res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                            nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                            QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW);
                }
            }
        }
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_ESSENTIAL( "completed with %d", res );
    return res;
} // qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only



//===========================================================================
//qmi_ril_nwreg_designated_number_ensure_fresh_check
//===========================================================================
void qmi_ril_nwreg_designated_number_ensure_fresh_check_ncl(void)
{
    NAS_CACHE_LOCK();
    nas_cached_info.designated_number_added_for_designated_country_status &=
       ~ (
            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED | QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED |
            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED
         );
    NAS_CACHE_UNLOCK();
} // qmi_ril_nwreg_designated_number_ensure_fresh_check

//===========================================================================
//qcril_common_update_current_imsi
//===========================================================================
static void qcril_qmi_nas_update_mccmnc_for_eval_customer_ecc
(
    char* mcc,
    char* mnc
)
{
    QCRIL_NOTUSED(mnc);

    int need_assess_emrgy_num = FALSE;
    uint32 cur_status;

    if (mcc)
    {
        NAS_CACHE_LOCK();
        if (memcmp(nas_cached_info.mcc_from_imsi_cache, mcc, NAS_MCC_MNC_MAX_V01 ))
        {
            memcpy( nas_cached_info.mcc_from_imsi_cache, mcc, sizeof(nas_cached_info.mcc_from_imsi_cache) );
            need_assess_emrgy_num = TRUE;
            cur_status = nas_cached_info.designated_number_added_for_designated_country_status;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
            nas_cached_info.designated_number_added_for_designated_country_status = cur_status;
        }
        NAS_CACHE_UNLOCK();

        if ( need_assess_emrgy_num )
        {
            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                       NULL,
                       QMI_RIL_ZERO,
                       (RIL_Token) QCRIL_CUSTOM_ECC_INTERNAL_TOKEN );
        }
    }
}

//===========================================================================
//qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc
//===========================================================================
void qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc()
{
    char current_mcc [ NAS_MCC_MNC_MAX_V01 + 1];
    char current_mnc [ NAS_MCC_MNC_MAX_V01 + 1];
    uint32 cur_status;
    int is_mcc_retrieved;
    int is_mcc_changed;
    int is_recalculate;

    QCRIL_LOG_FUNC_ENTRY();

    memset(current_mcc, 0, sizeof(current_mcc));
    memset(current_mnc, 0, sizeof(current_mnc));
    cur_status = nas_cached_info.designated_number_added_for_designated_country_status;
    is_mcc_retrieved = FALSE;
    is_mcc_changed = FALSE;
    is_recalculate = FALSE;

    if ( nas_common_info.custom_emergency_numbers_enabled )
    {
        is_mcc_retrieved = qcril_qmi_nas_find_current_mcc_mnc( current_mcc, current_mnc, FALSE, NULL );
        if( is_mcc_retrieved )
        {
            QCRIL_LOG_INFO( "retrieve nw mcc - %s mnc - %s", current_mcc, current_mnc );
            cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED;
            if( strcmp(current_mcc, nas_cached_info.mcc_from_device_reg) )
            {
                QCRIL_LOG_INFO( "mcc changed" );
                is_mcc_changed = TRUE;
                strlcpy(nas_cached_info.mcc_from_device_reg, current_mcc, sizeof(nas_cached_info.mcc_from_device_reg));
            }
        }
        else
        {
            QCRIL_LOG_INFO( "No need to reset cached NW NCC.cached NW MCC can be used to cover no service cases" );
        }

        if ( is_mcc_changed == TRUE )
        {
            is_recalculate = TRUE;
            cur_status &= ~( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED |
                             QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH |
                             QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK
                          );
        }

        nas_cached_info.designated_number_added_for_designated_country_status = cur_status;

        if( is_recalculate )
        {
            QCRIL_LOG_INFO( "recalculate emergency numbers" );
            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_DATA_ON_STACK,
                               QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                               NULL,
                               QMI_RIL_ZERO,
                               (RIL_Token) QCRIL_CUSTOM_ECC_INTERNAL_TOKEN );
        }
    }

    QCRIL_LOG_FUNC_RETURN();

} // qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc




// ** eMBMS s

//===========================================================================
//qcril_qmi_nas_embms_txn_enable_act
//===========================================================================
void qcril_qmi_nas_embms_txn_enable_act( qmi_ril_embms_op_enable_transaction_command_e_type command, RIL_Errno status, void* extra )
{
    qmi_ril_embms_op_enable_transaction_state_e_type cur_state;
    qmi_ril_embms_op_enable_transaction_state_e_type outcome_state;

    RIL_Errno                                        res = RIL_E_GENERIC_FAILURE;
    int                                              need_conclusion;
    int                                              need_state_transition;
    errno_enum_type                                  found_qcril_request;
    qcril_reqlist_public_type                        qcril_req_info;
    nas_config_embms_req_msg_v01                     nas_enable_req;
    nas_config_embms_resp_msg_v01*                   nas_enable_resp;
    int                                              is_ok;
    int                                              need_post_data_cmd;
    qcril_embms_enable_request_payload_type          data_enable_payload_req;
    qcril_embms_enable_response_payload_type*        data_con_payload;
    int                                              data_con_payload_struct_valid;
    qcril_embms_enable_response_payload_type         data_con_payload_struct;
    int                                              need_abnormal_drop;
    qcril_request_resp_params_type                   resp;
    embms_enable_embms_resp_msg_v01                  tunneled_resp;
    const struct timeval                             enable_timeout = { 30 , 0 }; // 30 seconds
    uint32                                           timeout_timer_id = 0;
    qmi_client_error_type                            qmi_client_error;
    uint8_t                                          is_embms_enabled = FALSE;

    QCRIL_LOG_INFO( "command: %d", (int) command );

    NAS_EMBMS_CACHE_LOCK();
    cur_state = nas_cached_info.embms_enable_txn_state;
    NAS_EMBMS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. cur txn state %d", (int) cur_state );

    outcome_state               = cur_state; // default
    need_conclusion             = FALSE;
    need_state_transition       = FALSE;
    need_abnormal_drop          = FALSE;
    need_post_data_cmd          = FALSE;
    data_con_payload            = NULL;
    data_con_payload_struct_valid      = FALSE;

    switch ( command )
    {
        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_INITIATE:
            // Update nas cache for embms status
            NAS_EMBMS_CACHE_LOCK();
            is_embms_enabled = nas_cached_info.embms_enabled;
            NAS_EMBMS_CACHE_UNLOCK();

            if(is_embms_enabled == FALSE)
            {
                nas_enable_resp = NULL;
                is_ok           = FALSE;
                do
                {
                    if ( cur_state != QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE )
                        break;

                    memset( &nas_enable_req, 0, sizeof(nas_enable_req) );
                    nas_enable_req.enable = TRUE;
                    nas_enable_req.trace_id_valid = TRUE;
                    NAS_EMBMS_CACHE_LOCK();
                    nas_enable_req.trace_id = nas_cached_info.embms_enable_dbg_trace_id;
                    NAS_EMBMS_CACHE_UNLOCK();

                    qmi_client_error =  qmi_client_nas_send_async(QMI_NAS_CONFIG_EMBMS_REQ_MSG_V01,
                                                                    &nas_enable_req,
                                                                    sizeof( nas_enable_req ),
                                                                    sizeof( *nas_enable_resp ),
                                                                    qcril_qmi_nas_embms_set_enable_cmd_cb,
                                                                    NULL);

                    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );

                    if ( RIL_E_SUCCESS != res )
                    {
                        QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)res, (int)qmi_client_error );
                        break;
                    }

                    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                QCRIL_DEFAULT_MODEM_ID,
                                                qcril_qmi_nas_embms_set_enable_timeout_handler_handler,
                                                &enable_timeout,
                                                &timeout_timer_id );
                    NAS_EMBMS_CACHE_LOCK();
                    nas_cached_info.embms_enable_timeout_timerid = timeout_timer_id;
                    NAS_EMBMS_CACHE_UNLOCK();

                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND;

                    is_ok = TRUE;
                } while (FALSE);

                if ( !is_ok )
                {
                    need_abnormal_drop = TRUE;
                }
            }
            else
            {
                //From NAS perspective embms is already enabled.
                //We just need to enable the data here.
                need_post_data_cmd = TRUE;
            }
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_CON:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON;
                    }
                    else
                    {
                        need_abnormal_drop = TRUE;
                        res                =  status;
                    }
                    break;

                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_post_data_cmd = TRUE;
                    }
                    else
                    {
                        need_abnormal_drop = TRUE;
                        res                =  status;
                    }
                    break;

                default:
                    // no action
                    break;
            }
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_IND:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION;
                    break;

                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON:
                    need_post_data_cmd = TRUE;
                    break;

                default:
                    // no action
                    break;
            }
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_DATA_CON:
            data_con_payload = (qcril_embms_enable_response_payload_type*)extra;
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON:
                    need_conclusion             = TRUE;

                    need_state_transition       = TRUE;
                    outcome_state               = QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE;

                    if ( NULL != data_con_payload )
                    {
                        res                      = (RIL_Errno) data_con_payload->cause;
                        data_con_payload_struct_valid = TRUE;
                        data_con_payload_struct       = *(data_con_payload);
                    }
                    else
                    {
                        res = RIL_E_SUCCESS;
                    }
                    break;

                default:
                    // nothing
                    break;
            }
            QCRIL_LOG_DEBUG("storing data_con_payload in cache");
            NAS_EMBMS_CACHE_LOCK();
            NAS_CACHE_STORE_ENTRY(nas_cached_info.embms_data_con_payload, data_con_payload_struct);
            NAS_EMBMS_CACHE_UNLOCK();
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT:   // pass through
        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND:
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON:
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION:
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON:
                    need_abnormal_drop          = TRUE;
                    break;

                default:
                    // nothing
                    break;
            }
            break;

        default:
            break;
    }

    if ( need_post_data_cmd )
    {
        memset( &data_enable_payload_req, 0, sizeof( data_enable_payload_req ) );
        NAS_EMBMS_CACHE_LOCK();
        data_enable_payload_req.dbg_trace_id = nas_cached_info.embms_enable_dbg_trace_id;
        NAS_EMBMS_CACHE_UNLOCK();
        qcril_request_params_type embms_enable_params = { QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     QCRIL_DATA_ON_STACK,
                                                     QCRIL_EVT_QMI_RIL_EMBMS_ENABLE_DATA_REQ,
                                                     (void *) &data_enable_payload_req,
                                                     sizeof( data_enable_payload_req ),
                                                     (RIL_Token) QCRIL_TOKEN_ID_INTERNAL, NULL };

#ifndef QMI_RIL_UTF
        std::shared_ptr<rildata::EmbmsEnableDataReqMessage> embmsEnableDataMsgPtr =
                       std::make_shared<rildata::EmbmsEnableDataReqMessage>(embms_enable_params);
        if(embmsEnableDataMsgPtr)
        {
          embmsEnableDataMsgPtr->dispatch();
        }
        else
        {
          QCRIL_LOG_ERROR("embmsEnableDataMsgPtr is NULL");
        }
#endif


        need_state_transition = TRUE;
        outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON;
    }

    if ( need_abnormal_drop )
    {
        need_conclusion             = TRUE;
        need_state_transition       = TRUE;
        outcome_state               = QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE;
    }

    if ( need_state_transition )
    {
        NAS_EMBMS_CACHE_LOCK();
        nas_cached_info.embms_enable_txn_state = outcome_state;
        NAS_EMBMS_CACHE_UNLOCK();
    }
    if ( need_conclusion )
    {
        found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                            QCRIL_DEFAULT_MODEM_ID,
                                                            QCRIL_EVT_QMI_REQUEST_EMBMS_ENABLE,
                                                            &qcril_req_info );
        if ( E_SUCCESS == found_qcril_request )
        {
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               qcril_req_info.t,
                                               qcril_req_info.request,
                                               res,
                                               &resp );
            memset( &tunneled_resp, 0, sizeof( tunneled_resp ) );

            if ( RIL_E_SUCCESS == res && NULL != data_con_payload )
            {
                tunneled_resp.call_id_valid = TRUE;
                tunneled_resp.call_id       = data_con_payload->call_id;

                tunneled_resp.interface_name_valid = TRUE;
                strlcpy( tunneled_resp.interface_name, data_con_payload->interafce_name, NUMBER_MAX_V01 );

                tunneled_resp.if_index_valid = TRUE;
                tunneled_resp.if_index = data_con_payload->if_index;

                tunneled_resp.dbg_trace_id = data_con_payload->dbg_trace_id;
                tunneled_resp.resp_code = data_con_payload->resp_code;
            }
            else
            {
                NAS_EMBMS_CACHE_LOCK();
                tunneled_resp.dbg_trace_id = nas_cached_info.embms_enable_dbg_trace_id;
                NAS_EMBMS_CACHE_UNLOCK();
                tunneled_resp.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
            }
            resp.resp_pkt = (void *) &tunneled_resp;
            resp.resp_len = sizeof( tunneled_resp );

            qcril_send_request_response( &resp );

            NAS_EMBMS_CACHE_LOCK();
            QCRIL_LOG_INFO("res: %d, data_con_payload: %p, nas_cached_info.embms_enabled: %d", res, data_con_payload, nas_cached_info.embms_enabled);
            if (RIL_E_SUCCESS == res && NULL != data_con_payload && nas_cached_info.embms_enabled)
            {
               nas_cached_info.embms_enable_success_sent_to_atel = TRUE;
               nas_cached_info.embms_cell_id_sent_after_enabled = FALSE;
               nas_cached_info.embms_coverage_sent_after_enabled = FALSE;
            }
            NAS_EMBMS_CACHE_UNLOCK();

            qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(FALSE, 0, FALSE, NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE_V01);
            qcril_qmi_nas_embms_send_cell_info_changed_if_needed(FALSE, NULL);
            qcril_qmi_nas_embms_send_radio_state( ( RADIO_STATE_UNAVAILABLE == qcril_qmi_nas_dms_get_current_power_state() )
                                                  ? RADIO_STATE_NOT_AVAILABLE_V01 : RADIO_STATE_AVAILABLE_V01
                                                );
        }
        else
        {
            QCRIL_LOG_ERROR( ".. pending event not found %d", (int) found_qcril_request );
        }

        NAS_EMBMS_CACHE_LOCK();
        timeout_timer_id = nas_cached_info.embms_enable_timeout_timerid;
        NAS_EMBMS_CACHE_UNLOCK();
        if ( QMI_RIL_ZERO != timeout_timer_id )
        {
            qcril_cancel_timed_callback( (void*)(uintptr_t)timeout_timer_id );
        }
        NAS_EMBMS_CACHE_LOCK();
        nas_cached_info.embms_enable_timeout_timerid = QMI_RIL_ZERO;
        NAS_EMBMS_CACHE_UNLOCK();

    }

    QCRIL_LOG_INFO( "completed and cur state is %d", (int) outcome_state );
} // qcril_qmi_nas_embms_txn_enable_act

//===========================================================================
// qcril_qmi_nas_embms_set_enable_timeout_handler_handler
//===========================================================================
void  qcril_qmi_nas_embms_set_enable_timeout_handler_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_EMBMS_CACHE_LOCK();
    nas_cached_info.embms_enable_timeout_timerid = QMI_RIL_ZERO;
    NAS_EMBMS_CACHE_UNLOCK();

    qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_enable_timeout_handler_handler

//===========================================================================
// qcril_qmi_nas_embms_set_enable_cmd_cb_helper_handler
//===========================================================================
void qcril_qmi_nas_embms_set_enable_cmd_cb_helper_handler
(
   qcril_timed_callback_handler_params_type *handler_params
)
{
    qmi_resp_callback_type *qmi_resp_data = NULL;
    qmi_client_error_type  transp_err = QMI_NO_ERR;
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_config_embms_resp_msg_v01 *qmi_response = NULL;
    boolean use_txn_signal_halt = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if (NULL == handler_params)
        {
            use_txn_signal_halt = TRUE;
            QCRIL_LOG_ERROR ("handler_params is NULL");
            break;
        }

        qmi_resp_data = (qmi_resp_callback_type *)(handler_params->custom_param);
        if (NULL == qmi_resp_data)
        {
            use_txn_signal_halt = TRUE;
            QCRIL_LOG_ERROR ("qmi_resp_data is NULL");
            break;
        }

        qmi_response = (nas_config_embms_resp_msg_v01 *)(qmi_resp_data->data_buf);
        transp_err = qmi_resp_data->transp_err;

        QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

        if (NULL == qmi_response)
        {
            use_txn_signal_halt = TRUE;
            QCRIL_LOG_ERROR ("qmi_response is NULL");
            break;
        }
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &qmi_response->resp );

        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi err %d", (int) ril_req_res, (int)transp_err, (int) qmi_response->resp.error );

        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_CON, ril_req_res, NULL );

    } while (FALSE);

    if (use_txn_signal_halt)
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );
    }

    if (qmi_response)
    {
      qcril_free(qmi_response);
    }

    if(qmi_resp_data)
    {
      qcril_free( qmi_resp_data );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_enable_cmd_cb_helper_handler

//===========================================================================
// qcril_qmi_nas_embms_set_enable_cmd_cb
//===========================================================================
void qcril_qmi_nas_embms_set_enable_cmd_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    qmi_resp_callback_type *resp_data = NULL;
    QCRIL_LOG_FUNC_ENTRY();


    resp_data = (qmi_resp_callback_type *) qcril_malloc(sizeof(*resp_data));
    if(resp_data)
    {
        resp_data->user_handle = 0;
        resp_data->msg_id = msg_id;
        resp_data->data_buf_len = resp_c_struct_len;
        resp_data->cb_data = resp_cb_data;
        resp_data->transp_err = transp_err;
        if ((resp_data->data_buf = qcril_malloc(resp_c_struct_len))) // alloc success
        {
          memcpy(resp_data->data_buf, resp_c_struct.get(), resp_c_struct_len);
          qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  qcril_qmi_nas_embms_set_enable_cmd_cb_helper_handler,
                                  (void*)resp_data,
                                  NULL,   // immediate
                                  NULL );
        }
        else
        {
          QCRIL_LOG_ERROR("Failed to allocate memory for resp payload");
          free(resp_data);
        }
    }
    else
    {
        QCRIL_LOG_ERROR ("Failed to allocate memory for resp_data");
    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_enable_cmd_cb_helper

//===========================================================================
// qcril_qmi_nas_embms_fetch_embms_status
//===========================================================================
RIL_Errno qcril_qmi_nas_embms_fetch_embms_status()
{
    qmi_client_error_type qmi_client_error;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_get_embms_status_resp_msg_v01 * qmi_response = NULL;

    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        qmi_response = (nas_get_embms_status_resp_msg_v01 *) qcril_malloc( sizeof( *qmi_response ) );
        if ( qmi_response )
        {

            qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_EMBMS_STATUS_REQ_MSG_V01,
                                                          NULL,
                                                          NAS_NIL,  // empty request payload
                                                          (void*) qmi_response,
                                                          sizeof( *qmi_response ),
                                                          ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);


            ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response->resp );


            if ( RIL_E_SUCCESS == ril_req_res )
            {
                NAS_EMBMS_CACHE_LOCK();
                QCRIL_LOG_INFO(".. embms current valid %d value %d, cached value %d",
                               qmi_response->enabled_valid,
                               qmi_response->enabled,
                               nas_cached_info.embms_enabled);

                if( qmi_response->enabled_valid &&
                    nas_cached_info.embms_enabled != qmi_response->enabled )
                {
                    nas_cached_info.embms_enabled = qmi_response->enabled;
                    qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                                QCRIL_DEFAULT_MODEM_ID,
                                                qcril_qmi_nas_embms_embms_status_ind_handler_retranslator,
                                                NULL,   // no param
                                                NULL,   // immediate
                                                NULL );
                }
                NAS_EMBMS_CACHE_UNLOCK();
            }

            qcril_free( qmi_response );
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_embms_fetch_embms_status

//===========================================================================
// qcril_qmi_nas_embms_embms_status_ind_handler
//===========================================================================
void qcril_qmi_nas_embms_embms_status_ind_handler(nas_embms_status_ind_msg_v01* status_ind)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO( ".. embms enabled %d", status_ind->enabled );
    NAS_EMBMS_CACHE_LOCK();
    nas_cached_info.embms_enabled = status_ind->enabled;
    NAS_EMBMS_CACHE_UNLOCK();

    qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                QCRIL_DEFAULT_MODEM_ID,
                                qcril_qmi_nas_embms_embms_status_ind_handler_retranslator,
                                NULL,   // no param
                                NULL,   // immediate
                                NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_embms_status_ind_handler

//===========================================================================
// qcril_qmi_nas_embms_embms_status_ind_handler_retranslator
//===========================================================================
void qcril_qmi_nas_embms_embms_status_ind_handler_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    uint8_t enabled;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(handler_params);

    NAS_EMBMS_CACHE_LOCK();
    enabled = nas_cached_info.embms_enabled;
    NAS_EMBMS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. is embms enabled %d", enabled );

    if ( enabled )
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_IND, RIL_E_SUCCESS, NULL );
    }
    else
    {
        qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_IND, RIL_E_SUCCESS, NULL );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_embms_status_ind_handler_retranslator

//===========================================================================
// qcril_qmi_nas_embms_enable_error_halt_retranslator
//===========================================================================
void qcril_qmi_nas_embms_enable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    QCRIL_LOG_INFO( "%s", "qcril_qmi_nas_embms_enable_error_halt_retranslator entered" );

    QCRIL_NOTUSED( handler_params );

    qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_enable_error_halt_retranslator


//===========================================================================
// qcril_qmi_nas_embms_enable_data_con_retranslator
//===========================================================================
void qcril_qmi_nas_embms_enable_data_con_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    qcril_embms_enable_response_payload_type* response_payload_copy;

    QCRIL_LOG_FUNC_ENTRY();

    response_payload_copy = (qcril_embms_enable_response_payload_type*)handler_params->custom_param;
    if ( NULL != response_payload_copy )
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_DATA_CON, RIL_E_SUCCESS, response_payload_copy );

        qcril_free( response_payload_copy );
    }
    else
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_enable_data_con_retranslator

//===========================================================================
//QCRIL_EVT_QMI_RIL_EMBMS_ENABLE_DATA_CON
//===========================================================================
void qcril_qmi_nas_embms_enable_data_con
(
    const qcril_embms_enable_response_payload_type* response_payload
)
{
    qcril_embms_enable_response_payload_type* response_payload_copy;

    int is_error;

    QCRIL_LOG_FUNC_ENTRY();

    is_error = TRUE;

    if ( response_payload != NULL )
    {
        response_payload_copy = (qcril_embms_enable_response_payload_type *) qcril_malloc( sizeof( *response_payload_copy ) );
        if ( response_payload_copy )
        {
            *response_payload_copy = *response_payload;
            qcril_setup_timed_callback_ex_params_adv( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qcril_qmi_nas_embms_enable_data_con_retranslator,
                                        (void*)response_payload_copy,
                                        TRUE,
                                        NULL,   // immediate
                                        NULL );
            is_error = FALSE;
        }
        else
        {
            QCRIL_LOG_ERROR( ".. retranslation buf alloc failed" );
        }
    }

    if ( is_error )
    {
        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_enable_error_halt_retranslator,
                                    NULL,   // no param
                                    NULL,   // immediate
                                    NULL );
    }


    QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_embms_enable_data_con

//===========================================================================
// qcril_qmi_nas_embms_request_enable_handler
//===========================================================================
void qcril_qmi_nas_embms_request_enable_handler
(
   qcril_timed_callback_handler_params_type *handler_params
)
{
  qcril_request_params_type *const params_ptr =
    (qcril_request_params_type *)handler_params->custom_param;
  qcril_request_return_type *const ret_ptr = NULL;

  qcril_request_resp_params_type    resp;
  RIL_Errno                         ril_req_res = RIL_E_GENERIC_FAILURE;

  qcril_reqlist_public_type         qcril_req_info_ptr;
  embms_enable_embms_req_msg_v01    *req_payload;
  embms_enable_embms_resp_msg_v01   resp_payload;

  boolean enable_needed = TRUE;
  uint8_t embms_data_con_payload_valid;
  qcril_embms_enable_response_payload_type embms_data_con_payload;
  uint8_t is_data_embms_active = FALSE;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  memset(&embms_data_con_payload, 0, sizeof(embms_data_con_payload));

  NAS_EMBMS_CACHE_LOCK();
  if (nas_cached_info.embms_enabled)
  {
     nas_cached_info.embms_enable_success_sent_to_atel = FALSE;
  }

  embms_data_con_payload_valid = nas_cached_info.embms_data_con_payload_valid;
  QCRIL_LOG_DEBUG("cached data_con_payload_valid %d", nas_cached_info.embms_data_con_payload_valid);
  if (embms_data_con_payload_valid && nas_cached_info.embms_data_con_payload)
  {
    embms_data_con_payload = *(nas_cached_info.embms_data_con_payload);
  }
  NAS_EMBMS_CACHE_UNLOCK();

  do
  {
    if( NULL == params_ptr )
    {
      QCRIL_LOG_ERROR("invalid NULL parameter for params_ptr");
      break;
    }

    req_payload = (embms_enable_embms_req_msg_v01 *) params_ptr->data;
    if ( NULL != req_payload )
    {
      NAS_EMBMS_CACHE_LOCK();
      nas_cached_info.embms_enable_dbg_trace_id = req_payload->dbg_trace_id;
      NAS_EMBMS_CACHE_UNLOCK();
    }
    else
    {
      QCRIL_LOG_ERROR("invalid NULL parameter for embms disable request");
      break;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                         params_ptr->event_id,
                         QCRIL_DEFAULT_MODEM_ID,
                         QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                         QCRIL_EVT_QMI_REQUEST_EMBMS_ENABLE,
                         NULL,
                         &qcril_req_info_ptr );
    if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) )
    {
        break;
    }

    // Update nas cache for embms status
    if ( RIL_E_SUCCESS != qcril_qmi_nas_embms_fetch_embms_status())
    {
        break;
    }

    // If embms already enabled, send RIL resp
    NAS_EMBMS_CACHE_LOCK();
    uint8_t is_embms_enabled = nas_cached_info.embms_enabled;
    NAS_EMBMS_CACHE_UNLOCK();

#ifndef QMI_RIL_UTF
    // DATA STUB is_data_embms_active = qcril_data_is_embms_active();
    std::shared_ptr<rildata::RilDataEmbmsActiveMessage> embms_active_ptr =
                             std::make_shared<rildata::RilDataEmbmsActiveMessage>();
    std::shared_ptr<bool> respPtr = NULL;
    if(embms_active_ptr != NULL)
    {
      if(embms_active_ptr->dispatchSync(respPtr) == Message::Callback::Status::SUCCESS)
      {
        if(respPtr != NULL)
        {
          is_data_embms_active = *respPtr;
        }
      }
    }
#else
    is_data_embms_active = is_embms_enabled;
#endif

    if (is_embms_enabled && is_data_embms_active && embms_data_con_payload_valid)
    {
      QCRIL_LOG_DEBUG("EMBMS was enabled in both RIL and data");
      ril_req_res = (RIL_Errno) embms_data_con_payload.cause;
      enable_needed = FALSE;
      break;
    }
    // else intiate eMBMS enable
    else
    {
      QCRIL_LOG_DEBUG("Clearing local cache and enabling eMBMS...");
      NAS_EMBMS_CACHE_LOCK();
      NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.embms_data_con_payload);
      NAS_EMBMS_CACHE_UNLOCK();
      ril_req_res = RIL_E_SUCCESS;
      qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_INITIATE, RIL_E_SUCCESS, NULL );
      break;
    }
  } while ( FALSE );

  QCRIL_LOG_DEBUG("ril_req_res %d, enable_needed %d", ril_req_res, enable_needed);

  if (((RIL_E_SUCCESS != ril_req_res) || !enable_needed) && (NULL != params_ptr))
  { // rollback
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      memset( &resp_payload, 0, sizeof( resp_payload ) );

      if ( RIL_E_SUCCESS == ril_req_res && is_data_embms_active)
      {
          resp_payload.call_id_valid = TRUE;
          resp_payload.call_id       = embms_data_con_payload.call_id;

          resp_payload.interface_name_valid = TRUE;
          strlcpy( resp_payload.interface_name, embms_data_con_payload.interafce_name, NUMBER_MAX_V01 );

          resp_payload.if_index_valid = TRUE;
          resp_payload.if_index = embms_data_con_payload.if_index;

          resp_payload.dbg_trace_id = embms_data_con_payload.dbg_trace_id;
          resp_payload.resp_code = embms_data_con_payload.resp_code;
          nas_cached_info.embms_enable_success_sent_to_atel = TRUE;
      }
      else
      {
          NAS_EMBMS_CACHE_LOCK();
          resp_payload.dbg_trace_id = nas_cached_info.embms_enable_dbg_trace_id;
          NAS_EMBMS_CACHE_UNLOCK();
          if (RIL_E_SUCCESS != ril_req_res)
          {
            resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
          }
      }

      resp.resp_pkt = (void *) &resp_payload;
      resp.resp_len = sizeof( resp_payload );

      QCRIL_LOG_DEBUG("Sending RIL response with res %d, call_id %d, interface_name %s, if_index %d, resp_code %d",
                       ril_req_res,
                       resp_payload.call_id,
                       resp_payload.interface_name,
                       resp_payload.if_index,
                       resp_payload.resp_code);
      qcril_send_request_response( &resp );
  }

  // we own it
  if (params_ptr)
  {
      if (params_ptr->data)
      {
          qcril_free(params_ptr->data);
      }
      qcril_free(params_ptr);
  }

  QCRIL_LOG_INFO( "ril_req_res: %d", (int) ril_req_res );
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_request_enable_handler

//===========================================================================
//QCRIL_EVT_HOOK_EMBMS_ENABLE
//===========================================================================
void qcril_qmi_nas_embms_requst_enable
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_params_type *req_ptr = NULL;
  RIL_Errno ril_res = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  req_ptr = (qcril_request_params_type *) qcril_malloc(sizeof(qcril_request_params_type));
  if(req_ptr)
  {
    memcpy(req_ptr, params_ptr, sizeof(qcril_request_params_type));
    if ((req_ptr->data = qcril_malloc(req_ptr->datalen)))
    {
      memcpy(req_ptr->data, params_ptr->data, req_ptr->datalen);

      qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  qcril_qmi_nas_embms_request_enable_handler,
                                  (void*)req_ptr,
                                  NULL,   // immediate
                                  NULL );
    }
    else
    {
      ril_res = RIL_E_NO_MEMORY;
      qcril_free(req_ptr);
    }
  }
  else
  {
    ril_res = RIL_E_NO_MEMORY;
    QCRIL_LOG_ERROR ("Failed to allocate memory for req_ptr");
  }

  if (ril_res != RIL_E_SUCCESS)
  {
    qcril_request_resp_params_type resp;
    embms_enable_embms_resp_msg_v01 resp_payload;

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_res,
                                       &resp );
    memset( &resp_payload, 0, sizeof( resp_payload ) );
    if (params_ptr->data)
        resp_payload.dbg_trace_id = ((embms_enable_embms_req_msg_v01*)params_ptr->data)->dbg_trace_id;
    resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;

    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();
}// qcril_qmi_nas_embms_requst_enable


//===========================================================================
//qcril_qmi_nas_embms_txn_disable_act
//===========================================================================
void qcril_qmi_nas_embms_txn_disable_act( qmi_ril_embms_op_disable_transaction_command_e_type command, RIL_Errno status, void* extra )
{
    qmi_ril_embms_op_disable_transaction_state_e_type cur_state;
    qmi_ril_embms_op_disable_transaction_state_e_type outcome_state;

    RIL_Errno                                        res = RIL_E_GENERIC_FAILURE;
    int                                              need_conclusion;
    int                                              need_state_transition;
    errno_enum_type                                  found_qcril_request;
    qcril_reqlist_public_type                        qcril_req_info;
    nas_config_embms_req_msg_v01                     nas_disable_req;
    nas_config_embms_resp_msg_v01*                   nas_disable_resp;
    int                                              is_ok;
    qcril_embms_disable_indication_payload_type*     data_ind_payload;
    int                                              need_abnormal_drop;
    int                                              need_normal_drop;
    qcril_request_resp_params_type                   resp;
    embms_disable_embms_resp_msg_v01                 tunneled_resp;
    const struct timeval                             disable_timeout = { 30 , 0 }; // 30 seconds
    uint32                                           timeout_timer_id = 0;
    qmi_client_error_type                            qmi_client_error;

    QCRIL_LOG_INFO( "command: %d", (int) command );

    NAS_EMBMS_CACHE_LOCK();
    cur_state = nas_cached_info.embms_disable_txn_state;
    NAS_EMBMS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. cur txn state %d", (int) cur_state );

    outcome_state               = cur_state; // default
    need_conclusion             = FALSE;
    need_state_transition       = FALSE;
    need_abnormal_drop          = FALSE;
    need_normal_drop            = FALSE;
    data_ind_payload            = NULL;

    switch ( command )
    {
        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_INITIATE:
            nas_disable_resp = NULL;
            is_ok            = FALSE;
            do
            {
                if ( cur_state != QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE )
                    break;

                memset( &nas_disable_req, 0, sizeof(nas_disable_req) );
                nas_disable_req.enable = FALSE;
                nas_disable_req.trace_id_valid = TRUE;
                NAS_EMBMS_CACHE_LOCK();
                nas_disable_req.trace_id = nas_cached_info.embms_disable_dbg_trace_id;
                NAS_EMBMS_CACHE_UNLOCK();

                qmi_client_error =  qmi_client_nas_send_async(QMI_NAS_CONFIG_EMBMS_REQ_MSG_V01,
                                                                &nas_disable_req,
                                                                sizeof( nas_disable_req ),
                                                                sizeof( *nas_disable_resp ),
                                                                qcril_qmi_nas_embms_set_disable_cmd_cb,
                                                                NULL);

                res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );

                if ( RIL_E_SUCCESS != res )
                    break;

                qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                            QCRIL_DEFAULT_MODEM_ID,
                                            qcril_qmi_nas_embms_set_disable_timeout_handler_handler,
                                            &disable_timeout,
                                            &timeout_timer_id );
                NAS_EMBMS_CACHE_LOCK();
                nas_cached_info.embms_disable_timeout_timerid = timeout_timer_id;
                NAS_EMBMS_CACHE_UNLOCK();

                need_state_transition = TRUE;
                outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND;

                is_ok = TRUE;
            } while (FALSE);

            if ( !is_ok )
            {
                need_abnormal_drop = TRUE;
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_CON:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_normal_drop      = TRUE;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                default:
                    // nothing
                    break;
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_IND:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND;
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND;
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON;
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND:
                    need_normal_drop      = TRUE;
                    break;

                default:
                    // break
                    break;
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_DATA_IND:
            if ( RIL_E_SUCCESS != status )
            {
                res                = status;
                need_abnormal_drop = TRUE;
            }
            else
            {
                data_ind_payload = (qcril_embms_disable_indication_payload_type* )extra;
                if ( data_ind_payload )
                {
                    switch ( cur_state )
                    {
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND:
                            NAS_EMBMS_CACHE_LOCK();
                            nas_cached_info.embms_disable_resp_call_id = data_ind_payload->call_id;
                            NAS_EMBMS_CACHE_UNLOCK();
                            break;

                        default:
                            // nothing
                            break;
                    }
                    switch ( cur_state )
                    {
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                            need_state_transition = TRUE;
                            outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND;
                            break;

                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:
                            need_state_transition = TRUE;
                            outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND;
                            break;

                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:
                            need_state_transition = TRUE;
                            outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON;
                            break;

                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND:
                            need_normal_drop      = TRUE;
                            break;

                        default:
                            // nothing
                            break;
                    }
                }
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:       // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:              // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:              // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND:                   // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON:                          // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND:                                 // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND:                          // pass through
                    need_abnormal_drop = TRUE;
                    break;

                default:
                    // nothing
                    break;
            }
            break;

        default:
            break;
    }


    if ( need_abnormal_drop )
    {
        need_conclusion             = TRUE;
        need_state_transition       = TRUE;
        outcome_state               = QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE;
    }

    if ( need_normal_drop )
    {
        need_conclusion             = TRUE;
        need_state_transition       = TRUE;
        res                         = RIL_E_SUCCESS;
        outcome_state               = QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE;
    }

    if ( need_state_transition )
    {
        NAS_EMBMS_CACHE_LOCK();
        nas_cached_info.embms_disable_txn_state = outcome_state;
        NAS_EMBMS_CACHE_UNLOCK();
    }
    if ( need_conclusion )
    {
        found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                            QCRIL_DEFAULT_MODEM_ID,
                                                            QCRIL_EVT_QMI_REQUEST_EMBMS_DISABLE,
                                                            &qcril_req_info );
        if ( E_SUCCESS == found_qcril_request )
        {
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               qcril_req_info.t,
                                               qcril_req_info.request,
                                               res,
                                               &resp );
            memset( &tunneled_resp, 0, sizeof( tunneled_resp ) );

            if ( RIL_E_SUCCESS == res )
            {
                tunneled_resp.call_id_valid = TRUE;
                NAS_EMBMS_CACHE_LOCK();
                tunneled_resp.call_id       = nas_cached_info.embms_disable_resp_call_id;
                tunneled_resp.dbg_trace_id  = nas_cached_info.embms_disable_dbg_trace_id;
                NAS_EMBMS_CACHE_UNLOCK();
                tunneled_resp.resp_code     = QMI_RIL_EMBMS_SUCCESS;
            }
            else
            {
                NAS_EMBMS_CACHE_LOCK();
                tunneled_resp.dbg_trace_id  = nas_cached_info.embms_disable_dbg_trace_id;
                NAS_EMBMS_CACHE_UNLOCK();
                tunneled_resp.resp_code     = QMI_RIL_EMBMS_ERROR_UNKNOWN;
            }
            resp.resp_pkt = (void *) &tunneled_resp;
            resp.resp_len = sizeof( tunneled_resp );

            qcril_send_request_response( &resp );
        }
        else
        {
            QCRIL_LOG_ERROR( ".. pending event not found %d", (int) found_qcril_request );
        }

        NAS_EMBMS_CACHE_LOCK();
        timeout_timer_id = nas_cached_info.embms_disable_timeout_timerid;
        NAS_EMBMS_CACHE_UNLOCK();
        if ( QMI_RIL_ZERO != timeout_timer_id )
        {
            qcril_cancel_timed_callback( (void*)(uintptr_t)timeout_timer_id );
        }
        NAS_EMBMS_CACHE_LOCK();
        nas_cached_info.embms_disable_timeout_timerid = QMI_RIL_ZERO;
        // clear the cache for embms_data_con after embms disable
        NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.embms_data_con_payload);
        NAS_EMBMS_CACHE_UNLOCK();
        QCRIL_LOG_DEBUG("Cleared eMBMS local cache...");

    }

    QCRIL_LOG_INFO( "completed and cur state is %d", (int) outcome_state );
} // qcril_qmi_nas_embms_txn_disable_act

//===========================================================================
// qcril_qmi_nas_embms_set_disable_cmd_cb
//===========================================================================
void qcril_qmi_nas_embms_set_disable_cmd_cb
(
    unsigned int                   msg_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    nas_config_embms_resp_msg_v01 * qmi_response   = (nas_config_embms_resp_msg_v01 *) resp_c_struct.get();
    RIL_Errno                       ril_req_res = RIL_E_GENERIC_FAILURE;

    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    QCRIL_NOTUSED(msg_id);
    QCRIL_NOTUSED(resp_c_struct_len);
    QCRIL_NOTUSED(resp_cb_data);

    if ( qmi_response )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &qmi_response->resp );

        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d", (int) ril_req_res, (int)transp_err, (int) qmi_response->resp.error );

        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator,
                                    (void*)ril_req_res,
                                    NULL,   // immediate
                                    NULL );
    }
    else
    {
        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_disable_error_halt_retranslator,
                                    NULL,   // no param
                                    NULL,   // immediate
                                    NULL );
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_embms_set_disable_cmd_cb

//===========================================================================
// qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator
//===========================================================================
void qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    RIL_Errno  ril_req_res;

    QCRIL_LOG_FUNC_ENTRY();

    ril_req_res = (RIL_Errno) (intptr_t) handler_params->custom_param;
    qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_CON, ril_req_res, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator

//===========================================================================
// qcril_qmi_nas_embms_disable_error_halt_retranslator
//===========================================================================
void qcril_qmi_nas_embms_disable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED( handler_params );

    qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_disable_error_halt_retranslator

//===========================================================================
//QCRIL_EVT_QMI_RIL_EMBMS_DISABLE_DATA_IND
//===========================================================================
void qcril_qmi_nas_embms_disable_data_ind
(
    const qcril_embms_disable_indication_payload_type* indication_payload
)
{
    qcril_embms_disable_indication_payload_type* indication_payload_copy;
    int is_error;

    QCRIL_LOG_FUNC_ENTRY();

    is_error = TRUE;
    if ( indication_payload != NULL )
    {
        indication_payload_copy = (qcril_embms_disable_indication_payload_type *) qcril_malloc( sizeof( *indication_payload_copy ) );
        if ( indication_payload_copy )
        {
           *indication_payload_copy = *indication_payload;
            qcril_setup_timed_callback_ex_params_adv( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qcril_qmi_nas_embms_disable_data_ind_retranslator,
                                        (void*)indication_payload_copy,
                                        TRUE,
                                        NULL,   // immediate
                                        NULL );
            is_error = FALSE;
        }
        else
        {
            QCRIL_LOG_ERROR( ".. retranslation buf alloc failed" );
        }
    }
    if ( is_error )
    {
        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_disable_error_halt_retranslator,
                                    NULL,   // no param
                                    NULL,   // immediate
                                    NULL );
    }


    QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_embms_disable_data_ind

//===========================================================================
// qcril_qmi_nas_embms_disable_data_ind_retranslator
//===========================================================================
void qcril_qmi_nas_embms_disable_data_ind_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    qcril_embms_disable_indication_payload_type* indication_payload_copy;

    QCRIL_LOG_FUNC_ENTRY();

    indication_payload_copy = (qcril_embms_disable_indication_payload_type*)handler_params->custom_param;
    if ( NULL != indication_payload_copy )
    {
        qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_DATA_IND, RIL_E_SUCCESS, indication_payload_copy );

        qcril_free( indication_payload_copy );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_disable_data_ind_retranslator

//===========================================================================
// qcril_qmi_nas_embms_set_disable_timeout_handler_handler
//===========================================================================
void  qcril_qmi_nas_embms_set_disable_timeout_handler_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_EMBMS_CACHE_LOCK();
    nas_cached_info.embms_disable_timeout_timerid = QMI_RIL_ZERO;
    NAS_EMBMS_CACHE_UNLOCK();

    qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_disable_timeout_handler_handler

//===========================================================================
// qcril_qmi_nas_embms_request_disable_handler
//===========================================================================
void qcril_qmi_nas_embms_request_disable_handler
(
   qcril_timed_callback_handler_params_type *handler_params
)
{
  qcril_request_params_type *const params_ptr =
    (qcril_request_params_type *)handler_params->custom_param;
  qcril_request_return_type *const ret_ptr = NULL;

  qcril_request_resp_params_type        resp;
  RIL_Errno                             ril_req_res = RIL_E_GENERIC_FAILURE;

  qcril_reqlist_public_type             qcril_req_info_ptr;
  embms_disable_embms_req_msg_v01   *   req_params;
  embms_disable_embms_resp_msg_v01      resp_payload;

  boolean disable_needed = TRUE;
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  do
  {
    if(NULL == params_ptr)
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for params_ptr");
        break;
    }

    req_params = (embms_disable_embms_req_msg_v01 *) params_ptr->data;
    if ( NULL == req_params )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms disable request");
        break;
    }

    QCRIL_LOG_INFO( ".. param call id %d", (int)req_params->call_id );

    NAS_EMBMS_CACHE_LOCK();
    nas_cached_info.embms_disable_dbg_trace_id = req_params->dbg_trace_id;
    NAS_EMBMS_CACHE_UNLOCK();

    qcril_reqlist_default_entry( params_ptr->t,
                         params_ptr->event_id,
                         QCRIL_DEFAULT_MODEM_ID,
                         QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                         QCRIL_EVT_QMI_REQUEST_EMBMS_DISABLE,
                         NULL,
                         &qcril_req_info_ptr );
    if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) )
    {
        break;
    }

    // Update nas cache for embms status
    if ( RIL_E_SUCCESS != qcril_qmi_nas_embms_fetch_embms_status())
    {
        break;
    }

    // If embms already disabled, send RIL resp
    NAS_EMBMS_CACHE_LOCK();
    uint8_t is_embms_enabled = nas_cached_info.embms_enabled;
    NAS_EMBMS_CACHE_UNLOCK();
    if(!is_embms_enabled)
    {
      ril_req_res = RIL_E_SUCCESS;
      disable_needed = FALSE;
      break;
    }
    // else, set ebmbs to "disable"
    else {
      ril_req_res = RIL_E_SUCCESS;
      qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_INITIATE, RIL_E_SUCCESS, NULL );
      break;
    }
  } while ( FALSE );


  if (((RIL_E_SUCCESS != ril_req_res) || !disable_needed) && (NULL != params_ptr))
  { // rollback
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      memset( &resp_payload, 0, sizeof( resp_payload ) );

      NAS_EMBMS_CACHE_LOCK();
      resp_payload.dbg_trace_id = nas_cached_info.embms_disable_dbg_trace_id;
      NAS_EMBMS_CACHE_UNLOCK();
      if (RIL_E_SUCCESS != ril_req_res)
      {
        resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
      }

      resp.resp_pkt = (void *) &resp_payload;
      resp.resp_len = sizeof( resp_payload );
      qcril_send_request_response( &resp );
  }

  // we own it
  if (params_ptr)
  {
      if (params_ptr->data)
      {
          qcril_free(params_ptr->data);
      }
      qcril_free(params_ptr);
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res );
} // qcril_qmi_nas_embms_request_disable_handler

//===========================================================================
//QCRIL_EVT_HOOK_EMBMS_DISABLE
//===========================================================================
void qcril_qmi_nas_embms_requst_disable
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_params_type *req_ptr = NULL;
  RIL_Errno ril_res = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  req_ptr = (qcril_request_params_type *) qcril_malloc(sizeof(qcril_request_params_type));
  if(req_ptr)
  {
    memcpy(req_ptr, params_ptr, sizeof(qcril_request_params_type));
    if ((req_ptr->data = qcril_malloc(req_ptr->datalen)))
    {
      memcpy(req_ptr->data, params_ptr->data, req_ptr->datalen);

      qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  qcril_qmi_nas_embms_request_disable_handler,
                                  (void*)req_ptr,
                                  NULL,   // immediate
                                  NULL );
    }
    else
    {
      ril_res = RIL_E_NO_MEMORY;
      qcril_free(req_ptr);
    }
  }
  else
  {
    ril_res = RIL_E_NO_MEMORY;
    QCRIL_LOG_ERROR ("Failed to allocate memory for req_ptr");
  }

  if (ril_res != RIL_E_SUCCESS)
  {
    qcril_request_resp_params_type resp;
    embms_disable_embms_resp_msg_v01 resp_payload;

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_res,
                                       &resp );
    memset( &resp_payload, 0, sizeof( resp_payload ) );
    if (params_ptr->data)
        resp_payload.dbg_trace_id = ((embms_disable_embms_req_msg_v01*)params_ptr->data)->dbg_trace_id;
    resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;

    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();
}// qcril_qmi_nas_embms_requst_disable

//===========================================================================
// qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed
//===========================================================================
void qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(
        uint8_t prev_lte_embms_coverage_valid,
        uint8_t prev_lte_embms_coverage,
        uint8_t prev_lte_embms_coverage_status_valid,
        nas_lte_rrc_embms_coverage_status_enum_v01 prev_lte_embms_coverage_status)
{
    embms_unsol_broadcast_coverage_ind_msg_v01 payload;
    int need_update_embms_coverage = FALSE;
    nas_lte_rrc_embms_coverage_status_enum_v01 embms_coverage;
    qmi_ril_embms_coverage_state_e_type broadcast_coverage;

    QCRIL_LOG_FUNC_ENTRY();

    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        NAS_EMBMS_CACHE_LOCK();
        if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.embms_coverage_status) &&
             nas_cached_info.embms_enabled &&
             nas_cached_info.embms_enable_success_sent_to_atel
           )
        {
           if ( !nas_cached_info.embms_coverage_sent_after_enabled ||
                !prev_lte_embms_coverage_status_valid ||
                prev_lte_embms_coverage_status != nas_cached_info.embms_coverage_status
              )
           {
              need_update_embms_coverage = TRUE;
              embms_coverage = nas_cached_info.embms_coverage_status;
              broadcast_coverage = qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(embms_coverage);
              QCRIL_LOG_INFO("qmi embms_coverage status %d", embms_coverage);
              QCRIL_LOG_INFO("qmi braodcast_coverage status %d", broadcast_coverage);
           }
        }
        else if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_embms_coverage) &&
             nas_cached_info.embms_enabled &&
             nas_cached_info.embms_enable_success_sent_to_atel
           )
        {
           if ( !nas_cached_info.embms_coverage_sent_after_enabled ||
                !prev_lte_embms_coverage_valid ||
                prev_lte_embms_coverage != nas_cached_info.lte_embms_coverage
              )
           {
              need_update_embms_coverage = TRUE;
              embms_coverage = (nas_lte_rrc_embms_coverage_status_enum_v01) nas_cached_info.lte_embms_coverage;
              broadcast_coverage = (embms_coverage ? QMI_RIL_EMBMS_IN_COVERAGE : QMI_RIL_EMBMS_OUT_OF_COVERAGE);
              QCRIL_LOG_INFO("qmi lte_embms_coverage status %d", embms_coverage);
              QCRIL_LOG_INFO("qmi braodcast_coverage status %d", broadcast_coverage);
           }
        }
        NAS_EMBMS_CACHE_UNLOCK();

        if ( need_update_embms_coverage )
        {
           memset( &payload, 0, sizeof( payload ) );
           payload.dbg_trace_id = -1;
           QCRIL_LOG_INFO("qmi lte_embms_coverage status %d", embms_coverage);
           payload.broadcast_coverage = broadcast_coverage;
           qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_UNSOL_COVERAGE, (char*)&payload, sizeof(payload));
           NAS_EMBMS_CACHE_LOCK();
           nas_cached_info.embms_coverage_sent_after_enabled = TRUE;
           NAS_EMBMS_CACHE_UNLOCK();
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed

//===========================================================================
// qcril_qmi_nas_embms_request_get_coverage_state
//===========================================================================
void qcril_qmi_nas_embms_request_get_coverage_state
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type        resp;
    RIL_Errno                             ril_req_res = RIL_E_GENERIC_FAILURE;
    embms_get_coverage_state_req_msg_v01  *req_payload = (embms_get_coverage_state_req_msg_v01* )params_ptr->data;
    embms_get_coverage_state_resp_msg_v01 resp_payload;

    memset( &resp_payload, 0, sizeof( resp_payload ) );

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    if ( NULL == req_payload )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms get coverage request");
        resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
    }
    else
    {
        resp_payload.dbg_trace_id = req_payload->dbg_trace_id;
        resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;

        NAS_EMBMS_CACHE_LOCK();
        if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.embms_coverage_status) )
        {
            QCRIL_LOG_INFO("coverage_state %d", nas_cached_info.embms_coverage_status);
            resp_payload.coverage_state_valid = TRUE;
            resp_payload.coverage_state = qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(nas_cached_info.embms_coverage_status);
            resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;
            ril_req_res = RIL_E_SUCCESS;
        }
        NAS_EMBMS_CACHE_UNLOCK();
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_request_get_coverage_state

//===========================================================================
// qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage
//===========================================================================
qmi_ril_embms_coverage_state_e_type qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(
        nas_lte_rrc_embms_coverage_status_enum_v01 qmi_embms_coverage)
{
    qmi_ril_embms_coverage_state_e_type coverage;

    switch (qmi_embms_coverage) {
        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_AVAILABLE_V01:
            coverage = QMI_RIL_EMBMS_IN_COVERAGE;
            break;

        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE_V01:
            coverage = QMI_RIL_EMBMS_OUT_OF_COVERAGE_DUE_TO_UEMODE;
            break;

        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_EMERGENCY_V01:
            coverage = QMI_RIL_EMBMS_OUT_OF_COVERAGE_E911;
            break;

        default: //fall-through
        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE_V01:
            coverage = QMI_RIL_EMBMS_OUT_OF_COVERAGE;
            break;
    }
    return coverage;
} // qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage

//===========================================================================
// qcril_qmi_nas_embms_get_rssi_cb
//===========================================================================
void qcril_qmi_nas_embms_get_rssi_cb
(
    unsigned int                   message_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    qcril_request_resp_params_type   resp;
    embms_get_rssi_resp_msg_v01      ril_resp_payload;
    nas_get_embms_sig_ext_resp_msg_v01 *qmi_response = (nas_get_embms_sig_ext_resp_msg_v01 *) resp_c_struct.get();
    RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type        request_info;

    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    QCRIL_NOTUSED(message_id);
    QCRIL_NOTUSED(resp_c_struct_len);
    QCRIL_NOTUSED(resp_cb_data);

    if ( qmi_response )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &qmi_response->resp );
        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d", (int) ril_req_res, (int)transp_err, (int) qmi_response->resp.error );

        if ( E_SUCCESS != qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_GET_RSSI, &request_info) )
        {
            QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_RSSI not found");
        }
        else
        {
            memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );

            if ( qmi_response->trace_id_valid )
            {
                ril_resp_payload.dbg_trace_id = qmi_response->trace_id;
            }
            else
            {
                QCRIL_LOG_ERROR("trace id in qmi_response not valid");
                ril_resp_payload.dbg_trace_id = -1;
            }

            ril_resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;

            if ( RIL_E_SUCCESS == ril_req_res )
            {
                if ( qmi_response->snr_and_tmgi_list_valid )
                {
                   ril_resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;

                   ril_resp_payload.area_id_valid = TRUE;
                   ril_resp_payload.area_id_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.sig_noise_ratio_valid = TRUE;
                   ril_resp_payload.sig_noise_ratio_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.excess_snr_valid = TRUE;
                   ril_resp_payload.excess_snr_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.number_of_tmgi_per_mbsfn_valid = TRUE;
                   ril_resp_payload.number_of_tmgi_per_mbsfn_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.active_tgmi_valid = TRUE;

                   uint32_t i;
                   for (i = 0; i < ril_resp_payload.area_id_len; i++)
                   {
                      ril_resp_payload.area_id[i]                  = qmi_response->snr_and_tmgi_list[i].area_id;
                      ril_resp_payload.sig_noise_ratio[i]          = qmi_response->snr_and_tmgi_list[i].snr;
                      ril_resp_payload.excess_snr[i]               = qmi_response->snr_and_tmgi_list[i].excess_snr;
                      ril_resp_payload.number_of_tmgi_per_mbsfn[i] = qmi_response->snr_and_tmgi_list[i].tmgi_info_len;

                      uint32_t j;
                      for (j = 0; j < qmi_response->snr_and_tmgi_list[i].tmgi_info_len; j++)
                      {
                         ril_resp_payload.active_tgmi[j].tmgi_len = NAS_TMGI_IDENTIFIER_LEN_V01;
                         memcpy( ril_resp_payload.active_tgmi[j].tmgi,
                                 qmi_response->snr_and_tmgi_list[i].tmgi_info[j].tmgi_identifier,
                                 NAS_TMGI_IDENTIFIER_LEN_V01);
                      }
                      ril_resp_payload.active_tgmi_len += ril_resp_payload.number_of_tmgi_per_mbsfn[i];
                   }
                }
                else
                {
                   QCRIL_LOG_DEBUG("snr_and_tmgi_list is not valid");
                }
            }

            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               request_info.t,
                                               request_info.request,
                                               ril_req_res,
                                               &resp );
            resp.resp_pkt = (void *) &ril_resp_payload;
            resp.resp_len = sizeof( ril_resp_payload );
            qcril_send_request_response( &resp );
        }
    }
    else
    {
        QCRIL_LOG_ERROR("qmi_response is NULL");
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_embms_get_rssi_cb

//===========================================================================
// qcril_qmi_nas_embms_get_rssi
//===========================================================================
void qcril_qmi_nas_embms_get_rssi
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type      qcril_req_info_ptr;

    embms_get_rssi_req_msg_v01     *ril_req_payload = (embms_get_rssi_req_msg_v01* )params_ptr->data;
    embms_get_rssi_resp_msg_v01    ril_resp_payload;
    nas_get_embms_sig_ext_req_msg_v01  qmi_req;
    nas_get_embms_sig_ext_resp_msg_v01 *qmi_resp;

    qmi_client_error_type          qmi_client_error;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    do
    {
        if ( NULL == ril_req_payload )
        {
            QCRIL_LOG_ERROR("invalid NULL parameter for embms get rssi request");
            break;
        }

        qcril_reqlist_default_entry( params_ptr->t,
                                     params_ptr->event_id,
                                     QCRIL_DEFAULT_MODEM_ID,
                                     QCRIL_REQ_AWAITING_CALLBACK,
                                     QCRIL_EVT_NONE,
                                     NULL,
                                     &qcril_req_info_ptr );
        if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) )
        {
            QCRIL_LOG_ERROR("failed to create request");
            break;
        }

        memset( &qmi_req, 0, sizeof( qmi_req ) );
        qmi_req.trace_id_valid = TRUE;
        qmi_req.trace_id = ril_req_payload->dbg_trace_id;

        qmi_client_error =  qmi_client_nas_send_async(QMI_NAS_GET_EMBMS_SIG_EXT_REQ_MSG_V01,
                                                        &qmi_req,
                                                        sizeof( qmi_req ),
                                                        sizeof( *qmi_resp ),
                                                        qcril_qmi_nas_embms_get_rssi_cb,
                                                        NULL);

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );

        if ( RIL_E_SUCCESS != ril_req_res )
        {
            QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)ril_req_res, (int)qmi_client_error );
        }
    } while ( 0 );

    if ( RIL_E_SUCCESS != ril_req_res )
    {
        if ( NULL != ril_req_payload )
        {
            memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
            ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
            ril_resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        if ( NULL != ril_req_payload )
        {
            resp.resp_pkt = (void *) &ril_resp_payload;
            resp.resp_len = sizeof( ril_resp_payload );
        }
        qcril_send_request_response( &resp );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_rssi

//===========================================================================
// qcril_qmi_nas_embms_send_cell_info_changed_if_needed
//===========================================================================
void qcril_qmi_nas_embms_send_cell_info_changed_if_needed(boolean prev_lte_sys_info_valid, const nas_lte_sys_info_type_v01* prev_lte_sys_info)
{
    int need_send_unsol_resp = FALSE;
    embms_unsol_cell_info_changed_ind_msg_v01 payload;
    boolean new_lte_sys_info_valid;
    nas_lte_sys_info_type_v01* new_lte_sys_info;

    QCRIL_LOG_FUNC_ENTRY();

    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        NAS_CACHE_LOCK();
        NAS_EMBMS_CACHE_LOCK();
        if ( nas_cached_info.embms_enabled && nas_cached_info.embms_enable_success_sent_to_atel )
        {
            new_lte_sys_info_valid = nas_cached_info.lte_sys_info_valid;
            new_lte_sys_info = nas_cached_info.lte_sys_info;

            if ( new_lte_sys_info_valid && new_lte_sys_info )
            {
                memset( &payload, 0, sizeof( payload ) );
                payload.dbg_trace_id = -1;

                if (new_lte_sys_info->threegpp_specific_sys_info.cell_id_valid)
                {
                    if ( !prev_lte_sys_info_valid ||
                         NULL == prev_lte_sys_info ||
                         !prev_lte_sys_info->threegpp_specific_sys_info.cell_id_valid ||
                         prev_lte_sys_info->threegpp_specific_sys_info.cell_id != new_lte_sys_info->threegpp_specific_sys_info.cell_id
                       )
                    {
                        need_send_unsol_resp = TRUE;
                        nas_cached_info.embms_cell_id_sent_after_enabled = TRUE;
                    }
                    payload.cell_id = new_lte_sys_info->threegpp_specific_sys_info.cell_id;
                }
                else if ( prev_lte_sys_info_valid && NULL != prev_lte_sys_info && prev_lte_sys_info->threegpp_specific_sys_info.cell_id_valid )
                {
                    payload.cell_id = prev_lte_sys_info->threegpp_specific_sys_info.cell_id;
                }

                if (new_lte_sys_info->threegpp_specific_sys_info.network_id_valid)
                {
                    if ( !prev_lte_sys_info_valid ||
                         NULL == prev_lte_sys_info ||
                         !prev_lte_sys_info->threegpp_specific_sys_info.network_id_valid ||
                         memcmp(prev_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, NAS_MCC_MNC_MAX_V01) ||
                         memcmp(prev_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, NAS_MCC_MNC_MAX_V01)
                       )
                    {
                        need_send_unsol_resp = TRUE;
                        nas_cached_info.embms_cell_id_sent_after_enabled = TRUE;
                    }

                    memcpy(payload.mcc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, MCC_MNC_MAX_V01);
                    memcpy(payload.mnc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, MCC_MNC_MAX_V01);
                }
                else if ( prev_lte_sys_info_valid && NULL != prev_lte_sys_info && prev_lte_sys_info->threegpp_specific_sys_info.cell_id_valid )
                {
                    memcpy(payload.mcc, prev_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, MCC_MNC_MAX_V01);
                    memcpy(payload.mnc, prev_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, MCC_MNC_MAX_V01);
                }

                if (!nas_cached_info.embms_cell_id_sent_after_enabled)
                {
                   need_send_unsol_resp = TRUE;
                   nas_cached_info.embms_cell_id_sent_after_enabled = TRUE;
                }

                if ( 0xFF == payload.mcc[MCC_MNC_MAX_V01-1])
                {
                   payload.mcc[MCC_MNC_MAX_V01-1] = 0;
                }
                if ( 0xFF == payload.mnc[MCC_MNC_MAX_V01-1])
                {
                   payload.mnc[MCC_MNC_MAX_V01-1] = 0;
                }
            }
        }
        NAS_EMBMS_CACHE_UNLOCK();
        NAS_CACHE_UNLOCK();

        if ( need_send_unsol_resp )
        {
           QCRIL_LOG_INFO("mcc: %s, mnc: %s, cell_id: %d", payload.mcc, payload.mnc, payload.cell_id);
           qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_UNSOL_CELL_INFO_CHANGED, (char*)&payload, sizeof(payload));
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_send_cell_info_changed_if_needed

void qcril_qmi_nas_embms_send_e911_state_changed_if_needed
(
  uint8_t new_mode_valid,
  uint8_t new_mode
)
{
    uint8_t old_mode_valid;
    uint8_t old_mode;

    QCRIL_LOG_FUNC_ENTRY();

    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        NAS_CACHE_LOCK();
        old_mode_valid = nas_cached_info.emergency_mode_valid;
        old_mode = nas_cached_info.emergency_mode;
        NAS_CACHE_UNLOCK();

        if (new_mode_valid && (old_mode != new_mode || old_mode_valid != new_mode_valid))
        {
            embms_unsol_e911_state_ind_msg_v01 data;
            int data_len;

            memset(&data, 0, sizeof(data));
            data.dbg_trace_id = 0xffffffff; // Unsols have a trace id of 0xffffffff
            data.e911_state = (new_mode == NAS_CMN_EMERGENCY_MODE_ON) ? EMBMS_E911_MODE_ACTIVE_V01 :
                                                                              EMBMS_E911_MODE_INACTIVE_V01;
            data_len = sizeof(data);
            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID,
                                       QCRIL_EVT_HOOK_EMBMS_UNSOL_E911_STATE_CHANGED,
                                       (char *)&data,
                                       data_len);
        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_embms_send_embms_status
(
  uint8_t is_available
)
{
    embms_unsol_embms_status_ind_msg_v01 data;
    int data_len;
    QCRIL_LOG_FUNC_ENTRY();
    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        memset(&data, 0, sizeof(data));
        data.is_available = is_available;

        data_len = sizeof(data);
        qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID,
                                   QCRIL_EVT_HOOK_EMBMS_UNSOL_EMBMS_STATUS,
                                   (char *)&data,
                                   data_len);
        QCRIL_LOG_INFO("Setting is_embms_avaliable to %d", is_available);
    }
    QCRIL_LOG_FUNC_RETURN();
}


//===========================================================================
// qcril_qmi_nas_embms_send_radio_state
//===========================================================================
void qcril_qmi_nas_embms_send_radio_state(radio_state_enum_v01 radio_state)
{
    QCRIL_LOG_FUNC_ENTRY();
    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_EMBMS_SEND_UNSOL_RADIO_STATE,
                       &radio_state,
                       sizeof(radio_state),
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_send_radio_state

//===========================================================================
// qcril_qmi_nas_embms_send_radio_state_helper
//===========================================================================
void qcril_qmi_nas_embms_send_radio_state_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   embms_unsol_radio_state_ind_msg_v01 payload;
   uint8_t embms_enabled;
   uint8_t embms_enable_success_sent_to_atel;
   uint8_t embms_ssr_in_progress;

   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(ret_ptr);

   if (params_ptr && params_ptr->data)
   {
      NAS_EMBMS_CACHE_LOCK();
      embms_enabled = nas_cached_info.embms_enabled;
      embms_enable_success_sent_to_atel = nas_cached_info.embms_enable_success_sent_to_atel;
      embms_ssr_in_progress = nas_cached_info.embms_ssr_in_progress;
      NAS_EMBMS_CACHE_UNLOCK();
      QCRIL_LOG_INFO("embms_enabled: %d, embms_enable_success_sent_to_atel: %d, embms_ssr_in_progress: %d",
                     embms_enabled, embms_enable_success_sent_to_atel, embms_ssr_in_progress);

      if ( (embms_enabled && embms_enable_success_sent_to_atel) || embms_ssr_in_progress )
      {
         memset( &payload, 0, sizeof( payload ) );
         payload.dbg_trace_id = -1;
         payload.radio_state = *((radio_state_enum_v01*)params_ptr->data);
         QCRIL_LOG_INFO("radio_state: %d", payload.radio_state);
         qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_UNSOL_RADIO_STATE_CHANGED, (char*)&payload, sizeof(payload));

         NAS_EMBMS_CACHE_LOCK();
         if ( RADIO_STATE_NOT_AVAILABLE_V01 == payload.radio_state || RADIO_STATE_OFF_V01 == payload.radio_state)
         {
            nas_cached_info.embms_ssr_in_progress = TRUE;
            nas_cached_info.embms_enabled = FALSE;
            nas_cached_info.embms_enable_success_sent_to_atel = FALSE;
         }
         if ( RADIO_STATE_AVAILABLE_V01 == payload.radio_state && nas_cached_info.embms_ssr_in_progress )
         {
            nas_cached_info.embms_ssr_in_progress = FALSE;
         }
         NAS_EMBMS_CACHE_UNLOCK();
      }
   }
   else
   {
      QCRIL_LOG_ERROR("unexpected NULL pointer of params_ptr or params_ptr->data");
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_send_radio_state_helper

//=========================================================================
// qcril_qmi_nas_embms_get_active_log_packet_ids
//===========================================================================
void qcril_qmi_nas_embms_get_active_log_packet_ids
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
#ifndef QMI_RIL_UTF
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    embms_get_active_log_packet_ids_req_msg_v01 *req_payload = (embms_get_active_log_packet_ids_req_msg_v01* )params_ptr->data;
    embms_get_active_log_packet_ids_resp_msg_v01 resp_payload;
    memset( &resp_payload, 0, sizeof( resp_payload ) );

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    if ( NULL == req_payload )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms get_active_log_packet_ids request");
        ril_req_res = RIL_E_GENERIC_FAILURE;
    }
    else
    {
        uint32_t i;
        for (i=0; i<req_payload->supported_log_packet_id_list_len; i++)
        {
            boolean is_active_log_packet_id = FALSE;

            int diag_packet_id = req_payload->supported_log_packet_id_list[i] + QMI_RIL_EMBMS_LOG_PACKET_ID_MIN;
            if (diag_packet_id >= QMI_RIL_EMBMS_LOG_PACKET_ID_MIN && diag_packet_id <= QMI_RIL_EMBMS_LOG_PACKET_ID_MAX)
            {
                is_active_log_packet_id = log_status (diag_packet_id);
                QCRIL_LOG_INFO ("packet id %d; is_active_log_packet_id %d", (int) diag_packet_id, (int) is_active_log_packet_id);
            }

            if (is_active_log_packet_id)
            {
                resp_payload.active_log_packet_id_list[resp_payload.active_log_packet_id_list_len] = req_payload->supported_log_packet_id_list[i];
                resp_payload.active_log_packet_id_list_len++;
            }
        }
        resp_payload.dbg_trace_id = req_payload->dbg_trace_id;
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );
#endif
} // qcril_qmi_nas_embms_get_active_log_packet_ids

//=========================================================================
// qcril_qmi_nas_embms_deliver_log_packet
//===========================================================================
void qcril_qmi_nas_embms_deliver_log_packet
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
#ifndef QMI_RIL_UTF
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res = RIL_E_SUCCESS;
    qcril_qmi_nas_embms_log_type *embms_log = NULL;

    embms_deliver_log_packet_req_msg_v01 *req_payload = (embms_deliver_log_packet_req_msg_v01 *) params_ptr->data;
    embms_deliver_log_packet_resp_msg_v01 resp_payload;
    memset( &resp_payload, 0, sizeof( resp_payload ) );

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    if ( NULL == req_payload )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms deliver_log_packet request");
        ril_req_res = RIL_E_GENERIC_FAILURE;
    }
    else
    {
        int diag_packet_id = req_payload->packet_id + QMI_RIL_EMBMS_LOG_PACKET_ID_MIN;
        embms_log = (qcril_qmi_nas_embms_log_type *) log_alloc (diag_packet_id, sizeof (embms_log->hdr) + (req_payload->log_packet_len) * sizeof (int8_t));
        if (NULL != embms_log)
        {
            memcpy (embms_log->log_payload, req_payload->log_packet, (req_payload->log_packet_len) * sizeof (int8_t));
            log_commit (embms_log);
            QCRIL_LOG_INFO ("DIAG log delivered for packet id %d", diag_packet_id);
        }
        else
        {
            QCRIL_LOG_ERROR ("log_alloc failed for packet id %d", diag_packet_id);
            ril_req_res = RIL_E_GENERIC_FAILURE;
        }
        resp_payload.dbg_trace_id = req_payload->dbg_trace_id;
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );
#endif
} // qcril_qmi_nas_embms_deliver_log_packet


//=========================================================================
//  FUNCTION: is_empty_or_white_space
//===========================================================================
boolean is_operator_name_empty_or_white_space ( char * str, int max_len)
{
  boolean is_empty_or_white_space = TRUE;
  int idx = 0;

  if ( str )
  {
    for ( idx = 0; idx < max_len && str[idx] ; idx++ )
    {
      if ( str[idx] != ' ' )
      {
        is_empty_or_white_space = FALSE;
        break;
      }
    }
  }

  return is_empty_or_white_space;
}
// ** eMBMS e

//===========================================================================
// qcril_qmi_nas_setting_srv_type_based_on_elaboration_and_rat
//===========================================================================
voice_dial_call_service_type_enum_v02 qcril_qmi_nas_setting_srv_type_based_on_elaboration_and_rat
(
  uint64_t ela
)
{
    voice_dial_call_service_type_enum_v02 service_type = VOICE_DIAL_CALL_SRV_TYPE_AUTOMATIC_V02;

    bool ims_voip_in_service = qcril_qmi_nas_ims_is_ims_voip_in_service();

    NAS_CACHE_LOCK();

    if ( ela & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN ) // To verify Call to be dialled on CS
    {
       service_type = VOICE_DIAL_CALL_SRV_TYPE_CS_ONLY_V02;
       if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000) ||
                 qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000_HRPD) )
       {
          service_type = VOICE_DIAL_CALL_SRV_TYPE_CDMA_AUTOMATIC_V02;
       }
       /* Set service_type to automatic if the IMS VoIP service is not available and property
         nas_common_info.cs_srv_type is disable. */
       else if ((qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_VOICE) ||
             qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_NR5G, QMI_RIL_RTE_KIND_VOICE)) &&
             !ims_voip_in_service && !nas_common_info.cs_srv_type)
       {
           service_type = VOICE_DIAL_CALL_SRV_TYPE_AUTOMATIC_V02;
       }
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO ("SRV TYPE %d", service_type);
    return service_type;
} //qcril_qmi_nas_setting_srv_type_based_on_elaboration_and_rat

//===========================================================================
// qcril_qmi_nas_process_sib16_network_time
//===========================================================================
void qcril_qmi_nas_process_sib16_network_time
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
)
{
   QCRIL_LOG_FUNC_ENTRY();

   if(nas_common_info.sib16_support)
   {
       qcril_qmi_nas_process_sib16_network_time_for_ats_utc( universal_time,
                                                             abs_time,
                                                             time_zone_valid,
                                                             time_zone,
                                                             daylt_sav_adj_valid,
                                                             daylt_sav_adj
                                                             );
   }

   qcril_qmi_nas_process_sib16_network_time_for_ats_modem( abs_time );


   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_process_sib16_network_time

//===========================================================================
// qcril_qmi_nas_process_sib16_network_time_for_ats_utc
//===========================================================================
void qcril_qmi_nas_process_sib16_network_time_for_ats_utc
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
)
{
   QCRIL_LOG_FUNC_ENTRY();

   char ril_nitz_time[NAS_NITZ_STR_BUF_MAX];
   int ret_code;

   ret_code = 0;

   if (NULL != universal_time)
   {
      int time_zone_west=FALSE;

      if (time_zone_valid)
      {
         if (0 > time_zone)
         {
            time_zone *= -1;
            time_zone_west = TRUE;
         }
      }
      else
      {
         time_zone = 0;
      }

      if (!daylt_sav_adj_valid)
      {
        daylt_sav_adj = 0;
      }

      // accroding to ril.h the NITZ time string is in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
      QCRIL_SNPRINTF( ril_nitz_time, NAS_NITZ_STR_BUF_MAX, "%02d/%02d/%02d,%02d:%02d:%02d%c%02d,%02d",
                      (int) universal_time->year%100,
                      (int) universal_time->month,
                      (int) universal_time->day,
                      (int) universal_time->hour,
                      (int) universal_time->minute,
                      (int) universal_time->second,
                      time_zone_west ? '-' : '+',
                      (int) time_zone,
                      (int) daylt_sav_adj);
      QCRIL_LOG_INFO( "ril_nitz_time_msg is: %s", ril_nitz_time);

      auto msg = std::make_shared<RilUnsolNitzTimeReceivedMessage>(ril_nitz_time);
      Dispatcher::getInstance().dispatchSync(msg);

      time_genoff_info_type time_set;
      time_set.base = ATS_UTC;
      time_set.unit = TIME_MSEC;
      time_set.operation = T_SET;
      // convert the abs_time from an offset of "Jan 6, 1980 00:00:00" to an offset of "Jan 1, 1970 00:00:00"
      abs_time = abs_time + NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_6_1980_IN_MILLI_SEC;
      time_set.ts_val = &abs_time;
      ret_code = time_genoff_operation(&time_set);
      if(!ret_code)
      {
         QCRIL_LOG_INFO("set UTC successfully using sib16 time, abs time (%x, %x)",
                        (uint32) (abs_time >> 32),
                        (uint32) abs_time);
      }
      else
      {
         QCRIL_LOG_ESSENTIAL("QCRIL_WARNING:SET_TIME: unable to set UTC using sib16 time, error %d",
                        ret_code);
      }
   }
   else
   {
      QCRIL_LOG_ERROR("universal_time is NULL");
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_process_sib16_network_time_for_ats_utc

//===========================================================================
// qcril_qmi_nas_process_sib16_network_time_for_ats_modem
//===========================================================================
void qcril_qmi_nas_process_sib16_network_time_for_ats_modem(uint64_t abs_time)
{
   QCRIL_LOG_FUNC_ENTRY();

   int ret_code;
   time_genoff_info_type time_set;

   ret_code = 0;
   time_set.base = ATS_MODEM;
   time_set.unit = TIME_MSEC;
   time_set.operation = T_SET;
   // convert the abs_time from an offset of "Jan 6, 1980 00:00:00" to an offset of "Jan 1, 1970 00:00:00"
   abs_time = abs_time + NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_6_1980_IN_MILLI_SEC;
   time_set.ts_val = &abs_time;
   ret_code = time_genoff_operation(&time_set);
   if(!ret_code)
   {
       QCRIL_LOG_INFO("set MODEM successfully using sib16 time, abs time (%x, %x)",
                      (uint32) (abs_time >> 32),
                      (uint32) abs_time);
   }
   else
   {
       QCRIL_LOG_ESSENTIAL("QCRIL_WARNING:SET_TIME: unable to set MODEM using sib16 time, error %d",
                      ret_code);
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_process_sib16_network_time_for_ats_modem

//===========================================================================
// qcril_qmi_nas_fetch_sib16_network_time
//===========================================================================
void qcril_qmi_nas_fetch_sib16_network_time
(
   bool time_zone_valid,
   int8_t time_zone,
   bool daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
)
{
   QCRIL_LOG_FUNC_ENTRY();

   uint8_t prev_lte_sib16_acquired_valid, prev_lte_sib16_acquired;
   RIL_Errno res = RIL_E_SUCCESS;

   nas_get_lte_sib16_network_time_resp_msg_v01 qmi_response;
   memset(&qmi_response, 0, sizeof(qmi_response));

   qmi_client_error_type qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_LTE_SIB16_NETWORK_TIME_REQ_MSG_V01,
                                                            NULL,
                                                            NAS_NIL,
                                                            (void*) &qmi_response,
                                                            sizeof(qmi_response));

   res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, &qmi_response.resp);

   if (RIL_E_SUCCESS != res)
   {
      QCRIL_LOG_ERROR("qcril_qmi_client_send_msg_sync failure: %d", errno);
   }
   else
   {
     NAS_CACHE_LOCK();
     prev_lte_sib16_acquired_valid = nas_cached_info.lte_sib16_acquired_valid;
     prev_lte_sib16_acquired = (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired);
     NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired,
                                qmi_response.lte_sib16_acquired);

     qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(
         prev_lte_sib16_acquired_valid,
         prev_lte_sib16_acquired,
         nas_cached_info.lte_sib16_acquired_valid,
         NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired );

     if (qmi_response.lte_sib16_acquired_valid && (NAS_TRI_TRUE_V01 == qmi_response.lte_sib16_acquired))
     {
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

         NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.leap_seconds,
                                    qmi_response.leap_sec);

        /* When TZ and/or DST information is missing in SIB16 broadcasts, use
        * QMI_NAS_GET_NETWORK_TIME_REQ_MSG to get this information from the
        * contents of the last EMM information message sent by the network. */
        if (!qmi_response.time_zone_valid || !qmi_response.daylt_sav_adj_valid)
        {
           if (time_zone_valid && daylt_sav_adj_valid)
           {
              NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.day_light_saving,
                                             daylt_sav_adj);
              NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.local_time_offset,
                                             time_zone);
           }
           else
           {
              qcril_qmi_nas_query_network_time(NULL);
              if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving) && !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset))
              {
                NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                             qmi_response.daylt_sav_adj);
                NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                             qmi_response.time_zone);
              }
           }
        }
        else
        {
           NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                      qmi_response.daylt_sav_adj);
           NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                      qmi_response.time_zone);
        }

        if (qmi_response.universal_time_valid && qmi_response.abs_time_valid)
        {
           qcril_qmi_nas_process_sib16_network_time( &qmi_response.universal_time,
                                                     qmi_response.abs_time,
                                                     nas_cached_info.local_time_offset_valid,
                                                     nas_cached_info.local_time_offset,
                                                     nas_cached_info.day_light_saving_valid,
                                                     nas_cached_info.day_light_saving
                                                   );
        }
        else
        {
           QCRIL_LOG_ERROR("ignore the response as it does not contain all the necessary information");
        }
     }
     NAS_CACHE_UNLOCK();
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_fetch_sib16_network_time

//===========================================================================
// qcril_qmi_nas_sib16_network_time_ind_hdlr
//===========================================================================
void qcril_qmi_nas_sib16_network_time_ind_hdlr(const nas_lte_sib16_network_time_ind_msg_v01* decoded_payload)
{
   QCRIL_LOG_FUNC_ENTRY();

   uint8_t prev_lte_sib16_acquired_valid, prev_lte_sib16_acquired;

   if (NULL != decoded_payload)
   {
      NAS_CACHE_LOCK();
      prev_lte_sib16_acquired_valid = nas_cached_info.lte_sib16_acquired_valid;
      prev_lte_sib16_acquired = (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired);
      NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired, decoded_payload->lte_sib16_acquired);

      qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(
         prev_lte_sib16_acquired_valid,
         prev_lte_sib16_acquired,
         nas_cached_info.lte_sib16_acquired_valid,
         NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired );

      if(!prev_lte_sib16_acquired_valid && decoded_payload->lte_sib16_acquired_valid)
      {
        NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
        NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
        NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);
      }

      if (decoded_payload->lte_sib16_acquired_valid && decoded_payload->lte_sib16_acquired)
      {
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
         NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.leap_seconds,
                                    decoded_payload->leap_sec);

         if (decoded_payload->time_zone_valid && decoded_payload->daylt_sav_adj_valid)
         {
            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                       decoded_payload->time_zone);
            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                       decoded_payload->daylt_sav_adj);
         }
         else
         {
            /* When TZ and/or DST information is missing in SIB16 broadcasts, use
             * QMI_NAS_GET_NETWORK_TIME_REQ_MSG to get this information from the
             * contents of the last EMM information message sent by the network. */
            qcril_qmi_nas_query_network_time(NULL);
            if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving) && !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset))
            {
                NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                             decoded_payload->daylt_sav_adj);
                NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                             decoded_payload->time_zone);
            }
         }

         if ( decoded_payload->universal_time_valid && decoded_payload->abs_time_valid )
         {
            qcril_qmi_nas_process_sib16_network_time(&(decoded_payload->universal_time),
                                                     decoded_payload->abs_time,
                                                     nas_cached_info.local_time_offset_valid,
                                                     nas_cached_info.local_time_offset,
                                                     nas_cached_info.day_light_saving_valid,
                                                     nas_cached_info.day_light_saving);
         }
         else
         {
            QCRIL_LOG_ERROR("ignore the indication as it does not contain all the necessary information");
         }
      }
      NAS_CACHE_UNLOCK();
   }
   else
   {
      QCRIL_LOG_ERROR("decoded_payload is NULL");
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_sib16_network_time_ind_hdlr

//===========================================================================
// qcril_qmi_nas_convert_julian_time_to_abs_time
//      convert the julina time to abs_time as an offset of "Jan 1, 1970 00:00:00"
//===========================================================================
uint64_t qcril_qmi_nas_convert_julian_time_to_abs_time(uint16_t year, uint8_t month, uint8_t day,
                                                       uint8_t hour, uint8_t minute, uint8_t second, uint16_t milli_second)
{
   // year
   uint16_t year_offset = year-1970;
   uint days_offset = year_offset * 365;
   days_offset += (year_offset + 1) / 4; // and all the years % 4 == 0 need to add one day (do not consider year 2100 here)

   // month
   uint8_t days_of_month[13] = { 0, 31, 28, 31, 30, 31, 30,
                                    31, 31, 30, 31, 30, 31 };
   uint8_t i;
   for (i=1; i<month; i++)
   {
      days_offset += days_of_month[i];
   }
   if ( month > 2 && (0 == (year_offset + 2) % 4 ) )
   {
      days_offset++;
   }

   // day
   days_offset += day - 1;

   // to milli_second
   uint64_t ret = ((((uint64_t) days_offset * 24 + (uint64_t) hour) * 60 + (uint64_t) minute) * 60 + (uint64_t) second) * 1000 + (uint64_t) milli_second;

   QCRIL_LOG_INFO("return milli_second 0x%x %x", (int)(ret >> 32), (int)ret);

   return ret;
} // qcril_qmi_nas_convert_julian_time_to_abs_time

//===========================================================================
// qcril_qmi_nas_send_unsol_sib16_coverage_if_needed
//===========================================================================
void qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(uint8_t prev_lte_sib16_coverage_valid,
                                                       uint8_t prev_lte_sib16_coverage,
                                                       uint8_t curr_lte_sib16_coverage_valid,
                                                       uint8_t curr_lte_sib16_coverage)
{
    embms_unsol_sib16_coverage_ind_msg_v01 payload;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &payload, 0, sizeof( payload ) );

    if(nas_common_info.sib16_support)
    {
        QCRIL_LOG_INFO("lte sib16 coverage: previous valid %d, value %d, current valid %d, value %d",
                       prev_lte_sib16_coverage_valid,
                       prev_lte_sib16_coverage,
                       curr_lte_sib16_coverage_valid,
                       curr_lte_sib16_coverage);

        if ( TRUE == curr_lte_sib16_coverage_valid &&
             ((FALSE == prev_lte_sib16_coverage_valid) ||
             (prev_lte_sib16_coverage != curr_lte_sib16_coverage))
           )
        {
            payload.in_coverage = curr_lte_sib16_coverage;
            qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_EVT_HOOK_EMBMS_UNSOL_SIB16_COVERAGE,
                                      (char*)&payload,
                                      sizeof(payload));
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_send_unsol_sib16_coverage_if_needed

//===========================================================================
// qcril_qmi_nas_embms_get_sib16_coverage
//===========================================================================
void qcril_qmi_nas_embms_get_sib16_coverage
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_sib16_coverage_resp_msg_v01 resp_payload;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    ril_req_res = RIL_E_SUCCESS;
    memset(&resp_payload,
           0,
           sizeof(resp_payload));


    if(NULL !=params_ptr)
    {
        NAS_CACHE_LOCK();

        QCRIL_LOG_INFO("lte sib16 coverage: valid %d, value %d",
                       NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired),
                       nas_cached_info.lte_sib16_acquired);

        if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired))
        {
            resp_payload.in_coverage = (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired);
        }

        NAS_CACHE_UNLOCK();

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &resp_payload;
        resp.resp_len = sizeof( resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_sib16_coverage

//===========================================================================
// qcril_qmi_nas_embms_set_sntp_time
//===========================================================================
void qcril_qmi_nas_embms_set_sntp_time
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_resp_params_type resp;
  RIL_Errno ril_req_res;
  embms_set_sntp_time_req_msg_v01 req_payload;
  embms_set_sntp_time_resp_msg_v01 resp_payload;
  uint64_t abs_time;
  uint64_t system_time;
  time_genoff_info_type time_set;
  int ret_code;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  ril_req_res = RIL_E_GENERIC_FAILURE;
  memset(&req_payload,
         0,
         sizeof(req_payload));
  memset(&resp_payload,
         0,
         sizeof(resp_payload));
  abs_time = 0;
  system_time = 0;
  memset(&time_set,
         0,
         sizeof(time_set));
  ret_code = 0;

  if (NULL != params_ptr && params_ptr->datalen <= sizeof(req_payload))
  {
      NAS_CACHE_LOCK();

      QCRIL_LOG_INFO("lte sib16 coverage: valid %d, value %d",
                     NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired),
                     nas_cached_info.lte_sib16_acquired);

      if(FALSE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired) ||
         NAS_TRI_TRUE_V01 != nas_cached_info.lte_sib16_acquired)
      {
          memcpy(&req_payload, params_ptr->data, params_ptr->datalen);
          QCRIL_LOG_INFO("sntp: available %d, time valid %d, value (%x, %x), stamp valid %d, "
                         "value (%x, %x)",
                         req_payload.sntp_available,
                         req_payload.sntp_time_milli_sec_valid,
                         (uint32) (req_payload.sntp_time_milli_sec >> 32),
                         (uint32) req_payload.sntp_time_milli_sec,
                         req_payload.time_stamp_milli_sec_valid,
                         (uint32) (req_payload.time_stamp_milli_sec >> 32),
                         (uint32) req_payload.time_stamp_milli_sec);

          NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.sntp_available,
                                         req_payload.sntp_available);
          if(TRUE == req_payload.sntp_available)
          {
              NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
              NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
              NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

              if(TRUE == req_payload.sntp_time_milli_sec_valid)
              {
                  /*
                  SNTP time is already in offset of "Jan 1, 1970 00:00:00"
                  */
                  abs_time = req_payload.sntp_time_milli_sec;
                  if(nas_common_info.sib16_support)
                  {
                      time_set.base = ATS_UTC;
                      time_set.unit = TIME_MSEC;
                      time_set.operation = T_SET;
                      time_set.ts_val = &abs_time;
                      ret_code = time_genoff_operation(&time_set);
                      if(!ret_code)
                      {
                          ril_req_res = RIL_E_SUCCESS;
                          QCRIL_LOG_INFO("set UTC successfully using sntp time, abs time (%x, %x)",
                                         (uint32) (abs_time >> 32),
                                         (uint32) abs_time);
                      }
                      else
                      {
                          QCRIL_LOG_ESSENTIAL("QCRIL_WARNING:SET_TIME: unable to set UTC "
                                         "using sntp time, error %d", ret_code);
                      }
                  }

                  time_set.base = ATS_MODEM;
                  time_set.unit = TIME_MSEC;
                  time_set.operation = T_SET;
                  time_set.ts_val = &abs_time;
                  ret_code = time_genoff_operation(&time_set);
                  if(!ret_code)
                  {
                      ril_req_res = RIL_E_SUCCESS;
                      QCRIL_LOG_INFO("set MODEM successfully using sntp time, abs time (%x, %x)",
                                     (uint32) (abs_time >> 32),
                                     (uint32) abs_time);
                  }
                  else
                  {
                      QCRIL_LOG_ESSENTIAL("QCRIL_WARNING:SET_TIME: unable to set MODEM "
                                     "using sntp time, error %d", ret_code);
                  }
              }
              else
              {
                  QCRIL_LOG_INFO("sntp time milli sec is needed to set time");
              }
          }
          else
          {
              ril_req_res = RIL_E_SUCCESS;
          }
      }
      else
      {
          ril_req_res = RIL_E_SUCCESS;
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
          QCRIL_LOG_INFO("lte sib16 coverage acquired, sntp time ignored");
      }

      NAS_CACHE_UNLOCK();

      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      resp.resp_pkt = (void *) &resp_payload;
      resp.resp_len = sizeof( resp_payload );
      qcril_send_request_response( &resp );
  }
  else
  {
      QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_embms_set_sntp_time

//===========================================================================
// QCRIL_EVT_HOOK_EMBMS_GET_E911_STATE
//===========================================================================
void qcril_qmi_nas_embms_get_e911_state
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_e911_state_req_msg_v01 *ril_req_payload;
    embms_get_e911_state_resp_msg_v01 ril_resp_payload;
    uint8_t emergency_mode = NAS_CMN_EMERGENCY_MODE_OFF;
    QCRIL_NOTUSED(ret_ptr);


    QCRIL_LOG_FUNC_ENTRY();

    ril_req_res = RIL_E_GENERIC_FAILURE;


    if (NULL != params_ptr &&
        params_ptr->data &&
        params_ptr->datalen >= sizeof(*ril_req_payload))
    {

        ril_req_payload = (embms_get_e911_state_req_msg_v01 *) params_ptr->data;
        ril_req_res = RIL_E_SUCCESS;
        memset(&ril_resp_payload, 0, sizeof(ril_resp_payload));
        ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
        ril_resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;
        ril_resp_payload.e911_state_valid = TRUE;
        NAS_CACHE_LOCK();
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_mode ))
        {
            emergency_mode = nas_cached_info.emergency_mode;
        }
        NAS_CACHE_UNLOCK();
        if (emergency_mode == NAS_CMN_EMERGENCY_MODE_ON) {
            ril_resp_payload.e911_state = EMBMS_E911_MODE_ACTIVE_V01;
        } else {
            ril_resp_payload.e911_state = EMBMS_E911_MODE_INACTIVE_V01;
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &ril_resp_payload;
        resp.resp_len = sizeof( ril_resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_e911_state

void qcril_qmi_nas_embms_get_sib_plmn_cb
(
    unsigned int                   message_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    qcril_request_resp_params_type   resp;
    embms_get_sib_plmn_resp_msg_v01  ril_resp_payload;
    nas_get_serv_cell_sib_resp_msg_v01 *qmi_response =
      (nas_get_serv_cell_sib_resp_msg_v01 *) resp_c_struct.get();
    RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type        request_info;

    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    QCRIL_NOTUSED(message_id);
    QCRIL_NOTUSED(resp_c_struct_len);
    QCRIL_NOTUSED(resp_cb_data);

    memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
    NAS_SIB_CACHE_LOCK();
    ril_resp_payload.dbg_trace_id = sib_info.dbg_trace_id;

    if ( qmi_response )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(transp_err,
                                                                              &qmi_response->resp);
        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d",
                       (int) ril_req_res,
                       (int)transp_err,
                       (int) qmi_response->resp.error );

        if ( E_SUCCESS != qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID,
                                                         QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN,
                                                         &request_info))
        {
            QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN not found");
        }
        else
        {
            // QMI RESP Success, update NAS cache, RIL RESP will be sent by QMI IND
            if ((RIL_E_SUCCESS == ril_req_res) && (qmi_response->total_size_valid))
            {
              // Update nas cache, allocate memory, wait for indication
              sib_info.current_size = 0;
              sib_info.sequence = 0;
              sib_info.bin_data.len = qmi_response->total_size;
              sib_info.bin_data.data = (uint8_t *) qcril_malloc(qmi_response->total_size);
              QCRIL_LOG_INFO(".. total_size_valid: %d, total_size: %d",
                             qmi_response->total_size_valid,
                             qmi_response->total_size);
            }
            else // QMI RESP Error, send RIL RESP FAIL
            {
              if (!qmi_response->total_size_valid)
              {
                QCRIL_LOG_ERROR("total size not valid");
              }
              qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                                 request_info.t,
                                                 request_info.request,
                                                 ril_req_res,
                                                 &resp );
              resp.resp_pkt = (void *) &ril_resp_payload;
              resp.resp_len = sizeof( ril_resp_payload );
              qcril_send_request_response( &resp );
            }
        }
    }
    else
    {
      QCRIL_LOG_ERROR("qmi_response is NULL");
    }
    NAS_SIB_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_embms_get_sib_plmn_cb

//===========================================================================
// QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN
//===========================================================================
void qcril_qmi_nas_embms_get_sib_plmn
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_resp_params_type resp;
  RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_reqlist_public_type      qcril_req_info_ptr;

  embms_get_sib_plmn_req_msg_v01 *ril_req_payload =
    (embms_get_sib_plmn_req_msg_v01*)params_ptr->data;
  embms_get_sib_plmn_resp_msg_v01 ril_resp_payload;
  nas_get_serv_cell_sib_req_msg_v01 qmi_req;
  nas_get_serv_cell_sib_resp_msg_v01 *qmi_resp;

  qcril_reqlist_public_type        request_info;
  qmi_client_error_type          qmi_client_error;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  do
  {
      // If same request is already there, just ignore this one
      if ( E_SUCCESS == qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID,
                                                       QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN,
                                                       &request_info))
      {
        QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN already present");
        QCRIL_LOG_FUNC_RETURN();
        return;
      }

      if ( NULL == ril_req_payload )
      {
          QCRIL_LOG_ERROR("invalid NULL parameter for embms get sib plmn");
          break;
      }

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE,
                                   NULL,
                                   &qcril_req_info_ptr );
      if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr))
      {
          QCRIL_LOG_ERROR("failed to create request");
          break;
      }

      memset( &qmi_req, 0, sizeof( qmi_req ) );
      // Hardcode sib_num to 1
      qmi_req.sib_num = 1;

      NAS_SIB_CACHE_LOCK();
      memset(&sib_info, 0, sizeof(sib_info));
      sib_info.dbg_trace_id = ril_req_payload->dbg_trace_id;
      NAS_SIB_CACHE_UNLOCK();

      qmi_client_error =  qmi_client_nas_send_async(
                                 QMI_NAS_GET_SERV_CELL_SIB_REQ_MSG_V01,
                                 &qmi_req,
                                 sizeof( qmi_req ),
                                 sizeof( *qmi_resp ),
                                 qcril_qmi_nas_embms_get_sib_plmn_cb,
                                 NULL);

      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_client_error, NULL);

      if ( RIL_E_SUCCESS != ril_req_res )
      {
          QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d",
                           (int)ril_req_res,
                           (int)qmi_client_error);
      }
  } while ( 0 );

  if ( RIL_E_SUCCESS != ril_req_res )
  {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      if ( NULL != ril_req_payload )
      {
          memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
          ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
          resp.resp_pkt = (void *) &ril_resp_payload;
          resp.resp_len = sizeof( ril_resp_payload );
      }
      qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_sib_plmn

//===========================================================================
// QCRIL_EVT_HOOK_EMBMS_GET_EMBMS_STATUS
//===========================================================================
void qcril_qmi_nas_embms_get_embms_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_embms_status_req_msg_v01 *ril_req_payload;
    embms_get_embms_status_resp_msg_v01 ril_resp_payload;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    ril_req_res = RIL_E_GENERIC_FAILURE;

    if (NULL != params_ptr &&
        params_ptr->data &&
        params_ptr->datalen >= sizeof(*ril_req_payload))
    {

        ril_req_payload = (embms_get_embms_status_req_msg_v01 *) params_ptr->data;
        ril_req_res = RIL_E_SUCCESS;
        memset(&ril_resp_payload, 0, sizeof(ril_resp_payload));
        ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
        NAS_EMBMS_CACHE_LOCK();
        ril_resp_payload.is_available = nas_cached_info.is_embms_available;
        NAS_EMBMS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("is_embms_avaliable = %d", ril_resp_payload.is_available);

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &ril_resp_payload;
        resp.resp_len = sizeof( ril_resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_embms_status

//===========================================================================
// qcril_qmi_nas_embms_get_utc_time
//===========================================================================
void qcril_qmi_nas_embms_get_utc_time
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_utc_time_req_msg_v01  req_payload;
    embms_get_utc_time_resp_msg_v01 resp_payload;
    time_genoff_info_type time_get;
    uint64_t abs_time;
    int ret_code;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    ril_req_res = RIL_E_GENERIC_FAILURE;
    memset(&req_payload,
           0,
           sizeof(req_payload));
    memset(&resp_payload,
           0,
           sizeof(resp_payload));
    memset(&time_get,
           0,
           sizeof(time_get));
    abs_time = 0;
    ret_code = 0;


    if (NULL != params_ptr && params_ptr->datalen <= sizeof(req_payload))
    {
        memcpy(&req_payload, params_ptr->data, params_ptr->datalen);
        QCRIL_LOG_INFO("utc dbg trace id %d",
                       req_payload.dbg_trace_id);

        time_get.base = ATS_UTC;
        time_get.unit = TIME_MSEC;
        time_get.operation = T_GET;
        time_get.ts_val = &abs_time;
        ret_code = time_genoff_operation(&time_get);
        if(!ret_code)
        {
            resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;
            ril_req_res = RIL_E_SUCCESS;
            QCRIL_LOG_INFO("retrieved UTC successfully");
        }
        else
        {
            resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
            QCRIL_LOG_ESSENTIAL("QCRIL_WARNING:SET_TIME: unable to retrieve UTC, error %d",
                           ret_code);
        }

        resp_payload.dbg_trace_id = req_payload.dbg_trace_id;
        if(time_get.ts_val)
        {
            resp_payload.milli_sec = *((uint64_t*) time_get.ts_val);
        }

        NAS_CACHE_LOCK();
        if(TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving))
        {
            resp_payload.day_light_saving_valid = TRUE;
            resp_payload.day_light_saving = nas_cached_info.day_light_saving;
        }
        if(TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.leap_seconds))
        {
            resp_payload.leap_seconds_valid = TRUE;
            resp_payload.leap_seconds = nas_cached_info.leap_seconds;
        }
        if(TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset))
        {
            resp_payload.local_time_offset_valid = TRUE;
            resp_payload.local_time_offset = nas_cached_info.local_time_offset;
        }
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("utc time (%x, %x), daylight valid %d, value %d,"
                       "leap sec valid %d, value %d, offset valid %d value %d",
                       (uint32) (resp_payload.milli_sec >> 32),
                       (uint32) resp_payload.milli_sec,
                       resp_payload.day_light_saving_valid,
                       resp_payload.day_light_saving,
                       resp_payload.leap_seconds_valid,
                       resp_payload.leap_seconds,
                       resp_payload.local_time_offset_valid,
                       resp_payload.local_time_offset);

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &resp_payload;
        resp.resp_len = sizeof( resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_utc_time

//===========================================================================
// qcril_qmi_nas_connected_emergency_call_end_hdlr
//===========================================================================
void qcril_qmi_nas_connected_emergency_call_end_hdlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   boolean need_to_send_unsol = FALSE;
   qcril_nas_emer_call_end_hndlr_params *hdlr_params = NULL;

   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(ret_ptr);

   uint32_t slot = qmi_ril_get_sim_slot();
   hdlr_params = (qcril_nas_emer_call_end_hndlr_params *) params_ptr->data;

   if(hdlr_params == NULL)
   {
      return;
   }

   int is_eme_call_connected = hdlr_params->is_eme_call_connected;

   if(is_eme_call_connected)
   {
      NAS_CACHE_LOCK();
      nas_cached_info.is_eme_ip_call = hdlr_params->is_eme_ip_call;

      if (nas_cached_info.nas_enter_ecbm_propagation_pending)
      {
         need_to_send_unsol = TRUE;
         nas_cached_info.nas_enter_ecbm_propagation_pending = FALSE;
      }
      else
      {
         nas_cached_info.eme_call_end_recently = TRUE;

         const struct timeval TIMER = { 3 , 0 }; // 3 seconds
         qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
                                     qcril_qmi_nas_eme_call_end_recently_timeout_cb,
                                     &TIMER, &nas_cached_info.eme_call_end_recently_tcb_id);

      }
      NAS_CACHE_UNLOCK();

      if (need_to_send_unsol)
      {
         qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_ACTIVE );
      }
   }
   else
   {
      QCRIL_LOG_DEBUG("Emergency call was not connected...");
   }

   NAS_CACHE_LOCK();
   qcril_uim_card_status_e_type card_status = nas_common_info.card_info[ slot ].status;
   int prov_status = nas_common_info.prov_status;
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_DEBUG("need_to_send_unsol: %d prov_status: %d card_status: %d",
                                need_to_send_unsol, prov_status, card_status);
   if((need_to_send_unsol == FALSE) &&
      (prov_status != RIL_E_SUCCESS) && (card_status == QCRIL_CARD_STATUS_UP))
   {
      QCRIL_LOG_DEBUG("check sim provisioning state...");
      qcril_qmi_nas_prov_check_sim_provisioning();
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_connected_emergency_call_end_hdlr


//===========================================================================
// qcril_qmi_nas_emergency_mode_on_hdlr
//===========================================================================
void qcril_qmi_nas_emergency_mode_on_hdlr()
{
   boolean need_to_send_unsol = FALSE;

   QCRIL_LOG_FUNC_ENTRY();

   NAS_CACHE_LOCK();
   if (nas_cached_info.eme_call_end_recently)
   {
      need_to_send_unsol = TRUE;
      nas_cached_info.eme_call_end_recently = FALSE;
      qcril_cancel_timed_callback((void *)(uintptr_t)nas_cached_info.eme_call_end_recently_tcb_id);
   }
   else
   {
      nas_cached_info.nas_enter_ecbm_propagation_pending = TRUE;
   }
   NAS_CACHE_UNLOCK();

   if (need_to_send_unsol)
   {
      qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_ACTIVE );
   }
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_emergency_mode_on_hdlr

//===========================================================================
// qcril_qmi_nas_emergency_mode_off_hdlr
//===========================================================================
void qcril_qmi_nas_emergency_mode_off_hdlr()
{
   QCRIL_LOG_FUNC_ENTRY();

   NAS_CACHE_LOCK();
   uint32_t slot = qmi_ril_get_sim_slot();
   qcril_uim_card_status_e_type card_status = nas_common_info.card_info[ slot ].status;
   int prov_status = nas_common_info.prov_status;

   nas_cached_info.nas_enter_ecbm_propagation_pending = FALSE;
   if (nas_cached_info.eme_call_end_recently)
   {
      nas_cached_info.eme_call_end_recently = FALSE;
      qcril_cancel_timed_callback((void *)(uintptr_t)nas_cached_info.eme_call_end_recently_tcb_id);
   }
   NAS_CACHE_UNLOCK();
   qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_NOT_ACTIVE );

   QCRIL_LOG_DEBUG("prov_status: %d card_status: %d", prov_status, card_status);
   if((prov_status != RIL_E_SUCCESS) && (card_status == QCRIL_CARD_STATUS_UP))
   {
      QCRIL_LOG_DEBUG("check sim prov state...");
      qcril_qmi_nas_prov_check_sim_provisioning();
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_emergency_mode_off_hdlr

//===========================================================================
// qcril_qmi_nas_eme_call_end_recently_timeout_cb
//===========================================================================
void qcril_qmi_nas_eme_call_end_recently_timeout_cb(void * params)
{
   boolean result = FALSE;
   QCRIL_LOG_FUNC_ENTRY();

   QCRIL_NOTUSED(params);

   result = qcril_qmi_voice_nas_control_is_any_calls_present();
   NAS_CACHE_LOCK();
   nas_cached_info.eme_call_end_recently = FALSE;
   if ( !result )
   {
      qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally(NULL);
   }
   NAS_CACHE_UNLOCK();
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_eme_call_end_recently_timeout_cb

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_get_engineer_mode_info_timeout_handler

===========================================================================*/
/*!
    @brief
    Timeout handler when the timer for engineer mode information report expired.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_nas_get_engineer_mode_info_timeout_handler(sigval_t sval)
{
  struct cdma_ftm_data *cdma_data = NULL;
  struct gsm_ftm_data *gsm_data = NULL;
  struct wcdma_ftm_data *wcdma_data = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  (void)sval;

  do
  {
    if( FTM_SUBSCRIPTION_CDMA == qcril_qmi_nas_get_engineer_mode_info_timer.subs_type)
    {
      cdma_data = (cdma_ftm_data *) qcril_malloc(sizeof(*cdma_data));
      if( NULL == cdma_data)
      {
        QCRIL_LOG_INFO("Memory not allocated for cdma_ftm_data");
        break;
      }

      qcril_qmi_nas_get_field_test_mode_info_for_cdma( cdma_data );
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_ENGINEER_MODE, (char *)cdma_data, sizeof(*cdma_data));
    }
    else if( FTM_SUBSCRIPTION_GSM == qcril_qmi_nas_get_engineer_mode_info_timer.subs_type)
    {
      gsm_data = (gsm_ftm_data *) qcril_malloc(sizeof(*gsm_data));
      if( NULL == gsm_data)
      {
        QCRIL_LOG_INFO("Memory not allocated for gsm_ftm_data");
        break;
      }

      qcril_qmi_nas_get_field_test_mode_info_for_gsm( gsm_data );
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_ENGINEER_MODE, (char *)gsm_data, sizeof(*gsm_data));
    }
    else if( FTM_SUBSCRIPTION_WCDMA == qcril_qmi_nas_get_engineer_mode_info_timer.subs_type)
    {
      wcdma_data = (wcdma_ftm_data *) qcril_malloc(sizeof(*wcdma_data));
      if( NULL == wcdma_data)
      {
        QCRIL_LOG_INFO("Memory not allocated for gsm_ftm_data");
        break;
      }

      qcril_qmi_nas_get_field_test_mode_info_for_wcdma( wcdma_data );
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_ENGINEER_MODE, (char *)wcdma_data, sizeof(*wcdma_data));
    }

    if( NULL != cdma_data)
    {
      qcril_free( cdma_data );
      cdma_data = NULL;
    }

    if( NULL != gsm_data)
    {
      qcril_free( gsm_data );
      gsm_data = NULL;
    }

    if( NULL != wcdma_data)
    {
      qcril_free( wcdma_data );
      wcdma_data = NULL;
    }
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_start_get_engineer_mode_info_timer

===========================================================================*/
/*!
    @brief
    Start the timer for engineer mode information report.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_nas_start_get_engineer_mode_info_timer(qcril_instance_id_e_type instance_id,
            oem_hook_ftm_subscription_source_e_type subs_type)
{
  struct sigevent sigev;
  struct itimerspec itimers;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if (qcril_qmi_nas_get_engineer_mode_info_timer.timer_started)
    {
      QCRIL_LOG_DEBUG("%s","timer is already started,ignore");
      break;
    }

    qcril_qmi_nas_get_engineer_mode_info_timer.instance_id = instance_id;
    qcril_qmi_nas_get_engineer_mode_info_timer.subs_type = subs_type;
    sigev.sigev_notify = SIGEV_THREAD;
    sigev.sigev_notify_attributes = NULL;
    sigev.sigev_value.sival_ptr = &qcril_qmi_nas_get_engineer_mode_info_timer;
    sigev.sigev_notify_function = qcril_qmi_nas_get_engineer_mode_info_timeout_handler;

    if (timer_create(CLOCK_REALTIME,&sigev,&qcril_qmi_nas_get_engineer_mode_info_timer.timer_id) == -1)
    {
      QCRIL_LOG_ERROR("%s","failed to create no service guard timer");
      break;
    }

    itimers.it_value.tv_sec = 1; // 1sec
    itimers.it_value.tv_nsec = 0;
    itimers.it_interval.tv_sec = 1; // 1sec
    itimers.it_interval.tv_nsec = 0;

    if (timer_settime(qcril_qmi_nas_get_engineer_mode_info_timer.timer_id,0,&itimers,NULL) == -1)
    {
      QCRIL_LOG_ERROR("%s","failed to start timer,delete it");
      timer_delete(qcril_qmi_nas_get_engineer_mode_info_timer.timer_id);
      qcril_qmi_nas_get_engineer_mode_info_timer.timer_id = 0;
      break;
    }

    QCRIL_LOG_DEBUG("TIMER ID %d started",qcril_qmi_nas_get_engineer_mode_info_timer.timer_id);
    qcril_qmi_nas_get_engineer_mode_info_timer.timer_started = TRUE;
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_stop_get_engineer_mode_info_timer

===========================================================================*/
/*!
    @brief
    Stop the timer for engineer mode information report.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_nas_stop_get_engineer_mode_info_timer(qcril_instance_id_e_type instance_id,
            oem_hook_ftm_subscription_source_e_type subs_type)
{
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(instance_id);

  if ( ( qcril_qmi_nas_get_engineer_mode_info_timer.timer_started )
        && ( qcril_qmi_nas_get_engineer_mode_info_timer.subs_type == subs_type ) )
  {
    QCRIL_LOG_DEBUG("%s","stop the timer for engineer mode information report");
    timer_delete(qcril_qmi_nas_get_engineer_mode_info_timer.timer_id);
    qcril_qmi_nas_get_engineer_mode_info_timer.timer_started = FALSE;
    qcril_qmi_nas_get_engineer_mode_info_timer.timer_id = 0;
    qcril_qmi_nas_get_engineer_mode_info_timer.subs_type = FTM_SUBSCRIPTION_INVALID;
  }
  else
  {
    QCRIL_LOG_DEBUG("%s","timer is already stoped,ignore");
  }

  QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// Function: qcril_qmi_nas_get_field_test_mode_info_for_cdma
// To get data for cdma
//===========================================================================
void qcril_qmi_nas_get_field_test_mode_info_for_cdma( struct cdma_ftm_data *cdma_data)
{
    qmi_client_error_type qmi_client_error;
    nas_get_sys_info_resp_msg_v01 get_sys_info_response;
    nas_get_cell_location_info_resp_msg_v01 get_cell_loc_info_response;
    nas_get_sig_info_resp_msg_v01 get_sig_info_response;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char mnc_str[NAS_MCC_MNC_MAX_SIZE];

    QCRIL_LOG_FUNC_ENTRY();

    memset(&get_sys_info_response,0,sizeof(get_sys_info_response));
    memset(&get_cell_loc_info_response,0,sizeof(get_cell_loc_info_response));
    memset(&get_sig_info_response,0,sizeof(get_sig_info_response));
    memset(mcc_str,0,NAS_MCC_MNC_MAX_SIZE);
    memset(mnc_str,0,NAS_MCC_MNC_MAX_SIZE);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                  NULL,
                                                  NAS_NIL,  // empty request payload
                                                  (void *) &get_sys_info_response,
                                                  sizeof( get_sys_info_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                  NULL,
                                                  NAS_NIL,
                                                  (void *) &get_cell_loc_info_response,
                                                  sizeof( get_cell_loc_info_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SIG_INFO_REQ_MSG_V01,
                                                  NULL,
                                                  NAS_NIL,
                                                  &get_sig_info_response,
                                                  sizeof( get_sig_info_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    //Copying Service Status and System Mode to the buffer
    if( TRUE == get_sys_info_response.cdma_srv_status_info_valid )
    {
        cdma_data->srv_status = get_sys_info_response.cdma_srv_status_info.srv_status;
        cdma_data->system_mode = FTM_SUBSCRIPTION_CDMA;
    }

    //Copying Service Domain to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.common_sys_info.srv_domain_valid )
      )
    {
        cdma_data->srv_domain = get_sys_info_response.cdma_sys_info.common_sys_info.srv_domain;
    }

    //Copying Roaming Status to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.common_sys_info.roam_status_valid )
      )
    {
        cdma_data->roam_status = get_sys_info_response.cdma_sys_info.common_sys_info.roam_status;
    }

    //Copying MCC to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id.mcc, mcc_str);
        cdma_data->mcc = atoi(mcc_str);
    }

    //Copying MNC to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id.mnc, mnc_str);
        cdma_data->mnc = atoi(mnc_str);
    }

    //Copying rssi to the buffer
    if( TRUE == get_sig_info_response.cdma_sig_info_valid )
    {
        cdma_data->rssi = get_sig_info_response.cdma_sig_info.rssi;
    }

    //Copying ecio to the buffer
    if( TRUE == get_sig_info_response.cdma_sig_info_valid )
    {
        cdma_data->ecio = get_sig_info_response.cdma_sig_info.ecio;
    }

    //Copying cdma_1x_rx0_agc to the buffer
    if( TRUE == get_cell_loc_info_response.cdma_rx_power_valid )
    {
        cdma_data->cdma_1x_rx0_agc = get_cell_loc_info_response.cdma_rx_power.rx0_agc;
    }

    //Copying cdma_1x_rx1_agc to the buffer
    if( TRUE == get_cell_loc_info_response.cdma_rx_power_valid )
    {
        cdma_data->cdma_1x_rx1_agc = get_cell_loc_info_response.cdma_rx_power.rx1_agc;
    }

    //Copying cdma_evdo_rx0_agc to the buffer
    if( TRUE == get_cell_loc_info_response.hdr_rx_power_valid ) // Need to discuss from modem team
    {
        cdma_data->cdma_evdo_rx0_agc = get_cell_loc_info_response.hdr_rx_power.rx0_agc;
    }

    //Copying cdma_evdo_rx1_agc to the buffer
    if( TRUE == get_cell_loc_info_response.hdr_rx_power_valid ) // Need to discuss from modem team
    {
        cdma_data->cdma_evdo_rx1_agc = get_cell_loc_info_response.hdr_rx_power.rx1_agc;
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_field_test_mode_info_for_cdma

//===========================================================================
// Function: qcril_qmi_nas_get_field_test_mode_info_for_gsm
// To get data for gsm
//===========================================================================
void qcril_qmi_nas_get_field_test_mode_info_for_gsm( struct gsm_ftm_data *gsm_data)
{
    qmi_client_error_type qmi_client_error;
    nas_get_sys_info_resp_msg_v01 get_sys_info_response;
    nas_get_cell_location_info_resp_msg_v01 get_cell_loc_info_response;
    nas_get_sig_info_resp_msg_v01 get_sig_info_response;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char mnc_str[NAS_MCC_MNC_MAX_SIZE];
    uint32_t i = 0;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&get_sys_info_response,0,sizeof(get_sys_info_response));
    memset(&get_cell_loc_info_response,0,sizeof(get_cell_loc_info_response));
    memset(&get_sig_info_response,0,sizeof(get_sig_info_response));
    memset(mcc_str,0,NAS_MCC_MNC_MAX_SIZE);
    memset(mnc_str,0,NAS_MCC_MNC_MAX_SIZE);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                  NULL,
                                                  NAS_NIL,  // empty request payload
                                                  (void *) &get_sys_info_response,
                                                  sizeof( get_sys_info_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                   NULL,
                                                   NAS_NIL,
                                                   (void *) &get_cell_loc_info_response,
                                                   sizeof( get_cell_loc_info_response ),
                                                   ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SIG_INFO_REQ_MSG_V01,
                                                  NULL,
                                                  NAS_NIL,
                                                  &get_sig_info_response,
                                                  sizeof( get_sig_info_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    //Copying Service Status and System Mode to the buffer
    if( TRUE == get_sys_info_response.gsm_srv_status_info_valid )
    {
        gsm_data->srv_status = get_sys_info_response.gsm_srv_status_info.srv_status;
        gsm_data->system_mode = FTM_SUBSCRIPTION_GSM;
    }

    //Copying Service Domain to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.common_sys_info.srv_domain_valid )
      )
    {
        gsm_data->srv_domain = get_sys_info_response.gsm_sys_info.common_sys_info.srv_domain;
    }

    //Copying Roaming Status to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.common_sys_info.roam_status_valid )
      )
    {
        gsm_data->roam_status = get_sys_info_response.gsm_sys_info.common_sys_info.roam_status;
    }

    //Copying MCC to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id.mcc, mcc_str);
        gsm_data->mcc = atoi(mcc_str);
    }

    //Copying MNC to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id.mnc, mnc_str);
        gsm_data->mnc = atoi(mnc_str);
    }

    //Copying LAC to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.lac_valid )
      )
    {
        gsm_data->lac = get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.lac;
    }

    //Copying RSSI to the buffer
    if( TRUE == get_sig_info_response.gsm_sig_info_valid )
    {
        gsm_data->rssi = get_sig_info_response.gsm_sig_info;
    }

    //Copying BCCH to the buffer
    if( TRUE == get_cell_loc_info_response.gsm_info_ext_valid )
    {
        gsm_data->bcch = get_cell_loc_info_response.gsm_info_ext.g_bcch;
    }

    //Copying BSIC to the buffer
    if( TRUE == get_cell_loc_info_response.geran_info_valid )
    {
        gsm_data->bsic = get_cell_loc_info_response.geran_info.bsic;
    }

    //Copying RX LEVEL to the buffer
    if( TRUE == get_cell_loc_info_response.geran_info_valid )
    {
        gsm_data->rx_level = get_cell_loc_info_response.geran_info.rx_lev;
    }

    //Copying RX QUALITY FULL to the buffer
    gsm_data->rx_qual_full = 0; //QMI_NAS to confirm

    //Copying RX QUALITY SUB to the buffer
    gsm_data->rx_qual_sub = 0; //QMI_NAS to confirm

    //Copying TA to the buffer
    if( TRUE == get_cell_loc_info_response.gsm_info_ext_valid )
    {
        gsm_data->ta = get_cell_loc_info_response.gsm_info_ext.g_ta;
    }

    //Copying GSM neighbor cells info  to the buffer
    if( TRUE == get_cell_loc_info_response.geran_info_valid )
    {
        gsm_data->no_of_neigh_cell_info_len = get_cell_loc_info_response.geran_info.nmr_cell_info_len;
        for(i=0;i<get_cell_loc_info_response.geran_info.nmr_cell_info_len;i++)
        {
            gsm_data->gsm_neigh_cell[i].cell_id = get_cell_loc_info_response.geran_info.nmr_cell_info[i].nmr_cell_id;
            gsm_data->gsm_neigh_cell[i].bsic = get_cell_loc_info_response.geran_info.nmr_cell_info[i].nmr_bsic;
            gsm_data->gsm_neigh_cell[i].rx_level = get_cell_loc_info_response.geran_info.nmr_cell_info[i].nmr_rx_lev;

            if( TRUE == get_cell_loc_info_response.gncell_bcch_valid )
            {
               gsm_data->gsm_neigh_cell[i].bcch = get_cell_loc_info_response.gncell_bcch[i];
            }
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_field_test_mode_info_for_gsm

//===========================================================================
// Function: qcril_qmi_nas_get_field_test_mode_info_for_wcdma
// To get data for wcdma
//===========================================================================
void qcril_qmi_nas_get_field_test_mode_info_for_wcdma( struct wcdma_ftm_data *wcdma_data)
{
    qmi_client_error_type qmi_client_error;
    nas_get_sys_info_resp_msg_v01 get_sys_info_response;
    nas_get_cell_location_info_resp_msg_v01 get_cell_loc_info_response;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char mnc_str[NAS_MCC_MNC_MAX_SIZE];
    uint32_t i =0;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&get_sys_info_response,0,sizeof(get_sys_info_response));
    memset(&get_cell_loc_info_response,0,sizeof(get_cell_loc_info_response));
    memset(mcc_str,0,NAS_MCC_MNC_MAX_SIZE);
    memset(mnc_str,0,NAS_MCC_MNC_MAX_SIZE);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                  NULL,
                                                  NAS_NIL,  // empty request payload
                                                  (void *) &get_sys_info_response,
                                                  sizeof( get_sys_info_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                  NULL,
                                                  NAS_NIL,
                                                  (void *) &get_cell_loc_info_response,
                                                  sizeof( get_cell_loc_info_response ),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    //Copying Service Status and System Mode to the buffer
    if( TRUE == get_sys_info_response.wcdma_srv_status_info_valid )
    {
        wcdma_data->srv_status = get_sys_info_response.wcdma_srv_status_info.srv_status;
        wcdma_data->system_mode = FTM_SUBSCRIPTION_WCDMA;
    }

    //Copying Service Domain to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.common_sys_info.srv_domain_valid )
      )
    {
        wcdma_data->srv_domain = get_sys_info_response.wcdma_sys_info.common_sys_info.srv_domain;
    }

    //Copying Roaming Status to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.common_sys_info.roam_status_valid )
      )
    {
        wcdma_data->roam_status = get_sys_info_response.wcdma_sys_info.common_sys_info.roam_status;
    }

    //Copying MCC to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id.mcc, mcc_str);
        wcdma_data->mcc = atoi(mcc_str);
    }

    //Copying MNC to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id.mnc, mnc_str);
        wcdma_data->mnc = atoi(mnc_str);
    }

    //Copying LAC to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.lac_valid )
      )
    {
        wcdma_data->lac = get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.lac;
    }

    //Copying BLER to the buffer
    if( TRUE == get_cell_loc_info_response.wcdma_info_ext_valid )
    {
        wcdma_data->bler = get_cell_loc_info_response.wcdma_info_ext.w_dl_bler;
    }

    //Copying ECIO to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->ecio = get_cell_loc_info_response.umts_info.ecio;
    }

    //Copying RSCP to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->rscp = get_cell_loc_info_response.umts_info.rscp;
    }

    //Copying RX_AGC to the buffer
    if( TRUE == get_cell_loc_info_response.wcdma_info_ext_valid )
    {
        wcdma_data->rx_agc = get_cell_loc_info_response.wcdma_info_ext.w_agc;
    }

    //Copying TX_AGC to the buffer
    if( TRUE == get_cell_loc_info_response.wcdma_info_ext_valid )
    {
        wcdma_data->tx_agc = get_cell_loc_info_response.wcdma_info_ext.w_txagc;
    }

    //Copying UARFCN to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->uarfcn = get_cell_loc_info_response.umts_info.uarfcn;
    }

    //Copying PSC to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->psc = get_cell_loc_info_response.umts_info.psc;
    }

    //Copying WCDMA neighbor cells info  to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->no_of_neigh_cell_info_len = get_cell_loc_info_response.umts_info.umts_monitored_cell_len;
        for(i=0;i<get_cell_loc_info_response.umts_info.umts_monitored_cell_len;i++)
        {
            wcdma_data->wcdma_neigh_cell[i].cell_id = 0; // QMI_NAS to confirm
            wcdma_data->wcdma_neigh_cell[i].uarfcn = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_uarfcn;
            wcdma_data->wcdma_neigh_cell[i].psc = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_psc;
            wcdma_data->wcdma_neigh_cell[i].rscp = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_rscp;
            wcdma_data->wcdma_neigh_cell[i].ecio = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_ecio;
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_field_test_mode_info_for_wcdma

//===========================================================================
// Request: QCRIL_EVT_HOOK_ENABLE_ENGINEER_MODE
// Function: qcril_qmi_nas_enable_engineer_mode
//===========================================================================
void qcril_qmi_nas_enable_engineer_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  struct ftm_subs_status *ftm_subs_data;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(ret_ptr);

  do
  {
    if ( ( NULL == params_ptr ) )
    {
      break;
    }

    instance_id = params_ptr->instance_id;

    modem_id = params_ptr->modem_id;

    if ( ( params_ptr->data == NULL ) || ( instance_id >= QCRIL_MAX_INSTANCE_ID ) || ( modem_id >= QCRIL_MAX_MODEM_ID ) )
    {
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
  qcril_send_request_response( &resp );
      break;
    }

    ftm_subs_data = (struct ftm_subs_status *)params_ptr->data;

    if ( TRUE == ftm_subs_data->is_enable )
    {
      qcril_qmi_nas_start_get_engineer_mode_info_timer(instance_id, ftm_subs_data->subs_type);
    }
    else
    {
      qcril_qmi_nas_stop_get_engineer_mode_info_timer(instance_id, ftm_subs_data->subs_type);
    }

    QCRIL_LOG_DEBUG( "qcril_qmi_nas_enable_engineer_mode status = %d", ftm_subs_data->is_enable );

    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );

  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================
 qcril_qmi_nas_get_attch_state
============================================================================*/
/*!
    @brief
    Retireves initial attach apn state.

    @return
    initial attach apn state.
*/
/*=========================================================================*/
qmi_ril_nas_attch_state_e_type qcril_qmi_nas_get_attch_state(void)
{
    qmi_ril_nas_attch_state_e_type res;
    NAS_CACHE_LOCK();
    res = nas_cached_info.attch_state;
    NAS_CACHE_UNLOCK();
    return res;
}

/*===========================================================================
 qcril_qmi_nas_set_attch_state
============================================================================*/
/*!
    @brief
    Sets initial attach apn state.

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_set_attch_state
(
    qmi_ril_nas_attch_state_e_type state
)
{
    NAS_CACHE_LOCK();
    nas_cached_info.attch_state = state;
    NAS_CACHE_UNLOCK();
}

/*===========================================================================
 qcril_qmi_nas_send_attach_detach_request
============================================================================*/
/*!
    @brief
    Send attach ot detach action down to qmi nas.

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_send_attach_detach_request
(
    const nas_srv_domain_pref_enum_type_v01 attach_action
)
{
    nas_set_system_selection_preference_req_msg_v01  qmi_attach_req;
    nas_set_system_selection_preference_resp_msg_v01 qmi_attach_resp;
    qmi_client_error_type                            qmi_attach_error;
    RIL_Errno                                        res;

    QCRIL_LOG_INFO("qcril_qmi_nas_send_attach_detach_request action %d", attach_action);

    memset(&qmi_attach_req,0,sizeof(qmi_attach_req));
    memset(&qmi_attach_resp,0,sizeof(qmi_attach_resp));

    qmi_attach_req.srv_domain_pref_valid    = TRUE;
    qmi_attach_req.srv_domain_pref          = attach_action;

    qmi_attach_req.change_duration_valid    = TRUE;
    qmi_attach_req.change_duration          = NAS_POWER_CYCLE_V01;

    qmi_attach_error = qmi_client_nas_send_sync(QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                  (void*) &qmi_attach_req,
                                                  sizeof(qmi_attach_req),
                                                  (void*) &qmi_attach_resp,
                                                  sizeof(qmi_attach_resp),
                                                  ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_attach_error, &qmi_attach_resp.resp);
    if (res != RIL_E_SUCCESS)
    {
      QCRIL_LOG_ERROR("NAS APN attach/detach failed with error code %d",res);
    }

    return res;
}

/*===========================================================================
 qcril_qmi_nas_initial_attach_timeout_handler
============================================================================*/
/*!
    @brief
    Timie out handler for ss event wait

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_attach_timeout_handler
(
    void *param
)
{
    qmi_ril_nas_attch_state_e_type ps_attach_state;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(param);

    ps_attach_state = qcril_qmi_nas_get_attch_state();

    NAS_CACHE_LOCK();

    auto& msgList = getNasModule().getPendingMessageList();
    auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());

    QCRIL_LOG_INFO( ".. found_req %d", (msg != nullptr));
    if (msg != nullptr)
    {
        if (QMI_RIL_NAS_ALLOW_DATA_ATTCH_ATTACH == ps_attach_state ||
            QMI_RIL_NAS_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH == ps_attach_state ||
            QMI_RIL_NAS_ALLOW_DATA_ATTCH_DETACH == ps_attach_state)
        {
            qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
            msgList.erase(msg);
            auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    RIL_E_INTERNAL_ERR, nullptr);
            allowDataMsg->sendResponse(allowDataMsg, Message::Callback::Status::SUCCESS, respData);
        }
    }

    nas_cached_info.attch_timeout_watch = NAS_NIL;
    NAS_CACHE_UNLOCK();
}

/*===========================================================================

 qcril_qmi_nas_set_ps_service_domain

============================================================================*/
/*!
    @brief
    Set ps service domain detach or attach and start timer

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_set_ps_service_domain
(
    qmi_ril_nas_attch_state_e_type action
)
{
    RIL_Errno   res;
    uint32      new_timeout_watch = 0;
    int         new_timeout_set_res;

    nas_srv_domain_pref_enum_type_v01 attach_action;

    /*
      See Spec 3GPP TS 24.301 version 11.9.0 Release 11
      75s - The maximum time the UE is going to wait for the detach request response.
      2s - Buffer for communication between RIL and QMI.
    */
    const struct timeval attach_timeout = {77 , 0};
    QCRIL_LOG_FUNC_ENTRY();


    if (action == QMI_RIL_NAS_ALLOW_DATA_ATTCH_DETACH)
    {
        attach_action = QMI_SRV_DOMAIN_PREF_PS_DETACH_V01;
    }
    else if (action == QMI_RIL_NAS_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH)
    {
        attach_action = QMI_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH_V01;
    }
    else
    {
        attach_action = QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01;
    }

    res = qcril_qmi_nas_send_attach_detach_request(attach_action);

    if(res != RIL_E_SUCCESS)
    {
      QCRIL_LOG_ERROR("NAS APN detach failed with error code %d", res);
    }
    else
    {
        // start timer
        new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                          QCRIL_DEFAULT_MODEM_ID,
                                                          qcril_qmi_nas_attach_timeout_handler,
                                                          &attach_timeout, &new_timeout_watch );
        QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );

        if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
        {
            if(new_timeout_set_res == E_SUCCESS)
            {
              QCRIL_LOG_ERROR("Internal error..timed callback failed to set timer_id");
              res = RIL_E_INTERNAL_ERR;
            }
            else
            {
              res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err((IxErrnoType) new_timeout_set_res);
            }
        }
        else
        {
            NAS_CACHE_LOCK();
            nas_cached_info.attch_timeout_watch = new_timeout_watch;
            NAS_CACHE_UNLOCK();
        }
    }

    return res;
}

/*===========================================================================
 qcril_qmi_nas_is_lte_ps_attached
============================================================================*/
/*!
    @brief
    Checks if lte is ps attached

    @return
    TRUE  : if lte is ps attached
    FALSE : else
*/
/*=========================================================================*/
int qcril_qmi_nas_is_lte_ps_attached
(
    uint8_t                     lte_sys_info_valid,
    nas_lte_sys_info_type_v01  *lte_sys_info
)
{
    if (lte_sys_info_valid &&
        lte_sys_info &&
        lte_sys_info->common_sys_info.srv_domain_valid &&
        ((lte_sys_info->common_sys_info.srv_domain == SYS_SRV_DOMAIN_PS_ONLY_V01) ||
         (lte_sys_info->common_sys_info.srv_domain == SYS_SRV_DOMAIN_CS_PS_V01)))
    {
        return TRUE;
    }

    return FALSE;
}

/*===========================================================================
qcril_qmi_nas_check_ps_attach_status
===========================================================================*/
void qcril_qmi_nas_check_ps_attach_status();

void qcril_qmi_nas_check_ps_attach_status()
{
    IxErrnoType                     found_qcril_request;
    int                             send_resp_to_tel = FALSE;
    qmi_ril_nas_attch_state_e_type  cur_attach_state;
    int ps_attch_status;
    qcril_arb_pref_data_type        pref_data;
    int is_dds_set_for_all_rat_cap_support = 0;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);

    NAS_CACHE_LOCK();
    auto& msgList = getNasModule().getPendingMessageList();
    auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
    found_qcril_request = (msg != nullptr) ? E_SUCCESS : E_FAILURE;

    cur_attach_state = qcril_qmi_nas_get_attch_state();

    ps_attch_status = ((QMI_RIL_RAT_CONFIDENCE_FULL_SVC ==
                            nas_cached_info.data_rte_confidence_tag) &&
                        (QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data.pref_data_tech) &&
                        (pref_data.is_extrapolation != TRUE));

    is_dds_set_for_all_rat_cap_support = ( NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) &&
                                           (TRUE == nas_dms_cached_info.both_sub_support_all_rat_cap) &&
                                           NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
                                           (2 == nas_dms_cached_info.max_active_data_subs));

    QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );
    QCRIL_LOG_INFO( "attach_state %d ps_attch_status %d",
                                                cur_attach_state, ps_attch_status);
    QCRIL_LOG_INFO( "is_dds_set_for_all_rat_cap_support = %d", is_dds_set_for_all_rat_cap_support );
    if (found_qcril_request == E_SUCCESS)
    {
        if ((QMI_RIL_NAS_ALLOW_DATA_ATTCH_DETACH == cur_attach_state &&
            ((!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref)) ||
            ( nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_ONLY_V01 ))) ||
            ((((QMI_RIL_NAS_ALLOW_DATA_ATTCH_ATTACH == cur_attach_state) && !is_dds_set_for_all_rat_cap_support) ||
            (QMI_RIL_NAS_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH == cur_attach_state)) &&
            ( ps_attch_status == TRUE )))
        {
          send_resp_to_tel = TRUE;
        }
        else if (QMI_RIL_NAS_ALLOW_DATA_ATTCH_WAIT_FOR_RAT_EXP == cur_attach_state)
        {
            /* check if it there is any rat expansion, if so wait for dsd indication */
            if (qcril_qmi_nas_did_rat_expansion_occur() || (ps_attch_status != TRUE))
            {
                qcril_qmi_nas_set_attch_state(
                                        QMI_RIL_NAS_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH);
            }
            else
            {
                send_resp_to_tel = TRUE;
            }
        }

        if(send_resp_to_tel)
        {
            qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
        }
    }

    if ((found_qcril_request == E_SUCCESS) && send_resp_to_tel)
    {
        if (nas_cached_info.attch_timeout_watch)
        {
            qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.attch_timeout_watch);
            nas_cached_info.attch_timeout_watch = NAS_NIL;
        }
        msgList.erase(msg);
        auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(RIL_E_SUCCESS, nullptr);
        allowDataMsg->sendResponse(allowDataMsg, Message::Callback::Status::SUCCESS, respData);
    }
    NAS_CACHE_UNLOCK();
}

/*===========================================================================
  qcril_qmi_nas_did_rat_expansion_occur
============================================================================*/
/*!
    @brief
    Check if rat expansion occured

    @return
    TRUE or FALSE
*/
/*=========================================================================*/
boolean qcril_qmi_nas_did_rat_expansion_occur
(
    void
)
{
    boolean ret = FALSE;
    mode_pref_mask_type_v01 rat_disabled_mask;
    mode_pref_mask_type_v01 stored_rat_disabled_mask;

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rat_disabled_mask))
    {
        rat_disabled_mask = 0;
    }
    else
    {
        rat_disabled_mask = nas_cached_info.rat_disabled_mask;
    }

    stored_rat_disabled_mask =
            nas_common_info.rat_disabled_mask_during_on_demand_attach;
    rat_disabled_mask = (stored_rat_disabled_mask & rat_disabled_mask);

    /* rat expansion is considered to be occured if any disabled rat is
     * not more disabled */
    if (stored_rat_disabled_mask > rat_disabled_mask)
    {
        ret = TRUE;
    }

    return ret;
}

/*===========================================================================
  qcril_qmi_nas_check_if_service_domain_has_ps
============================================================================*/
/*!
    @brief
    Check if service domain has PS

    @return
    TRUE or FALSE
*/
/*=========================================================================*/
boolean qcril_qmi_nas_check_if_service_domain_has_ps
(
    void
)
{
    boolean ret = FALSE;

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref) &&
        ((nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_PS_ONLY_V01) ||
        (nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_PS_V01)))
    {
        ret = TRUE;
    }

    return ret;
}

/*===========================================================================
  qcril_qmi_nas_sys_sel_pref_setup_timed_callback
============================================================================*/

int qcril_qmi_nas_sys_sel_pref_setup_timed_callback ()
{
    const struct timeval sys_sel_pref_timeout = {60 , 0};
    uint32 sys_sel_pref_tmr = 0;
    int sys_sel_pref_tmr_res = E_FAILURE, ret = E_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();

    sys_sel_pref_tmr_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler,
                                                     &sys_sel_pref_timeout,
                                                     &sys_sel_pref_tmr );
    if ( E_SUCCESS == sys_sel_pref_tmr_res && NAS_NIL != sys_sel_pref_tmr )
    {
        nas_cached_info.sys_sel_pref_tmr = sys_sel_pref_tmr;
        ret = E_SUCCESS;
    }
    else if(sys_sel_pref_tmr_res == E_SUCCESS)
    {
      QCRIL_LOG_ERROR("Internal error..timed callback failed to set timer_id");
      ret = E_FAILURE; //will be mapped to internal err
    }
    else
    {
      ret = sys_sel_pref_tmr_res;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}//qcril_qmi_nas_sys_sel_pref_setup_timed_callback

/*===========================================================================
  qcril_qmi_nas_initialize_is_indication_received
============================================================================*/
void qcril_qmi_nas_initialize_is_indication_received()
{
    NAS_CACHE_LOCK();
    nas_cached_info.is_indication_received = FALSE;
    NAS_CACHE_UNLOCK();
} //qcril_qmi_nas_initialize_is_indication_received

/*===========================================================================
  qcril_qmi_nas_check_is_indication_received
============================================================================*/
uint8 qcril_qmi_nas_check_is_indication_received()
{
    uint8 ret;
    ret = nas_cached_info.is_indication_received;
    return ret;
} //qcril_qmi_nas_check_is_indication_received

/*===========================================================================
  qcril_qmi_nas_cancel_sys_sel_pref_tmr
============================================================================*/
void qcril_qmi_nas_cancel_sys_sel_pref_tmr()
{
    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_LOCK();
    if( NAS_ZERO != nas_cached_info.sys_sel_pref_tmr )
    {
        auto& msgList = getNasModule().getPendingMessageList();
        auto pendingMsg = msgList.find(RilRequestSetPrefNetworkTypeMessage::get_class_message_id());

        if ((pendingMsg != nullptr ) && (FALSE == nas_cached_info.is_indication_received))
        {
             //since this function is called only when SSR happens - send RADIO_NOT_AVAILABLE
            //TODO: In new hal - change this function to take RIL_Errno/error type and return that
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    RIL_E_RADIO_NOT_AVAILABLE, nullptr);
            auto setMsg = std::static_pointer_cast<RilRequestSetPrefNetworkTypeMessage>(pendingMsg);
            setMsg->sendResponse(setMsg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(pendingMsg);
        }
        qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.sys_sel_pref_tmr);
        nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
    }
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_cancel_sys_sel_pref_tmr

/*===========================================================================
  qcril_qmi_nas_mode_pref_request_response_helper
============================================================================*/
RIL_Errno qcril_qmi_nas_mode_pref_request_response_helper(std::shared_ptr<RilRequestSetPrefNetworkTypeMessage> msg, uint8 *is_change)
{
    RIL_Errno ril_req_res = RIL_E_SUCCESS;
    NAS_CACHE_LOCK();
    if( TRUE == qcril_qmi_nas_check_is_indication_received() )
    {
        if( is_change )
        {
            *is_change = FALSE;
        }
    }
    else
    {
        ril_req_res = qcril_qmi_nas2_create_reqlist_setup_timer_helper(msg);
    }
    NAS_CACHE_UNLOCK();
    return ril_req_res;
}

/*=========================================================================
 qcril_qmi_nas_request_allow_data
============================================================================*/
/*!
    @brief
    Processes RIL_REQUEST_ALLOW_DATA

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_request_allow_data
(
  std::shared_ptr<RilRequestAllowDataMessage> msg
)
{
  RIL_Errno res = RIL_E_SUCCESS;
  int do_ps_attach;
  int send_resp_to_atel = FALSE;
  char prop_val[ PROPERTY_VALUE_MAX ];
  DDSSubIdInfo dds_data_sub;
  uint8_t need_to_update_dds = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&prop_val, 0 , sizeof(prop_val));
  property_get( QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val, "" );
  QCRIL_LOG_INFO ( "Multisim prop val %s", prop_val );

    do
    {
      do_ps_attach = msg->isAllowData();
      QCRIL_LOG_INFO("allow_data %d", do_ps_attach);

#if 0 // Remove the logic of waiting for card status
      /* Remove the QCRIL_EVT_QMI_REQUEST_ALLOW_DATA_WAIT_FOR_CARD_READY request
         if it exists from the request list. At this point, it should be the only
         request in the request list with the token of the ALLOW_DATA request.
         The payload stored in the request can safely be freed at this point as
         it should have already been copied to the local variable "do_ps_attach". */
      auto& msgList = getNasModule().getPendingMessageList();
      auto item = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
      msgList.erase(item);
#endif

      // Add Message to the pending list, and get the token in case of success
      auto ret = getNasModule().getPendingMessageList().insert(msg);
      if (!ret.second) {
          res = RIL_E_INTERNAL_ERR;
          break;
      }
      uint16_t token = ret.first;
#if 0 // Remove the logic of waiting for card status
      NAS_CACHE_LOCK();
      auto card_state = nas_common_info.card_info[ qmi_ril_get_sim_slot() ].status;
      NAS_CACHE_UNLOCK();

      /* Process ALLOW_DATA requests right away if the card is up, or if it's not present.
         Otherwise, hold them in the request list and process them when the card is up. */
      if !(QCRIL_CARD_STATUS_UP == card_state || QCRIL_CARD_STATUS_ABSENT == card_state ||
          QCRIL_CARD_STATUS_DOWN == card_state ||(FALSE == do_ps_attach))

      {
          // set the wait bit and return with sending response (res = SUCCESS)
          msg->setWaitForCard(true);
          break;
      }
#endif

      if(qmi_ril_is_feature_supported(QMI_RIL_FEATURE_BLOCK_ALLOW_DATA))
      {
        QCRIL_LOG_INFO("Block request, don't process to modem");
        send_resp_to_atel = TRUE;
        res = RIL_E_SUCCESS;
        break;
      }

      NAS_CACHE_LOCK();
      if( !NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) || !NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.current_sub_capability) )
      {
        qcril_qmi_nas_get_device_capability(FALSE, FALSE, TRUE, FALSE);
      }

      if (TRUE == do_ps_attach)
      {
        qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ALLOW_DATA_ATTCH_ATTACH);
        qcril_qmi_fetch_system_selection_preference();

        if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.is_default_data_subs) )
        {
            qcril_qmi_nas_get_subscription_info();
        }

        // DDS switch request
        if (qmi_ril_is_multi_sim_feature_supported() &&
              ((nas_common_info.dsds.is_default_data_set == FALSE) ||
               ((nas_common_info.dsds.is_default_data_set == TRUE ) &&
               (nas_common_info.dsds.default_data_instance_id == qmi_ril_get_process_instance_id()))))
        {
          if( NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) &&
              (TRUE == nas_dms_cached_info.both_sub_support_all_rat_cap) &&
              NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
              (2 == nas_dms_cached_info.max_active_data_subs)
            )
          {
#ifndef QMI_RIL_UTF
            if(!nas_common_info.dsds.dds_data_sub_valid)
            {
                QCRIL_LOG_DEBUG("Query DDS sub from DATA layer as cache not valid");
                std::shared_ptr<rildata::GetDdsSubIdMessage> msg =
                        std::make_shared<rildata::GetDdsSubIdMessage>();
                if(msg != nullptr)
                {
                    NasDataGetDdsSubIdCallback cb("set-cb-token", token, TRUE);
                    msg->setCallback(&cb);
                    msg->dispatch();
                    //..else part below will be handled in the callback
                }
                else
                {
                    QCRIL_LOG_DEBUG("Unable to allocate memory for GetDdsSubIdMessage msg");
                }
            }
            else
            {
                QCRIL_LOG_DEBUG("DDS sub inform via DATA layer = %d", nas_common_info.dsds.dds_data_sub.dds_sub_id);
                QCRIL_LOG_DEBUG("DDS switch type inform via DATA layer = %d", nas_common_info.dsds.dds_data_sub.switch_type);
                QCRIL_LOG_DEBUG("default_data_reason = %d", nas_common_info.dsds.default_data_reason);
                if(qcril_qmi_nas_is_dds_change())
                {
                    need_to_update_dds = TRUE;
                    qcril_qmi_nas_dds_to_be_updated(&dds_data_sub);
                    QCRIL_LOG_DEBUG("dds_sub_id = %d", dds_data_sub.dds_sub_id);
                    QCRIL_LOG_DEBUG("dds_switch_type = %d", dds_data_sub.switch_type);
                }

                QCRIL_LOG_DEBUG("need_to_update_dds = %d", need_to_update_dds);
                if(need_to_update_dds)
                {
                    std::shared_ptr<rildata::RequestDdsSwitchMessage> msg =
                      std::make_shared<rildata::RequestDdsSwitchMessage>(dds_data_sub);
                    if(msg != nullptr)
                    {
                        NasDataRequestDdsSwitchCallback cb("set-cb-token", token);
                        msg->setCallback(&cb);
                        msg->dispatch();
                    }
                    else
                    {
                        QCRIL_LOG_DEBUG("Unable to allocate memory for RequestDdsSwitchMessage msg");
                    }
                }
                else
                {
                    send_resp_to_atel = TRUE;
                    res = RIL_E_SUCCESS;
                    QCRIL_LOG_ESSENTIAL("Already it is DDS sub, no need to update to modem");
                }
            }
#endif
          }
          else if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.is_default_data_subs) || (0 == nas_cached_info.is_default_data_subs) ||
              (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.dds_type) && (NAS_DDS_TYPE_TEMPORARY_V01 == nas_cached_info.dds_type)) )
          {
            res = qcril_qmi_nas_send_data_subscription_request(NAS_DDS_DURATION_PERMANANT_V01);
            QCRIL_LOG_ESSENTIAL("Set data subscription request sent.. res %d", res);
          }
          else
          {
              if (qcril_qmi_nas_check_if_service_domain_has_ps())
              {
                  QCRIL_LOG_ESSENTIAL("Already PS attached!");
                  send_resp_to_atel = TRUE;
                  res = RIL_E_SUCCESS;
              }
              else
              {
                  res = qcril_qmi_nas_send_attach_detach_request(QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01);
                  if (RIL_E_SUCCESS == res)
                  {
                      QCRIL_LOG_ESSENTIAL("PS ATTACH request got success, so don't wait");
                      send_resp_to_atel = TRUE;
                  }
              }
          }
        }
        else if( ( qmi_ril_is_multi_sim_feature_supported() &&
                 (!strncmp(prop_val, "dsds", QMI_RIL_SYS_PROP_LENGTH_MULTI_SIM )) &&
                 (nas_common_info.dsds.is_default_data_set == TRUE ) &&
                 (nas_common_info.dsds.default_data_instance_id != qmi_ril_get_process_instance_id()) &&
                 (!NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) ||
                 (1 == nas_dms_cached_info.max_active_data_subs))
                 ) || ( qmi_ril_is_multi_sim_feature_supported() && /*In case of DSDA config, there are some target in which DATA+MMS feature not supported, so it will be DSDS for DATA*/
                (!NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) ||
                 (1 == nas_dms_cached_info.max_active_data_subs)) )
               )
        {
            if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.is_default_data_subs) ||
                (0 == nas_cached_info.is_default_data_subs) ||
                (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.dds_type) && (NAS_DDS_TYPE_PERMANENT_V01 == nas_cached_info.dds_type)))
            {
                res = qcril_qmi_nas_send_data_subscription_request(NAS_DDS_DURATION_TEMPORARY_V01);
                QCRIL_LOG_ESSENTIAL("DDS change triggered because of MMS in DSDS.. res %d", res);
            }
            else
            {
                if (qcril_qmi_nas_check_if_service_domain_has_ps())
                {
                    QCRIL_LOG_ESSENTIAL("Already PS attached!");
                    send_resp_to_atel = TRUE;
                    res = RIL_E_SUCCESS;
                }
                else
                {
                    res = qcril_qmi_nas_send_attach_detach_request(QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01);
                    if (RIL_E_SUCCESS == res)
                    {
                        QCRIL_LOG_ESSENTIAL("PS ATTACH request got success, so don't wait");
                        send_resp_to_atel = TRUE;
                    }
                }
            }
        }
        // Return SUCCESS for regular PS attach or on demand ps attach request if already attached.
        else if (qcril_qmi_nas_check_if_service_domain_has_ps() &&
                 !qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_DATA))
        {
          QCRIL_LOG_ESSENTIAL("Already PS attached!");
          send_resp_to_atel = TRUE;
          res = RIL_E_SUCCESS;
        }
        else
        {
          //Data+MMS --- DSDA
          if (qmi_ril_is_multi_sim_feature_supported())
          {
            if( NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) &&
                (TRUE == nas_dms_cached_info.both_sub_support_all_rat_cap) &&
                NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
                (2 == nas_dms_cached_info.max_active_data_subs))
            {
                QCRIL_LOG_ESSENTIAL("No need to send on_demand_ps_attach");
                send_resp_to_atel = TRUE;
                res = RIL_E_SUCCESS;
            }
            else
            {
                if (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_DATA))
                {
                    QCRIL_LOG_ESSENTIAL("On demand PS attach with 1x in service!");
                    qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ALLOW_DATA_ATTCH_WAIT_FOR_RAT_EXP);
                    (void)qcril_qmi_nas_get_rat_disabled_mask(&nas_common_info.rat_disabled_mask_during_on_demand_attach);
                }
                else
                {
                    QCRIL_LOG_ESSENTIAL("On demand PS attach!");
                    qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH);
                }

                res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH);
            }
          }
          // SS: Send PS attach request.
          else
          {
            if (qcril_qmi_nas_check_if_service_domain_has_ps())
            {
                QCRIL_LOG_ESSENTIAL("Already PS attached!");
                send_resp_to_atel = TRUE;
                res = RIL_E_SUCCESS;
            }
            else
            {
                QCRIL_LOG_ESSENTIAL("PS attach!");
                res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_ALLOW_DATA_ATTCH_ATTACH);
            }
          }
        }
      }
      else
      {
        if( NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) &&
            (TRUE == nas_dms_cached_info.both_sub_support_all_rat_cap) &&
            NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
            (2 == nas_dms_cached_info.max_active_data_subs)
          )
        {
          QCRIL_LOG_ESSENTIAL("No need to trigger PS_DETACH");
          send_resp_to_atel = TRUE;
          res = RIL_E_SUCCESS;
        }
        else if ((!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref)) ||
            ( nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_ONLY_V01 ))
        {
          QCRIL_LOG_ESSENTIAL("Already PS detached!");
          send_resp_to_atel = TRUE;
          res = RIL_E_SUCCESS;
        }
        else
        {
          QCRIL_LOG_ESSENTIAL("PS detach!");
          qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ALLOW_DATA_ATTCH_DETACH);
          res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_ALLOW_DATA_ATTCH_DETACH);
        }
      }
      /* Set the state to NONE before unlocking the cache to avoid the response
         for ALLOW_DATA being sent back to telephony */
      if((res != RIL_E_SUCCESS) || (send_resp_to_atel == TRUE))
      {
         qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
      }

      NAS_CACHE_UNLOCK();
    } while (0);

  // ** respond
  if ((res != RIL_E_SUCCESS) || (send_resp_to_atel == TRUE))
  {
    QCRIL_LOG_ESSENTIAL("PS ATTACH/DETACH resp %d", res);
    qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);

    getNasModule().getPendingMessageList().erase(msg);
    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(res, nullptr);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
  }
}

/*===========================================================================
  qcril_qmi_nas_modem_power_ril_resumed
============================================================================*/
void qcril_qmi_nas_modem_power_ril_resumed()
{
    QCRIL_LOG_FUNC_ENTRY();
    RADIO_POWER_LOCK();
    if (nas_common_info.modem_power_info.radio_power_process_pending)
    {
        RADIO_POWER_SIGNAL();
        nas_common_info.modem_power_info.radio_power_process_pending = FALSE;
        QCRIL_LOG_INFO("Modem power signalled");
    }
    RADIO_POWER_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================
  qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm
============================================================================*/
boolean qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm()
{
    boolean ret = FALSE;
    boolean apm_mdm_not_pwdn = FALSE;
    boolean apm_sim_not_pwdn = FALSE;
    apm_mdm_not_pwdn = nas_common_info.modem_power_info.apm_mdm_not_pwdn;
    apm_sim_not_pwdn = nas_common_info.apm_sim_not_pwdn;
    if (!apm_sim_not_pwdn && !apm_mdm_not_pwdn &&
        qcril_qmi_modem_power_is_voting_feature_supported_for_primary_modem())
        ret = TRUE;

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}

/*===========================================================================
  qcril_qmi_nas_modem_power_load_apm_mdm_not_pwdn
============================================================================*/
void qcril_qmi_nas_modem_power_load_apm_mdm_not_pwdn()
{
    nas_common_info.modem_power_info.apm_mdm_not_pwdn = FALSE;
    qmi_ril_get_property_value_from_integer(QCRIL_APM_MDM_NOT_PWDN,
                                            &nas_common_info.modem_power_info.apm_mdm_not_pwdn,
                                            1);
    QCRIL_LOG_INFO ("QCRIL_APM_MDM_NOT_PWDN=%d", nas_common_info.modem_power_info.apm_mdm_not_pwdn);
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_set_is_data_enabled

===========================================================================*/
/*!
    @brief
    set if data is enabled by the user

    @return
    void
*/
/*=========================================================================*/
void qcril_qmi_nas_set_is_data_enabled
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    boolean                        is_data_enabled;
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    if ((params_ptr->datalen > 0) && (params_ptr->data != NULL))
    {
        is_data_enabled = *((uint8_t *)params_ptr->data);
        QCRIL_LOG_DEBUG("is data enabled %d", is_data_enabled);
#ifndef QMI_RIL_UTF
        std::shared_ptr<rildata::SetIsDataEnabledMessage> msg =
              std::make_shared<rildata::SetIsDataEnabledMessage>(*params_ptr);
        if (msg)
        {
            msg->dispatch();
            ril_req_res = RIL_E_SUCCESS;
        }
#endif
    }

    if(RIL_E_SUCCESS != ril_req_res)
    {
        qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                      params_ptr->t,
                                      params_ptr->event_id,
                                      ril_req_res, &resp);
        qcril_send_request_response(&resp);
    }

    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_set_is_data_roaming_enabled

===========================================================================*/
/*!
    @brief
    set if data roaming is enabled by the user

    @return
    void
*/
/*=========================================================================*/
void qcril_qmi_nas_set_is_data_roaming_enabled
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    boolean                        is_data_roaming_enabled;
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    if ((params_ptr->datalen > 0) && (params_ptr->data != NULL))
    {
        is_data_roaming_enabled = *((uint8_t *)params_ptr->data);
        QCRIL_LOG_DEBUG("is data roaming enabled %d", is_data_roaming_enabled);
#ifndef QMI_RIL_UTF
        std::shared_ptr<rildata::SetIsDataRoamingEnabledMessage> msg =
                std::make_shared<rildata::SetIsDataRoamingEnabledMessage>(*params_ptr);
        if(msg)
        {
            msg->dispatch();
            ril_req_res = RIL_E_SUCCESS;
        }
#endif
    }

    if(RIL_E_SUCCESS != ril_req_res)
    {
        qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                      params_ptr->t,
                                      params_ptr->event_id,
                                      ril_req_res, &resp);
        qcril_send_request_response(&resp);
    }

    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_set_apn_info

===========================================================================*/
/*!
    @brief
    set apn info

    @return
    void
*/
/*=========================================================================*/
void qcril_qmi_nas_set_apn_info
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    qcril_qmi_oem_evt_hook_set_set_apn_info_type apn_info;
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;

#define QCRIL_OEM_EVT_APN_INFO_MIN_LEN (3 * sizeof(int32))

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();
    memset(&apn_info, 0, sizeof(apn_info));

    do {
        if ((params_ptr->datalen > QCRIL_OEM_EVT_APN_INFO_MIN_LEN) &&
            (params_ptr->data != NULL))
        {
            /* retrieve apn type length */
            apn_info.apn_type_len = *((uint32_t *)params_ptr->data);

            /* retrieve apn type */
            apn_info.apn_type     = (((char *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len));
            if (params_ptr->datalen <
                    (QCRIL_OEM_EVT_APN_INFO_MIN_LEN + apn_info.apn_type_len))
            {
                QCRIL_LOG_DEBUG("data len and data does not match;"
                                "datalen: %d, apn_type_len: %d",
                                params_ptr->datalen, apn_info.apn_type_len);
                ril_req_res = RIL_E_GENERIC_FAILURE;
                break;
            }

            /* retrieve apn name length */
            apn_info.apn_name_len = *(uint32_t *)(((uint8_t *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len)+
                                                  apn_info.apn_type_len);

            if (params_ptr->datalen !=
                    (QCRIL_OEM_EVT_APN_INFO_MIN_LEN +
                     apn_info.apn_type_len +
                     apn_info.apn_name_len))
            {
                QCRIL_LOG_DEBUG("data len and data does not match;"
                                "datalen: %d, apn_type_len: %d, apn_name_len: %d",
                                params_ptr->datalen, apn_info.apn_type_len,
                                apn_info.apn_name_len);

                ril_req_res = RIL_E_GENERIC_FAILURE;
                break;
            }

            /* retrieve apn name */
            apn_info.apn_name     = (((char *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len)+
                                                  apn_info.apn_type_len +
                                                  sizeof(apn_info.apn_name_len));

            apn_info.is_apn_valid = *(uint32_t *)(((uint8_t *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len)+
                                                  apn_info.apn_type_len +
                                                  sizeof(apn_info.apn_name_len)+
                                                  apn_info.apn_name_len);
#ifndef QMI_RIL_UTF
            std::shared_ptr<rildata::SetApnInfoMessage> msg =
                   std::make_shared<rildata::SetApnInfoMessage>(*params_ptr,
                           apn_info.apn_type,
                           apn_info.apn_name,
                           apn_info.is_apn_valid);
            if(msg)
            {
                msg->dispatch();
                ril_req_res = RIL_E_SUCCESS;
            }
#endif

        }
    } while(0);

    if(RIL_E_SUCCESS != ril_req_res)
    {
        qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                    params_ptr->t,
                                    params_ptr->event_id,
                                    ril_req_res, &resp);
        qcril_send_request_response(&resp);
    }

    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

    qcril_uim_process_mcc_mnc_info

============================================================================*/
/*!
    @brief
    Process mcc mnc info

    @return
    None
*/
/*=========================================================================*/
void qcril_uim_process_mcc_mnc_info
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_uim_mcc_mnc_info_type *uim_mcc_mnc_info = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    do {
        if ((params_ptr == NULL) || (ret_ptr == NULL))
        {
            QCRIL_LOG_ERROR("%s", "Invalid input, cannot process request");
            break;
        }

        uim_mcc_mnc_info = (qcril_uim_mcc_mnc_info_type*)params_ptr->data;
        if (uim_mcc_mnc_info == NULL)
        {
            QCRIL_LOG_ERROR("%s", "null uim_mcc_mnc_info");
            break;
        }

        if (uim_mcc_mnc_info->err_code != RIL_UIM_E_SUCCESS)
        {
            QCRIL_LOG_ERROR("uim_mcc_mnc_info error %d", uim_mcc_mnc_info->err_code);
            qcril_qmi_nas_update_sim_mcc_mnc(FALSE,
                                             (char *) "null",
                                             (char *) "null");
            break;
        }

        QCRIL_LOG_DEBUG("mcc: %s, mnc: %s", uim_mcc_mnc_info->mcc,
                                            uim_mcc_mnc_info->mnc);

        qcril_qmi_nas_update_sim_mcc_mnc(TRUE,
                                         uim_mcc_mnc_info->mcc,
                                         uim_mcc_mnc_info->mnc);

        /* update mcc that is used to eval ecc number */
        qcril_qmi_nas_update_mccmnc_for_eval_customer_ecc(
                    uim_mcc_mnc_info->mcc, uim_mcc_mnc_info->mnc);

        /* evaluate possibility of voice radio tech change */
        qcril_qmi_nas_initiate_voice_rte_change_propagation();


    } while (0);

    QCRIL_LOG_FUNC_RETURN();
}

RIL_Errno qcril_qmi_nas_embms_parse_mcc_mnc
(
   qcril_binary_data_type bin_data,
   qcril_binary_data_type next_bin_data,
   const char* format,
   char* res
)
{
  int is_mcc = 1;
  char pattern[QMI_RIL_EMBMS_MIN_SIB_MCC_MNC_PARSE_LEN] = "mcc[";
  int ret = 0;
  if (strstr(format, "mnc") != NULL)
  {
    is_mcc = 0;
    strlcpy(pattern, "mnc[", sizeof(pattern));
  }
  qcril_binary_data_type tmp = qcril_find_pattern(bin_data, pattern);
  if (qcril_is_binary_data_empty(tmp))
  {
    QCRIL_LOG_ERROR("plmn list doesn't contain any mcc or mnc");
    return RIL_E_GENERIC_FAILURE;
  }
  int i;
  int index;
  char value = 0;
  for (i = 0; i < MCC_MNC_MAX_V01; ++i)
  {
    ret = sscanf((const char*)tmp.data, format, &index, &value);
    if (ret != 2) // two arguments
    {
      QCRIL_LOG_ERROR("cannot find %s%d]", pattern, i);
      return RIL_E_GENERIC_FAILURE;
    }

    if (i != index)
    {
      QCRIL_LOG_ERROR("%s%d] index in wrong order. Expected index %d:, actural index %d", pattern, index, i, index);
      return RIL_E_GENERIC_FAILURE;
    }

    if (!isdigit(value))
    {
      QCRIL_LOG_ERROR("%s%d] value is not digit. Received value: %c", pattern, i, value);
      return RIL_E_GENERIC_FAILURE;
    }
    res[index] = value;

    //move forward the pointer to find the next pattern
    tmp.data += strlen(pattern);
    tmp.len -= strlen(pattern);
    tmp = qcril_find_pattern(tmp, pattern);
    if (qcril_is_binary_data_empty(tmp))
    {
      return RIL_E_SUCCESS;
    }
    // If either mcc or mnc doesn't have 3 digits, we will have the mcc or mnc information for the
    // next plmn_list if it is not empty. In this case we should ignore it.
    if ((tmp.data > next_bin_data.data) && !qcril_is_binary_data_empty(next_bin_data))
    {
      return RIL_E_SUCCESS;
    }
  }
  return RIL_E_SUCCESS;
}

//===========================================================================
// qcril_qmi_nas_embms_parse_embms_plmn
//===========================================================================
RIL_Errno qcril_qmi_nas_embms_parse_embms_plmn(qcril_binary_data_type bin_data, uint32_t max_plmn_len, uint32_t *plmn_len, embms_plmn_type_v01 plmn[])
{
    RIL_Errno ret = RIL_E_GENERIC_FAILURE;
    if (!bin_data.len || !bin_data.data || !plmn_len || !plmn)
    {
        QCRIL_LOG_ERROR("Invalid bin_data or plmn");
        return ret;
    }
    /****************** bin_data format **********************
     * ...
     * plmn_IdentityList[0] {
     * plmn_Identity {
     * mcc[0] = 0
     * mcc[1] = 1
     * mcc[2] = 2
     * mnc[0] = 3
     * mnc[1] = 4
     * }
     * cellReservedForOperatorUse = notReserved
     * }
     * plmn_IdentityList[1] {
     * plmn_Identity {
     * mcc[0] = 5
     * mcc[1] = 6
     * mcc[2] = 7
     * mnc[0] = 8
     * mnc[1] = 9
     * }
     * cellReservedForOperatorUse = notReserved
     * }
     * ...
     ********************************************************/
    const char* plmn_pattern = "plmn_IdentityList[";
    *plmn_len = 0;
    uint32_t plmn_index;
    qcril_binary_data_type current_plmn_bin_data = qcril_find_pattern(bin_data, plmn_pattern);
    if (qcril_is_binary_data_empty(current_plmn_bin_data))
    {
      QCRIL_LOG_ERROR("bin_data doesn't contain any plmn");
      return ret;
    }
    while (*plmn_len < max_plmn_len)
    {
        // move forward the pointer to find the next matching pattern
        qcril_binary_data_type next_plmn_bin_data = current_plmn_bin_data;
        next_plmn_bin_data.data += strlen(plmn_pattern);
        next_plmn_bin_data.len -= strlen(plmn_pattern);
        next_plmn_bin_data = qcril_find_pattern(next_plmn_bin_data, plmn_pattern);

        int result = sscanf((const char*)current_plmn_bin_data.data, "plmn_IdentityList[%d]", &plmn_index);
        // if find a plmn_list, verify if plmnlist index == plmn_len
        if ( result == 1 && plmn_index != *plmn_len)
        {
          ret = RIL_E_GENERIC_FAILURE;
          break;
        }
        ret = qcril_qmi_nas_embms_parse_mcc_mnc(current_plmn_bin_data, next_plmn_bin_data, "mcc[%d] = %c", plmn[*plmn_len].mcc);
        if (ret != RIL_E_SUCCESS)
        {
          QCRIL_LOG_ERROR("cannot get mcc from plmn_list");
          break;
        }
        ret = qcril_qmi_nas_embms_parse_mcc_mnc(current_plmn_bin_data, next_plmn_bin_data, "mnc[%d] = %c", plmn[*plmn_len].mnc);
        if (ret != RIL_E_SUCCESS)
        {
          QCRIL_LOG_ERROR("cannot get mnc from plmn_list");
          break;
        }
        ++(*plmn_len);

        // if cannot find any more pattern, return with success
        if (qcril_is_binary_data_empty(next_plmn_bin_data))
        {
          ret = RIL_E_SUCCESS;
          break;
        }
        current_plmn_bin_data = next_plmn_bin_data;
    }
    return ret;
} // qcril_qmi_nas_embms_parse_embms_plmn

/*===========================================================================

 qcril_qmi_nas_dms_activity_info_ind_hndlr

============================================================================*/
/*!
    @brief
    Handles QMI_DMS_MODEM_ACTIVITY_INFO_IND_V01

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_dms_activity_info_ind_hndlr
(
    dms_activity_info_ind_msg_v01* qmi_msg
)
{
    IxErrnoType                     found_qcril_request;
    RIL_Errno                       ril_req_res = RIL_E_GENERIC_FAILURE;
    RIL_ActivityStatsInfo           modem_activity_info;
    uint32_t                        i;

    QCRIL_LOG_FUNC_ENTRY();
    memset(&modem_activity_info, 0, sizeof(modem_activity_info));

    auto& msgList = getDmsModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestGetModemActivityMessage::get_class_message_id());
    found_qcril_request = (pendingMsg != nullptr) ? E_SUCCESS : E_FAILURE;

    QCRIL_LOG_INFO(".. found_req %d", (int)found_qcril_request);
    if (found_qcril_request == E_SUCCESS)
    {
        if (qmi_msg && qmi_msg->is_newly_calculated_values_valid && qmi_msg->is_newly_calculated_values)
        {
            ril_req_res = RIL_E_SUCCESS;
            if (qmi_msg->idle_mode_duration_valid)
            {
                modem_activity_info.idle_mode_time_ms =
                                            qmi_msg->idle_mode_duration;
            }

            if (qmi_msg->sleep_mode_duration_valid)
            {
                modem_activity_info.sleep_mode_time_ms =
                                            qmi_msg->sleep_mode_duration;
            }

            if (qmi_msg->rx_mode_duration_valid)
            {
                modem_activity_info.rx_mode_time_ms =
                                            qmi_msg->rx_mode_duration;
            }

            if (qmi_msg->tx_mode_duration_valid)
            {
                for (i = 0; i < qmi_msg->tx_mode_duration_len; i++)
                {
                    switch (qmi_msg->tx_mode_duration[i].tx_mode_level)
                    {
                        case DMS_TX_MODE_LEVEL_ONE_V01:
                        {
                            modem_activity_info.tx_mode_time_ms[RIL_TX_POWER_LEVEL_ONE] =
                                            qmi_msg->tx_mode_duration[i].tx_mode_duration;
                            break;
                        }
                        case DMS_TX_MODE_LEVEL_TWO_V01:
                        {
                            modem_activity_info.tx_mode_time_ms[RIL_TX_POWER_LEVEL_TWO] =
                                            qmi_msg->tx_mode_duration[i].tx_mode_duration;
                            break;
                        }
                        case DMS_TX_MODE_LEVEL_THREE_V01:
                        {
                            modem_activity_info.tx_mode_time_ms[RIL_TX_POWER_LEVEL_THREE] =
                                            qmi_msg->tx_mode_duration[i].tx_mode_duration;
                            break;
                        }
                        case DMS_TX_MODE_LEVEL_FOUR_V01:
                        {
                            modem_activity_info.tx_mode_time_ms[RIL_TX_POWER_LEVEL_FOUR] =
                                            qmi_msg->tx_mode_duration[i].tx_mode_duration;
                            break;
                        }
                        case DMS_TX_MODE_LEVEL_FIVE_V01:
                        {
                            modem_activity_info.tx_mode_time_ms[RIL_TX_POWER_LEVEL_FIVE] =
                                            qmi_msg->tx_mode_duration[i].tx_mode_duration;
                            break;
                        }
                        default:
                        {
                            break;
                        }
                    }
                }
            }
        }
        else if (qmi_msg)
        {
            ril_req_res = RIL_E_REQUEST_RATE_LIMITED;
        }

        auto msg = std::static_pointer_cast<RilRequestGetModemActivityMessage>(pendingMsg);
        if ( msg != nullptr ) {
            std::shared_ptr<qcril::interfaces::RilGetModemActivityResult_t> shared_resp = nullptr;
            if (RIL_E_SUCCESS == ril_req_res)
            {
                auto payload = new qcril::interfaces::RilGetModemActivityResult_t();
                if (payload != nullptr)
                {
                    memcpy(&payload->respData, &modem_activity_info, sizeof(modem_activity_info));
                    shared_resp.reset(payload);
                }
                else
                {
                    ril_req_res = RIL_E_NO_MEMORY;
                }
            }

            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_req_res, shared_resp);
            msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(pendingMsg);
        }
    }
}


/*===========================================================================

qcril_qmi_nas_dms_device_power_info_ind_hdlr
============================================================================*/
/*!
    @brief
    Handles QMI_DMS_DEVICE_POWER_INFO_IND_V01

    @return
    None
*/
/*=========================================================================*/

void qcril_qmi_nas_dms_device_power_info_ind_hdlr
(
    dms_device_power_info_request_ind_msg_v01 *power_ind_msg
)
{
    if (power_ind_msg == nullptr) {
        QCRIL_LOG_ERROR("power indication message null");
        return;
    }
    bool reportDevicePowerInfo = (power_ind_msg->report_power_status_valid) ?
            power_ind_msg->report_power_status : false;
    uint32_t batteryThresholdLen = (power_ind_msg->battery_threshold_list_valid) ?
            power_ind_msg->battery_threshold_list_len : 0;
    uint32_t* batteryThreshold = nullptr;
    if (power_ind_msg->battery_threshold_list_valid)
    {
        batteryThreshold = (uint32_t *) qcril_malloc(batteryThresholdLen * sizeof(uint32_t));
        if (batteryThreshold == nullptr) {
            QCRIL_LOG_ERROR("batteryThreshold memory alloc failed");
            return;
        }
        for (size_t i = 0; i < batteryThresholdLen; i++)
            batteryThreshold[i] = power_ind_msg->battery_threshold_list[i];
    }

    std::shared_ptr<DevicePowerInfoIndMessage> devicePowerInfoIndMsg =
            std::make_shared<DevicePowerInfoIndMessage>(reportDevicePowerInfo,
            batteryThreshold, batteryThresholdLen);
    if (devicePowerInfoIndMsg != nullptr) {
        devicePowerInfoIndMsg->broadcast();
    } else if (batteryThreshold != nullptr) {
        qcril_free(batteryThreshold);
    }
}

/*===========================================================================

 qcril_qmi_nas_dms_device_interactive_state_ind_hdlr
============================================================================*/
/*!
    @brief
    Handles QMI_DMS_DEVICE_INTERACTIVE_STATE_REQUEST_IND_V01

    @return
    None
*/
/*=========================================================================*/

void qcril_qmi_nas_dms_device_interactive_state_ind_hdlr
(
    dms_device_interactive_state_request_ind_msg_v01 *interactive_ind_msg
)
{
    if (interactive_ind_msg == nullptr)
    {
        QCRIL_LOG_ERROR("Device interactive state indication NULL");
        return;
    }
    bool reportDeviceInteractiveInfo =
            (interactive_ind_msg->report_device_interactive_state_valid) ?
            interactive_ind_msg->report_device_interactive_state : false;
    std::shared_ptr<DeviceInteractiveInfoIndMessage> deviceInteractiveInfoIndMsg =
            std::make_shared<DeviceInteractiveInfoIndMessage>(
            reportDeviceInteractiveInfo);
    if (deviceInteractiveInfoIndMsg != nullptr) {
        deviceInteractiveInfoIndMsg->broadcast();
    }
}

/*===========================================================================

 qcril_qmi_nas_reset_modem

============================================================================*/
/*!
    @brief
    reset modem

    @return
    None
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_reset_modem
(
    void
)
{
    dms_set_operating_mode_req_msg_v01  qmi_request     = {DMS_OP_MODE_ONLINE_V01};
    dms_set_operating_mode_resp_msg_v01 qmi_response;

    qmi_client_error_type error = QMI_NO_ERR;
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_response, 0, sizeof(qmi_response));
    qmi_request.operating_mode = DMS_OP_MODE_RESETTING_V01;
    error = qmi_client_send_msg_sync_with_shm(
                qcril_qmi_client_get_user_handle(QCRIL_QMI_CLIENT_DMS),
                QMI_DMS_SET_OPERATING_MODE_REQ_V01,
                &qmi_request,
                sizeof(qmi_request),
                &qmi_response,
                sizeof(qmi_response),
                QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT);

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                                                error, &qmi_response.resp);

    QCRIL_LOG_ESSENTIAL("qmi_transport_error %d, resp.result %d, resp.error %d",
                            error,
                            qmi_response.resp.result,
                            qmi_response.resp.error);

    QCRIL_LOG_FUNC_RETURN();

    return ril_req_res;
 }

/*===========================================================================

 qcril_qmi_nas_dms_config_activity_info

============================================================================*/
/*!
    @brief
    Config Activity info

    @return
    None
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_dms_config_activity_info
(
    uint8_t enable_statistics
)
{
    RIL_Errno             res = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_transport_error;

    dms_config_modem_activity_info_req_msg_v01  qmi_request;
    dms_config_modem_activity_info_resp_msg_v01 qmi_response;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_request, 0, sizeof(qmi_request));
    qmi_request.enable_statistics_valid = TRUE;
    qmi_request.enable_statistics = enable_statistics;

    qmi_transport_error = qmi_client_send_msg_sync(
                         qcril_qmi_client_get_user_handle(QCRIL_QMI_CLIENT_DMS),
                         QMI_DMS_TRIGGER_MODEM_ACTIVITY_INFO_CALCULATION_REQ_V01,
                         &qmi_request,
                         sizeof(qmi_request),
                         &qmi_response,
                         sizeof(qmi_response),
                         QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT);

     res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(
                                            qmi_transport_error,
                                            &qmi_response.resp,
                                            QCRIL_QMI_ERR_CTX_NONE,
                                            NULL);
    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);

    return res;
}

/*===========================================================================

 qcril_qmi_nas_dms_get_activity_info

============================================================================*/
/*!
    @brief
    Processes RIL_REQUEST_GET_ACTIVITY_INFO

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_dms_get_activity_info
(
  std::shared_ptr<RilRequestGetModemActivityMessage> msg
)
{
    RIL_Errno                         res       = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type             qmi_error;

    dms_get_modem_activity_info_resp_msg_v01 qmi_get_activity_info_resp;

    QCRIL_LOG_FUNC_ENTRY();

    memset (&qmi_get_activity_info_resp, 0, sizeof(qmi_get_activity_info_resp));

    do
    {

        auto ret = getDmsModule().getPendingMessageList().insert(msg);
        if (!ret.second)
        {
            QCRIL_LOG_ERROR("failed to insert msg to pending list");
            res = RIL_E_GENERIC_FAILURE;
            break;
        }

        qmi_error = qmi_client_send_msg_sync(
                      qcril_qmi_client_get_user_handle(QCRIL_QMI_CLIENT_DMS),
                      QMI_DMS_GET_MODEM_ACTIVITY_INFO_REQ_V01,
                      NULL,
                      0,
                      (void*) &qmi_get_activity_info_resp,
                      sizeof(qmi_get_activity_info_resp),
                      QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT);

        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                            qmi_error,
                            &qmi_get_activity_info_resp.resp);
        if (res != RIL_E_SUCCESS)
        {
            QCRIL_LOG_ERROR("Get activity info failed %d",res);
            getDmsModule().getPendingMessageList().erase(msg);
            break;
        }

    } while(0);

    if (res != RIL_E_SUCCESS)
    {
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(res, nullptr);
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    }

    return;
}

/*===========================================================================

 qcril_qmi_nas_log_lookup_enum_index

============================================================================*/
/*!
    @brief
    get enum index from enum id

    @return
    enum index
*/
/*=========================================================================*/
int qcril_qmi_nas_log_lookup_enum_index(int enum_id, qcril_qmi_enum_log_type* data, int min_index, int max_index)
{
    int min = min_index, max = max_index, index;
    while (min <= max)
    {
        index = (min+max)/2;

        if (data[index].enum_id == enum_id)
        {
            break;
        }
        else if (data[index].enum_id < enum_id)
        {
            min = index + 1;
        }
        else
        {
            max = index - 1;
        }
    }

    // if min > max, return last element which is unkown enum
    if (min > max)
    {
        index = max_index;
    }

    return index;
}

/*===========================================================================

 qcril_qmi_nas_get_qmi_lte_band_name

============================================================================*/
/*!
    @brief
    get qmi_lte_band_name from qmi_lte_band_enum

    @return
    qmi lte_band_name string
*/
/*=========================================================================*/
const char* qcril_qmi_nas_get_qmi_lte_band_name(int nas_band)
{
    int index;

    index = qcril_qmi_nas_log_lookup_enum_index(nas_band, (qcril_qmi_enum_log_type*)nas_active_band_enum_v01_name, 0, sizeof(nas_active_band_enum_v01_name)/sizeof(nas_active_band_enum_v01_name[0]) - 1);
    return nas_active_band_enum_v01_name[index].enum_name;
}

/*===========================================================================

 qcril_qmi_nas_get_ril_lte_band_name

============================================================================*/
/*!
    @brief
    get ril_lte_band_name from ril_lte_band_enum

    @return
    ril lte_band_name string
*/
/*=========================================================================*/
const char* qcril_qmi_nas_get_ril_lte_band_name(int ril_band)
{
    int index;

    index = qcril_qmi_nas_log_lookup_enum_index(ril_band, (qcril_qmi_enum_log_type*)ril_lte_band_pref_name, 0, sizeof(ril_lte_band_pref_name)/sizeof(ril_lte_band_pref_name[0]) - 1);
    return ril_lte_band_pref_name[index].enum_name;
}

/*===========================================================================

 qcril_qmi_nas_get_lte_band_priority_list

============================================================================*/
/*!
    @brief
    get lte_band_priority_list and store it in NAS cache

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_get_lte_band_priority_list (void)
{
  RIL_Errno ret = RIL_E_GENERIC_FAILURE;
  nas_get_lte_band_priority_list_req_msg_v01 qmi_request;
  nas_get_lte_band_priority_list_resp_msg_v01 qmi_response;
  qmi_client_error_type qmi_client_error;
  uint32_t i;

  QCRIL_LOG_FUNC_ENTRY();
  memset(&qmi_request, 0, sizeof(qmi_request));
  memset(&qmi_response, 0, sizeof(qmi_response));

  qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_LTE_BAND_PRIORITY_LIST_REQ_MSG_V01,
                                                &qmi_request,
                                                sizeof( qmi_request ),
                                                (void*) &qmi_response,
                                                sizeof( qmi_response ),
                                                ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);


  ret  = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_client_error , &qmi_response.resp );

  if (RIL_E_SUCCESS != ret)
  {
    QCRIL_LOG_DEBUG( ".. qmi_client_error %d, ril_error %d", (int)qmi_client_error , (int)ret);
  }
  else
  {
    if (qmi_response.configured_band_priority_list_valid)
    {
      QCRIL_LOG_DEBUG("modem band_priority_list_len %u", qmi_response.configured_band_priority_list_len);
      for (i = 0; i < qmi_response.configured_band_priority_list_len; i++)
      {
        QCRIL_LOG_DEBUG("modem band_priority_list[%u] = %s", i, qcril_qmi_nas_get_qmi_lte_band_name(qmi_response.configured_band_priority_list[i]));
      }
    }
    else
    {
      QCRIL_LOG_INFO("Invalid band_priority_list from modem");
    }
    NAS_CACHE_LOCK();
    NAS_CACHE_STORE_ENTRY_FIXED_LEN_ARR(nas_cached_info.band_priority_list, qmi_response.configured_band_priority_list);
    NAS_CACHE_UNLOCK();
  }

  QCRIL_LOG_INFO("completed with %d", ret);
  QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  qcril_qmi_nas_convert_ril_band_pref_to_qmi_band_pref

============================================================================*/
/*!
    @brief
    convert ril_band_pref enum to qmi_band_pref_enum

    @return
    NAS_ACTIVE_BAND_ENUM_MIN_ENUM_VAL_V01 for unknown ril_band_pref
    Corresponding qmi_band_pref enum for known ril_band_pref

*/
/*=========================================================================*/
nas_active_band_enum_v01 qcril_qmi_nas_convert_ril_band_pref_to_qmi_band_pref
(
   RIL_LTE_band_pref ril_band_pref
)
{
  nas_active_band_enum_v01 ret;

  switch (ril_band_pref)
  {
    case E_UTRA_Operating_Band_1:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_1_V01;
      break;
    case E_UTRA_Operating_Band_2:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_2_V01;
      break;
    case E_UTRA_Operating_Band_3:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_3_V01;
      break;
    case E_UTRA_Operating_Band_4:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_4_V01;
      break;
    case E_UTRA_Operating_Band_5:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_5_V01;
      break;
    case E_UTRA_Operating_Band_6:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_6_V01;
      break;
    case E_UTRA_Operating_Band_7:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_7_V01;
      break;
    case E_UTRA_Operating_Band_8:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_8_V01;
      break;
    case E_UTRA_Operating_Band_9:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_9_V01;
      break;
    case E_UTRA_Operating_Band_10:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_10_V01;
      break;
    case E_UTRA_Operating_Band_11:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_11_V01;
      break;
    case E_UTRA_Operating_Band_12:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_12_V01;
      break;
    case E_UTRA_Operating_Band_13:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_13_V01;
      break;
    case E_UTRA_Operating_Band_14:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_14_V01;
      break;
    case E_UTRA_Operating_Band_17:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_17_V01;
      break;
    case E_UTRA_Operating_Band_33:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_33_V01;
      break;
    case E_UTRA_Operating_Band_34:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_34_V01;
      break;
    case E_UTRA_Operating_Band_35:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_35_V01;
      break;
    case E_UTRA_Operating_Band_36:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_36_V01;
      break;
    case E_UTRA_Operating_Band_37:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_37_V01;
      break;
    case E_UTRA_Operating_Band_38:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_38_V01;
      break;
    case E_UTRA_Operating_Band_39:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_39_V01;
      break;
    case E_UTRA_Operating_Band_40:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_40_V01;
      break;
    case E_UTRA_Operating_Band_18:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_18_V01;
      break;
    case E_UTRA_Operating_Band_19:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_19_V01;
      break;
    case E_UTRA_Operating_Band_20:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_20_V01;
      break;
    case E_UTRA_Operating_Band_21:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_21_V01;
      break;
    case E_UTRA_Operating_Band_24:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_24_V01;
      break;
    case E_UTRA_Operating_Band_25:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_25_V01;
      break;
    case E_UTRA_Operating_Band_41:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_41_V01;
      break;
    case E_UTRA_Operating_Band_42:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_42_V01;
      break;
    case E_UTRA_Operating_Band_43:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_43_V01;
      break;
    case E_UTRA_Operating_Band_23:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_23_V01;
      break;
    case E_UTRA_Operating_Band_26:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_26_V01;
      break;
    case E_UTRA_Operating_Band_32:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_32_V01;
      break;
    case E_UTRA_Operating_Band_125:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_125_V01;
      break;
    case E_UTRA_Operating_Band_126:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_126_V01;
      break;
    case E_UTRA_Operating_Band_127:
      ret = NAS_ACTIVE_BAND_E_UTRA_OPERATING_BAND_127_V01;
      break;
    default: // unsupported
      QCRIL_LOG_DEBUG("Invalid RIL band_pref %d", ril_band_pref);
      ret = NAS_ACTIVE_BAND_ENUM_MIN_ENUM_VAL_V01;
      break;
  }
  return ret;
}

/*===========================================================================

  qmi_nas_is_lte_band_pref_outdated

============================================================================*/
/*!
    @brief
    check if lte_band_pref in nas_cache is outdated

    @return
    FALSE for nas_cache_is_updated
    TRUE for nas_cache_is outdated
*/
/*=========================================================================*/
boolean qmi_nas_is_lte_band_pref_outdated(nas_set_lte_band_priority_req_msg_v01 qmi_request)
{
  boolean ret = FALSE;
  uint32_t i;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  do
  {
    if (!nas_cached_info.band_priority_list_valid)
    {
      QCRIL_LOG_DEBUG("NAS cache was empty");
      ret = TRUE;
      break;
    }
    if (nas_cached_info.band_priority_list_len != qmi_request.band_priority_list_len)
    {
      QCRIL_LOG_DEBUG("NAS cache length doesn't match");
      ret = TRUE;
      break;
    }
    for (i = 0; i < qmi_request.band_priority_list_len; i++)
    {
      if (nas_cached_info.band_priority_list[i] != qmi_request.band_priority_list[i])
      {
        QCRIL_LOG_DEBUG("band_priority_list[%d] doesn't match", i);
        ret = TRUE;
        break;
      }
    }
  }
  while (0);
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
}

/*===========================================================================

 qcril_qmi_nas_set_lte_band_pref

============================================================================*/
/*!
    @brief
    Processes RIL_REQUEST_SET_LTE_BAND_PREF

    @return
    None
*/
/*=========================================================================*/

void qcril_qmi_nas_set_lte_band_pref
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  int* req_val;
  int i, ril_band_pref_len;
  nas_active_band_enum_v01 qmi_band_pref;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_set_lte_band_priority_req_msg_v01 qmi_request;
  nas_set_lte_band_priority_resp_msg_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  do
  {
    if ( params_ptr->datalen > NAS_ZERO && params_ptr->data != NULL )
    {
      req_val = (int*)params_ptr->data;
      if (!req_val)
      {
        QCRIL_LOG_DEBUG("NULL band_priority_list length");
        break;
      }
      ril_band_pref_len = req_val[0];
      if (ril_band_pref_len < 0 || ril_band_pref_len > NAS_LTE_BAND_PRIORITY_LIST_MAX_V01) // Wrong length
      {
        QCRIL_LOG_DEBUG("Invalid band_priority_list length %d", ril_band_pref_len);
        break;
      }
      memset( &qmi_request, 0, sizeof( qmi_request ) );
      if (ril_band_pref_len)
      {
        QCRIL_LOG_DEBUG("band_priority_list length: %d", ril_band_pref_len);
        ril_req_res = RIL_E_SUCCESS;
        qmi_request.band_priority_list_len = ril_band_pref_len;

        for (i = 0; i < ril_band_pref_len; i++)
        {
          qmi_band_pref = qcril_qmi_nas_convert_ril_band_pref_to_qmi_band_pref((RIL_LTE_band_pref)req_val[i+1]);
          if (qmi_band_pref != NAS_ACTIVE_BAND_ENUM_MIN_ENUM_VAL_V01)
          {
            QCRIL_LOG_DEBUG("band_priority_list[%d]: ril_band_pref: %s, qmi_band_pref: %s",
                            i,
                            qcril_qmi_nas_get_ril_lte_band_name(req_val[i+1]),
                            qcril_qmi_nas_get_qmi_lte_band_name(qmi_band_pref));
            qmi_request.band_priority_list[i] = qmi_band_pref;
          }
          else // Invalid ril_band_pref
          {
            QCRIL_LOG_DEBUG("Invalid ril_band_pref at position %d", i);
            ril_req_res  = RIL_E_GENERIC_FAILURE;
            break;
          }
        } // end of for
      }
      else  // ril_band_pref_len == 0
      {
        QCRIL_LOG_DEBUG("zero ril_band_pref_len");
        break;
      }
    }
    else // Empty RIL request payload
    {
      QCRIL_LOG_DEBUG("Empty RIL request payload");
      break;
    }
  }
  while (0);

  if ( RIL_E_SUCCESS == ril_req_res)
  {
    // Get lte_band_priority_list from modem and update cache
    qcril_qmi_nas_get_lte_band_priority_list();

    if(qmi_nas_is_lte_band_pref_outdated(qmi_request))
    {
      // Send QMI request
      qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_SET_LTE_BAND_PRIORITY_REQ_MSG_V01,
                                                    &qmi_request,
                                                    sizeof( qmi_request ),
                                                    (void*) &qmi_response,
                                                    sizeof( qmi_response ),
                                                    ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
    }
    else
    {
      QCRIL_LOG_DEBUG("request lte_band_pref same as in modem, no need to update");
    }
  }

  // Send RIL response
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res );
  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_is_ims_available
//===========================================================================
uint8_t qcril_qmi_nas_is_ims_available(void)
{
    uint8_t is_available = 0;
    uint32_t sub_capability = 0;

    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_LOCK();
    sub_capability = qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();

    if (sub_capability & (1 << RADIO_TECH_LTE))
    {
      is_available = 1;
    }

    if (is_available && qmi_ril_is_multi_sim_feature_supported())
    {
      is_available = 0;
      if(!nas_cached_info.is_default_data_subs_valid)
      {
        qcril_qmi_nas_get_subscription_info();
      }
      if(nas_cached_info.is_default_data_subs_valid && nas_cached_info.is_default_data_subs)
      {
        is_available = 1;
      }
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_DEBUG("is_available %d", is_available);
    QCRIL_LOG_FUNC_RETURN();

    return is_available;
}

/*===========================================================================

    qmi_ril_enable_ril_operational_status

============================================================================*/
/*!
    @brief
    Verify and move ril operational status to UNRESTRICTED

    @return
    None
*/
/*=========================================================================*/
void qmi_ril_enable_ril_operational_status()
{

  qmi_ril_gen_operational_status_type op_status;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  nas_common_info.sim_provisioned = TRUE;
  NAS_CACHE_UNLOCK();

  op_status = qmi_ril_get_operational_status();
  QCRIL_LOG_INFO( ".. op status %d", (int) op_status );
  if ( ( QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING == op_status ||
         QMI_RIL_GEN_OPERATIONAL_STATUS_RESUMING == op_status ) &&
       ( qmi_ril_is_multi_sim_feature_supported()  ||
         qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDA2 ) ))
  {
    QCRIL_LOG_INFO( "!QMI RIL! set UNRESTRICTED operational status" );
    qmi_ril_set_operational_status( QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED );

#ifndef QMI_RIL_UTF
    qcril_qmi_sms_report_unsol_ims_state_change();
    query_wms_ready_status();
#endif
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_is_voice_over_lte_registered
//===========================================================================
uint8_t qcril_qmi_nas_is_voice_over_lte_registered(void)
{
    uint8_t ret = FALSE;

    NAS_CACHE_LOCK();

    do
    {
        // TRUE only if full svc
        if( ( QMI_RIL_RTE_SUB_LTE == nas_cached_info.voice_rte ) &&
            ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag )
          )
        {
            ret = TRUE;
            break;
        }
    }while(0);

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);

    return ret;
} //qcril_qmi_nas_is_voice_over_lte_registered

uint8_t qcril_qmi_nas_check_long_short_name_as_mcc_mnc(const char *mcc, const char *mnc, char *qmi_nas_eons_name, char *ril_eons_name)
{
    int qmi_nas_eons_len = 0;
    uint8_t ret = FALSE;
    char *ptr_eons_name = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if(!mcc || !mnc || !qmi_nas_eons_name || !ril_eons_name)
        {
            break;
        }

        QCRIL_LOG_INFO("MCC %s, MNC %s, QMI_NAS_EONS_NAME %s", mcc, mnc, qmi_nas_eons_name);

        ptr_eons_name = qmi_nas_eons_name;
        memset(ril_eons_name, 0, NAS_OPERATOR_RESP_MAX_EONS_LEN);

        if(!is_operator_name_empty_or_white_space( ptr_eons_name, NAS_OPERATOR_RESP_MAX_EONS_LEN ))
        {
            qmi_nas_eons_len = strlen(ptr_eons_name);

            if(!strncmp(ptr_eons_name, mcc, strlen(mcc)))
            {
                QCRIL_LOG_INFO("MCC matched");
                if((qmi_nas_eons_len - strlen(mcc)) >= strlen(mnc))
                {
                    QCRIL_LOG_INFO("Sufficient length to compare MNC");
                    ptr_eons_name += (qmi_nas_eons_len - strlen(mnc));
                    if(!strncmp(ptr_eons_name, mnc, strlen(mnc)))
                    {
                        QCRIL_LOG_INFO("MNC matched");
                        strlcpy(ril_eons_name, qmi_nas_eons_name, NAS_OPERATOR_RESP_MAX_EONS_LEN);
                        memset(qmi_nas_eons_name, 0, NAS_OPERATOR_RESP_MAX_EONS_LEN);
                        ret = TRUE;
                    }
                }
            }
        }
        else
        {
            memset(qmi_nas_eons_name, 0, NAS_OPERATOR_RESP_MAX_EONS_LEN);
        }
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}

//===========================================================================
// qcril_qmi_nas_is_lte_only_registered
//===========================================================================
uint8_t qcril_qmi_nas_is_lte_only_registered(void)
{
    uint8_t ret = FALSE;
    qmi_ril_nw_reg_rte_type voice_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rat_confidence_tag_type confidence = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    uint8_t lte_srv_domain_valid = FALSE;
    nas_service_domain_enum_type_v01 lte_srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;

    NAS_CACHE_LOCK();
    voice_rte = nas_cached_info.voice_rte;
    confidence = nas_cached_info.voice_rte_confidence_tag;

    if(NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ))
    {
        lte_srv_domain_valid = nas_cached_info.lte_sys_info->common_sys_info.srv_domain_valid;
        lte_srv_domain = nas_cached_info.lte_sys_info->common_sys_info.srv_domain;
    }
    NAS_CACHE_UNLOCK();

    if (RADIO_TECH_LTE == qcril_qmi_nas_retrieve_reported_data_technology())
    {
        ret = TRUE;
        if ((QMI_RIL_RAT_CONFIDENCE_FULL_SVC == confidence || QMI_RIL_RAT_CONFIDENCE_LTD_SVC == confidence) &&
             QMI_RIL_RTE_SUB_LTE != voice_rte)
        {
            ret = FALSE;
        }
        else if(((QMI_RIL_RAT_CONFIDENCE_FULL_SVC == confidence) || (QMI_RIL_RAT_CONFIDENCE_LTD_SVC == confidence)) &&
             (QMI_RIL_RTE_SUB_LTE == voice_rte) && lte_srv_domain_valid &&
             ((SYS_SRV_DOMAIN_CS_ONLY_V01 == lte_srv_domain) || (SYS_SRV_DOMAIN_CS_PS_V01 == lte_srv_domain)))
        {
            ret = FALSE;
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_lte_only_registered

uint8_t qcril_qmi_nas_fetch_data_reg_rat(uint8_t *reported_tech_valid, int *reported_tech)
{
    uint8_t reg_status = FALSE;
    uint8_t reported_state_valid;
    int reported_state;

    NAS_CACHE_LOCK();
    reported_state_valid = nas_cached_info.reported_data_reg_status_valid;
    reported_state = nas_cached_info.reported_data_reg_status;
    *reported_tech_valid = nas_cached_info.reported_data_technology_valid;
    *reported_tech = nas_cached_info.reported_data_technology;
    NAS_CACHE_UNLOCK();

    if(reported_state_valid && ( (RIL_VAL_REG_REGISTERED_HOME_NET == reported_state) ||
       (RIL_VAL_REG_REGISTERED_ROAMING == reported_state)))
    {
        reg_status = TRUE;
    }

    return reg_status;
}

//===========================================================================
// QCRIL_EVT_HOOK_GET_RAT_RAC
//===========================================================================
void qcril_qmi_nas_get_rat_rac_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno result = RIL_E_SUCCESS;
    qcril_request_resp_params_type resp;
    qmi_ril_rat_rac_info local_rat_rac;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    memset(&local_rat_rac, 0, sizeof(local_rat_rac));

    NAS_CACHE_LOCK();
    if ( nas_cached_info.prev_reported_rat_rac_valid )
    {
        local_rat_rac.rat = nas_cached_info.prev_reported_rat_rac.rat;
        local_rat_rac.rac = nas_cached_info.prev_reported_rat_rac.rac;
    }
    else
    {
        local_rat_rac.rat = QMI_RIL_FF;
        local_rat_rac.rac = QMI_RIL_FF;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("RAT = %d, RAC = %d", local_rat_rac.rat, local_rat_rac.rac);

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    params_ptr->t,
                                    params_ptr->event_id,
                                    result,
                                    &resp );

    resp.resp_pkt = &local_rat_rac;
    resp.resp_len = sizeof(local_rat_rac);
    qcril_send_request_response( &resp );

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_send_unsol_rat_rac_changed
//===========================================================================
void qcril_qmi_nas_send_unsol_rat_rac_changed(uint8_t rat, uint8_t rac)
{
    qmi_ril_rat_rac_info local_rat_rac;

    memset(&local_rat_rac, 0, sizeof(local_rat_rac) );
    local_rat_rac.rat = rat;
    local_rat_rac.rac = rac;
    qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_RAT_RAC_CHANGE_IND, (char *)&local_rat_rac, sizeof(local_rat_rac));
    NAS_CACHE_LOCK();
    nas_cached_info.prev_reported_rat_rac_valid = TRUE;
    nas_cached_info.prev_reported_rat_rac.rat = local_rat_rac.rat;
    nas_cached_info.prev_reported_rat_rac.rac = local_rat_rac.rac;
    NAS_CACHE_UNLOCK();
}

//===========================================================================
//qcril_qmi_nas_clear_reported_rat_rac_cache
//===========================================================================
void qcril_qmi_nas_clear_reported_rat_rac_cache()
{
    NAS_CACHE_LOCK();
    nas_cached_info.prev_reported_rat_rac_valid = FALSE;
    memset(&nas_cached_info.prev_reported_rat_rac, 0, sizeof(nas_cached_info.prev_reported_rat_rac));
    nas_cached_info.prev_reported_rat_rac.rat = QMI_RIL_FF;
    nas_cached_info.prev_reported_rat_rac.rac = QMI_RIL_FF;
    NAS_CACHE_UNLOCK();
}

//===========================================================================
//qcril_qmi_nas_report_change_in_rat_rac
//===========================================================================
void qcril_qmi_nas_report_change_in_rat_rac()
{
    uint8_t is_rat_rac_change = FALSE;
    uint8_t prev_reported_rat_rac_valid = FALSE;
    qmi_ril_rat_rac_info prev_reported_rat_rac;
    uint8_t new_reported_rat_rac_valid = FALSE;
    qmi_ril_rat_rac_info new_reported_rat_rac;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&prev_reported_rat_rac, 0, sizeof(prev_reported_rat_rac));
    memset(&new_reported_rat_rac, 0, sizeof(new_reported_rat_rac));

    NAS_CACHE_LOCK();
    prev_reported_rat_rac_valid = nas_cached_info.prev_reported_rat_rac_valid;
    prev_reported_rat_rac.rat = nas_cached_info.prev_reported_rat_rac.rat;
    prev_reported_rat_rac.rac = nas_cached_info.prev_reported_rat_rac.rac;

    if (  NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_rac) )
    {
        new_reported_rat_rac_valid = TRUE;
        new_reported_rat_rac.rat = RADIO_TECH_UMTS;
        new_reported_rat_rac.rac = nas_cached_info.wcdma_rac;
    }
    else if (  NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_rac) )
    {
        new_reported_rat_rac_valid = TRUE;
        new_reported_rat_rac.rat = RADIO_TECH_GSM;
        new_reported_rat_rac.rac = nas_cached_info.gsm_rac;
    }
    else
    {
        new_reported_rat_rac.rat = QMI_RIL_FF;
        new_reported_rat_rac.rac = QMI_RIL_FF;
    }
    NAS_CACHE_UNLOCK();

    do
    {
        if ( (new_reported_rat_rac_valid == TRUE) && (prev_reported_rat_rac_valid == TRUE) )
        {
            if ( prev_reported_rat_rac.rat != new_reported_rat_rac.rat )
            {
                is_rat_rac_change = TRUE;
                break;
            }
            else if ( prev_reported_rat_rac.rac != new_reported_rat_rac.rac )
            {
                is_rat_rac_change = TRUE;
                break;
            }
        }
        else if ( new_reported_rat_rac_valid || prev_reported_rat_rac_valid )
        {
            is_rat_rac_change = TRUE;
            break;
        }

    } while ( FALSE );


    if ( is_rat_rac_change == TRUE )
    {
        QCRIL_LOG_INFO("old RAT_RAC_VALID_STATUS - %d new RAT_RAC_VALID_STATUS - %d", prev_reported_rat_rac_valid, new_reported_rat_rac_valid);
        QCRIL_LOG_INFO("old RAT - %d new RAT - %d", prev_reported_rat_rac.rat, new_reported_rat_rac.rat);
        QCRIL_LOG_INFO("old RAC - %d new RAC - %d", prev_reported_rat_rac.rac, new_reported_rat_rac.rac);
        qcril_qmi_nas_send_unsol_rat_rac_changed(new_reported_rat_rac.rat, new_reported_rat_rac.rac);
    }
    else
    {
        QCRIL_LOG_INFO("No change in RAT - %d, RAC - %d", new_reported_rat_rac.rat, new_reported_rat_rac.rac);
    }

    QCRIL_LOG_FUNC_RETURN();
}  // qcril_qmi_nas_report_change_in_rat_rac

RIL_Errno qcril_qmi_nas_set_operating_mode_state(dms_operating_mode_enum_v01 requested_operating_mode)
{
    dms_set_operating_mode_req_msg_v01   qmi_request;
    dms_set_operating_mode_resp_msg_v01   qmi_response;
    qmi_client_error_type qmi_transport_error;
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    memset(&qmi_request, 0, sizeof(qmi_request));
    memset(&qmi_response, 0, sizeof(qmi_response));
    qmi_request.operating_mode = requested_operating_mode;

    if(QCRIL_DEFAULT_INSTANCE_ID == qmi_ril_get_process_instance_id())
    {
        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                           QMI_DMS_SET_OPERATING_MODE_REQ_V01,
                                                           &qmi_request,
                                                           sizeof( qmi_request ),
                                                           &qmi_response,
                                                           sizeof( qmi_response ),
                                                           QCRIL_QMI_DMS_SET_OPERATING_MODE_SYNC_TIMEOUT );

        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(qmi_transport_error,
                                                                         &qmi_response.resp,
                                                                         QCRIL_QMI_ERR_TOLERATE_NOT_READY,
                                                                         NULL);

        QCRIL_LOG_INFO("Requested operating mode setted to modem is %d result %d", requested_operating_mode, res);
    }

    return res;
}

void qcril_qmi_nas_poll_operating_mode_handler(void* params)
{
    (void)params;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    nas_common_info.opmode_query_timer_id_valid = FALSE;
    NAS_CACHE_UNLOCK();

    auto cur_op_mode = qcril_qmi_nas_dms_get_current_operating_mode();
    QCRIL_LOG_DEBUG("get current op mode: %d", cur_op_mode);
    if (cur_op_mode == DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01)
    {
        qcril_qmi_nas_trigger_polling_operating_mode();
    }
    else
    {
        qcril_qmi_nas_notify_radio_power_if_dms_up();
        if (QCRIL_POWER_OPT_BOOT_UP_TRIGGER_LPM == qcril_qmi_nas_get_bootup_power_optimization_state())
        {
            qcril_qmi_nas_trigger_bootup_optimization();
        }
        else if (QCRIL_POWER_OPT_BOOT_UP_TRIGGER_COMPLETE == qcril_qmi_nas_get_bootup_power_optimization_state())
        {
            qcril_qmi_nas_set_lpm_after_ssr_in_apm();
        }
        qmi_ril_wave_modem_status();
    }
}

void qcril_qmi_nas_trigger_polling_operating_mode()
{
    NAS_CACHE_LOCK();

    if (!nas_common_info.opmode_query_timer_id_valid)
    {
        struct timeval poll_interval = {.tv_sec = 1, .tv_usec = 0 };
        int ret = qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
                qcril_qmi_nas_poll_operating_mode_handler,
                &poll_interval, &nas_common_info.opmode_query_timer_id);
        if (ret == E_SUCCESS)
        {
            nas_common_info.opmode_query_timer_id_valid = TRUE;
        }
        else
        {
            QCRIL_LOG_ERROR("failed to setup timed callback: %d", ret);
        }
    }
    else
    {
        QCRIL_LOG_DEBUG("There is already a polling timer...");
    }

    NAS_CACHE_UNLOCK();
}

void qcril_qmi_nas_trigger_bootup_optimization()
{
    QCRIL_LOG_FUNC_ENTRY();

    if (!qmi_ril_is_feature_supported(QMI_RIL_FEATURE_POWER_ON_OPTIMIZATION))
        return;

    auto cur_op_mode = qcril_qmi_nas_dms_get_current_operating_mode();
    if (cur_op_mode == DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01)
    {
        QCRIL_LOG_DEBUG("Operating mode is not available, polling...");
        // For long term solution, qcril_qmi_nas_trigger_bootup_optimization()
        // will be called again by dms event indication. Use poll for now
        qcril_qmi_nas_trigger_polling_operating_mode();
        return;
    }

    if (DMS_OP_MODE_FACTORY_TEST_MODE_V01 == cur_op_mode)
    {
        qcril_qmi_nas_set_bootup_power_optimization_state(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_COMPLETE);
    }
    else if (FALSE == qcril_qmi_nas_is_apm_enabled())
    {
        // use NAS_LOCK to protect "GET and SET" combination
        NAS_CACHE_LOCK();
        if (QCRIL_POWER_OPT_BOOT_UP_TRIGGER_LPM == qcril_qmi_nas_get_bootup_power_optimization_state())
        {
            qcril_qmi_nas_set_bootup_power_optimization_state(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_ONLINE);
            NAS_CACHE_UNLOCK();
            if (cur_op_mode == DMS_OP_MODE_LOW_POWER_V01)
            {
                QCRIL_LOG_DEBUG("The operating state is already LPM...");
                qcril_qmi_nas_boot_up_optimization_state_machine();
            }
            else
            {
                if (qcril_qmi_nas_set_operating_mode_state(DMS_OP_MODE_LOW_POWER_V01) != RIL_E_SUCCESS)
                {
                    QCRIL_LOG_ERROR("Unexpected: failed to set LPM");
                    qcril_qmi_nas_set_bootup_power_optimization_state(QCRIL_POWER_OPT_BOOT_UP_TRIGGER_COMPLETE);
                }
            }
        }
        else
        {
            NAS_CACHE_UNLOCK();
        }
    }
}

void qcril_qmi_nas_decide_mode_pref_to_set_on_modem(int *android_mode_pref)
{
    unsigned long ret_val;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int temp_len;
    char *end_ptr;

    memset(&property_name, 0, sizeof(property_name));
    memset(&property_value, 0, sizeof(property_value));

    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s%d", QMI_RIL_POWER_OPT_MODE_PREF, qmi_ril_get_process_instance_id() );
    property_get( property_name, property_value, "" );
    temp_len = strlen( property_value );
    if ( temp_len > 0 )
    {
        ret_val = strtoul( property_value, &end_ptr, 0 );
        *android_mode_pref = (int)ret_val;
    }
    else
    {
        memset(&property_name, 0, sizeof(property_name));
        memset(&property_value, 0, sizeof(property_value));
        strlcpy(property_name, QCRIL_DEFAULT_NETWORK, PROPERTY_VALUE_MAX);
        property_get( property_name, property_value, "" );
        temp_len = strlen( property_value );
        if ( temp_len > 0 )
        {
            ret_val = strtoul( property_value, &end_ptr, 0 );
            *android_mode_pref = (int)ret_val;
        }
    }
}

void qcril_qmi_nas_update_mode_pref_prop(int android_mode_pref)
{
    errno_enum_type result;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];

    memset(&property_name, 0, sizeof(property_name));
    memset(&property_value, 0, sizeof(property_value));
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s%d", QMI_RIL_POWER_OPT_MODE_PREF, qmi_ril_get_process_instance_id() );
    QCRIL_SNPRINTF( property_value, sizeof(property_value), "%d", android_mode_pref );
    result = (IxErrnoType)property_set(property_name, property_value);
    QCRIL_LOG_INFO( "result %d", (int) result );
    if ( E_SUCCESS != result)
    {
        QCRIL_LOG_ERROR( "Failed to set user mode pref prop!");
    }
}

uint8_t qcril_qmi_nas_get_bootup_power_optimization_state()
{
    uint8_t status = FALSE;
    NAS_CACHE_LOCK();
    status = nas_cached_info.bootup_power_optimization_state;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_DEBUG("get bootup power optimizaiton state as %d", status);

    return status;
}

void qcril_qmi_nas_set_bootup_power_optimization_state(uint8_t status)
{
    QCRIL_LOG_DEBUG("set bootup power optimizaiton state as %d", status);
    NAS_CACHE_LOCK();
    nas_cached_info.bootup_power_optimization_state = status;
    NAS_CACHE_UNLOCK();
}

void qcril_qmi_nas_report_vrt_for_power_optimization()
{
    unsigned int reported_voice_radio_tech;

    reported_voice_radio_tech = qcril_qmi_nas_get_reported_voice_radio_tech();

    auto msg = std::make_shared<RilUnsolVoiceRadioTechChangedMessage>(reported_voice_radio_tech);
    Dispatcher::getInstance().dispatchSync(msg);
}

void qcril_qmi_nas_oem_hook_set_atel_ui_status_to_modem
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    uint8_t ui_status = FALSE;
    qcril_instance_id_e_type instance_id;
    qcril_request_resp_params_type resp;
    RIL_Errno   ril_req_res = RIL_E_SUCCESS;
    QCRIL_NOTUSED(ret_ptr);

    instance_id = QCRIL_DEFAULT_INSTANCE_ID;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if( (NULL == params_ptr) || (params_ptr->data == NULL) || (params_ptr->datalen == 0))
        {
            ril_req_res = RIL_E_GENERIC_FAILURE;
            break;
        }

        qcril_qmi_nas_set_atel_ui_ready_req_came_to_cache(TRUE);

        if(qcril_qmi_nas_get_atel_ui_status_from_cache())
        {
            QCRIL_LOG_INFO("ATeL UI is already in ready state");
            ril_req_res = RIL_E_SUCCESS;
            break;
        }

        qcril_qmi_nas_send_known_signal_strength();
        qcril_qmi_nas_wave_voice_data_status();
        qcril_qmi_sms_report_unsol_ims_state_change();

        ui_status = *((uint8_t *)params_ptr->data);

        ril_req_res = qcril_qmi_nas_set_atel_ui_status_to_modem(ui_status);//ATEL_UI READY, ui_status=1
    }while(FALSE);

    if(params_ptr)
    {
        qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
        qcril_send_request_response( &resp );
    }

    if(ui_status)
    {
        NAS_CACHE_LOCK();
        qcril_qmi_nas_set_atel_ui_status_to_cache(ui_status);
        qcril_qmi_voice_notify_ussd_power_opt_to_atel();
        qcril_qmi_sms_notify_mt_sms_with_ack_needed_power_opt_to_atel();
        qcril_qmi_sms_notify_mt_sms_with_ack_not_needed_power_opt_to_atel();
        qcril_qmi_nas_notify_ril_nitz_time_to_atel();
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
}

RIL_Errno qcril_qmi_nas_set_atel_ui_status_to_modem(uint8_t ui_status)
{
    dms_set_ui_status_info_req_msg_v01   qmi_request;
    dms_set_ui_status_info_resp_msg_v01   qmi_response;
    qmi_client_error_type qmi_transport_error;
    RIL_Errno res = RIL_E_SUCCESS;
    memset(&qmi_request, 0, sizeof(qmi_request));
    memset(&qmi_response, 0, sizeof(qmi_response));
    qmi_request.ui_ready_status_valid = TRUE;
    qmi_request.ui_ready_status = ui_status;

    if(QCRIL_DEFAULT_INSTANCE_ID == qmi_ril_get_process_instance_id())
    {
        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                           QMI_DMS_SET_UI_STATUS_INFO_REQ_V01,
                                                           &qmi_request,
                                                           sizeof( qmi_request ),
                                                           &qmi_response,
                                                           sizeof( qmi_response ),
                                                           QCRIL_QMI_DMS_SET_OPERATING_MODE_SYNC_TIMEOUT );

        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(qmi_transport_error,
                                                                         &qmi_response.resp,
                                                                         QCRIL_QMI_ERR_TOLERATE_NOT_READY,
                                                                         NULL);

        QCRIL_LOG_INFO("Requested ATEL UI STATUS setted to modem is %d result %d", ui_status, res);
    }

    return res;
}

RIL_Errno qcril_qmi_nas_get_atel_ui_status_from_modem(uint8_t *ui_status_valid, uint8_t *ui_status)
{
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
    dms_get_ui_status_info_resp_msg_v01 qmi_response;
    qmi_client_error_type qmi_transport_error;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_response,0,sizeof(qmi_response));

    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_GET_UI_STATUS_INFO_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_response,
                                                       sizeof( qmi_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);

    QCRIL_LOG_INFO("msg send error code %d",ril_req_res);

    if ( RIL_E_SUCCESS == ril_req_res )
    {
        QCRIL_LOG_INFO(".. known ATEL UI STATUS Valid %d, value %d ", (int) qmi_response.ui_ready_status_valid, (int) qmi_response.ui_ready_status );
        *ui_status_valid = qmi_response.ui_ready_status_valid;
        *ui_status = qmi_response.ui_ready_status;
    }

    QCRIL_LOG_FUNC_RETURN();
    return ril_req_res;
}

uint8_t qcril_qmi_nas_get_atel_ui_status_from_cache()
{
    uint8_t ui_status_valid = FALSE;
    uint8_t ui_status = FALSE;
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

    NAS_CACHE_LOCK();
    ui_status_valid = nas_cached_info.atel_ui_status_valid;
    ui_status = nas_cached_info.atel_ui_status;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(".. In RIL cache, known ATEL UI STATUS Valid %d, value %d ", ui_status_valid, ui_status);
    if(!ui_status_valid)
    {
        ril_req_res = qcril_qmi_nas_get_atel_ui_status_from_modem(&ui_status_valid, &ui_status);
        if(RIL_E_SUCCESS == ril_req_res)
        {
            NAS_CACHE_LOCK();
            nas_cached_info.atel_ui_status_valid = ui_status_valid;
            nas_cached_info.atel_ui_status = ui_status;
            NAS_CACHE_UNLOCK();
        }
    }

    QCRIL_LOG_INFO(".. known ATEL UI STATUS Valid %d, value %d ", ui_status_valid, ui_status);
    return ui_status;
}

void qcril_qmi_nas_set_atel_ui_status_to_cache(uint8_t ui_status)
{
    NAS_CACHE_LOCK();
    nas_cached_info.atel_ui_status_valid = TRUE;
    nas_cached_info.atel_ui_status = ui_status;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(".. updated ATEL UI STATUS to cache %d", ui_status);
}

void qcril_qmi_nas_clean_atel_ui_status_from_cache()
{
    NAS_CACHE_LOCK();
    nas_cached_info.atel_ui_status_valid = FALSE;
    nas_cached_info.atel_ui_status = FALSE;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(".. Clean ATEL UI STATUS from cache");
}

void qcril_qmi_nas_notify_ussd_ind_hdlr(void* decoded_payload, uint32_t decoded_payload_len)
{
    uint8_t atel_ui_status = FALSE;

    if(qmi_ril_is_feature_supported(QMI_RIL_FEATURE_POWER_ON_OPTIMIZATION))
    {
        NAS_CACHE_LOCK();
        atel_ui_status = qcril_qmi_nas_get_atel_ui_status_from_cache();
        if(atel_ui_status)
        {
            qcril_qmi_voice_ussd_ind_hdlr(decoded_payload, decoded_payload_len);
        }
        else
        {
            qcril_qmi_voice_update_ussd_power_opt_buffer((voice_ussd_ind_msg_v02 *)decoded_payload);
        }
        NAS_CACHE_UNLOCK();
    }
    else
    {
        qcril_qmi_voice_ussd_ind_hdlr((voice_ussd_ind_msg_v02 *)decoded_payload, decoded_payload_len);
    }
}

void qcril_qmi_nas_notify_mt_sms_ind_hdlr(wms_event_report_ind_msg_v01* decoded_payload, qcril_instance_id_e_type instance_id)
{
    uint8_t atel_ui_status = FALSE;

    if(qmi_ril_is_feature_supported(QMI_RIL_FEATURE_POWER_ON_OPTIMIZATION))
    {
        NAS_CACHE_LOCK();
        atel_ui_status = qcril_qmi_nas_get_atel_ui_status_from_cache();
        if(atel_ui_status)
        {
            qcril_sms_process_event_report_ind((wms_event_report_ind_msg_v01 *)decoded_payload, instance_id);
        }
        else
        {
            qcril_sms_update_mt_sms_power_opt_buffer((wms_event_report_ind_msg_v01 *)decoded_payload);
        }
        NAS_CACHE_UNLOCK();
    }
    else
    {
        qcril_sms_process_event_report_ind((wms_event_report_ind_msg_v01 *)decoded_payload, instance_id);
    }
}

void qcril_qmi_nas_mt_sms_power_opt_transaction_expired(QCRIL_UNUSED(void * param))
{
    QCRIL_LOG_INFO(".. Reset MT SMS buffer for power opt");
    NAS_CACHE_LOCK();
    qcril_qmi_sms_reset_mt_sms_ack_needed_power_opt_buffer();
    NAS_CACHE_UNLOCK();
}

void qcril_qmi_nas_set_atel_ui_ready_req_came_to_cache(uint8_t status)
{
    NAS_CACHE_LOCK();
    nas_cached_info.is_atel_ready_request = status;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(".. updated ATEL UI READY REQ to cache %d", status);
}

void qcril_qmi_nas_clean_atel_ui_ready_req_came_from_cache()
{
    NAS_CACHE_LOCK();
    nas_cached_info.is_atel_ready_request = FALSE;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(".. Clean ATEL UI READY REQ from cache");
}

uint8_t qcril_qmi_nas_get_atel_ui_ready_req_came_from_cache()
{
    uint8_t status = FALSE;

    NAS_CACHE_LOCK();
    status = nas_cached_info.is_atel_ready_request;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(".. updated ATEL UI READY REQ status in cache %d", status);

    return status;
}

void qcril_qmi_nas_notify_ril_nitz_time_to_atel()
{
    char ril_nitz_time[NAS_NITZ_STR_BUF_MAX];
    qcril_unsol_resp_params_type unsol_resp_params;
    uint8_t nitz_updated = FALSE;

    memset(&ril_nitz_time,0,sizeof(ril_nitz_time));
    memset(&unsol_resp_params,0,sizeof(unsol_resp_params));

    nitz_updated = qcril_qmi_nas_query_sib16_network_time(ril_nitz_time);
    QCRIL_LOG_INFO(".. SIB16 NITZ TIME updated status: %d", nitz_updated);

    if(FALSE == nitz_updated)
    {
        nitz_updated = qcril_qmi_nas_query_network_time(ril_nitz_time);
        QCRIL_LOG_INFO(".. Network NITZ TIME updated status: %d", nitz_updated);
    }

    if(TRUE == nitz_updated)
    {
        auto msg = std::make_shared<RilUnsolNitzTimeReceivedMessage>(ril_nitz_time);
        Dispatcher::getInstance().dispatchSync(msg);
    }
}

uint8_t qcril_qmi_nas_is_feature_power_opt_enable()
{
    return nas_common_info.is_feature_power_opt_enabled;
}

void qcril_qmi_dms_get_msisdn_resp_hldr
(
    const qcril_request_params_type *const param_ptr
)
{
    uint32_t cur_status = 0;
    int need_update_cur_status = FALSE;
    int process_ecc_now = FALSE;
    int res = FALSE;
    char home_mcc_for_consideration[ NAS_MCC_MNC_MAX_V01 + 1 ];
    dms_get_msisdn_resp_msg_v01 *get_msisdn_resp;
    char emergency_nums[200] = {0};

    QCRIL_LOG_FUNC_ENTRY();

    if( param_ptr->data != NULL )
    {
        get_msisdn_resp = (dms_get_msisdn_resp_msg_v01 *)param_ptr->data;

        NAS_CACHE_LOCK();
        cur_status = nas_cached_info.designated_number_added_for_designated_country_status;
        NAS_CACHE_UNLOCK();

        if ( get_msisdn_resp->imsi_valid )
        {
            QCRIL_LOG_DEBUG( "known imsi %s", get_msisdn_resp->imsi );
            memset( home_mcc_for_consideration, 0, sizeof( home_mcc_for_consideration ));
            memcpy( home_mcc_for_consideration, get_msisdn_resp->imsi, NAS_MCC_MNC_MAX_V01 );
            NAS_CACHE_LOCK();
            strlcpy(nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                    home_mcc_for_consideration,
                    NAS_MCC_MNC_MAX_V01 + 1);
            NAS_CACHE_UNLOCK();

            cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
            process_ecc_now = TRUE;
        } // if ( get_msisdn_resp->imsi_valid )
        else
        {
            process_ecc_now = qcril_qmi_nas_fetch_imsi_from_cache_or_iccid((uint32 *)&cur_status);
        }

        if ( process_ecc_now )
        {
            qcril_qmi_nas_add_emergency_numbers(&cur_status,
                                                &res,
                                                &need_update_cur_status,
                                                emergency_nums);
        }

        if ( need_update_cur_status )
        {
            NAS_CACHE_LOCK();
            nas_cached_info.designated_number_added_for_designated_country_status = cur_status;
            NAS_CACHE_UNLOCK();
            qmi_ril_send_ecc_list_indication();
        }
        else
        {
            // In case failure received for GET IMSI, update property with PBM values.
            qmi_ril_send_ecc_list_indication();
        }
    }

    /* Free existing reqlist entry added while sending request */
    qcril_reqlist_free(QCRIL_DEFAULT_INSTANCE_ID, param_ptr->t);
}

void qcril_qmi_nas_add_emergency_numbers
(
    uint32_t* cur_status,
    int* res,
    int* need_update_cur_status,
    char* emergency_nums
)
{
    int nw_res = FALSE;
    int update_ecclist = FALSE;
    int valid_case = FALSE;
    char nw_ecc_nums[QCRIL_MAX_EMERGENCY_NUMBERS_LEN];
    qmi_ril_custom_emergency_numbers_source_type source;
    qcril::interfaces::RIL_EccMapType  ecc_map;

    QCRIL_LOG_FUNC_ENTRY();

    source = QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NONE;

    NAS_CACHE_LOCK();

    memset(nw_ecc_nums, 0, sizeof(nw_ecc_nums));

    if ( !( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_FETCHED ) &&
         !( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH ) &&
          ( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED ) )
    {
        // clear the status related with mcc/voice matched using mcc got from card
        // because we need to re-check this (triggered by card status change or voice service state change)
        *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
        *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
        *cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
        // firstly, check SOURCE_MCC table with voice service state
        *res = qcril_check_mcc_part_of_emergency_numbers_table_with_service_state(
                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC,
                        TRUE,
                        nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                        FALSE,
                        NULL,
                        emergency_nums);
        if ( *res )
        {
            QCRIL_LOG_ESSENTIAL( "matched with source mcc table using IMSI MCC");
            *cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH);
            *need_update_cur_status = TRUE;
        }

        // secondly, check SOURCE_VOICE_MCC table with voice service state
        *res = qcril_check_mcc_part_of_emergency_numbers_table_with_service_state(
                    QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC,
                    TRUE,
                    nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                    FALSE,
                    NULL,
                    emergency_nums);
        if ( *res )
        {
            QCRIL_LOG_ESSENTIAL("matched with source voice table using IMSI MCC");
            *cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH);
            *need_update_cur_status = TRUE;
        }

        if (*cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED)
        {
            // check SOURCE_SOURCE_MCC table with nw mcc
            *res = qcril_check_mcc_part_of_emergency_numbers_table_with_service_state(
                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC,
                        TRUE,
                        nas_cached_info.mcc_from_device_reg,
                        FALSE,
                        NULL,
                        emergency_nums);
            if ( *res )
            {
                QCRIL_LOG_ESSENTIAL("matched with source mcc table using NW MCC");
                *cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH);
                *need_update_cur_status = TRUE;
            }
        }

    } // if ( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED ) -
      //QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH and
      //QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH consider

    NAS_CACHE_UNLOCK();

    if ( *cur_status &
         QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED )
    {
        *cur_status &= ~( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED |
                         QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED |
                         QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH |
                         QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK );
        *need_update_cur_status = TRUE;
    }

    // on this iteration, or previously we know if home plmn matches designated plmn, now check if projection of design. number is required
    if ( !( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED ) )
    {
        if( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_MCC_MNC_MATCH )
        {
            source = QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC_MNC;
            valid_case = TRUE;
        }
        else if ( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_VOICE_MCC_MNC_MATCH )
        {
            source = QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC_MNC;
            valid_case = TRUE;
        }
        else if( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH )
        {
            source = QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC;
            valid_case = TRUE;
        }
        else if( *cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH )
        {
            source = QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC;
            valid_case = TRUE;
        }

        NAS_CACHE_LOCK();

        if( valid_case )
        {
            if ( source == QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC_MNC ||
                 source == QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE_MCC_MNC )
            {
                *res = qcril_db_is_mcc_part_of_emergency_numbers_table(source,
                            TRUE,
                            nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                            TRUE,
                            nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX],
                            emergency_nums);
                qmi_ril_fill_ecc_map(emergency_nums,
                    ecc_map,
                    RIL_EccNumberSourceMask::MODEM_CONFIG,
                    nas_cached_info.designated_number_mcc[QCRIL_CARD_MCC_MATCH_INDEX],
                    nas_cached_info.designated_number_mnc[QCRIL_CARD_MNC_MATCH_INDEX]);
            }
            else
            {
                *res = qcril_db_is_mcc_part_of_emergency_numbers_table(source,
                            TRUE,
                            nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                            FALSE,
                            NULL,
                            emergency_nums);

                qmi_ril_fill_ecc_map(emergency_nums,
                    ecc_map,
                    RIL_EccNumberSourceMask::MODEM_CONFIG,
                    nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                    nullptr);

                // If nw mcc is valid and different from card mcc,
                // add emergency numbers based on nw mcc as well
                if (*cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH)
                {
                    int ret = strncmp(nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                                     nas_cached_info.mcc_from_device_reg,
                                     NAS_MCC_MNC_MAX_V01);
                    // mcc differs, fetch numbers from MCC table using nw mcc
                    if (ret != 0)
                    {
                        nw_res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC,
                                        TRUE,
                                        nas_cached_info.mcc_from_device_reg,
                                        FALSE,
                                        NULL,
                                        nw_ecc_nums);

                        qmi_ril_fill_ecc_map(nw_ecc_nums,
                            ecc_map,
                            RIL_EccNumberSourceMask::MODEM_CONFIG,
                            nas_cached_info.mcc_from_device_reg,
                            nullptr);

                        if( nw_res )
                        {
                            strlcat(emergency_nums, ",", QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                            strlcat(emergency_nums, nw_ecc_nums, QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                            *cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH);
                            *cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED;
                            *need_update_cur_status = TRUE;
                            strlcpy(nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                nas_cached_info.mcc_from_device_reg,
                                NAS_MCC_MNC_MAX_V01 + 1);
                        }
                    }
                }
            }

            if ( *res || nw_res )
            {
                strlcat(emergency_nums,",",QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                update_ecclist = TRUE;
            }
        }

        if ( update_ecclist )
        {
            QCRIL_LOG_ESSENTIAL( "Update ril ecclist");
            *cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED; // indicate that we injected one of designated number
            *need_update_cur_status = TRUE;
            nas_cached_info.ril_ecc_map = ecc_map;
        }

        NAS_CACHE_UNLOCK();
    } // if for mcc match but not projected

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_start_timer_if_early_radio_power_req_came
//===========================================================================
void qcril_qmi_nas_start_timer_if_early_radio_power_req_came()
{
    QCRIL_LOG_FUNC_ENTRY();

    RADIO_POWER_LOCK();
    if(qcril_log_early_radio_power_status())
    {
        int i = 0;
        int num_of_early_radio_power = qcril_log_number_of_early_radio_power_req();
        qcril_log_reset_early_radio_power_req();
        RADIO_POWER_UNLOCK();
        for(i = 0; i < num_of_early_radio_power; i++)
        {
            qcril_qmi_nas_handle_multiple_rild_radio_power_state_propagation(TRUE);
        }
    }
    else
    {
        RADIO_POWER_UNLOCK();
    }
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_is_appropriate_srv_status
//===========================================================================
uint8_t qcril_qmi_nas_is_appropriate_srv_status(nas_service_status_enum_type_v01 srv_status)
{
    uint8_t status = FALSE;

    if( (NAS_SYS_SRV_STATUS_LIMITED_V01 == srv_status) ||
        (NAS_SYS_SRV_STATUS_SRV_V01 == srv_status) ||
        (NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01 == srv_status)
      )
    {
        status = TRUE;
    }

    return status;
}

//===========================================================================
// qcril_qmi_nas_invalidate_data_snapshot_if_applicable
//===========================================================================
void qcril_qmi_nas_invalidate_data_snapshot_if_applicable()
{
    uint8_t reset_flag = FALSE;
    qcril_arb_pref_data_type pref_data;

    QCRIL_LOG_FUNC_ENTRY();
    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);

    if( (TRUE == pref_data.is_current) && (TRUE == pref_data.is_extrapolation) )
    {
        switch ( pref_data.pref_data_tech )
        {
            case QCRIL_ARB_PREF_DATA_TECH_GSM:
            case QCRIL_ARB_PREF_DATA_TECH_UMTS:
            case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                if( ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.cdma_srv_status_info->srv_status) ) ||
                    ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.hdr_srv_status_info->srv_status) )
                  )
                {
                    reset_flag = TRUE;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_CDMA:
            case QCRIL_ARB_PREF_DATA_TECH_EVDO:
            case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                if( ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.gsm_srv_status_info->srv_status) ) ||
                    ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.wcdma_srv_status_info->srv_status) ) ||
                    ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.tdscdma_srv_status_info->srv_status) )
                  )
                {
                    reset_flag = TRUE;
                }
                break;

            default:
                break;
        }
    }

    QCRIL_LOG_INFO(" Reset snapshot data status %d", reset_flag);

    if(reset_flag)
    {
        // Clear the snapshot info and cancel timer
        qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
        qcril_qmi_arb_reset_pref_data_snapshot();
        qcril_qmi_drop_sig_info_cache();
    }

    QCRIL_LOG_FUNC_RETURN();
}

int qcril_qmi_nas_evaluate_data_rat_to_decide_ccs()
{
    int current_data_tech = RADIO_TECH_UNKNOWN;
    qcril_arb_pref_data_type pref_data;

    if(QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag)
    {
        memset( &pref_data, 0, sizeof(pref_data) );
        qcril_qmi_get_pref_data_tech(&pref_data);
        qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, NULL, NULL );
        if(TRUE == pref_data.is_current && (QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data.pref_data_tech) )
        {
            current_data_tech = pref_data.radio_technology;
        }
        else
        {
            current_data_tech = nas_cached_info.reported_data_technology;
        }
    }
    else
    {
        current_data_tech = nas_cached_info.reported_data_technology;
    }

    return current_data_tech;
}

//==============================================================================
// Handle UNSOL QMI Vops response and pass it to telephony
//==============================================================================
void qcril_qmi_nas_vops_info_ind_handler
(
    bool value
)
{

    QCRIL_LOG_FUNC_ENTRY();
    auto msg = std::make_shared<QcRilUnsolImsVopsIndication>(value);
    if (msg != nullptr)
    {
       Dispatcher::getInstance().dispatchSync(msg);
    }

    QCRIL_LOG_FUNC_RETURN();
}

//=========================================================================================
// Update the Cache with the response received as part of QMI_NAS_GET_SYS_INFO_RESP_MSG_V01
//=========================================================================================
void update_sys_info_cache_from_resp
(
    nas_get_sys_info_resp_msg_v01 * qmi_msg
)
{
    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_nas_notify_changes_to_5g_parameters(*qmi_msg);

    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_srv_status_info, qmi_msg->cdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_srv_status_info, qmi_msg->hdr_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_srv_status_info, qmi_msg->gsm_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_srv_status_info, qmi_msg->wcdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_srv_status_info, qmi_msg->tdscdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_srv_status_info, qmi_msg->lte_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_srv_status_info, qmi_msg->nr5g_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info, qmi_msg->cdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info, qmi_msg->hdr_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info, qmi_msg->gsm_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info, qmi_msg->wcdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_sys_info, qmi_msg->tdscdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info, qmi_msg->lte_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.nr5g_sys_info, qmi_msg->nr5g_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info2, qmi_msg->cdma_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info2, qmi_msg->hdr_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info2, qmi_msg->gsm_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info2, qmi_msg->wcdma_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info2, qmi_msg->lte_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info3, qmi_msg->gsm_sys_info3 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info3, qmi_msg->wcdma_sys_info3  );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_cell_status, qmi_msg->lte_cell_status  );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_support_on_lte,
            qmi_msg->voice_support_on_lte );

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_embms_coverage, qmi_msg->lte_embms_coverage );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.embms_coverage_status,
            qmi_msg->embms_coverage_status );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sim_rej_info, qmi_msg->sim_rej_info );

    nas_cached_info.is_considered_registered_cached_result_valid = FALSE;
    nas_cached_info.is_in_service_of_technology_cache_result_valid = FALSE;

    NAS_CACHE_STORE_ENTRY(nas_cached_info.wcdma_csg_info, qmi_msg->wcdma_csg_info );

    NAS_CACHE_STORE_ENTRY(nas_cached_info.lte_csg_info, qmi_msg->lte_csg_info );

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_voice_status,qmi_msg->lte_voice_status);

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sms_status,qmi_msg->lte_sms_status);

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.wcdma_rac,qmi_msg->wcdma_rac);

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.gsm_rac,qmi_msg->gsm_rac);

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_ims_voice_avail,
            qmi_msg->lte_ims_voice_avail );

    QCRIL_LOG_DEBUG("endc_available_valid: %d, endc_available: %d, restrict_dcnr_valid: %d,"
                    " restrict_dcnr: %d", qmi_msg->endc_available_valid, qmi_msg->endc_available,
                    qmi_msg->restrict_dcnr_valid, qmi_msg->restrict_dcnr);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.endc_available);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.endc_available, qmi_msg->endc_available);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.restrict_dcnr);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.restrict_dcnr, qmi_msg->restrict_dcnr);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available);
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.plmn_infolist_r15_available, qmi_msg->plmn_infolist_r15_available);

    qcril_qmi_nas_update_voice_rte();
    qcril_qmi_nas_update_data_rte();
    qcril_qmi_nas_update_ims_rte();
    qcril_qmi_voice_technology_updated();
    qmi_ril_nwr_update_reg_rej_from_sys_info();

    QCRIL_LOG_FUNC_RETURN();
}

//==============================================================================
// Convert Ssac QMI Unsol response to proto Ssac
//==============================================================================
std::shared_ptr<qcril::interfaces::SsacInfo> copy_qmi_ssac_info_ind_to_ssac
(
    nas_ssac_change_info_ind_msg_v01 *qmiSsacInfo
)
{
    QCRIL_LOG_FUNC_ENTRY();
    auto SsacInfo = std::make_shared<qcril::interfaces::SsacInfo>();

    if (SsacInfo != nullptr) {
        if( NAS_CACHE_IS_ENTRY_VALID(qmiSsacInfo->ssac_voice_info))
        {
            SsacInfo->setBarringFactorVoice(qmiSsacInfo->ssac_voice_info.barring_factor_voice);
            QCRIL_LOG_INFO("SSAC QMI barringFactorVoice = %d ", SsacInfo->getBarringFactorVoice());
            SsacInfo->setBarringTimeVoice(qmiSsacInfo->ssac_voice_info.barring_time_voice);
        }

        if( NAS_CACHE_IS_ENTRY_VALID(qmiSsacInfo->ssac_video_info))
        {
            SsacInfo->setBarringFactorVideo(qmiSsacInfo->ssac_video_info.barring_factor_video);
            SsacInfo->setBarringTimeVideo(qmiSsacInfo->ssac_video_info.barring_time_video);
        }

        if( NAS_CACHE_IS_ENTRY_VALID(qmiSsacInfo->sib2_ssac_voice_info))
        {
            SsacInfo->setBarringFactorVoiceSib(qmiSsacInfo->sib2_ssac_voice_info.sib2_barring_factor_voice);
            SsacInfo->setBarringTimeVoiceSib(qmiSsacInfo->sib2_ssac_voice_info.sib2_barring_time_voice);
        }

        if( NAS_CACHE_IS_ENTRY_VALID(qmiSsacInfo->sib2_ssac_video_info))
        {
            SsacInfo->setBarringFactorVideoSib(qmiSsacInfo->sib2_ssac_video_info.sib2_barring_factor_video);
            SsacInfo->setBarringFactorVideoSib(qmiSsacInfo->sib2_ssac_video_info.sib2_barring_time_video);
        }
    }
    return SsacInfo;

    QCRIL_LOG_FUNC_RETURN();
}

//==============================================================================
// Handles the QMI Ssac Unsol response
//==============================================================================
void qcril_qmi_nas_get_ssac_change_info_ind_handler
(
    nas_ssac_change_info_ind_msg_v01 * ssac_change_info
)
{
    QCRIL_LOG_INFO("ssac_change_info_ind_handler");
    if (ssac_change_info != nullptr) {
        std::shared_ptr<qcril::interfaces::SsacInfo> ssacInfo = nullptr;
        ssacInfo = copy_qmi_ssac_info_ind_to_ssac(ssac_change_info);
        if (ssacInfo != nullptr)
        {
            auto msg = std::make_shared<QcRilUnsolImsSsacInfoIndication>(ssacInfo);
            if (msg != nullptr)
            {
                Dispatcher::getInstance().dispatchSync(msg);
            }
        }
     }
    QCRIL_LOG_FUNC_RETURN();
}

typedef struct {
  std::shared_ptr<NasSetVoiceDomainPreferenceRequest> msg;
} NasSetVoiceDomainPreferenceUserData;

//===========================================================================
// qcril_qmi_nas_set_voice_domain_preference_cb
//===========================================================================
void qcril_qmi_nas_set_voice_domain_preference_cb
(
    unsigned int                   message_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_set_system_selection_preference_resp_msg_v01 *qmi_response = NULL;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    QCRIL_NOTUSED(message_id);
    QCRIL_NOTUSED(resp_c_struct_len);

    NasSetVoiceDomainPreferenceUserData *userData = (NasSetVoiceDomainPreferenceUserData *)resp_cb_data;

    qmi_response = (nas_set_system_selection_preference_resp_msg_v01*) resp_c_struct.get();

    if (qmi_response)
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(transp_err,
                &qmi_response->resp);
        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d",
                (int) ril_req_res,
                (int) transp_err,
                (int) qmi_response->resp.error );
    }
    else
    {
        QCRIL_LOG_ERROR("qmi_response is NULL");
    }

    if (userData && userData->msg) {
      userData->msg->sendResponse(userData->msg, Message::Callback::Status::SUCCESS,
          std::make_shared<RIL_Errno>(ril_req_res));
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_set_voice_domain_preference_cb

//===========================================================================
// qcril_qmi_nas_set_voice_domain_preference
//===========================================================================
RIL_Errno qcril_qmi_nas_set_voice_domain_preference
(
 std::shared_ptr<NasSetVoiceDomainPreferenceRequest> msg
)
{
    nas_set_system_selection_preference_req_msg_v01   qmi_set_sel_pref_req;
    nas_set_system_selection_preference_resp_msg_v01 *qmi_set_sel_pref_resp;
    qmi_client_error_type qmi_error;
    RIL_Errno             res = RIL_E_GENERIC_FAILURE;
    nas_voice_domain_pref_enum_type_v01 voice_domain_pref = msg->getVoiceDomainPreference();

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_LOG_INFO("voice_domain_pref : %d", voice_domain_pref);

    NasSetVoiceDomainPreferenceUserData *userData = (NasSetVoiceDomainPreferenceUserData *)qcril_malloc(sizeof(NasSetVoiceDomainPreferenceUserData));
    if (userData) {
      userData->msg = msg;
    }


    do {
        memset(&qmi_set_sel_pref_req,0,sizeof(qmi_set_sel_pref_req));

        qmi_set_sel_pref_req.voice_domain_pref_valid = TRUE;
        qmi_set_sel_pref_req.voice_domain_pref       = voice_domain_pref;

        qmi_error =  qmi_client_nas_send_async(
                QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                &qmi_set_sel_pref_req,
                sizeof(qmi_set_sel_pref_req),
                sizeof(*qmi_set_sel_pref_resp),
                qcril_qmi_nas_set_voice_domain_preference_cb,
                (void*)userData);
        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, NULL);

        if (res != RIL_E_SUCCESS)
        {
            QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)res, (int)qmi_error);
            if (userData) {
              userData->msg = NULL;
              qcril_free(userData);
            }
            msg->sendResponse(msg, Message::Callback::Status::SUCCESS,
                std::shared_ptr<RIL_Errno>(new RIL_Errno{RIL_E_GENERIC_FAILURE}));
        }
    } while (FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_wave_data_reg_in_case_of_csfb
===========================================================================*/
/*!
    @brief
*/
/*=========================================================================*/
void qcril_qmi_nas_wave_data_reg_in_case_of_csfb(uint8_t is_need_to_report_unsol)
{
    uint8_t data_reg_status = FALSE;
    int ccs_status = FALSE;
    qcril_arb_pref_data_type pref_data;
    boolean is_atel_call = FALSE;
    uint8_t reported_tech_valid = FALSE;
    int reported_tech = RADIO_TECH_UNKNOWN;

    NAS_CACHE_LOCK();
    ccs_status = nas_cached_info.ccs_status;
    NAS_CACHE_UNLOCK();

    is_atel_call = qcril_qmi_voice_has_specific_call(qcril_qmi_voice_call_to_atel , NULL);

    QCRIL_LOG_INFO(".. CCS status %d, is_atel_call status %d", ccs_status, is_atel_call);

    if (is_atel_call)
    {
        memset(&pref_data, 0, sizeof(pref_data));
        qcril_qmi_get_pref_data_tech(&pref_data);
        data_reg_status = qcril_qmi_nas_fetch_data_reg_rat(&reported_tech_valid, &reported_tech);

        QCRIL_LOG_INFO(".. data_reg_status %d", data_reg_status);

        if (pref_data.is_extrapolation && data_reg_status && !ccs_status)
        {
            QCRIL_LOG_INFO(".. Clear snapshot buffer");
            // Clear the snapshot info and cancel timer
            qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
            qcril_qmi_arb_reset_pref_data_snapshot();
            if(is_need_to_report_unsol)
            {
                qcril_qmi_nas_wave_voice_data_status();
            }
        }
    }
} // qcril_qmi_nas_wave_data_reg_in_case_of_csfb()

/*====================================================================================
  FUNCTION:  qcril_qmi_nas_invalidate_data_snapshot_in_case_of_csfb_in_alerting_state
======================================================================================*/
/*!
    @brief
*/
/*====================================================================================*/
void qcril_qmi_nas_invalidate_data_snapshot_in_case_of_csfb_in_alerting_state()
{
    uint8_t reset_flag = FALSE;
    int ccs_status = FALSE;
    uint8_t data_reg_status = FALSE;
    qcril_arb_pref_data_type pref_data;
    uint8_t reported_tech_valid = FALSE;
    int reported_tech = RADIO_TECH_UNKNOWN;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    ccs_status = nas_cached_info.ccs_status;
    NAS_CACHE_UNLOCK();

    data_reg_status = qcril_qmi_nas_fetch_data_reg_rat(&reported_tech_valid, &reported_tech);
    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);

    QCRIL_LOG_INFO(".. CCS status %d, data_reg_status %d", ccs_status, data_reg_status);
    QCRIL_LOG_INFO(".. is_current %d, is_extrapolation %d", pref_data.is_current, pref_data.is_extrapolation);
    QCRIL_LOG_INFO(".. reported_tech_valid %d, reported_tech %d", reported_tech_valid, reported_tech);

    if( (TRUE == pref_data.is_current) && (TRUE == pref_data.is_extrapolation) && data_reg_status && !ccs_status)
    {
        switch ( reported_tech )
        {
            case RADIO_TECH_LTE:
                NAS_CACHE_LOCK();
                if( ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.cdma_srv_status_info->srv_status) ) ||
                    ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.hdr_srv_status_info->srv_status) ) ||
                    ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.gsm_srv_status_info->srv_status) ) ||
                    ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.wcdma_srv_status_info->srv_status) ) ||
                    ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_srv_status_info) &&
                    qcril_qmi_nas_is_appropriate_srv_status(nas_cached_info.tdscdma_srv_status_info->srv_status) )
                  )
                {
                    reset_flag = TRUE;
                }
                NAS_CACHE_UNLOCK();
                break;

            default:
                break;
        }
    }

    QCRIL_LOG_INFO(".. reset_flag %d", reset_flag);
    if(reset_flag)
    {
        QCRIL_LOG_INFO(".. Clear snapshot buffer");
        // Clear the snapshot info and cancel timer
        qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
        qcril_qmi_arb_reset_pref_data_snapshot();
        qcril_qmi_nas_wave_voice_data_status();
    }

    QCRIL_LOG_FUNC_RETURN();
}

static void qcril_qmi_nas_gcell_info_ind_handler
(
    nas_gcell_info_ind_v01 * gcell_info_ind
)
{
  nas_bar_gcell_req_v01   req;

  QCRIL_LOG_FUNC_ENTRY();

  if(qcril_qmi_nas_check_fake_bs(gcell_info_ind))
  {
      QCRIL_LOG_INFO("Cell(%d) suspected fake bs!", (int)gcell_info_ind->uid_camped_cell.cell_id);
      memset(&req, 0, sizeof(req));

      req.uid_camped_cell = gcell_info_ind->uid_camped_cell;
      req.bar_time = QMI_RIL_FAKE_GCELL_BAR_TIME_MS;

      (void)qcril_event_queue(QCRIL_DEFAULT_INSTANCE_ID,
                          QCRIL_DEFAULT_MODEM_ID,
                          QCRIL_DATA_ON_STACK,
                          QCRIL_EVT_QMI_NAS_BAR_FAKE_GCELL,
                          (void *) &req,
                          sizeof(req),
                          (RIL_Token) QCRIL_TOKEN_ID_INTERNAL);
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// QCRIL_EVT_QMI_NAS_BAR_FAKE_GCELL
//===========================================================================
void qcril_qmi_nas_bar_fake_gcell
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_bar_gcell_req_v01 *nas_bar_gcell_req_ptr;
    nas_bar_gcell_resp_v01 nas_bar_gcell_resp;
    qmi_client_error_type qmi_transport_error;

    QCRIL_NOTUSED(ret_ptr);
    QCRIL_LOG_FUNC_ENTRY();

    nas_bar_gcell_req_ptr = (nas_bar_gcell_req_v01 *)params_ptr->data;

    memset(&nas_bar_gcell_resp, 0, sizeof(nas_bar_gcell_resp));

    if (nas_bar_gcell_req_ptr)
    {
        qmi_transport_error = qmi_client_nas_send_sync(QMI_NAS_BAR_GCELL_REQ_V01,
                                                       nas_bar_gcell_req_ptr,
                                                       sizeof(*nas_bar_gcell_req_ptr),
                                                       &nas_bar_gcell_resp,
                                                       sizeof(nas_bar_gcell_resp));
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_transport_error,
                                                                  &nas_bar_gcell_resp.resp );

        if ( RIL_E_SUCCESS == ril_req_res )
        {
            QCRIL_LOG_INFO("Bar request for this gcell successfully");
            qcril_qmi_nas_log_fake_bs(nas_bar_gcell_req_ptr->uid_camped_cell);
        }
        else
        {
            QCRIL_LOG_INFO("Bar request for this gcell with error code = %d",
                            (int)nas_bar_gcell_resp.resp.error);
        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

static bool qcril_qmi_nas_is_gcf_card_present_in_slot(uint8_t slot, std::shared_ptr<RIL_UIM_CardStatus> ril_card_status)
{
    string aid_param = {};
    char mcc_from_imsi[NAS_MCC_MNC_MAX_V01 + 1]     = {};
    RIL_UIM_AppType app_type;
    bool is_gcf_card = false;

    QCRIL_LOG_FUNC_ENTRY();

    memset(mcc_from_imsi, 0 , sizeof(mcc_from_imsi));

    do
    {
        if(NULL == ril_card_status)
            break;

        if (qcril_qmi_nas_retrieve_aid_from_card_status(ril_card_status, aid_param, &app_type) == E_SUCCESS)
        {
            auto imsi_msg = std::make_shared<UimGetImsiRequestSyncMsg>(slot, aid_param);
            std::shared_ptr<RIL_UIM_IMSI_Response> imsi_ptr = NULL;

            if(NULL == imsi_msg ||
               imsi_msg->dispatchSync(imsi_ptr) != Message::Callback::Status::SUCCESS ||
               imsi_ptr == NULL ||
               imsi_ptr->err != RIL_UIM_E_SUCCESS)
            {
                break;
            }

            memcpy(mcc_from_imsi, imsi_ptr->IMSI.c_str(), MIN(NAS_MCC_MNC_MAX_V01, imsi_ptr->IMSI.length()));
            is_gcf_card = qcril_qmi_nas_is_mcc_of_gcf_card(mcc_from_imsi);
            QCRIL_LOG_DEBUG("mcc from imsi = %s, is_gcf_card = %d", mcc_from_imsi, is_gcf_card);
        }
    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
    return is_gcf_card;
}

bool qcril_qmi_nas_is_gcf_card_present()
{
    uint8_t slot = 0;
    qcril_uim_card_status_e_type card_state;
    bool is_gcf_card_present = false;

    QCRIL_LOG_FUNC_ENTRY();

    slot = qmi_ril_get_sim_slot();

    NAS_CACHE_LOCK();
    card_state = nas_common_info.card_info[ slot ].status;
    NAS_CACHE_UNLOCK();

    if(QCRIL_CARD_STATUS_UP == card_state)
    {
        auto card_status = std::make_shared<UimGetCardStatusRequestSyncMsg>(slot);
        std::shared_ptr<RIL_UIM_CardStatus> ril_card_status= nullptr;
        if (card_status != nullptr &&
            card_status->dispatchSync(ril_card_status) == Message::Callback::Status::SUCCESS &&
            ril_card_status != nullptr &&
            ril_card_status->err == RIL_UIM_E_SUCCESS)
        {
            QCRIL_LOG_INFO("number of apps = %d", ril_card_status->num_applications);
            for(int idx = 0; idx < ril_card_status->num_applications; idx++)
            {
                QCRIL_LOG_INFO("idx = %d, app state = %d, app type = %d", idx,
                               ril_card_status->applications[idx].app_state,
                               ril_card_status->applications[idx].app_type);

                if( (RIL_UIM_APPTYPE_USIM == ril_card_status->applications[idx].app_type) ||
                    (RIL_UIM_APPTYPE_SIM == ril_card_status->applications[idx].app_type)
                  )
                {
                    if(RIL_UIM_APPSTATE_READY == ril_card_status->applications[idx].app_state)
                    {
                        is_gcf_card_present = qcril_qmi_nas_is_gcf_card_present_in_slot(slot, ril_card_status);
                        break;
                    }
                }
            }
        }
    }

    QCRIL_LOG_FUNC_RETURN();
    return is_gcf_card_present;
}

bool qcril_qmi_nas_is_mcc_of_gcf_card(const char *mcc_from_imsi)
{
    if(NULL == mcc_from_imsi)
        return false;
    long mcc = strtol(mcc_from_imsi, NULL, 10);
    return (mcc > 0 && mcc < 13);
}

void qcril_qmi_nas_print_atel_ui_status()
{
    uint8_t atel_ui_status = FALSE;

    if(qmi_ril_is_feature_supported(QMI_RIL_FEATURE_POWER_ON_OPTIMIZATION))
    {
        atel_ui_status = qcril_qmi_nas_get_atel_ui_status_from_cache();
        QCRIL_LOG_INFO(".. updated ATEL UI READY REQ to cache %d", atel_ui_status);
    }
}

//===========================================================================
// qcril_qmi_nas_decide_data_roam_status
//===========================================================================
int qcril_qmi_nas_decide_data_roam_status(qcril_arb_pref_data_tech_e_type pref_data_tech, int *reg_state)
{
    int status = FALSE;
    nas_service_status_enum_type_v01 srv_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    nas_common_sys_info_type_v01 *common_sys_info = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if(NULL == reg_state)
        {
            QCRIL_LOG_INFO( "Invalid buffer");
            break;
        }

        *reg_state = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;

        switch(pref_data_tech)
        {
            case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                srv_status = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) ? nas_cached_info.cdma_srv_status_info->srv_status : NAS_SYS_SRV_STATUS_NO_SRV_V01;
                common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
                break;

            case QCRIL_ARB_PREF_DATA_TECH_GSM:
                srv_status = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) ? nas_cached_info.gsm_srv_status_info->srv_status : NAS_SYS_SRV_STATUS_NO_SRV_V01;
                common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
                break;

            case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                srv_status = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) ? nas_cached_info.wcdma_srv_status_info->srv_status : NAS_SYS_SRV_STATUS_NO_SRV_V01;
                common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
                break;

            case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                srv_status = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) ? nas_cached_info.tdscdma_srv_status_info->srv_status : NAS_SYS_SRV_STATUS_NO_SRV_V01;
                common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
                break;

            case QCRIL_ARB_PREF_DATA_TECH_LTE:
                srv_status = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) ? nas_cached_info.lte_srv_status_info->srv_status : NAS_SYS_SRV_STATUS_NO_SRV_V01;
                common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
                break;

            case QCRIL_ARB_PREF_DATA_TECH_EVDO:
            case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                srv_status = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) ? nas_cached_info.hdr_srv_status_info->srv_status : NAS_SYS_SRV_STATUS_NO_SRV_V01;
                common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
                break;

            case QCRIL_ARB_PREF_DATA_TECH_5G:
                srv_status = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_srv_status_info ) ? nas_cached_info.nr5g_srv_status_info->srv_status : NAS_SYS_SRV_STATUS_NO_SRV_V01;
                common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nr5g_sys_info ) ? &nas_cached_info.nr5g_sys_info->common_sys_info : NULL;
                break;

            default:
                break;
        }

        if((NAS_SYS_SRV_STATUS_SRV_V01 == srv_status) && common_sys_info &&
            common_sys_info->srv_domain_valid &&
            ((SYS_SRV_DOMAIN_PS_ONLY_V01 == common_sys_info->srv_domain) ||
             (SYS_SRV_DOMAIN_CS_PS_V01 == common_sys_info->srv_domain) ) &&
            common_sys_info->srv_capability_valid &&
            ((SYS_SRV_DOMAIN_PS_ONLY_V01 == common_sys_info->srv_capability) ||
             (SYS_SRV_DOMAIN_CS_PS_V01 == common_sys_info->srv_capability) ) &&
            common_sys_info->roam_status_valid)
        {
            status = TRUE;
            if ( ( NAS_SYS_ROAM_STATUS_OFF_V01 == common_sys_info->roam_status ) ||
                 ( ( ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_64 == common_sys_info->roam_status ) ||
                     ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_65 == common_sys_info->roam_status ) ||
                     ( (common_sys_info->roam_status >= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_76 ) &&
                        (common_sys_info->roam_status <= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_83 )
                     ) ) && nas_common_info.eri_64_home )
               )
            {
                *reg_state = RIL_VAL_REG_REGISTERED_HOME_NET;
            }
            else
            {
                *reg_state = RIL_VAL_REG_REGISTERED_ROAMING;
            }
        }

        QCRIL_LOG_INFO( ".. data reg state %d", *reg_state);
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(status);
    return status;
}

uint8 qcril_qmi_nas_query_sib16_network_time(char *ril_nitz_time_msg)
{
    qmi_client_error_type qmi_error;
    RIL_Errno             ril_err;
    nas_get_lte_sib16_network_time_resp_msg_v01 qmi_response;
    uint8 nitz_updated = FALSE;
    int time_zone=0, time_zone_west=FALSE, daylight = 0;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if(NULL == ril_nitz_time_msg)
        {
            QCRIL_LOG_ERROR("NULL buffer");
            break;
        }

        memset(&qmi_response, 0, sizeof(qmi_response));
        qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_LTE_SIB16_NETWORK_TIME_REQ_MSG_V01,
                                             NULL,
                                             NAS_NIL,
                                             (void*) &qmi_response,
                                             sizeof(qmi_response));
        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, &qmi_response.resp);
        if (RIL_E_SUCCESS != ril_err)
        {
            QCRIL_LOG_ERROR("qcril_qmi_client_send_msg_sync failure: %d", qmi_error);
        }
        else
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired, qmi_response.lte_sib16_acquired);
            qcril_qmi_nas_send_unsol_sib16_coverage_if_needed( FALSE, FALSE, nas_cached_info.lte_sib16_acquired_valid, (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired ));

            if (qmi_response.lte_sib16_acquired_valid && (NAS_TRI_TRUE_V01 == qmi_response.lte_sib16_acquired))
            {
                NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
                NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
                NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
                NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

                if (qmi_response.daylt_sav_adj_valid && qmi_response.time_zone_valid)
                {
                    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                               qmi_response.daylt_sav_adj);
                    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                               qmi_response.time_zone);
                }

                NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.leap_seconds,
                                           qmi_response.leap_sec);

                if (qmi_response.universal_time_valid && qmi_response.abs_time_valid && nas_common_info.sib16_support)
                {
                    /* Fetch TZ/DST information from EMM information message */
                    if (!qmi_response.time_zone_valid || !qmi_response.daylt_sav_adj_valid)
                    {
                        qcril_qmi_nas_query_network_time(NULL);
                        if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving) && !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset))
                        {
                            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                             qmi_response.daylt_sav_adj);
                            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                             qmi_response.time_zone);
                        }
                    }

                    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset))
                    {
                        time_zone = nas_cached_info.local_time_offset;
                        if (0 > time_zone)
                        {
                           time_zone *= -1;
                           time_zone_west = TRUE;
                        }

                        if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving)) {
                           daylight = nas_cached_info.day_light_saving;
                        }

                        // according to ril.h the NITZ time string is in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
                        QCRIL_SNPRINTF(ril_nitz_time_msg, NAS_NITZ_STR_BUF_MAX, "%02d/%02d/%02d,%02d:%02d:%02d%c%02d,%02d",
                            (int) qmi_response.universal_time.year%100,
                            (int) qmi_response.universal_time.month,
                            (int) qmi_response.universal_time.day,
                            (int) qmi_response.universal_time.hour,
                            (int) qmi_response.universal_time.minute,
                            (int) qmi_response.universal_time.second,
                            time_zone_west ? '-' : '+',
                            (int) time_zone,
                            (int) daylight);
                        QCRIL_LOG_INFO( "ril_nitz_time_msg is: %s", ril_nitz_time_msg);
                        nitz_updated = TRUE;
                    }
                }
            }
            NAS_CACHE_UNLOCK();
        }
    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(nitz_updated);
    return nitz_updated;
}

uint8 qcril_qmi_nas_query_network_time(char *ril_nitz_time_msg)
{
    qmi_client_error_type qmi_error;
    RIL_Errno             ril_err;
    nas_get_network_time_resp_msg_v01 qmi_response;
    int sib16_support;
    uint8 sib16_acquired;
    uint8 sntp_available;
    uint8 nitz_updated = FALSE;
    int time_zone = 0, time_zone_west = FALSE, daylt_sav_adj = 0;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        memset(&qmi_response, 0, sizeof(qmi_response));
        qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_NETWORK_TIME_REQ_MSG_V01,
                                             NULL,
                                             NAS_NIL,
                                             (void*) &qmi_response,
                                             sizeof(qmi_response));

        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, &qmi_response.resp);

        if (RIL_E_SUCCESS != ril_err)
        {
            QCRIL_LOG_ERROR("qcril_qmi_client_send_msg_sync failure: %d", qmi_error);
        }
        else
        {
            if (QMI_RESULT_SUCCESS_V01 != qmi_response.resp.result)
            {
                QCRIL_LOG_ERROR("qmi response error - result: %d, error: %d", qmi_response.resp.result, qmi_response.resp.error);
            }
            else
            {
                NAS_CACHE_LOCK();
                sib16_support = nas_common_info.sib16_support;
                sib16_acquired = (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired) &&
                       (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired));
                sntp_available = (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.sntp_available) &&
                       (TRUE == nas_cached_info.sntp_available));
                QCRIL_LOG_INFO("sib16 support %d, acquired %d, sntp available %d", sib16_support, sib16_acquired, sntp_available);

                if (sib16_support && sib16_acquired)
                {
                    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset) ||
                            !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving))
                    {
                        if(qmi_response.nas_3gpp_time_valid)
                        {
                            if (qmi_response.nas_3gpp_time.radio_if == NAS_RADIO_IF_LTE_V01)
                            {
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.day_light_saving, qmi_response.nas_3gpp_time.daylt_sav_adj);
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.local_time_offset, qmi_response.nas_3gpp_time.time_zone);
                            }
                        }
                        else if(qmi_response.nas_3gpp2_time_valid)
                        {
                            if (qmi_response.nas_3gpp2_time.radio_if == NAS_RADIO_IF_LTE_V01)
                            {
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.day_light_saving, qmi_response.nas_3gpp2_time.daylt_sav_adj);
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.local_time_offset, qmi_response.nas_3gpp2_time.time_zone);
                            }
                        }
                    }
                }
                else
                {
                    if(qmi_response.nas_3gpp_time_valid)
                    {
                        if (ril_nitz_time_msg)
                        {
                            time_zone = qmi_response.nas_3gpp_time.time_zone;
                            if (0 > time_zone)
                            {
                                time_zone *= -1;
                                time_zone_west = TRUE;
                            }

                            // accroding to ril.h the NITZ time string is in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
                            QCRIL_SNPRINTF(ril_nitz_time_msg, NAS_NITZ_STR_BUF_MAX, "%02d/%02d/%02d,%02d:%02d:%02d%c%02d,%02d",
                                (int) qmi_response.nas_3gpp_time.universal_time.year%100,
                                (int) qmi_response.nas_3gpp_time.universal_time.month,
                                (int) qmi_response.nas_3gpp_time.universal_time.day,
                                (int) qmi_response.nas_3gpp_time.universal_time.hour,
                                (int) qmi_response.nas_3gpp_time.universal_time.minute,
                                (int) qmi_response.nas_3gpp_time.universal_time.second,
                                time_zone_west ? '-' : '+',
                                (int) time_zone,
                                (int) qmi_response.nas_3gpp_time.daylt_sav_adj);

                            nitz_updated = TRUE;
                            QCRIL_LOG_INFO( "ril_nitz_time_msg is: %s", ril_nitz_time_msg);
                        }

                        if(FALSE == sib16_acquired)
                        {
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

                            if(FALSE == sntp_available)
                            {
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.day_light_saving, qmi_response.nas_3gpp_time.daylt_sav_adj);
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.local_time_offset, qmi_response.nas_3gpp_time.time_zone);
                            }
                        }
                    }
                    else if(qmi_response.nas_3gpp2_time_valid)
                    {
                        if (ril_nitz_time_msg)
                        {
                            time_zone = qmi_response.nas_3gpp2_time.time_zone;
                            if (0 > time_zone)
                            {
                                time_zone *= -1;
                                time_zone_west = TRUE;
                            }

                            if (qmi_response.nas_3gpp2_time.radio_if != NAS_RADIO_IF_CDMA_1XEVDO_V01)
                            {
                                daylt_sav_adj = qmi_response.nas_3gpp2_time.daylt_sav_adj;
                            }
                            else if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving))
                            {
                                daylt_sav_adj = nas_cached_info.day_light_saving;
                            }

                            // accroding to ril.h the NITZ time string is in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
                            QCRIL_SNPRINTF(ril_nitz_time_msg, NAS_NITZ_STR_BUF_MAX, "%02d/%02d/%02d,%02d:%02d:%02d%c%02d,%02d",
                                (int) qmi_response.nas_3gpp2_time.universal_time.year%100,
                                (int) qmi_response.nas_3gpp2_time.universal_time.month,
                                (int) qmi_response.nas_3gpp2_time.universal_time.day,
                                (int) qmi_response.nas_3gpp2_time.universal_time.hour,
                                (int) qmi_response.nas_3gpp2_time.universal_time.minute,
                                (int) qmi_response.nas_3gpp2_time.universal_time.second,
                                time_zone_west ? '-' : '+',
                                (int) time_zone,
                                daylt_sav_adj);

                            nitz_updated = TRUE;
                            QCRIL_LOG_INFO( "ril_nitz_time_msg is: %s", ril_nitz_time_msg);
                        }

                        if(FALSE == sib16_acquired)
                        {
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

                            if(FALSE == sntp_available)
                            {
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.day_light_saving, qmi_response.nas_3gpp2_time.daylt_sav_adj);
                                NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.local_time_offset, qmi_response.nas_3gpp2_time.time_zone);
                            }
                        }
                    }
                }
                NAS_CACHE_UNLOCK();
            }
        }
    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(nitz_updated);
    return nitz_updated;
}

/*=========================================================================
FUNCTION:  qcril_qmi_nas_handle_data_call_status_notification
           Handles CallStatusMessage from DataModule
                   Replace ment for qcril_qmi_nas_data_control_cb
===========================================================================*/
void qcril_qmi_nas_handle_data_call_status_notification(qcril_qmi_nas_data_call_event_type evt)
{
    QCRIL_LOG_FUNC_ENTRY();

    int initiate_report = FALSE;

    QCRIL_LOG_INFO("dataCallEvent: %d", evt);

    switch (evt)
    {
    case QCRIL_QMI_NAS_DATA_EVT_CALL_RELEASED:
        qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler,
                                   NULL,  // immediate
                                   NULL);
        qcril_qmi_nas_control_signal_nas_on_current_calls_change();
        initiate_report = TRUE;
        break;

    case QCRIL_QMI_NAS_DATA_EVT_CALL_CONNECTED:
        qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler,
                                   NULL,  // immediate
                                   NULL);
        initiate_report = TRUE;
        break;

   case QCRIL_QMI_NAS_DATA_EVT_CALL_PHYSLINK_UP:
   case QCRIL_QMI_NAS_DATA_EVT_CALL_PHYSLINK_DOWN:
        initiate_report = TRUE;
        break;

   default: // nothing
        break;
   }

   if (TRUE == initiate_report)
   {
       qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  qmi_ril_report_data_connection_information,
                                  NULL,  // immediate
                                  NULL);
   }

   QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
FUNCTION:  qcril_qmi_nas_decide_need_to_reg_pbm_ind
           helper function to decide whether pbm indication registration
           is required or not.
===========================================================================*/
uint8_t qcril_qmi_nas_decide_need_to_reg_pbm_ind()
{
    uint8_t ret = FALSE;

    NAS_CACHE_LOCK();
    ret = (nas_common_info.wait_for_pbm_ind && nas_common_info.wait_for_pbm_ind_timer_id_valid);
    NAS_CACHE_UNLOCK();

    return ret;
}

/*===========================================================================

 qcril_qmi_nas_set_dds_through_data_layer

============================================================================*/
/*!
    @brief
    Set DDS through DATA layer and start timer

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_set_dds_start_timer()
{
    RIL_Errno   res = RIL_E_INTERNAL_ERR;
    uint32      new_timeout_watch = 0;
    IxErrnoType new_timeout_set_res;

    const struct timeval dds_timeout = {17 , 0}; //wait for 17sec
    QCRIL_LOG_FUNC_ENTRY();

    // start timer
    new_timeout_set_res = (IxErrnoType)qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                              QCRIL_DEFAULT_MODEM_ID,
                                                              qcril_qmi_nas_set_dds_timeout_handler,
                                                              &dds_timeout, &new_timeout_watch );
    QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );

    if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
    {
        if(new_timeout_set_res == E_SUCCESS)
        {
          QCRIL_LOG_ERROR("Internal error..timed callback failed to set timer_id");
          res = RIL_E_INTERNAL_ERR;
        }
        else
        {
          res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(new_timeout_set_res);
        }
    }
    else
    {
        res = RIL_E_SUCCESS;
        NAS_CACHE_LOCK();
        nas_cached_info.dds_timeout_watch = new_timeout_watch;
        NAS_CACHE_UNLOCK();
    }

    return res;
}
/*===========================================================================
 qcril_qmi_nas_set_dds_timeout_handler
============================================================================*/
/*!
   @brief
   Timie out handler for ss event wait

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_set_dds_timeout_handler
(
    void *param
)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(param);

    /* Acquiring lock to prevent race condition */
    NAS_CACHE_LOCK();

    auto& msgList = getNasModule().getPendingMessageList();
    auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
    QCRIL_LOG_INFO( ".. found_req %d", (msg != nullptr));
    if (msg != nullptr)
    {
        qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
        msgList.erase(msg);
        auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                RIL_E_INTERNAL_ERR, nullptr);
        allowDataMsg->sendResponse(allowDataMsg, Message::Callback::Status::SUCCESS, respData);
    }

    nas_cached_info.dds_timeout_watch = NAS_NIL;
    NAS_CACHE_UNLOCK();
}
//===========================================================================
// qcril_qmi_nas_data_event_dds_status_follow_up
//===========================================================================
void qcril_qmi_nas_data_event_dds_status_follow_up
(
  dds_status_info dds_status
)
{
    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if( (FALSE == nas_dms_cached_info.both_sub_support_all_rat_cap) ||
            (NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
            (1 == nas_dms_cached_info.max_active_data_subs) )
          )
        {
            QCRIL_LOG_INFO( "DDS has been setted via QMI_NAS");
            break;
        }

        if(RIL_E_SUCCESS == dds_status.result)
        {
            QCRIL_LOG_INFO("New DDS setted succesfully, wait for confirmation");
            break;
        }

        NAS_CACHE_LOCK();
        auto& msgList = getNasModule().getPendingMessageList();
        auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
        QCRIL_LOG_INFO( ".. found_req %d", (msg != nullptr));

        if (msg != nullptr)
        {
            qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
            if (nas_cached_info.dds_timeout_watch)
            {
                qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.dds_timeout_watch);
                nas_cached_info.dds_timeout_watch = NAS_NIL;
            }

            auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    RIL_E_INTERNAL_ERR, nullptr);
            allowDataMsg->sendResponse(allowDataMsg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(msg);
        }
        NAS_CACHE_UNLOCK();
    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// QCRIL_EVT_DATA_NEW_DDS_INFO
//===========================================================================
void qcril_qmi_nas_data_event_new_dds_info
(
  DDSSubIdInfo dds_sub_info
)
{
    int num_of_rilds;
    IxErrnoType                     found_qcril_request;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO( "nas_common_info.dsds.is_default_data_set: %d",
        nas_common_info.dsds.is_default_data_set);
    do
    {

        if( (TRUE == nas_common_info.dsds.is_default_data_set) &&
            ( (FALSE == nas_dms_cached_info.both_sub_support_all_rat_cap) ||
              (NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
              (1 == nas_dms_cached_info.max_active_data_subs) )
            )
          )
        {
            nas_common_info.dsds.dds_data_sub_valid = FALSE;
            QCRIL_LOG_INFO( "DDS confirmation to be considered if notified via QMI_NAS");
            break;
        }

        num_of_rilds = qmi_ril_retrieve_number_of_rilds();
        NAS_CACHE_LOCK();
        nas_common_info.dsds.dds_data_sub.dds_sub_id = dds_sub_info.dds_sub_id;
        nas_common_info.dsds.dds_data_sub.switch_type = dds_sub_info.switch_type;
        QCRIL_LOG_INFO( "DDS sub inform via DATA layer = %d", nas_common_info.dsds.dds_data_sub.dds_sub_id);
        QCRIL_LOG_INFO( "DDS switch type inform via DATA layer = %d", nas_common_info.dsds.dds_data_sub.switch_type);
        if( (nas_common_info.dsds.dds_data_sub.dds_sub_id >= QCRIL_DEFAULT_INSTANCE_ID) &&
            (nas_common_info.dsds.dds_data_sub.dds_sub_id < num_of_rilds)
          )
        {
            nas_common_info.dsds.dds_data_sub_valid = TRUE;
        }
        else
        {
            nas_common_info.dsds.dds_data_sub_valid = FALSE;
        }

        auto& msgList = getNasModule().getPendingMessageList();
        auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
        found_qcril_request = (msg != nullptr) ? E_SUCCESS : E_FAILURE;
        QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );

        if ((found_qcril_request == E_SUCCESS) && (dds_sub_info.dds_sub_id == qmi_ril_get_process_instance_id()))
        {
            qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
            if (nas_cached_info.dds_timeout_watch)
            {
                qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.dds_timeout_watch);
                nas_cached_info.dds_timeout_watch = NAS_NIL;
            }
            auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    RIL_E_SUCCESS, nullptr);
            allowDataMsg->sendResponse(allowDataMsg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(msg);
        }
        NAS_CACHE_UNLOCK();

        if(FALSE == nas_common_info.dsds.is_default_data_set)
        {
            qcril_qmi_nas_notify_embms_status();
        }
    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// qcril_qmi_nas_update_dds_sub_id
//===========================================================================
RIL_Errno qcril_qmi_nas_update_dds_sub_id(DDSSubIdInfo *dds_sub_info)
{
  RIL_Errno res = RIL_E_INTERNAL_ERR;
  NAS_CACHE_LOCK();
  int num_of_rilds = qmi_ril_retrieve_number_of_rilds();

  if(NULL == dds_sub_info)
    return res;

  nas_common_info.dsds.dds_data_sub.dds_sub_id = dds_sub_info->dds_sub_id;
  nas_common_info.dsds.dds_data_sub.switch_type = dds_sub_info->switch_type;

  if( (nas_common_info.dsds.dds_data_sub.dds_sub_id >= QCRIL_DEFAULT_INSTANCE_ID) &&
      (nas_common_info.dsds.dds_data_sub.dds_sub_id < num_of_rilds)
    )
  {
    nas_common_info.dsds.dds_data_sub_valid = TRUE;
    res = RIL_E_SUCCESS;
  }

  QCRIL_LOG_DEBUG("DDS sub id inform via DATA layer = %d", nas_common_info.dsds.dds_data_sub.dds_sub_id);
  QCRIL_LOG_DEBUG("DDS switch type inform via DATA layer = %d", nas_common_info.dsds.dds_data_sub.switch_type);

  NAS_CACHE_UNLOCK();
  return res;
}

void qcril_qmi_start_mbn_update() {
    QCRIL_LOG_FUNC_ENTRY();
    qcril_qmi_nas_check_for_hardware_update(FALSE);
    QCRIL_LOG_FUNC_RETURN();
}

/* check fake bs according to SI3 */
boolean qcril_qmi_nas_check_fake_bs
(
    nas_gcell_info_ind_v01 * gcell_info_ind
)
{
    uint8_t score = 0;
    uint8_t rxlev_access_min = 0;
    uint8_t cell_resel_offset = 0;
    uint8_t t3212 = 0;
    boolean gprs_ind = TRUE;
    boolean si2q_ind = TRUE;

    if(gcell_info_ind->rx_lev_min_valid)
    {
        rxlev_access_min = gcell_info_ind->rx_lev_min;
        if (QMI_RIL_GCELL_RXLEV_ACCESS_MIN_HIGH_FAKING_VALUE == rxlev_access_min)
        {
            score += QMI_RIL_GCELL_HIGH_FAKING_SCORE;
        }
        else if (QMI_RIL_GCELL_RXLEV_ACCESS_MIN_LOW_FAKING_VALUE > rxlev_access_min)
        {
            score += QMI_RIL_GCELL_LOW_FAKING_SCORE;
        }
    }

    if(gcell_info_ind->reselection_offset_valid)
    {
        cell_resel_offset = gcell_info_ind->reselection_offset;
        if (QMI_RIL_GCELL_RESEL_OFFSET_HIGH_FAKING_VALUE == cell_resel_offset)
        {
            score += QMI_RIL_GCELL_HIGH_FAKING_SCORE;
        }
        else if (QMI_RIL_GCELL_RESEL_OFFSET_LOW_FAKING_VALUE < cell_resel_offset)
        {
            score += QMI_RIL_GCELL_LOW_FAKING_SCORE;
        }
    }

    if(gcell_info_ind->t3212_valid)
    {
        t3212 = gcell_info_ind->t3212;
        if (QMI_RIL_GCELL_T3212_HIGH_FAKING_VALUE == t3212)
        {
           score += QMI_RIL_GCELL_HIGH_FAKING_SCORE;
        }
        else if ((QMI_RIL_GCELL_T3212_LOW_FAKING_VALUE > t3212)&&(0 < t3212))
        {
            score += QMI_RIL_GCELL_MEDIAL_FAKING_SCORE;
        }
    }

    if(gcell_info_ind->broadcast_si_mask_valid)
    {
        if ((gcell_info_ind->broadcast_si_mask & 0x4000) == 0x4000)
        {
          gprs_ind = TRUE;
        }
        else
        {
          gprs_ind = FALSE;
        }

        if ((gcell_info_ind->broadcast_si_mask & 0x0020) == 0x0020)
        {
          si2q_ind = TRUE;
        }
        else
        {
          si2q_ind = FALSE;
        }

        if (!gprs_ind)
        {
            score += QMI_RIL_GCELL_HIGH_FAKING_SCORE;
        }

        if(!si2q_ind)
        {
            score += QMI_RIL_GCELL_HIGH_FAKING_SCORE;
        }
    }

    QCRIL_LOG_INFO("rxlev_access_min: %d, cell_resel_offset: %d, t3212: %d, gprs_ind: %d, si2q_ind: %d",
        rxlev_access_min, cell_resel_offset, t3212, gprs_ind, si2q_ind);

    if( score >= QMI_RIL_GCELL_FAKING_SCORE_LEVEL )
    {
        return TRUE;
    }

    return FALSE;
}

boolean qcril_qmi_nas_log_fake_bs
(
    geran_grr_gcell_identifier_s_v01    uid_camped_cell
)
{
    char file_name[64];
    char final_string[64];

    QCRIL_SNPRINTF(file_name, sizeof(file_name),
                 "%s_%d", QCRIL_BAR_GCELL_INFO_FILE,
                 qmi_ril_get_process_instance_id());
    QCRIL_SNPRINTF(final_string, sizeof(final_string),
                 "Cell id is %d, arfcn is %d",
                 uid_camped_cell.cell_id,
                 uid_camped_cell.arfcn);

     FILE* fp = fopen(file_name, "a");
     if (fp == NULL)
     {
         QCRIL_LOG_DEBUG("Open file %s failed", file_name);
         return FALSE;
     }

     QCRIL_LOG_DEBUG("Write fake bs info to log file : %s", file_name);
     QCRIL_LOG_DEBUG("%s", final_string);
     fprintf(fp, "%s\n", final_string);
     fclose(fp);

    return TRUE;
}

/*===========================================================================
  FUNCTION:  qcril_qmi_nas_get_roam_pref
===========================================================================*/
uint8_t qcril_qmi_nas_get_roam_pref(uint16_t *roam_pref)
{
    uint8_t ret = FALSE;

    if ( NULL != roam_pref )
    {
        NAS_CACHE_LOCK();
        if ( !nas_cached_info.roam_pref_valid )
        {
            qcril_qmi_fetch_system_selection_preference();
        }

        if( nas_cached_info.roam_pref_valid )
        {
            *roam_pref = nas_cached_info.roam_pref;
            ret = TRUE;
        }

        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_roam_pref

/*===========================================================================
  FUNCTION:  qcril_qmi_nas_fetch_sub_blocked_status
===========================================================================*/
RIL_Errno qcril_qmi_nas_fetch_sub_blocked_status()
{
    qmi_client_error_type qmi_client_error;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_get_sub_blocked_status_resp_msg_v01 *qmi_response = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    qmi_response = (nas_get_sub_blocked_status_resp_msg_v01 *) qcril_malloc( sizeof( *qmi_response ) );

    if ( qmi_response )
    {
        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_SUB_BLOCKED_STATUS_REQ_MSG_V01,
                                                       NULL,
                                                       NAS_NIL,  // empty request payload
                                                       (void*) qmi_response,
                                                       sizeof( *qmi_response ));

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response->resp );

        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.is_blocked,qmi_response->is_blocked);
            QCRIL_LOG_INFO( "is_blocked_valid %d, is_blocked %d", nas_cached_info.is_blocked_valid, nas_cached_info.is_blocked);
            NAS_CACHE_UNLOCK();
        }
        qcril_free( qmi_response );
        qmi_response = NULL;
    }
    else
    {
        QCRIL_LOG_ERROR("Memory allocation failed..");
        ril_req_res = RIL_E_NO_MEMORY;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
}

void qcril_qmi_nas_sub_blocked_status_ind_handler(nas_sub_blocked_status_ind_msg_v01 *qmi_msg,
                                                  int *network_state_updated)
{
    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if((NULL == qmi_msg) || (NULL == network_state_updated))
        {
            break;
        }

        NAS_CACHE_LOCK();
        if((FALSE == nas_cached_info.is_blocked_valid) || (nas_cached_info.is_blocked != qmi_msg->is_blocked))
        {
            nas_cached_info.is_blocked_valid = TRUE;
            nas_cached_info.is_blocked = qmi_msg->is_blocked;
            QCRIL_LOG_INFO( "is_blocked_valid %d, is_blocked %d", nas_cached_info.is_blocked_valid, nas_cached_info.is_blocked);
            *network_state_updated = TRUE;
            qcril_qmi_nas_update_voice_rte();
            qcril_qmi_nas_update_data_rte();
            qcril_qmi_voice_technology_updated();
            qmi_ril_nwr_update_reg_rej_from_sys_info();
        }
        NAS_CACHE_UNLOCK();
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_send_response_for_pending_network_selection_request()
{
    qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_DONE );

    // look for any on-going request (including manually and automatically network selection)
    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.find(RilRequestSetNetworkSelectionManualMessage::get_class_message_id());
    if (!pendingMsg)
    {
        pendingMsg = msgList.find(RilRequestSetNetworkSelectionAutoMessage::get_class_message_id());
    }
    if (pendingMsg)
    {
        if ((pendingMsg->get_message_id() ==
                RilRequestSetNetworkSelectionManualMessage::get_class_message_id())
                && nas_common_info.is_restore_prev_mode_pref)
        {
            qcril_qmi_nas_restore_modem_pref();
        }

        // ** respond
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                RIL_E_INTERNAL_ERR, nullptr);
        auto selectMsg = std::static_pointer_cast<QcRilRequestMessage>(pendingMsg);
        selectMsg->sendResponse(selectMsg, Message::Callback::Status::SUCCESS, respData);
        msgList.erase(pendingMsg);
    }
}

/*===========================================================================
  FUNCTION:  qcril_qmi_nas_is_using_radio_based_on_data_rat_sys_info
===========================================================================*/
int qcril_qmi_nas_is_using_radio_based_on_data_rat_sys_info(uint8_t radio_if)
{
    int ret = FALSE;
    int rte_reg_status[ QMI_RIL_RTE_CAP ];

    QCRIL_LOG_INFO( ".. radio is %d", radio_if);
    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
    qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );

    QCRIL_LOG_INFO( ".. gsm ps reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma ps reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma ps reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte ps reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO(".. 5G ps reg %d", rte_reg_status[QMI_RIL_RTE_SUB_NR5G]);

    if( (NAS_RADIO_IF_GSM == radio_if) &&
        ((RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_GSM ]) ||
        (RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_GSM ]))
      )
    {
        ret = TRUE;
    }
    else if ( (NAS_RADIO_IF_UMTS == radio_if) &&
              ((RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_WCDMA ]) ||
             (RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_WCDMA ]))
            )
    {
        ret = TRUE;
    }
    else if ( (NAS_RADIO_IF_TDSCDMA == radio_if) &&
              ((RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ]) ||
             (RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ]))
            )
    {
        ret = TRUE;
    }
    else if ( (NAS_RADIO_IF_LTE == radio_if) &&
              ((RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ]) ||
             (RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ]))
            )
    {
        ret = TRUE;
    }
    else if ((NAS_RADIO_IF_NR5G == radio_if) &&
            ((RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[QMI_RIL_RTE_SUB_NR5G]) ||
             (RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[QMI_RIL_RTE_SUB_NR5G])))
    {
        ret = TRUE;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}

uint8_t qcril_qmi_nas_nw_select_is_registered_plmn_same_as_requested_plmn_with_rat()
{
    uint8_t ret = FALSE;
    uint8_t reg_mcc_mnc_valid = FALSE;
    char reg_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char reg_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    nas_radio_if_enum_v01 reg_rat = NAS_RADIO_IF_NO_SVC_V01;

    QCRIL_LOG_FUNC_ENTRY();
    memset(reg_mcc_str, 0, sizeof(reg_mcc_str));
    memset(reg_mnc_str, 0, sizeof(reg_mnc_str));

    do
    {
        if(FALSE == nas_cached_info.nw_select_is_manual)
        {
            QCRIL_LOG_INFO("Automatic selection, return TRUE");
            ret = TRUE;
            break;
        }

        reg_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(reg_mcc_str, reg_mnc_str, TRUE, &reg_rat);

        if(TRUE == reg_mcc_mnc_valid)
        {
            QCRIL_LOG_INFO("registered mcc %s, mnc %s, rat %d", reg_mcc_str, reg_mnc_str, reg_rat);
            QCRIL_LOG_INFO("requested mcc %s, mnc %s, rat %d", nas_cached_info.nw_select_manual_mcc_str, nas_cached_info.nw_select_manual_mnc_str, nas_cached_info.nw_select_manual_rat);
            ret = (!strncmp(reg_mcc_str,nas_cached_info.nw_select_manual_mcc_str,NAS_MCC_MNC_MAX_SIZE) &&
                   !strncmp(reg_mnc_str,nas_cached_info.nw_select_manual_mnc_str,NAS_MCC_MNC_MAX_SIZE) &&
                   ((nas_cached_info.nw_select_manual_rat == NAS_RADIO_IF_NO_SVC_V01) || (nas_cached_info.nw_select_manual_rat == reg_rat)));
            break;
        }
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}

void qcril_qmi_nas_send_response_for_dds_request(void)
{
    IxErrnoType                     found_qcril_request;
    qmi_ril_nas_attch_state_e_type cur_attch_state = qcril_qmi_nas_get_attch_state();

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if( NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) &&
            (TRUE == nas_dms_cached_info.both_sub_support_all_rat_cap) &&
            NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.max_active_data_subs) &&
            (2 == nas_dms_cached_info.max_active_data_subs)
          )
        {
            QCRIL_LOG_INFO( "DDS confirmation will come from DSD in L+L case");
            break;
        }

        if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.is_default_data_subs) || (0 == nas_cached_info.is_default_data_subs))
        {
            QCRIL_LOG_INFO( "Not a DDS sub with temporary or permanent");
            break;
        }

        if(QMI_RIL_NAS_ALLOW_DATA_ATTCH_ATTACH != cur_attch_state)
        {
            QCRIL_LOG_INFO( "No DDS request sent from RIL");
            break;
        }

        NAS_CACHE_LOCK();
        auto& msgList = getNasModule().getPendingMessageList();
        auto msg = msgList.find(RilRequestAllowDataMessage::get_class_message_id());
        found_qcril_request = (msg != nullptr) ? E_SUCCESS : E_FAILURE;
        QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );

        if (found_qcril_request == E_SUCCESS)
        {
            qcril_qmi_nas_set_attch_state(QMI_RIL_NAS_ATTCH_NONE);
            if (nas_cached_info.dds_timeout_watch)
            {
                qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.dds_timeout_watch);
                nas_cached_info.dds_timeout_watch = NAS_NIL;
            }

            auto allowDataMsg = std::static_pointer_cast<RilRequestAllowDataMessage>(msg);
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                    RIL_E_SUCCESS, nullptr);
            allowDataMsg->sendResponse(allowDataMsg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(msg);
        }
        NAS_CACHE_UNLOCK();
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_is_1x_sms_blocked
//===========================================================================
int qcril_qmi_nas_is_1x_sms_blocked(void)
{
    int ret = FALSE;
    qmi_ril_nw_reg_rte_type voice_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rat_confidence_tag_type confidence = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    int mode_pref_info_available = FALSE;
    uint16_t mode_pref = NAS_NIL;

    NAS_CACHE_LOCK();
    voice_rte = nas_cached_info.voice_rte;
    confidence = nas_cached_info.voice_rte_confidence_tag;
    mode_pref_info_available  = qcril_qmi_nas_fetch_mode_pref(&mode_pref);
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("voice_rte %d, confidence %d", voice_rte, confidence);
    QCRIL_LOG_INFO("mode_pref_info_available %d, mode_pref %d", mode_pref_info_available, mode_pref);

    /*LTE is in_service but SMS over IMS not possible and only 3gpp rats are in mode pref*/
    if((QMI_RIL_RAT_CONFIDENCE_FULL_SVC == confidence) && (QMI_RIL_RTE_SUB_LTE == voice_rte) &&
        mode_pref_info_available && (FALSE == (QMI_NAS_RAT_MODE_PREF_CDMA_HRPD & mode_pref)))
    {
        ret = TRUE;
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_1x_sms_blocked

//===========================================================================
// QCRIL_EVT_HOOK_GET_L_PLUS_L_FEATURE_SUPPORT_STATUS_REQ
//===========================================================================
void qcril_qmi_nas_get_l_plus_l_feature_support_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno result = RIL_E_SUCCESS;
    qcril_request_resp_params_type resp;
    uint8_t status = FALSE;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if( !NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) )
    {
        qcril_qmi_nas_get_device_capability(FALSE, FALSE, TRUE, FALSE);
    }

    if( NAS_CACHE_IS_ENTRY_VALID(nas_dms_cached_info.both_sub_support_all_rat_cap) )
    {
        status = nas_dms_cached_info.both_sub_support_all_rat_cap;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("L+L feature support status - %d", status);

    if (params_ptr != NULL)
    {
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    params_ptr->t,
                                    params_ptr->event_id,
                                    result,
                                    &resp );
        resp.resp_pkt = &status;
        resp.resp_len = sizeof(status);
        qcril_send_request_response( &resp );
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_is_device_registered_for_cs_domain
//===========================================================================
uint8_t qcril_qmi_nas_is_device_registered_for_cs_domain(void)
{
    uint8_t ret = FALSE;
    qmi_ril_nw_reg_rte_type voice_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rat_confidence_tag_type confidence = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    uint8_t srv_domain_valid = FALSE;
    nas_service_domain_enum_type_v01 srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;

    NAS_CACHE_LOCK();
    voice_rte = nas_cached_info.voice_rte;
    confidence = nas_cached_info.voice_rte_confidence_tag;

    if(voice_rte == QMI_RIL_RTE_SUB_LTE && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sys_info))
    {
        srv_domain_valid = nas_cached_info.lte_sys_info->common_sys_info.srv_domain_valid;
        srv_domain = nas_cached_info.lte_sys_info->common_sys_info.srv_domain;
    }
    else if(voice_rte == QMI_RIL_RTE_SUB_NR5G && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sys_info))
    {
        srv_domain_valid = nas_cached_info.nr5g_sys_info->common_sys_info.srv_domain_valid;
        srv_domain = nas_cached_info.nr5g_sys_info->common_sys_info.srv_domain;
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("voice_rte %d, voice_rte_confidence %d", voice_rte, confidence);
    QCRIL_LOG_INFO("srv_domain_valid %d, srv_domain %d", srv_domain_valid, srv_domain);

    if (confidence == QMI_RIL_RAT_CONFIDENCE_FULL_SVC)
    {
        if (voice_rte == QMI_RIL_RTE_SUB_LTE || voice_rte == QMI_RIL_RTE_SUB_NR5G)
        {
            if (srv_domain_valid && (srv_domain == SYS_SRV_DOMAIN_CS_ONLY_V01 ||
                    srv_domain == SYS_SRV_DOMAIN_CS_PS_V01))
            {
                ret = TRUE;
            }
        }
        else
        {
            ret = TRUE;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}

uint8_t qcril_qmi_nas_is_dds_change()
{
    uint8_t status = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if((nas_common_info.dsds.dds_data_sub.dds_sub_id != qmi_ril_get_process_instance_id()) || ((nas_common_info.dsds.default_data_reason != NONE) &&
       (nas_common_info.dsds.dds_data_sub.switch_type != nas_common_info.dsds.default_data_reason)))
    {
        status = TRUE;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(status);
    return status;
}

void qcril_qmi_nas_dds_to_be_updated(DDSSubIdInfo *dds_sub)
{
    if(NULL != dds_sub)
    {
        NAS_CACHE_LOCK();
        dds_sub->dds_sub_id = qmi_ril_get_process_instance_id();
        dds_sub->switch_type = (nas_common_info.dsds.default_data_reason == VOLTE)?DSD_DDS_DURATION_TEMPORARY_V01:DSD_DDS_DURATION_PERMANANT_V01;
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_DEBUG("dds_sub_id to be updated = %d", dds_sub->dds_sub_id);
        QCRIL_LOG_DEBUG("dds_switch_type to be updated = %d", dds_sub->switch_type);
    }
}

// TODO use macro to auto generate
void qcril_qmi_nas_request_data_registration_state_wrapper
(
    void* cb_data
)
{
    auto schedCbData = static_cast<ScheduleCallbackData*>(cb_data);
    auto msg(std::static_pointer_cast<RilRequestGetDataRegistrationMessage>(schedCbData->getData()));

    delete schedCbData;
    qcril_qmi_nas_request_data_registration_state(msg);
}

void qcril_qmi_nas_request_registration_state_wrapper
(
    void* cb_data
)
{
    auto schedCbData = static_cast<ScheduleCallbackData*>(cb_data);
    auto msg(std::static_pointer_cast<RilRequestGetVoiceRegistrationMessage>(schedCbData->getData()));

    delete schedCbData;
    qcril_qmi_nas_request_registration_state(msg);
}

void qcril_qmi_nas_request_operator_wrapper
(
    void* cb_data
)
{
    auto schedCbData = static_cast<ScheduleCallbackData*>(cb_data);
    auto msg(std::static_pointer_cast<RilRequestOperatorMessage>(schedCbData->getData()));

    delete schedCbData;
    qcril_qmi_nas_request_operator(msg);
}

void qcril_qmi_nas_query_network_selection_mode_wrapper
(
    void* cb_data
)
{
    auto schedCbData = static_cast<ScheduleCallbackData*>(cb_data);
    auto msg(std::static_pointer_cast<RilRequestQueryNetworkSelectModeMessage>(schedCbData->getData()));

    delete schedCbData;
    qcril_qmi_nas_query_network_selection_mode(msg);
}

#ifdef QMI_RIL_UTF
void qcril_qmi_hal_nas_module_cleanup()
{
    NasModule &module = getNasModule();
    module.qcrilHalNasModuleCleanup();
    qcril_qmi_nas_cleanup();
    qcril_qmi_nas_pre_init();
}

void qcril_qmi_hal_dms_module_cleanup()
{
    NAS_CACHE_LOCK();
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_dms_cached_info.operating_mode);
    NAS_CACHE_UNLOCK();
}
#endif

/**
 * Read Operator name from unicode table based on system locale set
**/
boolean qcril_qmi_nas_read_unicode_operator_names(nas_get_plmn_name_resp_msg_v01 *resp,
                                                 char *short_eons, size_t short_eons_sz,
                                                 char *long_eons, size_t long_eons_sz) {
    boolean op_name_result = FALSE;
    char args[PROPERTY_VALUE_MAX];
    //set to true for zh-Hant-TW, zh-Hant-HK, zh-Hant-MO
    boolean is_hans_locale_set = false;
    //set to true for zh-Hans-CN, zh-Hans-MO, zh-Hans-MO, zh-Hans-SG
    boolean is_hant_locale_set = false;
    const char *hans_locale = "zh-Hans";
    const char *hant_locale = "zh-Hant";
    uint32_t name_len;

    QCRIL_LOG_FUNC_ENTRY();

    if(nas_common_info.unicode_operator_names_support == FALSE) {
        QCRIL_LOG_DEBUG("no spupport to read unicode names");
        return op_name_result;
    }

    //read sys locale
    property_get( QMI_RIL_READ_SYS_LOCALE, args, "" );
    int temp_len = 0;
    temp_len = strlen( args );
    if(temp_len <= 0) {
        return op_name_result;
    }

    if ( temp_len > 0 ) {
        QCRIL_LOG_DEBUG("value from prop %s ",args);
    }

    //compare locale
    if(strncmp(args, hans_locale, strlen(hans_locale)) == 0) {
        is_hans_locale_set = TRUE;
    } else if(strncmp(args, hant_locale, strlen(hant_locale)) == 0) {
        is_hant_locale_set = TRUE;
    }

    if(!is_hans_locale_set && !is_hant_locale_set) {
        return op_name_result;
    }

    //read lang
    int list_length = resp->lang_plmn_names_len;
    bool locale_match = FALSE;
    QCRIL_LOG_DEBUG("operator list length is %d ",list_length);
    QCRIL_LOG_DEBUG("locale set %d %d ",is_hans_locale_set, is_hant_locale_set);

    for(int index = 0; index < list_length; index++) {
        int lang_id = resp->lang_plmn_names[index].lang_id;
        QCRIL_LOG_DEBUG("processing index:%d with lang-id:%d ",index, lang_id);
        switch(lang_id) {
            case NAS_LANG_ID_ZH_TRAD_V01: {
                if (is_hant_locale_set) {
                    //read short name
                    name_len = (resp->lang_plmn_names[index].plmn_short_name_len > NAS_ALT_LANG_NAME_LEN_MAX_V01) ?
                    NAS_ALT_LANG_NAME_LEN_MAX_V01 : resp->lang_plmn_names[index].plmn_short_name_len;
                    qcril_qmi_util_decode_operator_name_in_little_endian(short_eons,short_eons_sz,
                        QMI_CODING_SCHEME_UCS2, (uint8*)resp->lang_plmn_names[index].plmn_short_name,
                        name_len*2);

                    //read long name
                    name_len = (resp->lang_plmn_names[index].plmn_long_name_len > NAS_ALT_LANG_NAME_LEN_MAX_V01) ?
                    NAS_ALT_LANG_NAME_LEN_MAX_V01 : resp->lang_plmn_names[index].plmn_long_name_len;
                    qcril_qmi_util_decode_operator_name_in_little_endian(long_eons,long_eons_sz,
                        QMI_CODING_SCHEME_UCS2, (uint8*)resp->lang_plmn_names[index].plmn_long_name,
                        name_len*2);

                locale_match = TRUE;
                }
            break;
            }
            case NAS_LANG_ID_ZH_SIMP_V01: {
                if (is_hans_locale_set) {
                    //read short name
                    name_len = (resp->lang_plmn_names[index].plmn_short_name_len > NAS_ALT_LANG_NAME_LEN_MAX_V01) ?
                    NAS_ALT_LANG_NAME_LEN_MAX_V01 : resp->lang_plmn_names[index].plmn_short_name_len;
                    qcril_qmi_util_decode_operator_name_in_little_endian(short_eons,short_eons_sz,
                        QMI_CODING_SCHEME_UCS2, (uint8*)resp->lang_plmn_names[index].plmn_short_name,
                        name_len*2);

                    //read long name
                    name_len = (resp->lang_plmn_names[index].plmn_long_name_len > NAS_ALT_LANG_NAME_LEN_MAX_V01) ?
                    NAS_ALT_LANG_NAME_LEN_MAX_V01 : resp->lang_plmn_names[index].plmn_long_name_len;
                    qcril_qmi_util_decode_operator_name_in_little_endian(long_eons,long_eons_sz,
                        QMI_CODING_SCHEME_UCS2, (uint8*)resp->lang_plmn_names[index].plmn_long_name,
                        name_len*2);

                locale_match = TRUE;
                }
            break;
            }
            default:
                locale_match = FALSE;
            break;
        }

        if(locale_match) {
            break;
        }
    }

    if(locale_match) {
        op_name_result = TRUE;
    }

    return op_name_result;
}
//===========================================================================
// qmi_ril_nwreg_spawn_reported_data_reg_snapshot_timer
//===========================================================================
void qmi_ril_nwreg_spawn_reported_data_reg_snapshot_timer()
{
    uint32              reported_data_window_tmr = 0;
    struct timeval      reported_data_window_frame;

    QCRIL_LOG_FUNC_ENTRY();

    if( nas_common_info.reported_data_timer_value_valid )
    {
        if ( nas_common_info.reported_data_timer_value > NAS_NIL )
        {
            reported_data_window_frame.tv_sec  = NAS_NIL;
            reported_data_window_frame.tv_usec =
                nas_common_info.reported_data_timer_value * 1000; //convert msec to usec
        }
        else
        {
            reported_data_window_frame.tv_sec  = 0;
            reported_data_window_frame.tv_usec = 500000; //0.5sec
        }
    }
    else
    {
        reported_data_window_frame.tv_sec  = 0;
        reported_data_window_frame.tv_usec = 500000; //0.5sec
    }

    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
       QCRIL_DEFAULT_MODEM_ID,
       qmi_ril_nw_reported_data_reg_snapshot_validity_tmr_expry_handler,
       &reported_data_window_frame,
       &reported_data_window_tmr );

    nas_cached_info.reported_data_reg_expiry = reported_data_window_tmr;

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qmi_ril_nw_reported_data_reg_snapshot_validity_tmr_expry_handler
//===========================================================================
void qmi_ril_nw_reported_data_reg_snapshot_validity_tmr_expry_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.reported_data_reg_expiry = NAS_NIL;
    nas_cached_info.is_proper_data_reg_to_report = TRUE;
    NAS_CACHE_UNLOCK();
    qcril_qmi_nas_wave_voice_data_status();
    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_request_query_endc_dcnr
(
    std::shared_ptr<RilRequestQueryNrDcParamMessage> msg
)
{
    RIL_Errno ril_err = RIL_E_SUCCESS;

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available) ||
            !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.restrict_dcnr))
    {
        qcril_qmi_nas_fetch_sys_info();
    }

    five_g_endc_dcnr endc_dcnr_info;
    endc_dcnr_info.endc_available = -1;
    endc_dcnr_info.restrict_dcnr = -1;

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available))
    {
        endc_dcnr_info.endc_available = nas_cached_info.endc_available;
    }

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.restrict_dcnr))
    {
        endc_dcnr_info.restrict_dcnr = nas_cached_info.restrict_dcnr;
    }

    auto payload = std::make_shared<qcril::interfaces::RilQueryNrDcParamResult_t>(
            endc_dcnr_info);
    if (payload == nullptr) {
        ril_err = RIL_E_NO_MEMORY;
    }

    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            ril_err, payload);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
}

void qcril_qmi_nas_request_query_nr_bearer_allocation
(
    std::shared_ptr<RilRequestQueryNrBearAllocationMessage> msg
)
{
    RIL_Errno ril_err = RIL_E_SUCCESS;
    five_g_bearer_status status = qcril_qmi_is_5g_data_connected() ?
            five_g_bearer_status::FIVE_G_BEARER_STATUS_ALLOCATED :
            five_g_bearer_status::FIVE_G_BEARER_STATUS_NOT_ALLOCATED;

    auto payload = std::make_shared<qcril::interfaces::RilQueryNrBearAllocResult_t>(
            status);
    if (payload == nullptr) {
        ril_err = RIL_E_NO_MEMORY;
    }

    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            ril_err, payload);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
}

void qcril_qmi_nas_request_nr_signal_strength
(
    std::shared_ptr<RilRequestQueryNrSignalStrengthMessage> msg
)
{
    five_g_signal_strength ss;
    RIL_Errno ril_err;

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_sig_info))
    {
        ss.rsrp = nas_cached_info.nr5g_sig_info->rsrp;
        ss.snr = nas_cached_info.nr5g_sig_info->snr;
        ril_err = RIL_E_SUCCESS;
    }
    else
    {
        ss.rsrp = INT_MIN;
        ss.snr = INT_MIN;
        ril_err = RIL_E_INVALID_STATE;
    }

    auto payload = std::make_shared<qcril::interfaces::RilQueryNrSignalStrengthResult_t>(ss);
    if (payload == nullptr) {
        ril_err = RIL_E_NO_MEMORY;
    }

    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_err, payload);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
}

void qcril_qmi_nas_get_sys_info
(
    nas_get_sys_info_resp_msg_v01 *qmi_get_sys_info_resp_msg
)
{
    QCRIL_LOG_FUNC_ENTRY();
    qmi_client_error_type             qmi_error;
    RIL_Errno                         res = RIL_E_GENERIC_FAILURE;

    if(!qmi_get_sys_info_resp_msg)
    {
        QCRIL_LOG_ERROR("QMI NAS GET SYS INFO failed with NULL qmi_get_sys_info_resp_msg");
        return;
    }

    QCRIL_LOG_DEBUG("Executing  qcril_qmi_nas_get_sys_info. Issuing QMI cmd");
    qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                          NULL,
                                          0,
                                          (void*)qmi_get_sys_info_resp_msg,
                                          sizeof(*qmi_get_sys_info_resp_msg),
                                          ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, &(qmi_get_sys_info_resp_msg->resp));
    if (res != RIL_E_SUCCESS)
    {
        QCRIL_LOG_ERROR("QMI NAS GET SYS INFO failed with error code %d", res);
    }
    else
    {
        QCRIL_LOG_DEBUG("QMI NAS GET SYS INFO  request SUCCESS");
    }
}

//===========================================================================
// qcril_qmi_nas_fetch_band_pref
//===========================================================================
RIL_Errno qcril_qmi_nas_fetch_band_pref()
{
    RIL_Errno                                             ril_err;
    qmi_client_error_type                                 qmi_error = QMI_ERR_NONE_V01;
    nas_get_system_selection_preference_resp_msg_v01      get_system_sel_pref_resp;

    QCRIL_LOG_FUNC_ENTRY();

    do {
        memset(&get_system_sel_pref_resp, 0, sizeof(get_system_sel_pref_resp));

        qmi_error = qmi_client_nas_send_sync(QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                               NULL,// empty req payload
                                               NAS_NIL,
                                               &get_system_sel_pref_resp,
                                               sizeof( get_system_sel_pref_resp ),
                                               ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);
        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error,
            &get_system_sel_pref_resp.resp);

        if ( RIL_E_SUCCESS != ril_err )
            break;

    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_err);
    return ril_err;
}

//===========================================================================
// qcril_qmi_nas_fetch_dual_standby_pref
//===========================================================================
RIL_Errno qcril_qmi_nas_fetch_dual_standby_pref()
{
    qmi_client_error_type qmi_client_error;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

    nas_get_dual_standby_pref_resp_msg_v01 *qmi_response = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    qmi_response = (nas_get_dual_standby_pref_resp_msg_v01*)qcril_malloc( sizeof( *qmi_response ) );
    if ( qmi_response )
    {
        qmi_client_error = qmi_client_nas_send_sync(QMI_NAS_GET_DUAL_STANDBY_PREF_REQ_MSG_V01,
                                                       NULL,
                                                       NAS_NIL,  // empty request payload
                                                       (void*) qmi_response,
                                                       sizeof( *qmi_response ),
                                                       ModemEndPoint::SYNC_REQ_UNRESTRICTED_TIMEOUT);

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error,
                &qmi_response->resp );


        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();

            if ( qmi_response->standby_pref_valid )
            {
                QCRIL_LOG_INFO( ".. standby pref %d", qmi_response->standby_pref );
                nas_cached_info.dsds_standby_pref.standby_pref = qmi_response->standby_pref;
            }
            if (qmi_response->priority_subs_valid )
            {
                QCRIL_LOG_INFO( ".. priority subs %d", qmi_response->priority_subs );
                nas_common_info.dsds.paging_priority = qmi_response->priority_subs;
            }
            if (qmi_response->default_data_subs_valid)
            {
                QCRIL_LOG_INFO( ".. default data subs %d", qmi_response->default_data_subs );
                nas_common_info.dsds.default_data_sub = qmi_response->default_data_subs;
            }
            if( ( qmi_response->standby_pref == NAS_DUAL_STANDBY_WITH_TUNE_AWAY_V01 ) ||
                    ( qmi_response->standby_pref == NAS_AUTOMATIC_WITH_TUNE_AWAY_V01 ) )
            {
               nas_common_info.dsds.is_tune_away = TRUE;
               QCRIL_LOG_INFO( ".. tuneaway = %d", qmi_response->standby_pref);
            }
            if ( qmi_response->default_voice_subs_valid)
            {
                QCRIL_LOG_INFO( ".. default voice subs %d", qmi_response->default_voice_subs );
                nas_common_info.dsds.default_voice_sub = qmi_response->default_voice_subs;
            }
            if ( qmi_response->active_subs_mask_valid )
            {
                QCRIL_LOG_INFO( ".. active subs mask %d", qmi_response->active_subs_mask);
                nas_common_info.dsds.active_subs_mask = qmi_response->active_subs_mask;
            }

            NAS_CACHE_UNLOCK();
        }

        qcril_free( qmi_response );
    }
    else
    {
      QCRIL_LOG_ERROR("Memory allocation failed..");
      ril_req_res = RIL_E_NO_MEMORY;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_fetch_dual_standby_pref

/*===========================================================================
 qcril_qmi_nas_set_active_subs_timeout_handler
============================================================================*/
/*!
   @brief
   Timie out handler for ss event wait

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_set_active_subs_timeout_handler
(
    void *param
)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(param);

    QCRIL_LOG_INFO( "time out waiting for indication from modem");

    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.find(
            RilRequestEnableModemMessage::get_class_message_id());

    if (pendingMsg != nullptr) {
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            RIL_E_MODEM_ERR, nullptr);
        auto msg(std::static_pointer_cast<RilRequestEnableModemMessage>(pendingMsg));
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
        msgList.erase(pendingMsg);
    }

    NAS_CACHE_LOCK();
    nas_cached_info.active_subs_timeout_watch = NAS_NIL;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_set_active_subs_mask_cb
//===========================================================================
void qcril_qmi_nas_set_active_subs_mask_cb( RIL_Errno resp_res )
{
    uint32      new_timeout_watch = 0;
    int         new_timeout_set_res;
    const struct timeval timeout = {17 , 0}; //wait for 17sec

    QCRIL_LOG_FUNC_ENTRY();

    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.find(
            RilRequestEnableModemMessage::get_class_message_id());

    QCRIL_LOG_INFO( ".. resp_res - %d ", (int) resp_res);

    if (pendingMsg != nullptr)
    {
        if (resp_res == RIL_E_SUCCESS)
        {
            new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                    QCRIL_DEFAULT_MODEM_ID,
                    qcril_qmi_nas_set_active_subs_timeout_handler,
                    &timeout, &new_timeout_watch );

            QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );
            if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
            {
                if(new_timeout_set_res == E_SUCCESS)
                {
                    QCRIL_LOG_ERROR("Internal error..timed callback failed to set timer_id");
                    resp_res = RIL_E_INTERNAL_ERR;
                }
                else
                {
                    resp_res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err((IxErrnoType)new_timeout_set_res);
                }

            }
            else
            {
                NAS_CACHE_LOCK();
                nas_cached_info.active_subs_timeout_watch = new_timeout_watch;
                NAS_CACHE_UNLOCK();
            }
        }

        // Send response to telephony if there is any failure
        if (resp_res != RIL_E_SUCCESS) {
            auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
                resp_res, nullptr);
            auto msg(std::static_pointer_cast<RilRequestEnableModemMessage>(pendingMsg));
            msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
            msgList.erase(pendingMsg);
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_set_active_subs_mask_cb

//===========================================================================
// qcril_qmi_nas_enforce_modem_stack_status
//===========================================================================
RIL_Errno qcril_qmi_nas_enforce_modem_stack_status()
{
    bool req_sent_to_modem = false;
    char property_name[ PROPERTY_NAME_MAX ];
    char args[ PROPERTY_VALUE_MAX ];
    int stack_status = STACK_STATUS_UNKNOWN;
    RIL_Errno res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s%d", QMI_RIL_STACK_STATUS, qmi_ril_get_process_instance_id() );
        property_get( property_name, args, "" );

        NAS_CACHE_LOCK();
        nas_common_info.modem_stack_status = STACK_STATUS_UNKNOWN;
        if (strcmp(args, "0") == 0) {
            nas_common_info.modem_stack_status = STACK_STATUS_DISABLED;
        } else if (strcmp(args, "1") == 0) {
            nas_common_info.modem_stack_status = STACK_STATUS_ENABLED;
        } else {
            nas_common_info.modem_stack_status = STACK_STATUS_UNKNOWN;
        }
        stack_status = nas_common_info.modem_stack_status;
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_ERROR("stack status property - %s", property_name);
        QCRIL_LOG_ERROR("stack status property value - %s", args);
        QCRIL_LOG_ERROR("stack status - %d", stack_status);

        if (stack_status == STACK_STATUS_UNKNOWN) {
            QCRIL_LOG_INFO( "no need to change stack status");
            break;
        }

        if (stack_status == STACK_STATUS_ENABLED) {
            res = qcril_qmi_nas_enable_modem_stack_helper(true, req_sent_to_modem);
        } else if (stack_status == STACK_STATUS_DISABLED) {
            res = qcril_qmi_nas_enable_modem_stack_helper(false, req_sent_to_modem);
        }

    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) res);

    return res;
}

/*=========================================================================
 *   FUNCTION: qcril_qmi_nas_enable_modem_stack_helper
 *
 *   ===========================================================================*/
RIL_Errno qcril_qmi_nas_enable_modem_stack_helper(bool enable, bool &req_sent_to_modem)
{
    uint64_t sub_mask = 0;
    RIL_Errno res = RIL_E_SUCCESS;
    nas_active_subs_mask_type_v01 curr_active_subs_mask = 0;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO( "enable modem - %d", (int) enable);

    do
    {
        res = qcril_qmi_nas_fetch_dual_standby_pref();

        if (res != RIL_E_SUCCESS)
        {
            QCRIL_LOG_INFO( "fetch dual standby failed with res - %d", (int) res);
            break;
        }

        NAS_CACHE_LOCK();
        curr_active_subs_mask = nas_common_info.dsds.active_subs_mask;
        NAS_CACHE_UNLOCK();

        if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_get_modem_stack_id() ) {
            sub_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
        } else if ( QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_get_modem_stack_id() ) {
            sub_mask = QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
        } else {
            sub_mask = QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
        }

        if (enable) {
            // check if stack already UP
            if (curr_active_subs_mask & sub_mask) {
                QCRIL_LOG_INFO( "stack already up - stack id %d", (int) sub_mask);
                break;
            }

            // If stack already not up, bring it up.
            curr_active_subs_mask |= sub_mask;
        } else {
            // check if stack already DOWN
            if (!(curr_active_subs_mask & sub_mask)) {
                QCRIL_LOG_INFO( "stack already down - stack id %d", (int) sub_mask);
                break;
            }

            curr_active_subs_mask &= ~sub_mask;
        }

        // Do not set active_subs_mask as 0 to avoid ending up with no service at all
        if (curr_active_subs_mask == 0) {
            res = RIL_E_GENERIC_FAILURE;
            QCRIL_LOG_ERROR( "skipping as active_subs_mask is 0");
            break;
        }

        QCRIL_LOG_INFO( ".. send qmi request with active_subs_mask - %d", (int) curr_active_subs_mask);
        res = qcril_qmi_nas_dsds_util_request_set_subscription_mode(
                NULL,
                NULL,
                NULL,
                NULL,
                &curr_active_subs_mask,
                qcril_qmi_nas_set_active_subs_mask_cb);

        if (res != RIL_E_SUCCESS) {
            QCRIL_LOG_ERROR( ".. res %d", (int)res);
            break;
        }

        req_sent_to_modem = true;


    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

/*=========================================================================
 *   FUNCTION:  qcril_qmi_nas_get_modem_stack_status
 *
 *   ===========================================================================*/
void qcril_qmi_nas_get_modem_stack_status(
    std::shared_ptr<RilRequestGetModemStackStatusMessage> msg) {

    bool enable = true;
    uint64_t sub_mask = 0;
    uint64_t curr_active_subs_mask = 0;
    RIL_Errno res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

    do {
        res = qcril_qmi_nas_fetch_dual_standby_pref();
        if (res != RIL_E_SUCCESS) {
            QCRIL_LOG_INFO( "fetch dual standby failed with res - %d", (int) res);
            break;
        }

        NAS_CACHE_LOCK();
        curr_active_subs_mask = nas_common_info.dsds.active_subs_mask;
        NAS_CACHE_UNLOCK();

        if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_get_modem_stack_id() ) {
            sub_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
        } else if ( QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_get_modem_stack_id() ) {
            sub_mask = QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
        } else {
            sub_mask = QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
        }

        if (curr_active_subs_mask & sub_mask ) {
            enable = true;
        } else {
            enable = false;
        }
    } while(FALSE);

    QCRIL_LOG_INFO( "Send response to telephony, res - %d, stack status - %d", (int)res, enable);

    auto payload = std::make_shared<qcril::interfaces::RilGetModemStackResult_t>(enable);
    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
        res, payload);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);

    QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
 *   FUNCTION:  qcril_qmi_nas_enable_modem
 *
 *   ===========================================================================*/
void qcril_qmi_nas_request_enable_modem_stack(
    std::shared_ptr<RilRequestEnableModemMessage> msg) {

    bool enable = false;
    bool req_sent_to_modem = false;
    RIL_Errno res = RIL_E_SUCCESS;
    qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
    uint32 user_data;

    QCRIL_LOG_FUNC_ENTRY();

    do {

#ifndef QMI_RIL_UTF
        if ( !qmi_ril_is_multi_sim_feature_supported() ) {
            QCRIL_LOG_INFO( "enable modem supported only for multi sim targets");
            res = RIL_E_INVALID_STATE;
            break;
        }
#endif // QMI_RIL_UTF

        enable = msg->getEnableModem();

        res = qcril_qmi_nas_enable_modem_stack_helper(enable, req_sent_to_modem);

        if (res == RIL_E_SUCCESS && req_sent_to_modem)
        {
            // Insert to pending list only if request is successfully sent to modem
            auto& msgList = getNasModule().getPendingMessageList();
            auto pendingMsgStatus = msgList.insert(msg);
            uint16_t req_id = pendingMsgStatus.first;
            user_data = QCRIL_COMPOSE_USER_DATA(instance_id, QCRIL_DEFAULT_MODEM_ID, req_id);
            if (pendingMsgStatus.second != true) {
                QCRIL_LOG_INFO( "failed to create pending message list");
                res = RIL_E_GENERIC_FAILURE;
                break;
            }
        }

    } while(FALSE);

    if (res != RIL_E_SUCCESS || !req_sent_to_modem) {
        QCRIL_LOG_ERROR( "Send response to telephony, res - %d request sent to modem - %d",
                (int)res, req_sent_to_modem);

        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            res, nullptr);
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_set_system_selection_bands_cb
//===========================================================================
void qcril_qmi_nas_set_system_selection_bands_cb
(
    unsigned int                   message_id,
    std::shared_ptr<void>          resp_c_struct,
    unsigned int                   resp_c_struct_len,
    void                           *resp_cb_data,
    qmi_client_error_type          transp_err
)
{
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
    qcril_instance_id_e_type instance_id;
    uint32 user_data;
    uint16 req_id;
    nas_set_system_selection_preference_resp_msg_v01 *qmi_response = NULL;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(message_id);
    QCRIL_NOTUSED(resp_c_struct_len);

    /*-----------------------------------------------------------------------*/
    QCRIL_ASSERT( resp_c_struct != nullptr );
    user_data = ( uint32 )(uintptr_t)resp_cb_data;
    instance_id = (qcril_instance_id_e_type)QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
    req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );
    qmi_response = (nas_set_system_selection_preference_resp_msg_v01*)resp_c_struct.get();
    /*-----------------------------------------------------------------------*/
    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsg = msgList.extract(req_id);
    if (pendingMsg == nullptr) {
        QCRIL_LOG_ERROR("token: %d not found in NAS pending list", req_id);
    } else {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(transp_err,
                &qmi_response->resp);
        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d",
                (int) ril_req_res,
                (int) transp_err,
                (int) qmi_response->resp.error );

        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            ril_req_res, nullptr);
        auto msg(std::static_pointer_cast<RilRequestSetSysSelChannelsMessage>(pendingMsg));
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_set_system_selection_bands_cb

//===========================================================================
// qcril_qmi_nas_map_eutran_bands_to_qmi_bands
//===========================================================================
RIL_Errno qcril_qmi_nas_map_eutran_bands_to_qmi_bands
(
    RIL_EutranBands *band_arr,
    uint32_t band_len,
    nas_set_system_selection_preference_req_msg_v01 *qmi_req
)
{
    uint32_t i = 0;
    RIL_Errno res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

   do
   {
        if (qmi_req == nullptr) {
            res = RIL_E_GENERIC_FAILURE;
            break;
        }

        for(i = 0; (i < band_len) && (band_len <= MAX_BANDS); i++)
        {
            // BAND48 means 47th bit in bits_1_64
            if (band_arr[i] < 65) {
                qmi_req->lte_band_pref_ext_valid = TRUE;
                qmi_req->lte_band_pref_ext.bits_1_64 |= 1ULL << (band_arr[i]-1);
            } else if (band_arr[i] < 128) {
                qmi_req->lte_band_pref_ext_valid = TRUE;
                qmi_req->lte_band_pref_ext.bits_65_128 |= 1ULL << (band_arr[i]-1);
            } else if (band_arr[i] < 192) {
                qmi_req->lte_band_pref_ext_valid = TRUE;
                qmi_req->lte_band_pref_ext.bits_129_192 |= 1ULL << (band_arr[i]-1);
            } else if (band_arr[i] < 256) {
                qmi_req->lte_band_pref_ext_valid = TRUE;
                qmi_req->lte_band_pref_ext.bits_193_256 |= 1ULL << (band_arr[i]-1);
            }
        }

        QCRIL_LOG_INFO("qmi eutran bands to scan - 0x%lx, 0x%lx, 0x%lx, 0x%lx",
            qmi_req->lte_band_pref_ext.bits_1_64,
            qmi_req->lte_band_pref_ext.bits_65_128,
            qmi_req->lte_band_pref_ext.bits_129_192,
            qmi_req->lte_band_pref_ext.bits_193_256);

   } while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

//===========================================================================
// qcril_qmi_nas_map_utran_bands_to_qmi_bands
//===========================================================================
RIL_Errno qcril_qmi_nas_map_utran_bands_to_qmi_bands
(
    RIL_UtranBands *band_arr,
    uint32_t band_len,
    nas_set_system_selection_preference_req_msg_v01 *qmi_req
)
{
    uint32_t i = 0;
    RIL_Errno res = RIL_E_SUCCESS;
    nas_band_pref_mask_type_v01 utran_band_pref = 0;

    QCRIL_LOG_FUNC_ENTRY();

    for(i = 0; (i < band_len) && (band_len <= MAX_BANDS); i++)
    {
        switch (band_arr[i])
        {
            case UTRAN_BAND_1:
                utran_band_pref |= QMI_NAS_WCDMA_EU_J_CH_IMT_2100_BAND_V01;
                break;

            case UTRAN_BAND_2:
                utran_band_pref |= QMI_NAS_WCDMA_US_PCS_1900_BAND_V01;
                break;

            case UTRAN_BAND_3:
                utran_band_pref |= QMI_NAS_EU_CH_DCS_1800_BAND_V01;
                break;

            case UTRAN_BAND_4:
                utran_band_pref |= QMI_NAS_WCDMA_US_1700_BAND_V01;
                break;

            case UTRAN_BAND_5:
                utran_band_pref |= QMI_NAS_WCDMA_US_850_BAND_V01;
                break;

            case UTRAN_BAND_7:
                utran_band_pref |= QMI_NAS_WCDMA_EU_2600_BAND_V01;
                break;

            case UTRAN_BAND_8:
                utran_band_pref |= QMI_NAS_WCDMA_EU_J_900_BAND_V01;
                break;

            case UTRAN_BAND_9:
                utran_band_pref |= QMI_NAS_WCDMA_J_1700_BAND_V01;
                break;

            case UTRAN_BAND_19:
                utran_band_pref |= QMI_NAS_WCDMA_JAPAN_800_BAND_V01;
                break;

            case UTRAN_BAND_6:
            case UTRAN_BAND_10:
            case UTRAN_BAND_11:
            case UTRAN_BAND_12:
            case UTRAN_BAND_13:
            case UTRAN_BAND_14:
            case UTRAN_BAND_20:
            case UTRAN_BAND_21:
            case UTRAN_BAND_22:
            case UTRAN_BAND_25:
            case UTRAN_BAND_26:
                break;

            default:
                break;
        }
    }

    if (qmi_req) {
        qmi_req->band_pref_valid = TRUE;
        qmi_req->band_pref = utran_band_pref;
    }

    QCRIL_LOG_INFO("qmi utran bands to scan - 0x%lx res - %d", utran_band_pref, res);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

//===========================================================================
// qcril_qmi_nas_map_geran_bands_to_qmi_bands
//===========================================================================
RIL_Errno qcril_qmi_nas_map_geran_bands_to_qmi_bands
(
    RIL_GeranBands *band_arr,
    uint32_t band_len,
    nas_set_system_selection_preference_req_msg_v01 *qmi_req
)
{
    uint32_t i = 0;
    RIL_Errno res = RIL_E_SUCCESS;
    nas_band_pref_mask_type_v01 gsm_band_pref = 0;

    QCRIL_LOG_FUNC_ENTRY();

    for(i = 0; (i < band_len) && (band_len <= MAX_BANDS); i++)
    {
        switch (band_arr[i])
        {
            case GERAN_BAND_450:
                gsm_band_pref |= QMI_NAS_GSM_BAND_450_V01;
                break;

            case GERAN_BAND_480:
                gsm_band_pref |= QMI_NAS_GSM_BAND_480_V01;
                break;

            case GERAN_BAND_750:
                gsm_band_pref |= QMI_NAS_GSM_BAND_750_V01;
                break;

            case GERAN_BAND_850:
                gsm_band_pref |= QMI_NAS_GSM_BAND_850_V01;
                break;

            case GERAN_BAND_P900:
                gsm_band_pref |= QMI_NAS_P_GSM_900_BAND_V01;
                break;

            case GERAN_BAND_E900:
                gsm_band_pref |= QMI_NAS_E_GSM_900_BAND_V01;
                break;

            case GERAN_BAND_R900:
                gsm_band_pref |= QMI_NAS_GSM_BAND_RAILWAYS_900_BAND_V01;
                break;

            case GERAN_BAND_PCS1900:
                gsm_band_pref |= QMI_NAS_GSM_BAND_PCS_1900_BAND_V01;
                break;

            // Looks like there are no commercial deployments for these bands
            case GERAN_BAND_T380:
            case GERAN_BAND_T410:
            case GERAN_BAND_710:
            case GERAN_BAND_T810:
            case GERAN_BAND_DCS1800:
            case GERAN_BAND_ER900:
                break;

            default:
                break;
        }
    }

    if (qmi_req) {
        qmi_req->band_pref_valid = TRUE;
        qmi_req->band_pref = gsm_band_pref;
    }

    QCRIL_LOG_INFO("qmi geran bands to scan - 0x%lx res - %d", gsm_band_pref, res);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

/*=========================================================================
 *   FUNCTION:  qcril_qmi_nas_fill_default_bands_info
 *
 *   ===========================================================================*/
RIL_Errno qcril_qmi_nas_fill_default_bands_info(
    nas_set_system_selection_preference_req_msg_v01 &qmi_req) {

    RIL_Errno res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

    // bit 62 in reserved to allow reset of band preference.
    qmi_req.band_pref_valid = TRUE;
    qmi_req.band_pref = 1ULL << 62;

    qmi_req.lte_band_pref_ext_valid = TRUE;
    qmi_req.lte_band_pref_ext.bits_1_64 = 1ULL << 62;
    qmi_req.lte_band_pref_ext.bits_65_128 = 0;
    qmi_req.lte_band_pref_ext.bits_129_192 = 0;
    qmi_req.lte_band_pref_ext.bits_193_256 = 0;

    qmi_req.change_duration_valid = TRUE;
    qmi_req.change_duration = NAS_PERMANENT_V01;

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

/*=========================================================================
 *   FUNCTION:  qcril_qmi_nas_fill_band_info
 *
 *   ===========================================================================*/
RIL_Errno qcril_qmi_nas_fill_band_info(
    RIL_SysSelChannels &hlos_req,
    nas_set_system_selection_preference_req_msg_v01 &qmi_req) {

    uint32_t i = 0;
    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        for(i = 0; i < hlos_req.specifiers_length; i++)
        {
            switch (hlos_req.specifiers[i].radio_access_network)
            {
                case GERAN:
                    ril_req_res = qcril_qmi_nas_map_geran_bands_to_qmi_bands(
                        hlos_req.specifiers[i].bands.geran_bands,
                        hlos_req.specifiers[i].bands_length, &qmi_req);
                    break;

                case UTRAN:
                    ril_req_res = qcril_qmi_nas_map_utran_bands_to_qmi_bands(
                        hlos_req.specifiers[i].bands.utran_bands,
                        hlos_req.specifiers[i].bands_length, &qmi_req);
                    break;

                case EUTRAN:
                    ril_req_res = qcril_qmi_nas_map_eutran_bands_to_qmi_bands(
                        hlos_req.specifiers[i].bands.eutran_bands,
                        hlos_req.specifiers[i].bands_length, &qmi_req);
                    break;

                default:
                    break;
            }
        }

        if (qmi_req.band_pref != 0) {
            qmi_req.band_pref_valid = TRUE;
        }

        qmi_req.change_duration_valid = TRUE;
        qmi_req.change_duration = NAS_POWER_CYCLE_V01;

    } while(FALSE);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_req_res);
    return ril_req_res;
}


/*=========================================================================
 *   FUNCTION:  qcril_qmi_nas_request_set_system_selection_channels
 *
 *   ===========================================================================*/
void qcril_qmi_nas_request_set_system_selection_channels(
    std::shared_ptr<RilRequestSetSysSelChannelsMessage> msg) {

    uint32 user_data;
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_error;
    RIL_SysSelChannels req_info;
    qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
    nas_set_system_selection_preference_req_msg_v01   qmi_set_sel_pref_req;
    nas_set_system_selection_preference_resp_msg_v01 *qmi_set_sel_pref_resp;

    QCRIL_LOG_FUNC_ENTRY();

    auto& msgList = getNasModule().getPendingMessageList();
    auto pendingMsgStatus = msgList.insert(msg);

    do {

        if (pendingMsgStatus.second != true) {
            QCRIL_LOG_INFO( "failed to create pending message list");
            res = RIL_E_GENERIC_FAILURE;
            break;
        }
        uint16_t req_id = pendingMsgStatus.first;
        user_data = QCRIL_COMPOSE_USER_DATA(instance_id, QCRIL_DEFAULT_MODEM_ID, req_id);

        memset(&qmi_set_sel_pref_req,0,sizeof(qmi_set_sel_pref_req));

        req_info = msg->getSystemSelectionChannelInfo();

        // scan all bands
        if (req_info.specifiers_length == 0) {
            res = qcril_qmi_nas_fill_default_bands_info(qmi_set_sel_pref_req);
        } else { // scan specified bands
            res = qcril_qmi_nas_fill_band_info(req_info, qmi_set_sel_pref_req);
        }

        if (res != RIL_E_SUCCESS) {
            break;
        }

        qmi_error =  qmi_client_nas_send_async(
                QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                &qmi_set_sel_pref_req,
                sizeof(qmi_set_sel_pref_req),
                sizeof(*qmi_set_sel_pref_resp),
                qcril_qmi_nas_set_system_selection_bands_cb,
                (void*)(uintptr_t)user_data);
        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, NULL);

        if (res != RIL_E_SUCCESS)
        {
            QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)res, (int)qmi_error);
            break;
        }
    } while (FALSE);

    if (res != RIL_E_SUCCESS) {
        if (pendingMsgStatus.second) {
            msgList.erase(pendingMsgStatus.first);
        }
        auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(
            res, nullptr);
        msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    }

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_request_query_upperlayer_ind_info
(
    std::shared_ptr<RilRequestQueryUpperLayerIndInfoMessage> msg
)
{
    RIL_Errno ril_err = RIL_E_SUCCESS;

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.plmn_infolist_r15_available) ||
            !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available))
    {
        qcril_qmi_nas_fetch_sys_info();
    }

    five_g_upper_layer_ind_info upli_info;

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.plmn_infolist_r15_available) &&
        nas_cached_info.plmn_infolist_r15_available == 1)
    {
        upli_info.plmn_list_status = five_g_plmn_info_list_status::FIVE_G_PLMN_LIST_AVAILABLE;
    } else {
        upli_info.plmn_list_status = five_g_plmn_info_list_status::FIVE_G_PLMN_LIST_UNAVAILABLE;
    }

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.endc_available) &&
        nas_cached_info.endc_available == 1)
    {
        upli_info.upper_layer_ind_info_status = five_g_upper_layer_ind_status::FIVE_G_UPPER_LAYER_IND_AVAILABLE;
    } else {
        upli_info.upper_layer_ind_info_status = five_g_upper_layer_ind_status::FIVE_G_UPPER_LAYER_IND_UNAVAILABLE;
    }

    auto payload = std::make_shared<qcril::interfaces::RilQueryUpperLayerIndInfoResult_t>(upli_info);
    if (payload == nullptr) {
        ril_err = RIL_E_NO_MEMORY;
    }

    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_err, payload);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
}

void qcril_qmi_nas_request_query_5g_config_info
(
    std::shared_ptr<RilRequestQuery5gConfigInfoMessage> msg
)
{
    QCRIL_LOG_FUNC_ENTRY();
    RIL_Errno ril_err = RIL_E_SUCCESS;
    five_g_config_type config = FIVE_G_CONFIG_TYPE_NSA;

    QCRIL_LOG_INFO("nas_cached_info.nr5g_srv_status_info_valid: %d", nas_cached_info.nr5g_srv_status_info_valid);

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nr5g_srv_status_info)) {
        QCRIL_LOG_INFO("nas_cached_info.nr5g_srv_status_info->srv_status: %d", nas_cached_info.nr5g_srv_status_info->srv_status);
        if (nas_cached_info.nr5g_srv_status_info->srv_status == NAS_SYS_SRV_STATUS_SRV_V01)
            config = FIVE_G_CONFIG_TYPE_SA;
    }

    auto payload = std::make_shared<qcril::interfaces::RilQuery5gConfigInfoResult_t>(config);
    if (payload == nullptr) {
        ril_err = RIL_E_NO_MEMORY;
    }

    auto respData = std::make_shared<QcRilRequestMessageCallbackPayload>(ril_err, payload);
    msg->sendResponse(msg, Message::Callback::Status::SUCCESS, respData);
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_update_embms_status_based_on_dsd_dds
//===========================================================================
void qcril_qmi_nas_update_embms_status_based_on_dsd_dds()
{
    uint8_t is_available = 0;
    uint32_t sub_capability = 0;
    qcril_instance_id_e_type instance_id = qmi_ril_get_process_instance_id();

    QCRIL_LOG_FUNC_ENTRY();

    if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_EMBMS))
    {
        NAS_CACHE_LOCK();

        if (( nas_dms_cached_info.current_sub_capability_valid == TRUE ) &&
             (nas_common_info.dsds.dds_data_sub_valid == TRUE))
        {
            sub_capability = qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();

            if (sub_capability & (1 << RADIO_TECH_LTE))
            {
                is_available = 1;
            }

            if (is_available &&
                 ((nas_common_info.dsds.dds_data_sub.dds_sub_id != instance_id)||
                  (DSD_DDS_DURATION_PERMANANT_V01 != nas_common_info.dsds.dds_data_sub.switch_type)))
            {
                is_available = 0;
            }
        }
        NAS_CACHE_UNLOCK();

        NAS_EMBMS_CACHE_LOCK();
        if(is_available != nas_cached_info.is_embms_available)
        {
            nas_cached_info.is_embms_available = is_available;
        }
        NAS_EMBMS_CACHE_UNLOCK();
        QCRIL_LOG_DEBUG("is_available %d", is_available);
    }
    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_notify_embms_status()
{
    uint8_t is_default_data_set = FALSE;
    uint8_t is_prev_embms_available = FALSE;
    uint8_t is_latest_embms_available = FALSE;

    NAS_CACHE_LOCK();
    is_default_data_set = nas_common_info.dsds.is_default_data_set;
    NAS_CACHE_UNLOCK();

    NAS_EMBMS_CACHE_LOCK();
    is_prev_embms_available = nas_cached_info.is_embms_available;
    NAS_EMBMS_CACHE_UNLOCK();

    QCRIL_LOG_DEBUG("is_default_data_set %d", is_default_data_set);

    if ( !qmi_ril_is_multi_sim_feature_supported() )
    {
        qcril_qmi_nas_update_embms_status();
    }
    else
    {
        (FALSE == is_default_data_set)?qcril_qmi_nas_update_embms_status_based_on_dsd_dds():
            qcril_qmi_nas_update_embms_status();
    }

    NAS_EMBMS_CACHE_LOCK();
    is_latest_embms_available = nas_cached_info.is_embms_available;
    NAS_EMBMS_CACHE_UNLOCK();
    QCRIL_LOG_DEBUG("is_prev_embms_available %d", is_prev_embms_available);
    QCRIL_LOG_DEBUG("is_latest_embms_available %d", is_latest_embms_available);
    qcril_qmi_nas_embms_send_embms_status(is_latest_embms_available);
}

void qcril_qmi_util_proper_network_status_notify_for_plmn(char *mcc_str, char *mnc_str, int no_of_entries, char *nw_status, qcril_qmi_nw_scan_resp_helper_type  * unique_network_scan_plmns_table, int no_of_unique_network_scan_plmns)
{
    int iter_i;
    char plmn_str[NAS_NW_SCAN_RESP_MCCMNC_SIZE];

    QCRIL_LOG_FUNC_ENTRY();

    if( mcc_str && mnc_str && unique_network_scan_plmns_table )
    {
        snprintf( plmn_str, sizeof(plmn_str), "%s%s", mcc_str,mnc_str);
        QCRIL_LOG_INFO("checking plmn %s is unique or not",plmn_str);

        for( iter_i = 0; iter_i < no_of_unique_network_scan_plmns; iter_i++ )
        {
            if( (!strcmp(plmn_str, (char*) unique_network_scan_plmns_table->mccmnc_info[iter_i])) )

            {
                if(strcmp("current", unique_network_scan_plmns_table->nw_scan_info_array[no_of_entries*iter_i + 3]) &&
                   !strcmp("current",nw_status))
                {
                    unique_network_scan_plmns_table->nw_scan_info_array[no_of_entries*iter_i + 3] = nw_status;
                    QCRIL_LOG_INFO("nw_status changed to %s", unique_network_scan_plmns_table->nw_scan_info_array[no_of_entries*iter_i + 3]);
                }
                else if(strcmp("current", unique_network_scan_plmns_table->nw_scan_info_array[no_of_entries*iter_i + 3]) &&
                        strcmp("available", unique_network_scan_plmns_table->nw_scan_info_array[no_of_entries*iter_i + 3]) &&
                        !strcmp("available",nw_status))
                {
                    unique_network_scan_plmns_table->nw_scan_info_array[no_of_entries*iter_i + 3] = nw_status;
                    QCRIL_LOG_INFO("nw_status changed to %s", unique_network_scan_plmns_table->nw_scan_info_array[no_of_entries*iter_i + 3]);
                }
                QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%s",iter_i+1,
                                   unique_network_scan_plmns_table->nw_scan_info_array[ no_of_entries * iter_i ],
                                   unique_network_scan_plmns_table->nw_scan_info_array[ no_of_entries * iter_i + 1 ],
                                   unique_network_scan_plmns_table->nw_scan_info_array[ no_of_entries * iter_i + 2 ],
                                   unique_network_scan_plmns_table->nw_scan_info_array[ no_of_entries * iter_i + 3 ]);
                break;
            }

        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_util_proper_network_status_notify_for_plmn(char *mcc_str, char *mnc_str, qcril::interfaces::NetworkStatus nw_status, std::vector<qcril::interfaces::NetworkInfo>& list)
{
    int iter_i;

    QCRIL_LOG_FUNC_ENTRY();

    if( mcc_str && mnc_str )
    {
        std::string plmn = mcc_str;
        plmn.append(mnc_str);

        QCRIL_LOG_INFO("checking plmn %s is unique or not",plmn.c_str());

        for( iter_i = 0; iter_i < list.size(); iter_i++ )
        {
            if( !plmn.compare(list[iter_i].operatorNumeric) )

            {
                if((qcril::interfaces::NetworkStatus::CURRENT != list[iter_i].status) &&
                   (qcril::interfaces::NetworkStatus::CURRENT == nw_status))
                {
                    list[iter_i].status = nw_status;
                    QCRIL_LOG_INFO("nw_status changed to %d", list[iter_i].status);
                }
                else if((qcril::interfaces::NetworkStatus::CURRENT != list[iter_i].status) &&
                        (qcril::interfaces::NetworkStatus::AVAILABLE != list[iter_i].status) &&
                        (qcril::interfaces::NetworkStatus::AVAILABLE == nw_status))
                {
                    list[iter_i].status = nw_status;
                    QCRIL_LOG_INFO("nw_status changed to %d", list[iter_i].status);
                }

                QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%d", iter_i+1,
                    list[iter_i].alphaLong.c_str(), list[iter_i].alphaShort.c_str(),
                    list[iter_i].operatorNumeric.c_str(), list[iter_i].status);
                break;
            }

        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_set_lpm_flag_after_ssr_in_apm()
{
    if(qcril_qmi_nas_is_apm_enabled())
    {
        NAS_CACHE_LOCK();
        nas_common_info.set_lpm_after_ssr_in_apm = TRUE;
        NAS_CACHE_UNLOCK();
        QCRIL_LOG_DEBUG("set_lpm_after_ssr_in_apm: TRUE");
    }
}

void qcril_qmi_nas_set_lpm_after_ssr_in_apm()
{
    int opmode_query_timer_id_valid = FALSE;
    int set_lpm_after_ssr_in_apm = FALSE;

    NAS_CACHE_LOCK();
    set_lpm_after_ssr_in_apm = nas_common_info.set_lpm_after_ssr_in_apm;
    opmode_query_timer_id_valid = nas_common_info.opmode_query_timer_id_valid;
    NAS_CACHE_UNLOCK();

    auto cur_op_mode = qcril_qmi_nas_dms_get_current_operating_mode();

    QCRIL_LOG_DEBUG("set_lpm_after_ssr_in_apm: %d, opmode_query_timer_id_valid: %d, get current op mode: %d",
        set_lpm_after_ssr_in_apm, opmode_query_timer_id_valid, cur_op_mode);

    if(!set_lpm_after_ssr_in_apm)
    {
        return;
    }
    if(opmode_query_timer_id_valid || (DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01 == cur_op_mode))
    {
        return;
    }
    else if ((DMS_OP_MODE_FACTORY_TEST_MODE_V01 != cur_op_mode)&&
        (DMS_OP_MODE_LOW_POWER_V01 != cur_op_mode))
    {
        NAS_CACHE_LOCK();
        nas_common_info.set_lpm_after_ssr_in_apm = FALSE;
        NAS_CACHE_UNLOCK();
        qcril_qmi_nas_set_operating_mode_state(DMS_OP_MODE_LOW_POWER_V01);
    }
}

void qcril_qmi_nas_notify_radio_power_if_dms_up()
{
    int opmode_query_timer_id_valid = FALSE;

    NAS_CACHE_LOCK();
    opmode_query_timer_id_valid = nas_common_info.opmode_query_timer_id_valid;
    NAS_CACHE_UNLOCK();

    auto cur_op_mode = qcril_qmi_nas_dms_get_current_operating_mode();

    QCRIL_LOG_DEBUG("opmode_query_timer_id_valid: %d, get current op mode: %d",
        opmode_query_timer_id_valid, cur_op_mode);

    if(opmode_query_timer_id_valid || (DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01 == cur_op_mode))
    {
        return;
    }
    else
    {
        qcril_qmi_nas_notify_radio_power_handler_dms_service_is_up();
    }
}

//===========================================================================
//qcril_qmi_nas_reset_extrapolation_ban_expiry
//===========================================================================
void qcril_qmi_nas_reset_extrapolation_ban_expiry()
{
    QCRIL_LOG_FUNC_ENTRY();

    auto& msgList = getNasModule().getPendingMessageList();

    // look for any on-going set pref network type request
    auto pendingSetPrefNetworkTypeMsg = msgList.find(RilRequestSetPrefNetworkTypeMessage::get_class_message_id());

    // look for any on-going request (including manually and automatically network selection)
    auto pendingNetworkSelectionMsg = msgList.find(RilRequestSetNetworkSelectionManualMessage::get_class_message_id());
    if (!pendingNetworkSelectionMsg)
    {
        pendingNetworkSelectionMsg = msgList.find(RilRequestSetNetworkSelectionAutoMessage::get_class_message_id());
    }

    if (!pendingSetPrefNetworkTypeMsg && !pendingNetworkSelectionMsg)
    {
        NAS_CACHE_LOCK();
        if ( NAS_NIL != nas_cached_info.extrapolation_ban_expiry )
        {
            qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.extrapolation_ban_expiry );
            nas_cached_info.extrapolation_ban_expiry = NAS_NIL;
        }
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_reset_extrapolation_ban_expiry
