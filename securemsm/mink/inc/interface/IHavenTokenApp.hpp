// =======================================================================
// Copyright (c) 2016-2019 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
// =======================================================================

#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include "object.h"
#include "proxy_base.hpp"

/** @cond */

class IIHavenTokenApp {
   public:
    static const uint32_t SIG_SEC_LEVEL_HW = UINT32_C(7);
    static const uint32_t SIG_SEC_LEVEL_SEK = UINT32_C(6);
    static const uint32_t SIG_SEC_LEVEL_SEU = UINT32_C(5);
    static const uint32_t SIG_SEC_LEVEL_TEEK = UINT32_C(4);
    static const uint32_t SIG_SEC_LEVEL_TEEU = UINT32_C(3);
    static const uint32_t SIG_SEC_LEVEL_RICHOSK = UINT32_C(2);
    static const uint32_t SIG_SEC_LEVEL_RICHOSU = UINT32_C(1);
    static const uint32_t KEYTYPE_NONE = UINT32_C(0);
    static const uint32_t KEYTYPE_DEMO = UINT32_C(1);
    static const uint32_t KEYTYPE_GROUPLOW = UINT32_C(2);
    static const uint32_t KEYTYPE_GROUP = UINT32_C(3);
    static const uint32_t KEYTYPE_PERCHIP = UINT32_C(4);
    static const uint32_t KEYTYPE_RESERVED_1 = UINT32_C(5);
    static const uint32_t KEYTYPE_RESERVED_2 = UINT32_C(6);
    static const uint32_t KEYTYPE_GROUPTEST = UINT32_C(7);
    static const uint32_t KEYTYPE_BEST_PRIVACY_PRESERVING_AVAILABLE = UINT32_C(8);
    static const uint32_t KEYTYPE_QDAK = UINT32_C(9);
    static const uint32_t KEYTYPE_QDAKTEST = UINT32_C(10);
    static const uint32_t KEYTYPE_DEMO_NPP = UINT32_C(11);
    static const uint64_t OPT_NONE = UINT64_C(0x0000000000000000);
    static const uint64_t OPT_SIMDATA = UINT64_C(0x0000000000000001);
    static const uint64_t OPT_APPCERT = UINT64_C(0x0000000000000002);
    static const uint64_t OPT_LOCATION = UINT64_C(0x0000000000000004);
    static const uint64_t OPT_LONGRTIC = UINT64_C(0x0000000000000008);
    static const uint64_t OPT_RTIC_CURRENT = UINT64_C(0x0000000000000020);
    static const uint64_t OPT_NON_PRIVACY_PRESERVING = UINT64_C(0x0000000000000080);
    static const uint64_t OPT_CIPHER_SUITE_1 = UINT64_C(0x0000000000000100);
    static const uint64_t OPT_CIPHER_SUITE_2 = UINT64_C(0x0000000000000200);
    static const uint64_t OPT_CIPHER_SUITE_3 = UINT64_C(0x0000000000000400);
    static const uint32_t LICENSE_OPT_NONE = UINT32_C(0x00000000);
    static const uint32_t LICENSE_OPT_NO_OEMID_CHECK = UINT32_C(0x00000001);
    static const uint32_t LICENSE_OPT_NO_HWVERSION_CHECK = UINT32_C(0x00000002);
    static const uint32_t LICENSE_OPT_NO_FEATUREID_CHECK = UINT32_C(0x00000004);
    static const uint32_t LICENSE_OPT_NO_TIME_CHECK = UINT32_C(0x00000008);
    static const uint32_t LICENSE_OPT_CLOCK_NOT_SET_OK = UINT32_C(0x00000010);
    static const uint32_t LICENSE_OPT_SELECT_TEST_ROOT = UINT32_C(0x00000020);
    static const uint32_t LICENSE_OPT_USAGE_ENCRYPT = UINT32_C(0x00000040);

    static const int32_t ERROR_NOMEM = INT32_C(10);
    static const int32_t ERROR_SIGNING_KEY_UNAVAIL = INT32_C(11);
    static const int32_t ERROR_CBOR_ENCODE_ERR = INT32_C(12);
    static const int32_t ERROR_CERT_PKHASH = INT32_C(13);
    static const int32_t ERROR_INVALID_CERT = INT32_C(14);
    static const int32_t ERROR_CERT_FEATUREID = INT32_C(15);
    static const int32_t ERROR_CERT_EXPIRED = INT32_C(16);
    static const int32_t ERROR_CERT_OEM = INT32_C(17);
    static const int32_t ERROR_CERT_HWVERSION = INT32_C(18);
    static const int32_t ERROR_CERT_ISVCERTHASH = INT32_C(19);
    static const int32_t ERROR_DATA_MARSHAL = INT32_C(20);
    static const int32_t ERROR_HASH_GENERATION = INT32_C(21);
    static const int32_t ERROR_CERT_NOT_TRUSTED = INT32_C(22);
    static const int32_t ERROR_CERT_GENERAL_ERR = INT32_C(23);
    static const int32_t ERROR_DATA_TOO_BIG = INT32_C(24);
    static const int32_t ERROR_OFFSET_TOO_LARGE = INT32_C(25);
    static const int32_t ERROR_OUT_OF_ORDER = INT32_C(26);
    static const int32_t ERROR_NO_DATA = INT32_C(27);
    static const int32_t ERROR_RPMB_ERR = INT32_C(28);
    static const int32_t ERROR_ENCRYPTION = INT32_C(29);
    static const int32_t ERROR_NOT_ALLOWED = INT32_C(30);
    static const int32_t ERROR_LICENSE_TOO_BIG = INT32_C(31);
    static const int32_t ERROR_PRIVILEGE_ERR = INT32_C(32);
    static const int32_t ERROR_TOO_MUCH_APPDATA = INT32_C(33);
    static const int32_t ERROR_SECURITYLEVEL_NOT_SUPPORTED = INT32_C(34);
    static const int32_t ERROR_UNSUPPORTED_PAYLOAD_HASH = INT32_C(35);
    static const int32_t ERROR_SIGNING_ERR = INT32_C(36);
    static const int32_t ERROR_DEVICE_NOT_SECURE = INT32_C(37);
    static const int32_t ERROR_GROUPKEY_ERR = INT32_C(38);
    static const int32_t ERROR_CERT_DEVICEID = INT32_C(39);
    static const int32_t ERROR_SFS_ERR = INT32_C(40);
    static const int32_t ERROR_CERT_NOTYETVALID = INT32_C(41);
    static const int32_t ERROR_OPTS_NOT_SUPPORTED = INT32_C(42);
    static const int32_t ERROR_KEYSEQ_NOT_SUPPORTED = INT32_C(43);
    static const int32_t ERROR_KEYMGR_ERR = INT32_C(44);
    static const int32_t ERROR_CERT_PRODUCTID = INT32_C(45);

    virtual ~IIHavenTokenApp() {}

    virtual int32_t start(uint32_t uKeySelect_val, uint64_t nOpts_val, const void* LicenseCert_ptr, size_t LicenseCert_len) = 0;
    virtual int32_t addDataItem(const void* DataItem_ptr, size_t DataItem_len, const void* Label_ptr, size_t Label_len, const void* Data_ptr, size_t Data_len) = 0;
    virtual int32_t getSize(uint64_t* pnSize_ptr) = 0;
    virtual int32_t getBytes(uint64_t uOffset_val, void* pBuffer_ptr, size_t pBuffer_len, size_t* pBuffer_lenout) = 0;
    virtual int32_t finish() = 0;
    virtual int32_t setTime(uint64_t UTCTime_val) = 0;
    virtual int32_t processLicense(const void* LicenseCert_ptr, size_t LicenseCert_len, uint32_t OptFlags_val, const void* IntermediateCert_ptr, size_t IntermediateCert_len, uint32_t FeatureID_val, const void* ISVCertHash_ptr, size_t ISVCertHash_len, void* Licensee_ptr, size_t Licensee_len, size_t* Licensee_lenout, void* Issuer_ptr, size_t Issuer_len, size_t* Issuer_lenout, void* SerialNumber_ptr, size_t SerialNumber_len, size_t* SerialNumber_lenout, void* PublicKey_ptr, size_t PublicKey_len, size_t* PublicKey_lenout) = 0;
    virtual int32_t processLicense_TEE(const void* LicenseCert_ptr, size_t LicenseCert_len, uint32_t OptFlags_val, const void* IntermediateCert_ptr, size_t IntermediateCert_len, uint32_t FeatureID_val, const void* ISVCertHash_ptr, size_t ISVCertHash_len, void* Licensee_ptr, size_t Licensee_len, size_t* Licensee_lenout, void* Issuer_ptr, size_t Issuer_len, size_t* Issuer_lenout, void* SerialNumber_ptr, size_t SerialNumber_len, size_t* SerialNumber_lenout, void* PublicKey_ptr, size_t PublicKey_len, size_t* PublicKey_lenout, uint64_t* CalleeID_ptr) = 0;

   protected:
    static const ObjectOp OP_start = 0;
    static const ObjectOp OP_addDataItem = 1;
    static const ObjectOp OP_getSize = 2;
    static const ObjectOp OP_getBytes = 3;
    static const ObjectOp OP_finish = 4;
    static const ObjectOp OP_setTime = 5;
    static const ObjectOp OP_processLicense = 6;
    static const ObjectOp OP_processLicense_TEE = 7;
};

class IHavenTokenApp : public IIHavenTokenApp, public ProxyBase {
   public:
    IHavenTokenApp() {}
    IHavenTokenApp(Object impl) : ProxyBase(impl) {}
    virtual ~IHavenTokenApp() {}

    virtual int32_t start(uint32_t uKeySelect_val, uint64_t nOpts_val, const void* LicenseCert_ptr, size_t LicenseCert_len) {
        ObjectArg a[2];
        struct s1 {
            uint64_t m_nOpts;
            uint32_t m_uKeySelect;
        } i;
        a[0].b = (ObjectBuf) {&i, 12};
        i.m_uKeySelect = uKeySelect_val;
        i.m_nOpts = nOpts_val;
        a[1].bi = (ObjectBufIn) {LicenseCert_ptr, LicenseCert_len * 1};

        return invoke(OP_start, a, ObjectCounts_pack(2, 0, 0, 0));
    }

    virtual int32_t addDataItem(const void* DataItem_ptr, size_t DataItem_len, const void* Label_ptr, size_t Label_len, const void* Data_ptr, size_t Data_len) {
        ObjectArg a[3];
        a[0].bi = (ObjectBufIn) {DataItem_ptr, DataItem_len * 1};
        a[1].bi = (ObjectBufIn) {Label_ptr, Label_len * 1};
        a[2].bi = (ObjectBufIn) {Data_ptr, Data_len * 1};

        return invoke(OP_addDataItem, a, ObjectCounts_pack(3, 0, 0, 0));
    }

    virtual int32_t getSize(uint64_t* pnSize_ptr) {
        ObjectArg a[1];
        a[0].b = (ObjectBuf) {pnSize_ptr, sizeof(uint64_t)};

        return invoke(OP_getSize, a, ObjectCounts_pack(0, 1, 0, 0));
    }

    virtual int32_t getBytes(uint64_t uOffset_val, void* pBuffer_ptr, size_t pBuffer_len, size_t* pBuffer_lenout) {
        ObjectArg a[2];
        a[0].b = (ObjectBuf) {&uOffset_val, sizeof(uint64_t)};
        a[1].b = (ObjectBuf) {pBuffer_ptr, pBuffer_len * 1};

        int32_t result = invoke(OP_getBytes, a, ObjectCounts_pack(1, 1, 0, 0));
        if (Object_OK != result) { return result; }

        *pBuffer_lenout = a[1].b.size / 1;

        return result;
    }

    virtual int32_t finish() {
        return invoke(OP_finish, 0, 0);
    }

    virtual int32_t setTime(uint64_t UTCTime_val) {
        ObjectArg a[1];
        a[0].b = (ObjectBuf) {&UTCTime_val, sizeof(uint64_t)};

        return invoke(OP_setTime, a, ObjectCounts_pack(1, 0, 0, 0));
    }

    virtual int32_t processLicense(const void* LicenseCert_ptr, size_t LicenseCert_len, uint32_t OptFlags_val, const void* IntermediateCert_ptr, size_t IntermediateCert_len, uint32_t FeatureID_val, const void* ISVCertHash_ptr, size_t ISVCertHash_len, void* Licensee_ptr, size_t Licensee_len, size_t* Licensee_lenout, void* Issuer_ptr, size_t Issuer_len, size_t* Issuer_lenout, void* SerialNumber_ptr, size_t SerialNumber_len, size_t* SerialNumber_lenout, void* PublicKey_ptr, size_t PublicKey_len, size_t* PublicKey_lenout) {
        ObjectArg a[8];
        struct s1 {
            uint32_t m_OptFlags;
            uint32_t m_FeatureID;
        } i;
        a[0].b = (ObjectBuf) {&i, 8};
        a[1].bi = (ObjectBufIn) {LicenseCert_ptr, LicenseCert_len * 1};
        i.m_OptFlags = OptFlags_val;
        a[2].bi = (ObjectBufIn) {IntermediateCert_ptr, IntermediateCert_len * 1};
        i.m_FeatureID = FeatureID_val;
        a[3].bi = (ObjectBufIn) {ISVCertHash_ptr, ISVCertHash_len * 1};
        a[4].b = (ObjectBuf) {Licensee_ptr, Licensee_len * 1};
        a[5].b = (ObjectBuf) {Issuer_ptr, Issuer_len * 1};
        a[6].b = (ObjectBuf) {SerialNumber_ptr, SerialNumber_len * 1};
        a[7].b = (ObjectBuf) {PublicKey_ptr, PublicKey_len * 1};

        int32_t result = invoke(OP_processLicense, a, ObjectCounts_pack(4, 4, 0, 0));
        if (Object_OK != result) { return result; }

        *Licensee_lenout = a[4].b.size / 1;
        *Issuer_lenout = a[5].b.size / 1;
        *SerialNumber_lenout = a[6].b.size / 1;
        *PublicKey_lenout = a[7].b.size / 1;

        return result;
    }

    virtual int32_t processLicense_TEE(const void* LicenseCert_ptr, size_t LicenseCert_len, uint32_t OptFlags_val, const void* IntermediateCert_ptr, size_t IntermediateCert_len, uint32_t FeatureID_val, const void* ISVCertHash_ptr, size_t ISVCertHash_len, void* Licensee_ptr, size_t Licensee_len, size_t* Licensee_lenout, void* Issuer_ptr, size_t Issuer_len, size_t* Issuer_lenout, void* SerialNumber_ptr, size_t SerialNumber_len, size_t* SerialNumber_lenout, void* PublicKey_ptr, size_t PublicKey_len, size_t* PublicKey_lenout, uint64_t* CalleeID_ptr) {
        ObjectArg a[9];
        struct s1 {
            uint32_t m_OptFlags;
            uint32_t m_FeatureID;
        } i;
        a[0].b = (ObjectBuf) {&i, 8};
        a[1].bi = (ObjectBufIn) {LicenseCert_ptr, LicenseCert_len * 1};
        i.m_OptFlags = OptFlags_val;
        a[2].bi = (ObjectBufIn) {IntermediateCert_ptr, IntermediateCert_len * 1};
        i.m_FeatureID = FeatureID_val;
        a[3].bi = (ObjectBufIn) {ISVCertHash_ptr, ISVCertHash_len * 1};
        a[4].b = (ObjectBuf) {Licensee_ptr, Licensee_len * 1};
        a[5].b = (ObjectBuf) {Issuer_ptr, Issuer_len * 1};
        a[6].b = (ObjectBuf) {SerialNumber_ptr, SerialNumber_len * 1};
        a[7].b = (ObjectBuf) {PublicKey_ptr, PublicKey_len * 1};
        a[8].b = (ObjectBuf) {CalleeID_ptr, sizeof(uint64_t)};

        int32_t result = invoke(OP_processLicense_TEE, a, ObjectCounts_pack(4, 5, 0, 0));
        if (Object_OK != result) { return result; }

        *Licensee_lenout = a[4].b.size / 1;
        *Issuer_lenout = a[5].b.size / 1;
        *SerialNumber_lenout = a[6].b.size / 1;
        *PublicKey_lenout = a[7].b.size / 1;

        return result;
    }

};

