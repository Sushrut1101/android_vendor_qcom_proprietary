/*===========================================================================

  Copyright (c) 2018-2020 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.

===========================================================================*/
#include <cstring>
#include <string.h>
#include <framework/Log.h>
#include "modules/qmi/ModemEndPointFactory.h"
#include "modules/qmi/QmiSetupRequestCallback.h"

#include "legacy/qcril_event_facade.h"
#include "DataModule.h"
#include "CallInfo.h"
#include "CallManager.h"
#include "CallSetupProfile.h"
#include "qdp.h"

#include "request/SetupDataCallRequestMessage.h"
#include "request/DeactivateDataCallRequestMessage.h"
#include "UnSolMessages/HandoverInformationIndMessage.h"
#include "sync/GetCallBringUpCapabilitySyncMessage.h"
#include "event/CallBringupFallbackMessage.h"
#include "modules/nas/NasEmbmsEnableDataConMessage.h"
#include "modules/nas/NasEmbmsDisableDataMessage.h"
#include "legacy/qcril_data_utils.h"

extern "C" {
#include "qmi_platform.h"
}

using namespace rildata;

unordered_map<int, DataCallFailCause_t> CallEndReason::mipReasonMap = {
  {WDS_VCER_MIP_FA_REASON_UNSPECIFIED_V01, DataCallFailCause_t::MIP_FA_REASON_UNSPECIFIED},
  {WDS_VCER_MIP_FA_ADMIN_PROHIBITED_V01, DataCallFailCause_t::MIP_FA_ADMIN_PROHIBITED},
  {WDS_VCER_MIP_FA_INSUFFICIENT_RESOURCES_V01, DataCallFailCause_t::MIP_FA_INSUFFICIENT_RESOURCES},
  {WDS_VCER_MIP_FA_MOBILE_NODE_AUTH_FAILURE_V01, DataCallFailCause_t::MIP_FA_MOBILE_NODE_AUTHENTICATION_FAILURE},
  {WDS_VCER_MIP_FA_HA_AUTH_FAILURE_V01, DataCallFailCause_t::MIP_FA_HOME_AGENT_AUTHENTICATION_FAILURE},
  {WDS_VCER_MIP_FA_REQ_LIFETIME_TOO_LONG_V01, DataCallFailCause_t::MIP_FA_REQUESTED_LIFETIME_TOO_LONG},
  {WDS_VCER_MIP_FA_MALFORMED_REQUEST_V01, DataCallFailCause_t::MIP_FA_MALFORMED_REQUEST},
  {WDS_VCER_MIP_FA_MALFOMED_REPLY_V01, DataCallFailCause_t::MIP_FA_MALFORMED_REPLY},
  {WDS_VCER_MIP_FA_ENCAPSULATION_UNAVAILABLE_V01, DataCallFailCause_t::MIP_FA_ENCAPSULATION_UNAVAILABLE},
  {WDS_VCER_MIP_FA_VJHC_UNAVAILABLE_V01, DataCallFailCause_t::MIP_FA_VJ_HEADER_COMPRESSION_UNAVAILABLE},
  {WDS_VCER_MIP_FA_REV_TUNNEL_UNAVAILABLE_V01, DataCallFailCause_t::MIP_FA_REVERSE_TUNNEL_UNAVAILABLE},
  {WDS_VCER_MIP_FA_REV_TUNNEL_IS_MAND_AND_T_BIT_NOT_SET_V01, DataCallFailCause_t::MIP_FA_REVERSE_TUNNEL_IS_MANDATORY},
  {WDS_VCER_MIP_FA_DELIVERY_STYLE_NOT_SUPP_V01, DataCallFailCause_t::MIP_FA_DELIVERY_STYLE_NOT_SUPPORTED},
  {WDS_VCER_MIP_FA_MISSING_NAI_V01, DataCallFailCause_t::MIP_FA_MISSING_NAI},
  {WDS_VCER_MIP_FA_MISSING_HA_V01, DataCallFailCause_t::MIP_FA_MISSING_HOME_AGENT},
  {WDS_VCER_MIP_FA_MISSING_HOME_ADDR_V01, DataCallFailCause_t::MIP_FA_MISSING_HOME_ADDRESS},
  {WDS_VCER_MIP_FA_UNKNOWN_CHALLENGE_V01, DataCallFailCause_t::MIP_FA_UNKNOWN_CHALLENGE},
  {WDS_VCER_MIP_FA_MISSING_CHALLENGE_V01, DataCallFailCause_t::MIP_FA_MISSING_CHALLENGE},
  {WDS_VCER_MIP_FA_STALE_CHALLENGE_V01, DataCallFailCause_t::MIP_FA_STALE_CHALLENGE},
  {WDS_VCER_MIP_HA_REASON_UNSPECIFIED_V01, DataCallFailCause_t::MIP_HA_REASON_UNSPECIFIED},
  {WDS_VCER_MIP_HA_ADMIN_PROHIBITED_V01, DataCallFailCause_t::MIP_HA_ADMIN_PROHIBITED},
  {WDS_VCER_MIP_HA_INSUFFICIENT_RESOURCES_V01, DataCallFailCause_t::MIP_HA_INSUFFICIENT_RESOURCES},
  {WDS_VCER_MIP_HA_MOBILE_NODE_AUTH_FAILURE_V01, DataCallFailCause_t::MIP_HA_MOBILE_NODE_AUTHENTICATION_FAILURE},
  {WDS_VCER_MIP_HA_FA_AUTH_FAILURE_V01, DataCallFailCause_t::MIP_HA_FOREIGN_AGENT_AUTHENTICATION_FAILURE},
  {WDS_VCER_MIP_HA_REGISTRATION_ID_MISMATCH_V01, DataCallFailCause_t::MIP_HA_REGISTRATION_ID_MISMATCH},
  {WDS_VCER_MIP_HA_MALFORMED_REQUEST_V01, DataCallFailCause_t::MIP_HA_MALFORMED_REQUEST},
  {WDS_VCER_MIP_HA_UNKNOWN_HA_ADDR_V01, DataCallFailCause_t::MIP_HA_UNKNOWN_HOME_AGENT_ADDRESS},
  {WDS_VCER_MIP_HA_REV_TUNNEL_UNAVAILABLE_V01, DataCallFailCause_t::MIP_HA_REVERSE_TUNNEL_UNAVAILABLE},
  {WDS_VCER_MIP_HA_REV_TUNNEL_IS_MAND_AND_T_BIT_NOT_SET_V01, DataCallFailCause_t::MIP_HA_REVERSE_TUNNEL_IS_MANDATORY},
  {WDS_VCER_MIP_HA_ENCAPSULATION_UNAVAILABLE_V01, DataCallFailCause_t::MIP_HA_ENCAPSULATION_UNAVAILABLE},
  {WDS_VCER_MIP_HA_REASON_UNKNOWN_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::internalReasonMap = {
  {WDS_VCER_INTERNAL_CLOSE_IN_PROGRESS_V01, DataCallFailCause_t::CLOSE_IN_PROGRESS},
  {WDS_VCER_INTERNAL_NW_INITIATED_TERMINATION_V01, DataCallFailCause_t::NETWORK_INITIATED_TERMINATION},
  {WDS_VCER_INTERNAL_APP_PREEMPTED_V01, DataCallFailCause_t::MODEM_APP_PREEMPTED},
  {WDS_VCER_INTERNAL_ERR_PDN_IPV4_CALL_DISALLOWED_V01, DataCallFailCause_t::PDN_IPV4_CALL_DISALLOWED},
  {WDS_VCER_INTERNAL_ERR_PDN_IPV4_CALL_THROTTLED_V01, DataCallFailCause_t::PDN_IPV4_CALL_THROTTLED},
  {WDS_VCER_INTERNAL_ERR_PDN_IPV6_CALL_DISALLOWED_V01, DataCallFailCause_t::PDN_IPV6_CALL_DISALLOWED},
  {WDS_VCER_INTERNAL_ERR_PDN_IPV6_CALL_THROTTLED_V01, DataCallFailCause_t::PDN_IPV6_CALL_THROTTLED},
  {WDS_VCER_INTERNAL_MODEM_RESTART_V01, DataCallFailCause_t::MODEM_RESTART},
  {WDS_VCER_INTERNAL_PDP_PPP_NOT_SUPPORTED_V01, DataCallFailCause_t::PDP_PPP_NOT_SUPPORTED},
  {WDS_VCER_INTERNAL_UNPREFERRED_RAT_V01, DataCallFailCause_t::UNPREFERRED_RAT},
  {WDS_VCER_INTERNAL_PHYS_LINK_CLOSE_IN_PROGRESS_V01, DataCallFailCause_t::PHYSICAL_LINK_CLOSE_IN_PROGRESS},
  {WDS_VCER_INTERNAL_APN_PENDING_HANDOVER_V01, DataCallFailCause_t::APN_PENDING_HANDOVER},
  {WDS_VCER_INTERNAL_PROFILE_BEARER_INCOMPATIBLE_V01, DataCallFailCause_t::PROFILE_BEARER_INCOMPATIBLE},
  {WDS_VCER_INTERNAL_MMGSDI_CARD_EVT_V01, DataCallFailCause_t::SIM_CARD_CHANGED},
  {WDS_VCER_INTERNAL_LPM_OR_PWR_DOWN_V01, DataCallFailCause_t::LOW_POWER_MODE_OR_POWERING_DOWN},
  {WDS_VCER_INTERNAL_APN_DISABLED_V01, DataCallFailCause_t::APN_DISABLED},
  {WDS_VCER_INTERNAL_MPIT_EXPIRED_V01, DataCallFailCause_t::MAX_PPP_INACTIVITY_TIMER_EXPIRED},
  {WDS_VCER_INTERNAL_IPV6_ADDR_TRANSFER_FAILED_V01, DataCallFailCause_t::IPV6_ADDRESS_TRANSFER_FAILED},
  {WDS_VCER_INTERNAL_TRAT_SWAP_FAILED_V01, DataCallFailCause_t::TRAT_SWAP_FAILED},
  {WDS_VCER_INTERNAL_INTERNAL_EHRPD_TO_HRPD_FALLBACK_V01, DataCallFailCause_t::EHRPD_TO_HRPD_FALLBACK},
  {WDS_VCER_INTERNAL_MIP_CONFIG_FAILURE_V01, DataCallFailCause_t::MIP_CONFIG_FAILURE},
  {WDS_VCER_INTERNAL_INTERNAL_PDN_INACTIVITY_TIMER_EXPIRED_V01, DataCallFailCause_t::PDN_INACTIVITY_TIMER_EXPIRED},
  {WDS_VCER_INTERNAL_MAX_V4_CONNECTIONS_V01, DataCallFailCause_t::MAX_IPV4_CONNECTIONS},
  {WDS_VCER_INTERNAL_MAX_V6_CONNECTIONS_V01, DataCallFailCause_t::MAX_IPV6_CONNECTIONS},
  {WDS_VCER_INTERNAL_APN_MISMATCH_V01, DataCallFailCause_t::APN_MISMATCH},
  {WDS_VCER_INTERNAL_IP_VERSION_MISMATCH_V01, DataCallFailCause_t::IP_VERSION_MISMATCH},
  {WDS_VCER_INTERNAL_DUN_CALL_DISALLOWED_V01, DataCallFailCause_t::DUN_CALL_DISALLOWED},
  {WDS_VCER_INTERNAL_INTERNAL_EPC_NONEPC_TRANSITION_V01, DataCallFailCause_t::INTERNAL_EPC_NONEPC_TRANSITION},
  {WDS_VCER_INTERNAL_IFACE_IN_USE_V01, DataCallFailCause_t::INTERFACE_IN_USE},
  {WDS_VCER_INTERNAL_APN_DISALLOWED_ON_ROAMING_V01, DataCallFailCause_t::APN_DISALLOWED_ON_ROAMING},
  {WDS_VCER_INTERNAL_APN_PRM_CHG_V01, DataCallFailCause_t::APN_PARAMETERS_CHANGED},
  {WDS_VCER_INTERNAL_NULL_APN_DISALLOWED_V01, DataCallFailCause_t::NULL_APN_DISALLOWED},
  {WDS_VCER_INTERNAL_THERMAL_MITIGATION_V01, DataCallFailCause_t::THERMAL_MITIGATION},
  {WDS_VCER_INTERNAL_DATA_SETTINGS_DISABLED_V01, DataCallFailCause_t::DATA_SETTINGS_DISABLED},
  {WDS_VCER_INTERNAL_DATA_ROAMING_SETTINGS_DISABLED_V01, DataCallFailCause_t::DATA_ROAMING_SETTINGS_DISABLED},
  {WDS_VCER_INTERNAL_DDS_CALL_ABORT_V01, DataCallFailCause_t::DDS_SWITCHED},
  {WDS_VCER_INTERNAL_APN_FORMAT_INVALID_V01, DataCallFailCause_t::FORBIDDEN_APN_NAME},
  {WDS_VCER_INTERNAL_DDS_SWITCH_IN_PROGRESS_V01, DataCallFailCause_t::DDS_SWITCH_IN_PROGRESS},
  {WDS_VCER_INTERNAL_CALL_DISALLOWED_IN_ROAMING_V01, DataCallFailCause_t::CALL_DISALLOWED_IN_ROAMING},
  {WDS_VCER_INTERNAL_NON_IP_NOT_SUPPORTED_V01, DataCallFailCause_t::NON_IP_NOT_SUPPORTED},
  {WDS_VCER_INTERNAL_ERR_PDN_NON_IP_CALL_THROTTLED_V01, DataCallFailCause_t::PDN_NON_IP_CALL_THROTTLED},
  {WDS_VCER_INTERNAL_ERR_PDN_NON_IP_CALL_DISALLOWED_V01, DataCallFailCause_t::PDN_NON_IP_CALL_DISALLOWED},
  {WDS_VCER_INTERNAL_INTERNAL_ERROR_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_CALL_ENDED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_INTERNAL_UNKNOWN_CAUSE_CODE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_UNKNOWN_CAUSE_CODE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_MANDATORY_APN_DISABLED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_INVALID_PROFILE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_INVALID_PROFILE_ID_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_INTERNAL_CALL_ALREADY_PRESENT_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_IP_PDP_MISMATCH_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_IFACE_IN_USE_CFG_MATCH_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_SUBS_ID_MISMATCH_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_VALIDATION_FAILURE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_PROFILES_NOT_COMPATIBLE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_NULL_RESOLVED_APN_NO_MATCH_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_INVALID_APN_NAME_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_INTERNAL_MO_EXCEPTIONAL_NOT_SUPPORTED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::cmReasonMap = {
  {WDS_VCER_CM_CDMA_LOCK_V01, DataCallFailCause_t::CDMA_LOCK},
  {WDS_VCER_CM_INTERCEPT_V01, DataCallFailCause_t::CDMA_INTERCEPT},
  {WDS_VCER_CM_REORDER_V01, DataCallFailCause_t::CDMA_REORDER},
  {WDS_VCER_CM_REL_SO_REJ_V01, DataCallFailCause_t::CDMA_RELEASE_DUE_TO_SO_REJECTION},
  {WDS_VCER_CM_INCOM_CALL_V01, DataCallFailCause_t::CDMA_INCOMING_CALL},
  {WDS_VCER_CM_ALERT_STOP_V01, DataCallFailCause_t::CDMA_ALERT_STOP},
  {WDS_VCER_CM_ACTIVATION_V01, DataCallFailCause_t::CHANNEL_ACQUISITION_FAILURE},
  {WDS_VCER_CM_MAX_ACCESS_PROBE_V01, DataCallFailCause_t::MAX_ACCESS_PROBE},
  {WDS_VCER_CM_CCS_NOT_SUPP_BY_BS_V01, DataCallFailCause_t::CONCURRENT_SERVICE_NOT_SUPPORTED_BY_BASE_STATION},
  {WDS_VCER_CM_NO_RESPONSE_FROM_BS_V01, DataCallFailCause_t::NO_RESPONSE_FROM_BASE_STATION},
  {WDS_VCER_CM_REJECTED_BY_BS_V01, DataCallFailCause_t::REJECTED_BY_BASE_STATION},
  {WDS_VCER_CM_INCOMPATIBLE_V01, DataCallFailCause_t::CONCURRENT_SERVICES_INCOMPATIBLE},
  {WDS_VCER_CM_NO_CDMA_SRV_V01, DataCallFailCause_t::NO_CDMA_SERVICE},
  {WDS_VCER_CM_UIM_NOT_PRESENT_V01, DataCallFailCause_t::RUIM_NOT_PRESENT},
  {WDS_VCER_CM_RETRY_ORDER_V01, DataCallFailCause_t::CDMA_RETRY_ORDER},
  {WDS_VCER_CM_ACCESS_BLOCK_V01, DataCallFailCause_t::ACCESS_BLOCK},
  {WDS_VCER_CM_ACCESS_BLOCK_ALL_V01, DataCallFailCause_t::ACCESS_BLOCK_ALL},
  {WDS_VCER_CM_IS707B_MAX_ACC_V01, DataCallFailCause_t::IS707B_MAX_ACCESS_PROBES},
  {WDS_VCER_CM_THERMAL_EMERGENCY_V01, DataCallFailCause_t::THERMAL_EMERGENCY},
  {WDS_VCER_CM_USER_CALL_ORIG_DURING_VOICE_CALL_V01, DataCallFailCause_t::CONCURRENT_SERVICES_NOT_ALLOWED},
  {WDS_VCER_CM_INCOM_REJ_V01, DataCallFailCause_t::INCOMING_CALL_REJECTED},
  {WDS_VCER_CM_NEW_NO_GW_SERV_V01, DataCallFailCause_t::NO_SERVICE_ON_GATEWAY},
  {WDS_VCER_CM_NEW_NO_GPRS_CONTEXT_V01, DataCallFailCause_t::NO_GPRS_CONTEXT},
  {WDS_VCER_CM_NEW_ILLEGAL_MS_V01, DataCallFailCause_t::ILLEGAL_MS},
  {WDS_VCER_CM_NEW_ILLEGAL_ME_V01, DataCallFailCause_t::ILLEGAL_ME},
  {WDS_VCER_CM_NEW_GPRS_SERV_AND_NON_GPRS_SERV_NOT_ALLOWED_V01, DataCallFailCause_t::GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED},
  {WDS_VCER_CM_NEW_GPRS_SERV_NOT_ALLOWED_V01, DataCallFailCause_t::GPRS_SERVICES_NOT_ALLOWED},
  {WDS_VCER_CM_MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK_V01, DataCallFailCause_t::MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK},
  {WDS_VCER_CM_IMPLICITLY_DETACHED_V01, DataCallFailCause_t::IMPLICITLY_DETACHED},
  {WDS_VCER_CM_PLMN_NOT_ALLOWED_V01, DataCallFailCause_t::PLMN_NOT_ALLOWED},
  {WDS_VCER_CM_LA_NOT_ALLOWED_V01, DataCallFailCause_t::LOCATION_AREA_NOT_ALLOWED},
  {WDS_VCER_CM_GPRS_SERV_NOT_ALLOWED_IN_THIS_PLMN_V01, DataCallFailCause_t::GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN},
  {WDS_VCER_CM_PDP_DUPLICATE_V01, DataCallFailCause_t::PDP_DUPLICATE},
  {WDS_VCER_CM_UE_RAT_CHANGE_V01, DataCallFailCause_t::UE_RAT_CHANGE},
  {WDS_VCER_CM_CONGESTION_V01, DataCallFailCause_t::CONGESTION},
  {WDS_VCER_CM_NO_PDP_CONTEXT_ACTIVATED_V01, DataCallFailCause_t::NO_PDP_CONTEXT_ACTIVATED},
  {WDS_VCER_CM_ACCESS_CLASS_DSAC_REJECTION_V01, DataCallFailCause_t::ACCESS_CLASS_DSAC_REJECTION},
  {WDS_VCER_CM_PDP_ACTIVATE_MAX_RETRY_FAILED_V01, DataCallFailCause_t::PDP_ACTIVATE_MAX_RETRY_FAILED},
  {WDS_VCER_CM_RAB_FAILURE_V01, DataCallFailCause_t::RADIO_ACCESS_BEARER_FAILURE},
  {WDS_VCER_CM_ESM_UNKNOWN_EPS_BEARER_CONTEXT_V01, DataCallFailCause_t::ESM_UNKNOWN_EPS_BEARER_CONTEXT},
  {WDS_VCER_CM_DRB_RELEASED_AT_RRC_V01, DataCallFailCause_t::DRB_RELEASED_BY_RRC},
  {WDS_VCER_CM_NAS_SIG_CONN_RELEASED_V01, DataCallFailCause_t::CONNECTION_RELEASED},
  {WDS_VCER_CM_EMM_DETACHED_V01, DataCallFailCause_t::EMM_DETACHED},
  {WDS_VCER_CM_EMM_ATTACH_FAILED_V01, DataCallFailCause_t::EMM_ATTACH_FAILED},
  {WDS_VCER_CM_EMM_ATTACH_STARTED_V01, DataCallFailCause_t::EMM_ATTACH_STARTED},
  {WDS_VCER_CM_LTE_NAS_SERVICE_REQ_FAILED_V01, DataCallFailCause_t::LTE_NAS_SERVICE_REQUEST_FAILED},
  {WDS_VCER_CM_ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW_V01, DataCallFailCause_t::DUPLICATE_BEARER_ID},
  {WDS_VCER_CM_ESM_LOWER_LAYER_FAILURE_V01, DataCallFailCause_t::ESM_COLLISION_SCENARIOS},
  {WDS_VCER_CM_ESM_SYNC_UP_WITH_NW_V01, DataCallFailCause_t::ESM_BEARER_DEACTIVATED_TO_SYNC_WITH_NETWORK},
  {WDS_VCER_CM_ESM_NW_ACTIVATED_DED_BEARER_WITH_ID_OF_DEF_BEARER_V01, DataCallFailCause_t::ESM_NW_ACTIVATED_DED_BEARER_WITH_ID_OF_DEF_BEARER},
  {WDS_VCER_CM_ESM_BAD_OTA_MESSAGE_V01, DataCallFailCause_t::ESM_BAD_OTA_MESSAGE},
  {WDS_VCER_CM_ESM_DS_REJECTED_THE_CALL_V01, DataCallFailCause_t::ESM_DOWNLOAD_SERVER_REJECTED_THE_CALL},
  {WDS_VCER_CM_ESM_CONTEXT_TRANSFERED_DUE_TO_IRAT_V01, DataCallFailCause_t::ESM_CONTEXT_TRANSFERRED_DUE_TO_IRAT},
  {WDS_VCER_CM_DS_EXPLICIT_DEACT_V01, DataCallFailCause_t::DS_EXPLICIT_DEACTIVATION},
  {WDS_VCER_CM_ESM_LOCAL_CAUSE_NONE_V01, DataCallFailCause_t::ESM_LOCAL_CAUSE_NONE},
  {WDS_VCER_CM_LTE_NAS_SERVICE_REQ_FAILED_NO_THROTTLE_V01, DataCallFailCause_t::LTE_THROTTLING_NOT_REQUIRED},
  {WDS_VCER_CM_ACL_FAILURE_V01, DataCallFailCause_t::ACCESS_CONTROL_LIST_CHECK_FAILURE},
  {WDS_VCER_CM_LTE_NAS_SERVICE_REQ_FAILED_DS_DISALLOW_V01, DataCallFailCause_t::SERVICE_NOT_ALLOWED_ON_PLMN},
  {WDS_VCER_CM_EMM_T3417_EXPIRED_V01, DataCallFailCause_t::EMM_T3417_EXPIRED},
  {WDS_VCER_CM_EMM_T3417_EXT_EXPIRED_V01, DataCallFailCause_t::EMM_T3417_EXT_EXPIRED},
  {WDS_VCER_CM_LRRC_UL_DATA_CNF_FAILURE_TXN_V01, DataCallFailCause_t::RRC_UPLINK_DATA_TRANSMISSION_FAILURE},
  {WDS_VCER_CM_LRRC_UL_DATA_CNF_FAILURE_HO_V01, DataCallFailCause_t::RRC_UPLINK_DELIVERY_FAILED_DUE_TO_HANDOVER},
  {WDS_VCER_CM_LRRC_UL_DATA_CNF_FAILURE_CONN_REL_V01, DataCallFailCause_t::RRC_UPLINK_CONNECTION_RELEASE},
  {WDS_VCER_CM_LRRC_UL_DATA_CNF_FAILURE_RLF_V01, DataCallFailCause_t::RRC_UPLINK_RADIO_LINK_FAILURE},
  {WDS_VCER_CM_LRRC_UL_DATA_CNF_FAILURE_CTRL_NOT_CONN_V01, DataCallFailCause_t::RRC_UPLINK_ERROR_REQUEST_FROM_NAS},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_V01, DataCallFailCause_t::RRC_CONNECTION_ACCESS_STRATUM_FAILURE},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_ABORTED_V01, DataCallFailCause_t::RRC_CONNECTION_ANOTHER_PROCEDURE_IN_PROGRESS},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_ACCESS_BARRED_V01, DataCallFailCause_t::RRC_CONNECTION_ACCESS_BARRED},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_CELL_RESEL_V01, DataCallFailCause_t::RRC_CONNECTION_CELL_RESELECTION},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_CONFIG_FAILURE_V01, DataCallFailCause_t::RRC_CONNECTION_CONFIG_FAILURE},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_TIMER_EXPIRED_V01, DataCallFailCause_t::RRC_CONNECTION_TIMER_EXPIRED},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_LINK_FAILURE_V01, DataCallFailCause_t::RRC_CONNECTION_LINK_FAILURE},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_NOT_CAMPED_V01, DataCallFailCause_t::RRC_CONNECTION_CELL_NOT_CAMPED},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_SI_FAILURE_V01, DataCallFailCause_t::RRC_CONNECTION_SYSTEM_INTERVAL_FAILURE},
  {WDS_VCER_CM_LRRC_CONN_EST_FAILURE_CONN_REJECT_V01, DataCallFailCause_t::RRC_CONNECTION_REJECT_BY_NETWORK},
  {WDS_VCER_CM_LRRC_CONN_REL_NORMAL_V01, DataCallFailCause_t::RRC_CONNECTION_NORMAL_RELEASE},
  {WDS_VCER_CM_LRRC_CONN_REL_RLF_V01, DataCallFailCause_t::RRC_CONNECTION_RADIO_LINK_FAILURE},
  {WDS_VCER_CM_LRRC_CONN_REL_CRE_FAILURE_V01, DataCallFailCause_t::RRC_CONNECTION_REESTABLISHMENT_FAILURE},
  {WDS_VCER_CM_LRRC_CONN_REL_OOS_DURING_CRE_V01, DataCallFailCause_t::RRC_CONNECTION_OUT_OF_SERVICE_DURING_CELL_REGISTER},
  {WDS_VCER_CM_LRRC_CONN_REL_ABORTED_V01, DataCallFailCause_t::RRC_CONNECTION_ABORT_REQUEST},
  {WDS_VCER_CM_LRRC_CONN_REL_SIB_READ_ERROR_V01, DataCallFailCause_t::RRC_CONNECTION_SYSTEM_INFORMATION_BLOCK_READ_ERROR},
  {WDS_VCER_CM_DETACH_WITH_REATTACH_LTE_NW_DETACH_V01, DataCallFailCause_t::NETWORK_INITIATED_DETACH_WITH_AUTO_REATTACH},
  {WDS_VCER_CM_DETACH_WITH_OUT_REATTACH_LTE_NW_DETACH_V01, DataCallFailCause_t::NETWORK_INITIATED_DETACH_NO_AUTO_REATTACH},
  {WDS_VCER_CM_ESM_PROC_TIME_OUT_V01, DataCallFailCause_t::ESM_PROCEDURE_TIME_OUT},
  {WDS_VCER_CM_INVALID_CONNECTION_ID_V01, DataCallFailCause_t::INVALID_CONNECTION_ID},
  {WDS_VCER_CM_INVALID_NSAPI_V01, DataCallFailCause_t::MAXIMIUM_NSAPIS_EXCEEDED},
  {WDS_VCER_CM_INVALID_PRI_NSAPI_V01, DataCallFailCause_t::INVALID_PRIMARY_NSAPI},
  {WDS_VCER_CM_INVALID_FIELD_V01, DataCallFailCause_t::CANNOT_ENCODE_OTA_MESSAGE},
  {WDS_VCER_CM_RAB_SETUP_FAILURE_V01, DataCallFailCause_t::RADIO_ACCESS_BEARER_SETUP_FAILURE},
  {WDS_VCER_CM_PDP_ESTABLISH_MAX_TIMEOUT_V01, DataCallFailCause_t::PDP_ESTABLISH_TIMEOUT_EXPIRED},
  {WDS_VCER_CM_PDP_MODIFY_MAX_TIMEOUT_V01, DataCallFailCause_t::PDP_MODIFY_TIMEOUT_EXPIRED},
  {WDS_VCER_CM_PDP_INACTIVE_MAX_TIMEOUT_V01, DataCallFailCause_t::PDP_INACTIVE_TIMEOUT_EXPIRED},
  {WDS_VCER_CM_PDP_LOWERLAYER_ERROR_V01, DataCallFailCause_t::PDP_LOWERLAYER_ERROR},
  {WDS_VCER_CM_PDP_MODIFY_COLLISION_V01, DataCallFailCause_t::PDP_MODIFY_COLLISION},
  {WDS_VCER_CM_MESSAGE_EXCEED_MAX_L2_LIMIT_V01, DataCallFailCause_t::MAXINUM_SIZE_OF_L2_MESSAGE_EXCEEDED},
  {WDS_VCER_CM_SM_NAS_SRV_REQ_FAILURE_V01, DataCallFailCause_t::NAS_REQUEST_REJECTED_BY_NETWORK},
  {WDS_VCER_CM_RRC_CONN_EST_FAILURE_REQ_ERROR_V01, DataCallFailCause_t::RRC_CONNECTION_INVALID_REQUEST},
  {WDS_VCER_CM_RRC_CONN_EST_FAILURE_TAI_CHANGE_V01, DataCallFailCause_t::RRC_CONNECTION_TRACKING_AREA_ID_CHANGED},
  {WDS_VCER_CM_RRC_CONN_EST_FAILURE_RF_UNAVAILABLE_V01, DataCallFailCause_t::RRC_CONNECTION_RF_UNAVAILABLE},
  {WDS_VCER_CM_RRC_CONN_REL_ABORTED_IRAT_SUCCESS_V01, DataCallFailCause_t::RRC_CONNECTION_ABORTED_DUE_TO_IRAT_CHANGE},
  {WDS_VCER_CM_RRC_CONN_REL_RLF_SEC_NOT_ACTIVE_V01, DataCallFailCause_t::RRC_CONNECTION_RELEASED_SECURITY_NOT_ACTIVE},
  {WDS_VCER_CM_RRC_CONN_REL_IRAT_TO_LTE_ABORTED_V01, DataCallFailCause_t::RRC_CONNECTION_ABORTED_AFTER_HANDOVER},
  {WDS_VCER_CM_RRC_CONN_REL_IRAT_FROM_LTE_TO_G_CCO_SUCCESS_V01, DataCallFailCause_t::RRC_CONNECTION_ABORTED_AFTER_IRAT_CELL_CHANGE},
  {WDS_VCER_CM_RRC_CONN_REL_IRAT_FROM_LTE_TO_G_CCO_ABORTED_V01, DataCallFailCause_t::RRC_CONNECTION_ABORTED_DURING_IRAT_CELL_CHANGE},
  {WDS_VCER_CM_IMSI_UNKNOWN_IN_HSS_V01, DataCallFailCause_t::IMSI_UNKNOWN_IN_HOME_SUBSCRIBER_SERVER},
  {WDS_VCER_CM_IMEI_NOT_ACCEPTED_V01, DataCallFailCause_t::IMEI_NOT_ACCEPTED},
  {WDS_VCER_CM_EPS_SERVICES_AND_NON_EPS_SERVICES_NOT_ALLOWED_V01, DataCallFailCause_t::EPS_SERVICES_AND_NON_EPS_SERVICES_NOT_ALLOWED},
  {WDS_VCER_CM_EPS_SERVICES_NOT_ALLOWED_IN_PLMN_V01, DataCallFailCause_t::EPS_SERVICES_NOT_ALLOWED_IN_PLMN},
  {WDS_VCER_CM_MSC_TEMPORARILY_NOT_REACHABLE_V01, DataCallFailCause_t::MSC_TEMPORARILY_NOT_REACHABLE},
  {WDS_VCER_CM_CS_DOMAIN_NOT_AVAILABLE_V01, DataCallFailCause_t::CS_DOMAIN_NOT_AVAILABLE},
  {WDS_VCER_CM_ESM_FAILURE_V01, DataCallFailCause_t::ESM_FAILURE},
  {WDS_VCER_CM_MAC_FAILURE_V01, DataCallFailCause_t::MAC_FAILURE},
  {WDS_VCER_CM_SYNCH_FAILURE_V01, DataCallFailCause_t::SYNCHRONIZATION_FAILURE},
  {WDS_VCER_CM_UE_SECURITY_CAPABILITIES_MISMATCH_V01, DataCallFailCause_t::UE_SECURITY_CAPABILITIES_MISMATCH},
  {WDS_VCER_CM_SECURITY_MODE_REJ_UNSPECIFIED_V01, DataCallFailCause_t::SECURITY_MODE_REJECTED},
  {WDS_VCER_CM_NON_EPS_AUTH_UNACCEPTABLE_V01, DataCallFailCause_t::UNACCEPTABLE_NON_EPS_AUTHENTICATION},
  {WDS_VCER_CM_CS_FALLBACK_CALL_EST_NOT_ALLOWED_V01, DataCallFailCause_t::CS_FALLBACK_CALL_ESTABLISHMENT_NOT_ALLOWED},
  {WDS_VCER_CM_NO_EPS_BEARER_CONTEXT_ACTIVATED_V01, DataCallFailCause_t::NO_EPS_BEARER_CONTEXT_ACTIVATED},
  {WDS_VCER_CM_EMM_INVALID_STATE_V01, DataCallFailCause_t::INVALID_EMM_STATE},
  {WDS_VCER_CM_NAS_LAYER_FAILURE_V01, DataCallFailCause_t::NAS_LAYER_FAILURE},
  {WDS_VCER_CM_MULTI_PDN_NOT_ALLOWED_V01, DataCallFailCause_t::MULTIPLE_PDP_CALL_NOT_ALLOWED},
  {WDS_VCER_CM_EMBMS_NOT_ENABLED_V01, DataCallFailCause_t::EMBMS_NOT_ENABLED},
  {WDS_VCER_CM_PENDING_REDIAL_CALL_CLEANUP_V01, DataCallFailCause_t::IRAT_HANDOVER_FAILED},
  {WDS_VCER_CM_EMBMS_REGULAR_DEACTIVATION_V01, DataCallFailCause_t::EMBMS_REGULAR_DEACTIVATION},
  {WDS_VCER_CM_TLB_REGULAR_DEACTIVATION_V01, DataCallFailCause_t::TEST_LOOPBACK_REGULAR_DEACTIVATION},
  {WDS_VCER_CM_LOWER_LAYER_REGISTRATION_FAILURE_V01, DataCallFailCause_t::LOWER_LAYER_REGISTRATION_FAILURE},
  {WDS_VCER_CM_DETACH_EPS_SERVICES_NOT_ALLOWED_V01, DataCallFailCause_t::DATA_PLAN_EXPIRED},
  {WDS_VCER_CM_SM_INTERNAL_PDP_DEACTIVATION_V01, DataCallFailCause_t::UMTS_HANDOVER_TO_IWLAN},
  {WDS_VCER_CM_CD_GEN_OR_BUSY_V01, DataCallFailCause_t::EVDO_CONNECTION_DENY_BY_GENERAL_OR_NETWORK_BUSY},
  {WDS_VCER_CM_CD_BILL_OR_AUTH_V01, DataCallFailCause_t::EVDO_CONNECTION_DENY_BY_BILLING_OR_AUTHENTICATION_FAILURE},
  {WDS_VCER_CM_CHG_HDR_V01, DataCallFailCause_t::EVDO_HDR_CHANGED},
  {WDS_VCER_CM_EXIT_HDR_V01, DataCallFailCause_t::EVDO_HDR_EXITED},
  {WDS_VCER_CM_HDR_NO_SESSION_V01, DataCallFailCause_t::EVDO_HDR_NO_SESSION},
  {WDS_VCER_CM_HDR_ORIG_DURING_GPS_FIX_V01, DataCallFailCause_t::EVDO_USING_GPS_FIX_INSTEAD_OF_HDR_CALL},
  {WDS_VCER_CM_HDR_CS_TIMEOUT_V01, DataCallFailCause_t::EVDO_HDR_CONNECTION_SETUP_TIMEOUT},
  {WDS_VCER_CM_COLLOC_ACQ_FAIL_V01, DataCallFailCause_t::FAILED_TO_ACQUIRE_COLOCATED_HDR},
  {WDS_VCER_CM_OTASP_COMMIT_IN_PROG_V01, DataCallFailCause_t::OTASP_COMMIT_IN_PROGRESS},
  {WDS_VCER_CM_NO_HYBR_HDR_SRV_V01, DataCallFailCause_t::NO_HYBRID_HDR_SERVICE},
  {WDS_VCER_CM_HDR_NO_LOCK_GRANTED_V01, DataCallFailCause_t::HDR_NO_LOCK_GRANTED},
  {WDS_VCER_CM_HOLD_OTHER_IN_PROG_V01, DataCallFailCause_t::DBM_OR_SMS_IN_PROGRESS},
  {WDS_VCER_CM_HDR_FADE_V01, DataCallFailCause_t::HDR_FADE},
  {WDS_VCER_CM_HDR_ACC_FAIL_V01, DataCallFailCause_t::HDR_ACCESS_FAILURE},
  {WDS_VCER_CM_UNSUPPORTED_1X_PREV_V01, DataCallFailCause_t::UNSUPPORTED_1X_PREV},
  {WDS_VCER_CM_CLIENT_END_V01, DataCallFailCause_t::LOCAL_END},
  {WDS_VCER_CM_NO_SRV_V01, DataCallFailCause_t::NO_SERVICE},
  {WDS_VCER_CM_FADE_V01, DataCallFailCause_t::FADE},
  {WDS_VCER_CM_REL_NORMAL_V01, DataCallFailCause_t::NORMAL_RELEASE},
  {WDS_VCER_CM_ACC_IN_PROG_V01, DataCallFailCause_t::ACCESS_ATTEMPT_ALREADY_IN_PROGRESS},
  {WDS_VCER_CM_REDIR_OR_HANDOFF_V01, DataCallFailCause_t::REDIRECTION_OR_HANDOFF_IN_PROGRESS},
  {WDS_VCER_CM_EMERGENCY_MODE_V01, DataCallFailCause_t::EMERGENCY_MODE},
  {WDS_VCER_CM_PHONE_IN_USE_V01, DataCallFailCause_t::PHONE_IN_USE},
  {WDS_VCER_CM_INVALID_MODE_V01, DataCallFailCause_t::INVALID_MODE},
  {WDS_VCER_CM_INVALID_SIM_STATE_V01, DataCallFailCause_t::INVALID_SIM_STATE},
  {WDS_VCER_CM_NO_COLLOC_HDR_V01, DataCallFailCause_t::NO_COLLOCATED_HDR},
  {WDS_VCER_CM_EMM_DETACHED_PSM_V01, DataCallFailCause_t::UE_IS_ENTERING_POWERSAVE_MODE},
  {WDS_VCER_CM_DUAL_SWITCH_V01, DataCallFailCause_t::DUAL_SWITCH},
  {WDS_VCER_CM_SM_NO_RADIO_AVAILABLE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_SM_ABORT_SERVICE_NOT_AVAILABLE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_ACC_FAIL_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_ALREADY_IN_TC_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_USER_CALL_ORIG_DURING_GPS_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_USER_CALL_ORIG_DURING_SMS_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_MC_ABORT_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_PSIST_NG_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_CALL_ORIG_THROTTLED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_CONF_FAILED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NO_GW_SERV_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NO_GPRS_CONTEXT_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_ILLEGAL_MS_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_ILLEGAL_ME_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_GPRS_SERV_AND_NON_GPRS_SERV_NOT_ALLOWED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_GPRS_SERV_NOT_ALLOWED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_IMPLICITLY_DETACHED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_PLMN_NOT_ALLOWED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_LA_NOT_ALLOWED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_GPRS_SERV_NOT_ALLOWED_IN_THIS_PLMN_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_PDP_DUPLICATE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_UE_RAT_CHANGE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_CONGESTION_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_NO_PDP_CONTEXT_ACTIVATED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NEW_ACCESS_CLASS_DSAC_REJECTION_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_EPS_SERVICES_NOT_ALLOWED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_TRACKING_AREA_NOT_ALLOWED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_ROAMING_NOT_ALLOWED_IN_THIS_TRACKING_AREA_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NO_SUITABLE_CELLS_IN_TRACKING_AREA_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_NOT_AUTHORIZED_FOR_THIS_CSG_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_PPD_UNKNOWN_REASON_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_PDP_MBMS_REQUEST_COLLISION_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_MBMS_DUPLICATE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_SM_PS_DETACHED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_HDR_RELEASED_BY_CM_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_OFFLINE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_CALL_CONTROL_REJECTED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_CALL_MANAGER_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_INVALID_CLASS3_APN_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_CM_MPLMN_IN_PROGRESS_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::_3gppReasonMap = {
  {WDS_VCER_3GPP_OPERATOR_DETERMINED_BARRING_V01, DataCallFailCause_t::OPERATOR_BARRED},
  {WDS_VCER_3GPP_NAS_SIGNALLING_ERROR_V01, DataCallFailCause_t::NAS_SIGNALLING},
  {WDS_VCER_3GPP_LLC_SNDCP_FAILURE_V01, DataCallFailCause_t::LLC_SNDCP},
  {WDS_VCER_3GPP_INSUFFICIENT_RESOURCES_V01, DataCallFailCause_t::INSUFFICIENT_RESOURCES},
  {WDS_VCER_3GPP_UNKNOWN_APN_V01, DataCallFailCause_t::MISSING_UKNOWN_APN},
  {WDS_VCER_3GPP_UNKNOWN_PDP_V01, DataCallFailCause_t::UNKNOWN_PDP_ADDRESS_TYPE},
  {WDS_VCER_3GPP_AUTH_FAILED_V01, DataCallFailCause_t::USER_AUTHENTICATION},
  {WDS_VCER_3GPP_GGSN_REJECT_V01, DataCallFailCause_t::ACTIVATION_REJECT_GGSN},
  {WDS_VCER_3GPP_ACTIVATION_REJECT_V01, DataCallFailCause_t::ACTIVATION_REJECT_UNSPECIFIED},
  {WDS_VCER_3GPP_OPTION_NOT_SUPPORTED_V01, DataCallFailCause_t::SERVICE_OPTION_NOT_SUPPORTED},
  {WDS_VCER_3GPP_OPTION_UNSUBSCRIBED_V01, DataCallFailCause_t::SERVICE_OPTION_NOT_SUBSCRIBED},
  {WDS_VCER_3GPP_OPTION_TEMP_OOO_V01, DataCallFailCause_t::SERVICE_OPTION_OUT_OF_ORDER},
  {WDS_VCER_3GPP_NSAPI_ALREADY_USED_V01, DataCallFailCause_t::NSAPI_IN_USE},
  {WDS_VCER_3GPP_REGULAR_DEACTIVATION_V01, DataCallFailCause_t::REGULAR_DEACTIVATION},
  {WDS_VCER_3GPP_QOS_NOT_ACCEPTED_V01, DataCallFailCause_t::QOS_NOT_ACCEPTED},
  {WDS_VCER_3GPP_NETWORK_FAILURE_V01, DataCallFailCause_t::NETWORK_FAILURE},
  {WDS_VCER_3GPP_UMTS_REACTIVATION_REQ_V01, DataCallFailCause_t::UMTS_REACTIVATION_REQ},
  {WDS_VCER_3GPP_FEATURE_NOT_SUPP_V01, DataCallFailCause_t::FEATURE_NOT_SUPP},
  {WDS_VCER_3GPP_TFT_SEMANTIC_ERROR_V01, DataCallFailCause_t::TFT_SEMANTIC_ERROR},
  {WDS_VCER_3GPP_TFT_SYTAX_ERROR_V01, DataCallFailCause_t::TFT_SYTAX_ERROR},
  {WDS_VCER_3GPP_UNKNOWN_PDP_CONTEXT_V01, DataCallFailCause_t::UNKNOWN_PDP_CONTEXT},
  {WDS_VCER_3GPP_FILTER_SEMANTIC_ERROR_V01, DataCallFailCause_t::FILTER_SEMANTIC_ERROR},
  {WDS_VCER_3GPP_FILTER_SYTAX_ERROR_V01, DataCallFailCause_t::FILTER_SYTAX_ERROR},
  {WDS_VCER_3GPP_PDP_WITHOUT_ACTIVE_TFT_V01, DataCallFailCause_t::PDP_WITHOUT_ACTIVE_TFT},
  {WDS_VCER_3GPP_ACTIVATION_REJECTED_BCM_VIOLATION_V01, DataCallFailCause_t::ACTIVATION_REJECTED_BCM_VIOLATION},
  {WDS_VCER_3GPP_IP_V4_ONLY_ALLOWED_V01, DataCallFailCause_t::ONLY_IPV4_ALLOWED},
  {WDS_VCER_3GPP_IP_V6_ONLY_ALLOWED_V01, DataCallFailCause_t::ONLY_IPV6_ALLOWED},
  {WDS_VCER_3GPP_SINGLE_ADDR_BEARER_ONLY_V01, DataCallFailCause_t::ONLY_SINGLE_BEARER_ALLOWED},
  {WDS_VCER_3GPP_ESM_INFO_NOT_RECEIVED_V01, DataCallFailCause_t::ESM_INFO_NOT_RECEIVED},
  {WDS_VCER_3GPP_PDN_CONN_DOES_NOT_EXIST_V01, DataCallFailCause_t::PDN_CONN_DOES_NOT_EXIST},
  {WDS_VCER_3GPP_MULTI_CONN_TO_SAME_PDN_NOT_ALLOWED_V01, DataCallFailCause_t::MULTI_CONN_TO_SAME_PDN_NOT_ALLOWED},
  {WDS_VCER_3GPP_COLLISION_WITH_NW_INIT_REQ_V01, DataCallFailCause_t::COLLISION_WITH_NETWORK_INITIATED_REQUEST},
  {WDS_VCER_3GPP_IP_V4V6_ONLY_ALLOWED_V01, DataCallFailCause_t::ONLY_IPV4V6_ALLOWED},
  {WDS_VCER_3GPP_NON_IP_ONLY_ALLOWED_V01, DataCallFailCause_t::ONLY_NON_IP_ALLOWED},
  {WDS_VCER_3GPP_UNSUPPORTED_QCI_VALUE_V01, DataCallFailCause_t::UNSUPPORTED_QCI_VALUE},
  {WDS_VCER_3GPP_BEARER_HANDLING_NOT_SUPPORTED_V01, DataCallFailCause_t::BEARER_HANDLING_NOT_SUPPORTED},
  {WDS_VCER_3GPP_MAX_ACTIVE_PDP_CONTEXT_REACHED_V01, DataCallFailCause_t::MAX_ACTIVE_PDP_CONTEXT_REACHED},
  {WDS_VCER_3GPP_UNSUPPORTED_APN_IN_CURRENT_PLMN_V01, DataCallFailCause_t::UNSUPPORTED_APN_IN_CURRENT_PLMN},
  {WDS_VCER_3GPP_INVALID_TRANSACTION_ID_V01, DataCallFailCause_t::INVALID_TRANSACTION_ID},
  {WDS_VCER_3GPP_MESSAGE_INCORRECT_SEMANTIC_V01, DataCallFailCause_t::MESSAGE_INCORRECT_SEMANTIC},
  {WDS_VCER_3GPP_INVALID_MANDATORY_INFO_V01, DataCallFailCause_t::INVALID_MANDATORY_INFO},
  {WDS_VCER_3GPP_MESSAGE_TYPE_UNSUPPORTED_V01, DataCallFailCause_t::MESSAGE_TYPE_UNSUPPORTED},
  {WDS_VCER_3GPP_MSG_TYPE_NONCOMPATIBLE_STATE_V01, DataCallFailCause_t::MSG_TYPE_NONCOMPATIBLE_STATE},
  {WDS_VCER_3GPP_UNKNOWN_INFO_ELEMENT_V01, DataCallFailCause_t::UNKNOWN_INFO_ELEMENT},
  {WDS_VCER_3GPP_CONDITIONAL_IE_ERROR_V01, DataCallFailCause_t::CONDITIONAL_IE_ERROR},
  {WDS_VCER_3GPP_MSG_AND_PROTOCOL_STATE_UNCOMPATIBLE_V01, DataCallFailCause_t::MSG_AND_PROTOCOL_STATE_UNCOMPATIBLE},
  {WDS_VCER_3GPP_PROTOCOL_ERROR_V01, DataCallFailCause_t::PROTOCOL_ERRORS},
  {WDS_VCER_3GPP_APN_TYPE_CONFLICT_V01, DataCallFailCause_t::APN_TYPE_CONFLICT},
  {WDS_VCER_3GPP_INVALID_PCSCF_ADDR_V01, DataCallFailCause_t::INVALID_PCSCF_ADDR},
  {WDS_VCER_3GPP_INTERNAL_CALL_PREEMPT_BY_HIGH_PRIO_APN_V01, DataCallFailCause_t::INTERNAL_CALL_PREEMPT_BY_HIGH_PRIO_APN},
  {WDS_VCER_3GPP_EMM_ACCESS_BARRED_V01, DataCallFailCause_t::EMM_ACCESS_BARRED},
  {WDS_VCER_3GPP_EMERGENCY_IFACE_ONLY_V01, DataCallFailCause_t::EMERGENCY_IFACE_ONLY},
  {WDS_VCER_3GPP_IFACE_MISMATCH_V01, DataCallFailCause_t::IFACE_MISMATCH},
  {WDS_VCER_3GPP_COMPANION_IFACE_IN_USE_V01, DataCallFailCause_t::COMPANION_IFACE_IN_USE},
  {WDS_VCER_3GPP_IP_ADDRESS_MISMATCH_V01, DataCallFailCause_t::IP_ADDRESS_MISMATCH},
  {WDS_VCER_3GPP_IFACE_AND_POL_FAMILY_MISMATCH_V01, DataCallFailCause_t::IFACE_AND_POL_FAMILY_MISMATCH},
  {WDS_VCER_3GPP_EMM_ACCESS_BARRED_INFINITE_RETRY_V01, DataCallFailCause_t::EMM_ACCESS_BARRED_INFINITE_RETRY},
  {WDS_VCER_3GPP_AUTH_FAILURE_ON_EMERGENCY_CALL_V01, DataCallFailCause_t::AUTH_FAILURE_ON_EMERGENCY_CALL},
  {WDS_VCER_3GPP_INVALID_DNS_ADDR_V01, DataCallFailCause_t::INVALID_DNS_ADDR},
  {WDS_VCER_3GPP_PTI_MISMATCH_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_3GPP_TEST_LOOPBACK_MODE_A_OR_B_ENABLED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_3GPP_EMM_ACCESS_BARRED_EAB_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_3GPP_INVALID_PCSCF_DNS_ADDR_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_3GPP_CALL_PREEMPT_BY_EMERGENCY_APN_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_3GPP_UE_INIT_DETACH_OR_DISCONNECT_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::pppReasonMap = {
  {WDS_VCER_PPP_TIMEOUT_V01, DataCallFailCause_t::PPP_TIMEOUT},
  {WDS_VCER_PPP_AUTH_FAILURE_V01, DataCallFailCause_t::PPP_AUTH_FAILURE},
  {WDS_VCER_PPP_OPTION_MISMATCH_V01, DataCallFailCause_t::PPP_OPTION_MISMATCH},
  {WDS_VCER_PPP_PAP_FAILURE_V01, DataCallFailCause_t::PPP_PAP_FAILURE},
  {WDS_VCER_PPP_CHAP_FAILURE_V01, DataCallFailCause_t::PPP_CHAP_FAILURE},
  {WDS_VCER_PPP_ERR_CLOSE_IN_PROGRESS_V01, DataCallFailCause_t::PPP_CLOSE_IN_PROGRESS},
  {WDS_VCER_PPPNV_REFRESH_IN_PROGRESS_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_PPP_UNKNOWN_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::ehrpdReasonMap = {
  {WDS_VCER_EHRPD_SUBS_LIMITED_TO_V4_V01, DataCallFailCause_t::LIMITED_TO_IPV4},
  {WDS_VCER_EHRPD_SUBS_LIMITED_TO_V6_V01, DataCallFailCause_t::LIMITED_TO_IPV6},
  {WDS_VCER_EHRPD_VSNCP_TIMEOUT_V01, DataCallFailCause_t::VSNCP_TIMEOUT},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_GEN_ERROR_V01, DataCallFailCause_t::VSNCP_GEN_ERROR},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_UNAUTH_APN_V01, DataCallFailCause_t::VSNCP_APN_UNATHORIZED},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_PDN_LIMIT_EXCEED_V01, DataCallFailCause_t::VSNCP_PDN_LIMIT_EXCEEDED},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_NO_PDN_GW_V01, DataCallFailCause_t::VSNCP_NO_PDN_GATEWAY_ADDRESS},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_PDN_GW_UNREACH_V01, DataCallFailCause_t::VSNCP_PDN_GATEWAY_UNREACHABLE},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_PDN_GW_REJ_V01, DataCallFailCause_t::VSNCP_PDN_GATEWAY_REJECT},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_INSUFF_PARAM_V01, DataCallFailCause_t::VSNCP_INSUFFICIENT_PARAMETERS},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_RESOURCE_UNAVAIL_V01, DataCallFailCause_t::VSNCP_RESOURCE_UNAVAILABLE},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_ADMIN_PROHIBIT_V01, DataCallFailCause_t::VSNCP_ADMINISTRATIVELY_PROHIBITED},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_PDN_ID_IN_USE_V01, DataCallFailCause_t::VSNCP_PDN_ID_IN_USE},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_SUBSCR_LIMITATION_V01, DataCallFailCause_t::VSNCP_SUBSCRIBER_LIMITATION},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_PDN_EXISTS_FOR_THIS_APN_V01, DataCallFailCause_t::VSNCP_PDN_EXISTS_FOR_THIS_APN},
  {WDS_VCER_EHRPD_VSNCP_3GPP2I_RECONNECT_NOT_ALLOWED_V01, DataCallFailCause_t::VSNCP_RECONNECT_NOT_ALLOWED},
  {WDS_VCER_EHRPD_VSNCP_FAILURE_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::ipv6ReasonMap = {
  {WDS_VCER_IPV6_PREFIX_UNAVAILABLE_V01, DataCallFailCause_t::IPV6_PREFIX_UNAVAILABLE},
  {WDS_VCER_IPV6_ERR_HRPD_IPV6_DISABLED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
  {WDS_VCER_IPV6_DISABLED_V01, DataCallFailCause_t::ERROR_UNSPECIFIED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::handoffReasonMap = {
  {WDS_VCER_HANDOFF_PREF_SYS_BACK_TO_SRAT_V01, DataCallFailCause_t::HANDOFF_PREFERENCE_CHANGED},
};

unordered_map<int, DataCallFailCause_t> CallEndReason::apAssistHandoffReasonMap = {
  {static_cast<int>(ApAssistHandoverFailCause_t::NONE), DataCallFailCause_t::NONE},
  {static_cast<int>(ApAssistHandoverFailCause_t::TIMEOUT), DataCallFailCause_t::ERROR_UNSPECIFIED},
  {static_cast<int>(ApAssistHandoverFailCause_t::APN_PREF_SYSTEM_CHANGE_REQUEST_FAILURE), DataCallFailCause_t::HANDOFF_PREFERENCE_CHANGED},
  {static_cast<int>(ApAssistHandoverFailCause_t::HANDOFF_FAILURE), DataCallFailCause_t::HANDOFF_PREFERENCE_CHANGED},
};

unordered_map<dsi_ce_reason_type_t, unordered_map<int, DataCallFailCause_t>> CallEndReason::callEndReasonTypeMap = {
  {DSI_CE_TYPE_MOBILE_IP, mipReasonMap},
  {DSI_CE_TYPE_INTERNAL, internalReasonMap},
  {DSI_CE_TYPE_CALL_MANAGER_DEFINED, cmReasonMap},
  {DSI_CE_TYPE_3GPP_SPEC_DEFINED, _3gppReasonMap},
  {DSI_CE_TYPE_PPP, pppReasonMap},
  {DSI_CE_TYPE_EHRPD, ehrpdReasonMap},
  {DSI_CE_TYPE_IPV6, ipv6ReasonMap},
  {static_cast<dsi_ce_reason_type_t>(CallEndReason::AP_ASSIST_HANDOVER), apAssistHandoffReasonMap},
};

DataCallFailCause_t CallEndReason::getCallEndReason(dsi_ce_reason_t dsiReason) {
  dsi_ce_reason_type_t reasonType = dsiReason.reason_type;
  int reasonCode = dsiReason.reason_code;
  if (callEndReasonTypeMap.find(reasonType) == callEndReasonTypeMap.end()) {
    Log::getInstance().d("[CallEndReason]: getCallEndReason type unknown");
    return DataCallFailCause_t::ERROR_UNSPECIFIED;
  }
  if (callEndReasonTypeMap[reasonType].find(reasonCode) == callEndReasonTypeMap[reasonType].end()) {
    Log::getInstance().d("[CallEndReason]: getCallEndReason code unknown");
    return DataCallFailCause_t::ERROR_UNSPECIFIED;
  }
  return callEndReasonTypeMap[reasonType][reasonCode];
}

bool CallEndReason::isPermanentFailure(DataCallFailCause_t rilReason) {
  bool retVal = false;
  switch (rilReason) {
    case DataCallFailCause_t::SERVICE_OPTION_NOT_SUPPORTED:
    case DataCallFailCause_t::SERVICE_OPTION_NOT_SUBSCRIBED:
    case DataCallFailCause_t::NSAPI_IN_USE:
    case DataCallFailCause_t::ONLY_IPV4_ALLOWED:
    case DataCallFailCause_t::ONLY_IPV6_ALLOWED:
    case DataCallFailCause_t::PROTOCOL_ERRORS:
    case DataCallFailCause_t::MISSING_UKNOWN_APN:
    case DataCallFailCause_t::UNKNOWN_PDP_ADDRESS_TYPE:
      retVal = true;
      break;
    default:
      retVal = false;
      break;
  }
  std::ostringstream ss;
  ss << std::boolalpha << "[CallInfo]: isPermanentFailure=" << retVal <<
      ", rilReason=" << (int)rilReason;
  Log::getInstance().d(ss.str());
  return retVal;
}

CallInfo::CallInfo(LocalLogBuffer& setLogBuffer): logBuffer(setLogBuffer) {
  Log::getInstance().d("[CallInfo]: CallInfo");

  cId = 0;
  active = _eInactive;
  dormantState = false;
  linkStateChangeReport = false;
  partialRetryEnabled = true;
  maxPartialRetryTimeout = DEFAULT_MAX_PARTIAL_RETRY_TIMEOUT;
  v4Connected = false;
  v6Connected = false;
  v4HandedOver = false;
  v6HandedOver = false;
  intentToChangeInProgress = false;
  thirdPartyHOParamsSet = false;
  fallbackInProgress = false;
  currentRAT = HandoffNetworkType_t::_eWWAN;
  preferredRAT = HandoffNetworkType_t::_eWWAN;
  transportType = 0;
  handoverTimerId=nullptr;
  deviceName = "";
  ipAddresses = "";
  dnsAddresses = "";
  pcscfAddresses = "";
  ipType = "";
  mtu = 0;
  callParamsChanged = false;

  dsiHandle = nullptr;
  eventId = 0;

  pProfileInfo = nullptr;
  pEmbmsInfo = nullptr;

  setupDataCallCompleteCallback = nullptr;
  deactivateDataCallCompleteCallback = nullptr;
  embmsCallCompleteCallback = nullptr;

  pCallsm = new CallStateMachine(*this, logBuffer);
  pCallsm->setCurrentState(_eIdle);

  wds_v4_call_endpoint = nullptr;
  wds_v6_call_endpoint = nullptr;

  callInfoChangedCallback = nullptr;
  // TODO: initialize pCallInfoList
}

CallInfo::~CallInfo() {
  Log::getInstance().d("[CallInfo]: ~CallInfo");

  if (pCallsm) {
    delete pCallsm;
    pCallsm = nullptr;
  }

  /* Release the dsi_hndl if its valid */
  if (this->getDsiHandle() != nullptr) {
    dsi_rel_data_srvc_hndl(this->getDsiHandle());
    dsiHandle = nullptr;
  }

  if (pProfileInfo) {
    /* Release qdp profile */
    if(pProfileInfo->getUmtsProfileId() != QDP_PROFILE_ID_INVALID) {
      qdp_profile_release(pProfileInfo->getUmtsProfileId());
    }
    if(pProfileInfo->getCdmaProfileId() != QDP_PROFILE_ID_INVALID) {
      qdp_profile_release(pProfileInfo->getCdmaProfileId());
    }
    delete pProfileInfo;
    pProfileInfo = nullptr;
  }
}

bool CallInfo::isEmbmsCall() {
  if(pEmbmsInfo != nullptr)
    return TRUE;
  else
    return FALSE;
}

void CallInfo::dump(string padding, ostream& os) {
  os << padding << "  CallId: " << cId << endl;
  os << padding << "    CallInfo:" << endl;
  os << padding << std::boolalpha << "      linkState=" << active <<
        ", dormant=" << dormantState << endl;
  os << padding << "      v4Connected=" << v4Connected <<
        ", v6Connected=" << v6Connected << endl;
  os << padding << "      v4HandedOver=" << v4HandedOver <<
        ", v6HandedOver=" << v6HandedOver << endl;
  os << padding << "      currentRAT=" << currentRAT <<
        ", preferredRAT=" << preferredRAT << endl;
  os << padding << "      transportType=" << transportType <<
        ", dsiHandle=" << dsiHandle << endl;
  os << padding << "      deviceName=" << deviceName << endl;
  os << padding << "      ipAddresses=" << ipAddresses << endl;
  os << padding << "      gatewayAddresses=" << gatewayAddresses << endl;
  os << padding << "      dnsAddresses=" << dnsAddresses << endl;
  os << padding << "      pcscfAddresses=" << pcscfAddresses << endl;
  os << padding << "      ipType=" << ipType << endl;
  os << padding << "    StateMachine:" << endl;
  if (pCallsm != nullptr) {
    pCallsm->dump(padding + "      ", os);
  } else {
    os << padding << "      NULL" << endl;
  }
  os << padding << "    ProfileInfo:" << endl;
  if (pProfileInfo != nullptr) {
    pProfileInfo->dump(padding + "      ", os);
  } else {
    os << padding << "      NULL" << endl;
  }
}

bool CallInfo::hasWdsCallEndPoints() {
  return (wds_v4_call_endpoint != nullptr || wds_v6_call_endpoint != nullptr);
}

void CallInfo::deleteWdsCallEndPoint(IpFamilyType_t type)
{
  if(type == IpFamilyType_t::IPv4)
  {
    if(wds_v4_call_endpoint) {
      wds_v4_call_endpoint.reset();
      wds_v4_call_endpoint = nullptr;
    }
  }
  if(type == IpFamilyType_t::IPv6)
  {
    if(wds_v6_call_endpoint) {
      wds_v6_call_endpoint.reset();
      wds_v6_call_endpoint = nullptr;
    }
  }
}

void CallInfo::resetCallInfo()
{
  Log::getInstance().d("CallInfo::resetCallInfo");

  active = _eInactive;
  dormantState = false;
  linkStateChangeReport = false;
  partialRetryEnabled = true;
  maxPartialRetryTimeout = DEFAULT_MAX_PARTIAL_RETRY_TIMEOUT;
  v4Connected = false;
  v6Connected = false;
  v4HandedOver = false;
  v6HandedOver = false;
  intentToChangeInProgress = false;
  thirdPartyHOParamsSet = false;
  fallbackInProgress = false;
  currentRAT = HandoffNetworkType_t::_eWWAN;
  preferredRAT = HandoffNetworkType_t::_eWWAN;
  transportType = 0;
  handoverTimerId=nullptr;
  deviceName = "";
  ipAddresses = "";
  dnsAddresses = "";
  pcscfAddresses = "";
  ipType = "";
  mtu = 0;
  callParamsChanged = false;
  eventId = 0;
  setupDataCallCompleteCallback = nullptr;
  deactivateDataCallCompleteCallback = nullptr;
  embmsCallCompleteCallback = nullptr;
  callInfoChangedCallback = nullptr;

  if (pCallsm) {
    delete pCallsm;
    pCallsm = nullptr;
  }

  /* Release the dsi_hndl if its valid */
  if (this->getDsiHandle() != nullptr) {
    dsi_rel_data_srvc_hndl(this->getDsiHandle());
    dsiHandle = nullptr;
  }

  if (pProfileInfo) {
    /* Release qdp profile */
    if(pProfileInfo->getUmtsProfileId() != QDP_PROFILE_ID_INVALID) {
      qdp_profile_release(pProfileInfo->getUmtsProfileId());
    }
    if(pProfileInfo->getCdmaProfileId() != QDP_PROFILE_ID_INVALID) {
      qdp_profile_release(pProfileInfo->getCdmaProfileId());
    }
    delete pProfileInfo;
    pProfileInfo = nullptr;
  }
  pEmbmsInfo = nullptr;
}

/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param profile [description]
 */
bool CallInfo::setProfileInfo(CallSetupProfile *profile) {
  Log::getInstance().d("[CallInfo]: setProfileInfo");

  pProfileInfo = profile;

  // getting dsi handle
  dsi_hndl_t dsiHandle = nullptr;
  if((dsiHandle = dsi_get_data_srvc_hndl(CallInfo::dsiNetCallback, this)) == nullptr) {
    Log::getInstance().d("Unable to get dsi handle");
    return false;
  }

  if(pProfileInfo == nullptr) {
    Log::getInstance().d("ProfileInfo is nullptr");
    return false;
  }

  // look up profile using qdp
  if((!pProfileInfo->getApn().empty()) || (pProfileInfo->getApn().empty() && DATA_IS_RIL_RADIO_TECH_3GPP(pProfileInfo->getAvailableRadioRAT()))) {
    logBuffer.addLogWithTimestamp("[CallInfo(" + std::to_string(cId) + ")]: Looking up profile using qdp");
    //If either cdma or umts profile ids are available on profile info, this is
    //likely a retry due to fallback. No need to do qdp lookup again
    if ((pProfileInfo->getCdmaProfileId() != QDP_PROFILE_ID_INVALID ||
         pProfileInfo->getUmtsProfileId() != QDP_PROFILE_ID_INVALID) ||
        (pProfileInfo->lookup())) {
      // set default profile number
      if((pProfileInfo->getApnTypes() & (uint32_t)ApnTypes_t::DEFAULT) && pProfileInfo->getPreferred()) {
        Log::getInstance().d("Set default 3gpp profile num = " +std::to_string(pProfileInfo->getUmtsProfileId()));
        wds_endpoint = ModemEndPointFactory<WDSModemEndPoint>::getInstance().buildEndPoint();
        if(wds_endpoint) {
          wds_endpoint->setDefaultProfileNum(pProfileInfo->getUmtsProfileId());
          prevDefaultProfileId = currDefaultProfileId;
          currDefaultProfileId = pProfileInfo->getUmtsProfileId();
          Log::getInstance().d("setting previous default to" + std::to_string(prevDefaultProfileId));
          if(prevDefaultProfileId != QDP_PROFILE_ID_INVALID && currDefaultProfileId != prevDefaultProfileId)
          {
            qdp_profile_release(prevDefaultProfileId);
            prevDefaultProfileId = QDP_PROFILE_ID_INVALID;
          }
        }
        else {
          Log::getInstance().d("wds_endpoint is nullptr ");
        }
      }

      #ifdef QMI_RIL_UTF
        dsi_call_param_value_t utf_apn;
        string apn_name = pProfileInfo->getApn();
        utf_apn.buf_val = (char *)(apn_name.c_str());
        utf_apn.num_val = pProfileInfo->getApn().length();
        dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_APN_NAME, &utf_apn);
      #endif

      dsi_call_param_value_t bringUpMode;
      bringUpMode.buf_val = nullptr;
      bringUpMode.num_val = DSI_CALL_BRINGUP_MODE_INVALID;

      if(mCallBringupCapability & BRING_UP_APN_TYPE) {
        wds_apn_type_mask_v01 wdsApnTypeMask;
        wdsApnTypeMask = WDSModemEndPointModule::convertToApnTypeMask((int32_t)pProfileInfo->getApnTypes());

        /*If more than one profile with the same APNtype is found
         then bring up the call using APNName*/
        if(qdp_profiles_for_apntype(wdsApnTypeMask) > 1 )
        {
          if(mCallBringupCapability & BRING_UP_APN_NAME)
          {
            Log::getInstance().d("More than one profile found with ApnType" + std::to_string((int)wdsApnTypeMask));
            Log::getInstance().d("Bringup the call by APNname " + pProfileInfo->getApn());
            bringUpMode.num_val = DSI_CALL_BRINGUP_MODE_APN_NAME;

            dsi_call_param_value_t apnName;
            string apn = pProfileInfo->getApn();
            apnName.buf_val = (char *)(apn.c_str());
            apnName.num_val = pProfileInfo->getApn().length();
            if(DSI_SUCCESS != dsi_set_data_call_param(dsiHandle,
                                                      DSI_CALL_INFO_APN_NAME,
                                                      &apnName)) {
              Log::getInstance().d("Unable to set the apn name");
              return false;
            }
          }
        }
        else
        {
          Log::getInstance().d("Bringup the call by APNType " + std::to_string((int)wdsApnTypeMask));
          bringUpMode.num_val = DSI_CALL_BRINGUP_MODE_APN_TYPE_MASK;

          dsi_call_param_value_t apnTypeMask;
          apnTypeMask.buf_val = (char*)&wdsApnTypeMask;
          apnTypeMask.num_val = (int)sizeof(wds_apn_type_mask_v01);
          if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle,
                                                   DSI_CALL_INFO_APN_TYPE_MASK,
                                                   &apnTypeMask)) {
            Log::getInstance().d("Unable to set bringup apn type mask");
            return false;
          }
        }

        if(bringUpMode.num_val != DSI_CALL_BRINGUP_MODE_INVALID)
        {
          if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle,
                                                     DSI_CALL_INFO_CALL_BRINGUP_MODE,
                                                    &bringUpMode)) {
            Log::getInstance().d("Unable to set bringup mode");
            return false;
          }
        }
      }

      if(bringUpMode.num_val == DSI_CALL_BRINGUP_MODE_INVALID) {
        dsi_call_param_value_t apnInfo;

        if(pProfileInfo->getUmtsProfileId() > QDP_PROFILE_ID_INVALID) {
          apnInfo.buf_val = nullptr;
          apnInfo.num_val = pProfileInfo->getUmtsProfileId();
          dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_UMTS_PROFILE_IDX, &apnInfo);
        }

        if(pProfileInfo->getCdmaProfileId() > QDP_PROFILE_ID_INVALID) {
          apnInfo.buf_val = nullptr;
          apnInfo.num_val = pProfileInfo->getCdmaProfileId();
          dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_CDMA_PROFILE_IDX, &apnInfo);
        }

        if(pProfileInfo->getCdmaProfileId() == QDP_PROFILE_ID_INVALID || pProfileInfo->getUmtsProfileId() == QDP_PROFILE_ID_INVALID) {
          Log::getInstance().d("[qdp] apn = " + pProfileInfo->getApn() + ", length = " + std::to_string(pProfileInfo->getApn().length()));
          string apnStr = pProfileInfo->getApn();
          apnInfo.buf_val = (char *)apnStr.c_str();
          apnInfo.num_val = apnStr.length();
          if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_APN_NAME, &apnInfo)) {
            Log::getInstance().d("Unable to set apn name");
            return false;
          }
        } else {
            Log::getInstance().d("[qdp] umtsProfileId = "+
                                 std::to_string((int)pProfileInfo->getUmtsProfileId())
                                 +", "+
                                 "[qdp] cdmaProfileId = "+
                                 std::to_string((int)pProfileInfo->getCdmaProfileId()));
        }
        logBuffer.addLogWithTimestamp("[CallInfo(" + std::to_string(cId) + ")]: Found umtsProfileId=" +
          std::to_string((int)pProfileInfo->getUmtsProfileId()) + ", cdmaProfileId=" +
          std::to_string((int)pProfileInfo->getCdmaProfileId()));
      } /* profile-id based bringup */
    } /* profile present or created (if needed) */
  } else { /* profile doesnt have valid APN name */

    Log::getInstance().d("RIL did not provide APN, not setting any APN in start_nw_params");
    /* use the RIL profile id only if APN was not provided */
    /* set profile id in the dsi store */

    if (true != setRilProfileId( dsiHandle,
                                 profile->getProfileId(),
                                 profile->getRadioTech()))
    {
      Log::getInstance().d("could not set ril profile id for dsiHndle");
      return false;
    }

    /* Update dsi tech pref to cdma so that route lookup returns cdma iface */
    if( DATA_IS_RIL_RADIO_TECH_CDMA_1X_EVDO(profile->getAvailableRadioRAT()) )
    {
      dsi_call_param_value_t techpref_info;
      techpref_info.buf_val = NULL;
      techpref_info.num_val = DSI_RADIO_TECH_CDMA;

      Log::getInstance().d("As Radio tech is 3gpp2, Setting DSI param -DSI_CALL_INFO_TECH_PREF");

      if ( ( DSI_SUCCESS !=  dsi_set_data_call_param( dsiHandle,
                                                      DSI_CALL_INFO_TECH_PREF,
                                                      &techpref_info ) ) )
      {
        Log::getInstance().d("unable to set tech pref");
        return false;
      }
    }
  }
  // set auth preference
  if(!pProfileInfo->getAuthType().empty()) {
    Log::getInstance().d("[qdp] authtype = " + pProfileInfo->getAuthType());
    dsi_call_param_value_t authPref;
    authPref.buf_val = nullptr;
    authPref.num_val = stoi(pProfileInfo->getAuthType());
    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_AUTH_PREF, &authPref)) {
      Log::getInstance().d("Unable to set auth type");
      return false;
    }
  }

  // set username
  if(!pProfileInfo->getUsername().empty()) {
    Log::getInstance().d("[qdp] username = " + pProfileInfo->getUsername());
    dsi_call_param_value_t username;
    string userNameStr = pProfileInfo->getUsername();
    username.buf_val = (char *)userNameStr.c_str();
    username.num_val = pProfileInfo->getUsername().length();
    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_USERNAME, &username)) {
      Log::getInstance().d("Unable to set username");
      return false;
    }
  }

  // set password
  if(!pProfileInfo->getPassword().empty()) {
    Log::getInstance().d("[qdp] password = " + pProfileInfo->getPassword());
    dsi_call_param_value_t password;
    string passwordStr = pProfileInfo->getPassword();
    password.buf_val = (char *)passwordStr.c_str();
    password.num_val = pProfileInfo->getPassword().length();
    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_PASSWORD, &password)) {
      Log::getInstance().d("Unable to set password");
      return false;
    }
  }

  // set IP family
  if(!pProfileInfo->getProtocol().empty()) {
    Log::getInstance().d("[qdp] protocol = " + pProfileInfo->getProtocol());
    dsi_call_param_value_t ipFamily;
    ipFamily.buf_val = nullptr;

    if(pProfileInfo->getProtocol().compare(string("IP"))==0) {
      ipFamily.num_val = DSI_IP_VERSION_4;
    }
    else if(pProfileInfo->getProtocol().compare(string("IPV6"))==0) {
      ipFamily.num_val = DSI_IP_VERSION_6;
      /*-------------------------------------------------------------------
        Add IPv4 automatically if CLAT is enabled on this profile
      -------------------------------------------------------------------*/
      if( global_qcril_clat_supported )
      {
        if (!pProfileInfo->getApn().empty() &&
             (pProfileInfo->getApnTypes()
                & (uint32_t)ApnTypes_t::DEFAULT) == (uint32_t)ApnTypes_t::DEFAULT)
        {
          Log::getInstance().d("[CallInfo] Automatic IPv4 request for APN "
                               + pProfileInfo->getApn());
          ipFamily.num_val = DSI_IP_VERSION_4_6;
        }
        else {
          wds_endpoint = ModemEndPointFactory<WDSModemEndPoint>::getInstance().buildEndPoint();
          if(!wds_endpoint)
          {
            Log::getInstance().d("[CallInfo] wds_endpoint is NULL.");
          }
          else {
            int32_t profile_type = ( pProfileInfo->getRadioTech() == QDP_RADIOTECH_3GPP2 ) ?
                WDS_PROFILE_TYPE_3GPP2_V01 : WDS_PROFILE_TYPE_3GPP_V01;
            uint8_t profile_index = ( pProfileInfo->getRadioTech() == QDP_RADIOTECH_3GPP2 ) ?
                pProfileInfo->getCdmaProfileId() : pProfileInfo->getUmtsProfileId();
            if(profile_index > QDP_PROFILE_ID_INVALID &&
                  wds_endpoint->getWDSProfileClatCapability(profile_type, profile_index))
            {
              ipFamily.num_val = DSI_IP_VERSION_4_6;
            }
          }
        }
      }
    }
    else
    {
      ipFamily.num_val = DSI_IP_VERSION_4_6;
    }

    if ((!pProfileInfo->getRoamingProtocol().empty()) && (pProfileInfo->getProtocol().compare(pProfileInfo->getRoamingProtocol()) != 0)) {
      QCRIL_LOG_INFO("%s", "Home Ip type is different from Roaming Ip type, use IPv4v6");
      ipFamily.num_val = DSI_IP_VERSION_4_6;
    }

    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_IP_VERSION, &ipFamily)) {
      Log::getInstance().d("Unable to set ip version");
      return false;
    }
  }

  // set disallow roaming state
  dsi_call_param_value_t disallowRoaming;
  disallowRoaming.buf_val = nullptr;
  disallowRoaming.num_val = pProfileInfo->isRoamingAllowed() ? 0 : 1;
  if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_DISALLOW_ROAMING, &disallowRoaming)) {
    Log::getInstance().d("Unable to set disallow roaming");
    return false;
  }

  // store dsiHandle into call instance
  this->setDsiHandle(dsiHandle);

  return true;
}

bool CallInfo::setEmergencyProfileInfo(CallSetupProfile *profile) {
  Log::getInstance().d("[CallInfo]: setEmergencyProfileInfo");

  // getting dsi handle
  dsi_hndl_t dsiHandle = nullptr;
  if((dsiHandle = dsi_get_data_srvc_hndl(CallInfo::dsiNetCallback, this)) == nullptr) {
    Log::getInstance().d("Unable to get dsi handle");
    return false;
  }
  if (!profile->emergencyLookup()) {
    Log::getInstance().d("Failed to get emergency profile");
    return false;
  }
  if(mCallBringupCapability & BRING_UP_APN_TYPE) {
    /* set DSI bringup mode as apn-type based bringup */
    wds_apn_type_mask_v01 wdsApnTypeMask;
    wdsApnTypeMask =
      WDSModemEndPointModule::convertToApnTypeMask((int32_t)profile->getApnTypes());
    Log::getInstance().d("Bringup using apn type mask = " +std::to_string((int)wdsApnTypeMask));
    dsi_call_param_value_t bringUpMode;
    bringUpMode.buf_val = nullptr;
    bringUpMode.num_val = DSI_CALL_BRINGUP_MODE_APN_TYPE_MASK;
    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle,
                                               DSI_CALL_INFO_CALL_BRINGUP_MODE,
                                               &bringUpMode)) {
      Log::getInstance().d("Unable to set bringup mode");
      return false;
    }
    /* set apnTypeBitmask */
    dsi_call_param_value_t apnTypeMask;
    apnTypeMask.buf_val = (char*)&wdsApnTypeMask;
    apnTypeMask.num_val = (int)sizeof(wds_apn_type_mask_v01);
    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle,
                                               DSI_CALL_INFO_APN_TYPE_MASK,
                                               &apnTypeMask)) {
      Log::getInstance().d("Unable to set bringup apn type mask");
      return false;
    }
  } else {
    dsi_call_param_value_t dsi_param;
    if(profile->getUmtsProfileId() > QDP_PROFILE_ID_INVALID) {
      dsi_param.buf_val = nullptr;
      dsi_param.num_val = profile->getUmtsProfileId();
      dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_UMTS_PROFILE_IDX, &dsi_param);
    } else if(profile->getCdmaProfileId() > QDP_PROFILE_ID_INVALID) {
      dsi_param.buf_val = nullptr;
      dsi_param.num_val = profile->getCdmaProfileId();
      dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_CDMA_PROFILE_IDX, &dsi_param);
    } else {
      Log::getInstance().d("Unable to set profile id");
      return false;
    }
  }

  // set IP family
  if(!profile->getProtocol().empty()) {
    Log::getInstance().d("[qdp] protocol = " + profile->getProtocol());
    dsi_call_param_value_t ipFamily;
    ipFamily.buf_val = nullptr;
    ipFamily.num_val = (profile->getProtocol().compare(string("IP"))==0)?DSI_IP_VERSION_4:
                       (profile->getProtocol().compare(string("IPV6"))==0)?DSI_IP_VERSION_6:DSI_IP_VERSION_4_6;
    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_IP_VERSION, &ipFamily)) {
      Log::getInstance().d("Unable to set ip version");
      return false;
    }
  }

  // store dsiHandle into call instance
  this->setDsiHandle(dsiHandle);

  pProfileInfo = profile;
  pProfileInfo->setIsEmergencyCall(true);

  return true;
}

void CallInfo::setIntentToChangeInProgress(bool inProgress)
{
  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return;
  }
  if (pCallsm->getCurrentState() == _eConnecting && inProgress) {
    CallEventType event;
    event.callEvent = _eAbortEvent;
    event.callEventData = (CallInfo *)this;

    Log::getInstance().d("[CallInfo]: disconnect pending call due to handover");
    int nextState = pCallsm->processEvent(event);
    pCallsm->setCurrentState(nextState);
  }
  intentToChangeInProgress=inProgress;
}

void CallInfo::setThirdPartyHOParams(std::vector<std::string> addr)
{
  thirdPartyHOAddr = addr;
  if (dsiHandle) {
    dsi_call_param_value_t apnInfo;
    memset(&apnInfo,0,sizeof(apnInfo));
    dsi_wds_handoff_ctxt_t hoParams;
    memset(&hoParams,0,sizeof(hoParams));
    bool ipV4Found=false, ipV6Found= false;
    for (unsigned long i=0 ; i<addr.size(); i++) {
      std::string addrNoPrefix = addr[i].substr(0,addr[i].find("/"));
      //Do simple check for '.' to decide if ipv4 or ipv6 addr
      if (addrNoPrefix.find(".")!=std::string::npos) {
        Log::getInstance().d("found IPV4 HO addr" + addrNoPrefix);
        ipV4Found = true;
        strlcpy(hoParams.ipv4_addr,addrNoPrefix.c_str(),sizeof(hoParams.ipv4_addr));
      }
      else
      {
        Log::getInstance().d("found IPV6 HO addr" + addrNoPrefix);
        ipV6Found = true;
        strlcpy(hoParams.ipv6_addr,addrNoPrefix.c_str(),sizeof(hoParams.ipv6_addr));
      }
    }

    if (ipV4Found && ipV6Found) {
      hoParams.bearer_ip_type = DSI_BEARER_IP_TYPE_V4_V6;
    }
    else if (ipV4Found) {
      hoParams.bearer_ip_type = DSI_BEARER_IP_TYPE_V4;
    }
    else {
      hoParams.bearer_ip_type = DSI_BEARER_IP_TYPE_V6;
    }
    apnInfo.num_val = sizeof(hoParams);
    apnInfo.buf_val = (char*)&hoParams;
    if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_HANDOFF_CONTEXT, &apnInfo)) {
      Log::getInstance().d("Unable to set handoff context");
    }
  }
  else {
    Log::getInstance().d("dsi handle is null, not setting handoff context");
  }
  thirdPartyHOParamsSet=true;
}


/**
 * @brief static function for DSI callback
 * @details static function requires to use call instance
 *
 * @param userData is CallInfo * type
 */
void CallInfo::dsiNetCallback(
  dsi_hndl_t dsiHandle,
  void *userData,
  dsi_net_evt_t netEvent,
  dsi_evt_payload_t *payload
)
{
  std::ignore = dsiHandle;

  Log::getInstance().d("[CallInfo]: dsi net evt = " + std::to_string(netEvent) +
    " for cid " + std::to_string(((CallInfo *)userData)->getCid()));

  EventDataType callbackEvent;
  memset(&callbackEvent, 0, sizeof(EventDataType));

  callbackEvent.evt = netEvent;
  callbackEvent.data = (void *)userData;
  callbackEvent.data_len = sizeof(CallInfo *);
  callbackEvent.self = (void *)&callbackEvent;
  memset(&callbackEvent.payload, '\0', sizeof(dsi_evt_payload_t));

  if(payload != nullptr)
  {
    memcpy(&callbackEvent.payload.embms_info, &(payload->embms_info), sizeof(dsi_embms_tmgi_info_type));
  }

  std::shared_ptr<RilEventDataCallback> msg = std::make_shared<RilEventDataCallback>(callbackEvent);
  if(msg) {
    msg->broadcast();
  }
}

/**
 * @brief Bring up call with call instance
 * @details call info instance should be passed to state machine
 *          to use call manager static function
 */
bool CallInfo::setupDataCall(std::shared_ptr<std::function<void(CallInfo *, rildata::SetupDataCallResponse_t)>> completeCb) {
  Log::getInstance().d("[CallInfo]: setupDataCall");
  bool bConnecting = false;

  CallEventType event;
  event.callEvent = _eConnectEvent;
  event.callEventData = (CallInfo *)this;
  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return false;
  }

  int nextState = pCallsm->processEvent(event);
  pCallsm->setCurrentState(nextState);

  if(nextState == _eConnecting) {
    bConnecting = true;
    setupDataCallCompleteCallback = completeCb;
  } else if (nextState == _eError) {
    setupDataCallCompleteCallback = completeCb;
    DataCallFailCause_t rilReason;
    dsi_ce_reason_t dsiReason = dsiGetVerboseCallEndReason(dsiHandle);
    rilReason = CallEndReason::getCallEndReason(dsiReason);
    setupDataCallFailResponse(rilReason);
  }

  return bConnecting;
}

bool CallInfo::setupEmbmsDataCall(qcril_instance_id_e_type instance_id) {
  Log::getInstance().d("[CallInfo]: setupEmbmsDataCall");
  bool bConnecting = false;
  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return false;
  }

  pEmbmsInfo = make_shared<EmbmsCallHandler>(logBuffer);
  pEmbmsInfo->setDsiHandle(getDsiHandle());
  pEmbmsInfo->setInstanceId(instance_id);

  CallEventType event;
  event.callEvent = _eConnectEvent;
  event.callEventData = (CallInfo *)this;

  int nextState = pCallsm->processEvent(event);
  pCallsm->setCurrentState(nextState);

  if(nextState == _eConnecting) {
    bConnecting = true;
  }
  return bConnecting;
}

/**
 * @brief [brief description]
 * @details expected next state is disconnecting
 * @return [description]
 */
bool CallInfo::deactivateDataCall(std::shared_ptr<std::function<void(CallInfo *, rildata::ResponseError_t)>> completeCb) {
  Log::getInstance().d("[CallInfo]: deactivateDataCall");
  bool bDisconnecting = false;

  CallEventType event;
  event.callEvent = _eDisconnectEvent;
  event.callEventData = (CallInfo *)this;
  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return false;
  }

  int nextState = pCallsm->processEvent(event);
  pCallsm->setCurrentState(nextState);

  if(nextState == _eDisconnecting) {
    bDisconnecting = true;
    deactivateDataCallCompleteCallback = completeCb;
  }

  return bDisconnecting;
}

void CallInfo::handleHandoverTimeout() {
  if (pCallsm == nullptr || pProfileInfo == nullptr) {
    Log::getInstance().d("CallStateMachine or ProfileInfo is null");
    return;
  }
  CallEventType event;
  event.callEvent = _eHandoverTimerExpiredEvent;
  event.callEventData = (CallInfo *)this;
  Log::getInstance().d("[CallInfo]: apn = "+pProfileInfo->getApn());
  int nextState = pCallsm->processEvent(event);
  pCallsm->setCurrentState(nextState);
  dsi_ce_reason_t dsiReason = {
    .reason_type = static_cast<dsi_ce_reason_type_e>(CallEndReason::AP_ASSIST_HANDOVER),
    .reason_code = static_cast<int>(ApAssistHandoverFailCause_t::TIMEOUT)
  };
  DataCallFailCause_t rilReason = CallEndReason::getCallEndReason(dsiReason);
  setupDataCallFailResponse(rilReason);
}

void CallInfo::handleSetupDataCallTimeout() {
  if (pCallsm == nullptr || pProfileInfo == nullptr) {
    Log::getInstance().d("CallStateMachine or ProfileInfo is null");
    return;
  }
  if(pCallsm->getCurrentState() == _eConnecting)
  {
    CallEventType event;
    event.callEvent = _eConnectTimerExpiredEvent;
    event.callEventData = (CallInfo *)this;
    Log::getInstance().d("[CallInfo]: apn = "+pProfileInfo->getApn());
    int nextState = pCallsm->processEvent(event);
    pCallsm->setCurrentState(nextState);
    DataCallFailCause_t rilReason = DataCallFailCause_t::OEM_DCFAILCAUSE_4;
    setupDataCallFailResponse(rilReason);
  }
  else
  {
    Log::getInstance().d("[CallInfo]: Already received a dsi event");
  }
}

void CallInfo::handleDeactivateDataCallTimeout() {
  if (pCallsm == nullptr || pProfileInfo == nullptr) {
    Log::getInstance().d("CallStateMachine or ProfileInfo is null");
    return;
  }
  if(pCallsm->getCurrentState() == _eDisconnecting)
  {
    CallEventType event;
    event.callEvent = _eDisconnectTimerExpiredEvent;
    event.callEventData = (CallInfo *)this;
    Log::getInstance().d("[CallInfo]: apn = "+pProfileInfo->getApn());
    int nextState = pCallsm->processEvent(event);
    pCallsm->setCurrentState(nextState);
    deactivateDataCallFailResponse();
  }
  else
  {
    Log::getInstance().d("[CallInfo]: Already received a dsi event");
  }
}

void CallInfo::handlePartialRetryTimeout() {
  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return;
  }
  dsi_ce_reason_t v4Reason = {DSI_CE_TYPE_INVALID, WDS_VCER_MIP_HA_REASON_UNKNOWN_V01};
  dsi_ce_reason_t v6Reason = {DSI_CE_TYPE_INVALID, WDS_VCER_MIP_HA_REASON_UNKNOWN_V01};
  DataCallFailCause_t v4RilReason = DataCallFailCause_t::OEM_DCFAILCAUSE_4;
  DataCallFailCause_t v6RilReason = DataCallFailCause_t::OEM_DCFAILCAUSE_4;
  if (dsiGetDualIpCallEndReason(dsiHandle, v4Reason, v6Reason)) {
    v4RilReason = CallEndReason::getCallEndReason(v4Reason);
    v6RilReason = CallEndReason::getCallEndReason(v6Reason);
    DataCallFailCause_t consolidatedReason = ((v4RilReason != DataCallFailCause_t::OEM_DCFAILCAUSE_4) ?
                                              v4RilReason : v6RilReason);
    if (!CallEndReason::isPermanentFailure(consolidatedReason)) {
      dsi_call_param_value_t partialRetry;
      partialRetry.buf_val = nullptr;
      partialRetry.num_val = TRUE;
      if (DSI_SUCCESS != dsi_set_data_call_param(dsiHandle, DSI_CALL_INFO_PARTIAL_RETRY, &partialRetry)) {
        Log::getInstance().d("Unable to set partial retry param");
        return;
      }

      CallEventType event;
      event.callEvent = _ePartialRetryTimerExpiredEvent;
      event.callEventData = (CallInfo *)this;

      int nextState = pCallsm->processEvent(event);
      pCallsm->setCurrentState(nextState);
    } else {
      Log::getInstance().d("[CallInfo]: Skipping partial retry due to permanent CE reason");
    }
  } else {
    Log::getInstance().d("[CallInfo]: Skipping partial retry due to invalid CE reason");
  }
}

void CallInfo::handlePartialRetryResponseTimeout() {
    if (pCallsm == nullptr) {
      Log::getInstance().d("CallStateMachine is null");
      return;
    }
    CallEventType event;
    event.callEvent = _ePartialRetryResponseTimerExpiredEvent;
    event.callEventData = (CallInfo *)this;

    int nextState = pCallsm->processEvent(event);
    pCallsm->setCurrentState(nextState);
}

/**
 * @brief [brief description]
 * @details [long description]
 */
bool CallInfo::handoverSetupDataCall(std::shared_ptr<std::function<void(CallInfo *, rildata::SetupDataCallResponse_t)>> completeCb) {
  Log::getInstance().d("[CallInfo]: handoverSetupDataCall");
  bool bHandover = false;

  CallEventType event;
  event.callEvent = _eHandoverSetupDataEvent;
  event.callEventData = (CallInfo *)this;

  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return false;
  }
  int nextState = pCallsm->processEvent(event);
  pCallsm->setCurrentState(nextState);

  if(nextState == _eHandover) {
    bHandover = true;
    v4HandedOver = false;
    v6HandedOver = false;
    setupDataCallCompleteCallback = completeCb;
  }

  return bHandover;
}

/**
 * @brief [brief description]
 * @details [long description]
 */
bool CallInfo::handoverDeactivateDataCall(std::shared_ptr<std::function<void(CallInfo *, rildata::ResponseError_t)>> completeCb) {
  Log::getInstance().d("[CallInfo]: handoverDeactivateDataCall");
  bool bHandover = false;

  CallEventType event;
  event.callEvent = _eHandoverDeactivateDataEvent;
  event.callEventData = (CallInfo *)this;

  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return false;
  }
  int nextState = pCallsm->processEvent(event);
  pCallsm->setCurrentState(nextState);

  if(nextState == _eConnected) {
    bHandover = true;
    v4HandedOver = false;
    v6HandedOver = false;
    deactivateDataCallCompleteCallback = completeCb;
    this->deactivateDataCallResponse();
  }

  return bHandover;
}


/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param reason [description]
 */
void CallInfo::getCallEndReason(int &reason) {
  Log::getInstance().d("[CallInfo]: getCallEndReason");
  reason = dsiGetCallEndReason(this->dsiHandle);
}

/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param msg [description]
 */
int CallInfo::handleRilEventDataCallback(std::shared_ptr<Message> msg) {
  std::shared_ptr<RilEventDataCallback> m = std::static_pointer_cast<RilEventDataCallback>(msg);

  EventDataType *pEvtData = m->getEventData();
  CallInfo *pCallInstance = (CallInfo *)pEvtData->data;

  Log::getInstance().d("[CallInfo]: handleRilEventDataCallback");

  // TODO: send event to state machine

  CallEventType event;
  DsiEventDataType dsiEvent;

  dsiEvent.netEvent = pEvtData->evt;
  dsiEvent.eventData = (void *)pCallInstance;

  event.callEvent = _eDsiEvent;
  event.callEventData = (void *)&dsiEvent;

  if (pCallInstance == nullptr || pCallInstance->pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return _eError;
  }
  int nextState = pCallInstance->pCallsm->processEvent(event);
  pCallInstance->pCallsm->setCurrentState(nextState);

  /* For Embms call  */
  if(pCallInstance->isEmbmsCall())
  {
    if(dsiEvent.netEvent == DSI_EVT_NET_IS_CONN)
    {
      qcril_embms_enable_response_payload_type enableResp;
      memset(&enableResp, 0, sizeof(enableResp));
      enableResp.call_id = pCallInstance->getCid();
      enableResp.cause = RIL_E_OEM_ERROR_4;
      enableResp.resp_code = (int32_t)EmbmsDataCallFailCause_t::ERROR_UNKNOWN;

      int if_index;
      string device_name;
      /*if callstate is errorstate then skip the below condition and send error response */
      if(nextState == _eConnected && dsiGetDeviceName(dsiHandle, device_name) == DSI_SUCCESS && qcril_data_get_ifindex(pCallInstance->getDeviceName().c_str(), &if_index) == DSI_SUCCESS)
      {
        enableResp.cause = RIL_E_SUCCESS;
        enableResp.resp_code = (int32_t)EmbmsDataCallFailCause_t::ERROR_NONE;
        strlcpy(enableResp.interafce_name, (pCallInstance->getDeviceName()).c_str(), QCRIL_EMBMS_INTERFACE_NAME_LENGTH_MAX);
        enableResp.if_index = if_index;
      }

      auto msg = std::make_shared<NasEmbmsEnableDataConMessage>(enableResp);
      msg->dispatch();
    }
    else if(dsiEvent.netEvent == DSI_EVT_NET_NO_NET)
    {
      if(nextState == _eError)
      {
        qcril_embms_disable_indication_payload_type disableResp;
        memset(&disableResp,0,sizeof(disableResp));

        if((dsiGetCallTech(dsiHandle)) == DSI_EXT_TECH_EMBMS)
        {
          disableResp.call_id = pCallInstance->getCid();
          pCallInstance->getCallEndReason(disableResp.cause);
          disableResp.resp_code = (int32_t)EmbmsDataCallFailCause_t::ERROR_UNKNOWN;

          auto msg = std::make_shared<NasEmbmsDisableDataMessage>(disableResp);
          msg->dispatch();
        }
      }
    }
    else
    {
      if (pEmbmsInfo != nullptr) {
        pEmbmsInfo->processEvents(dsiEvent.netEvent, &pEvtData->payload.embms_info);
      }
    }
    return nextState;
  }

  if( dsiEvent.netEvent == DSI_EVT_NET_NO_NET )
  {
    Log::getInstance().d("[CallInfo]: release WDSCallModemEndPointModule QMI clients");
    releaseWDSCallEPModuleQMIClient();
  }

  if(nextState == _eConnected) {
    pCallInstance->createQmiWdsClients();
    pCallInstance->setupDataCallResponse();
  }
  else if (nextState == _eError) {
    DataCallFailCause_t rilReason;
    dsi_ce_reason_t dsiReason = dsiGetVerboseCallEndReason(dsiHandle);
    if ((dsiReason.reason_type == DSI_CE_TYPE_INTERNAL) &&
        (dsiReason.reason_code == WDS_VCER_INTERNAL_APN_TYPE_MISMATCH_V01) &&
        (mCallBringupCapability != BRING_UP_LEGACY)){
      Log::getInstance().d("[CallInfo]: call failed for cid = " +
                           std::to_string(cId)
                   + " due to APN type mismatch, fallback to legacy bringup");
      fallbackInProgress = true;
      std::shared_ptr<CallBringupFallbackMessage> msg =
        std::make_shared<CallBringupFallbackMessage>(cId);
      if(msg) {
        msg->broadcast();
      }
    }
    else {
      rilReason = CallEndReason::getCallEndReason(dsiReason);
      pCallInstance->setupDataCallFailResponse(rilReason);
    }
  }

  Log::getInstance().d("[CallInfo]: return state = "+std::to_string(nextState));
  return nextState;
}

/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param msg [description]
 */
void CallInfo::setLinkActiveState(LinkActiveState state) {
  Log::getInstance().d("[CallInfo]: setLinkActiveState = " + std::to_string((int)state));
  this->active = state;
}

/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param msg [description]
 */
bool CallInfo::sendDormancyRequest() {

  bool status = false;
  if (this->wds_v4_call_endpoint) {
    status = this->wds_v4_call_endpoint->goDormant();
  }

  if (this->wds_v6_call_endpoint) {
    status = this->wds_v6_call_endpoint->goDormant();
  }

  return status;
}

/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param msg [description]
 */
bool CallInfo::configureParams(bool updateDataCallListChangeInd) {
  Log::getInstance().d("[CallInfo]: configureParams creating temporary callinfo"+
                        std::to_string((int)updateDataCallListChangeInd));

  CallInfo tempCallinfo (logBuffer);
  dsiGetDeviceName(this->dsiHandle, tempCallinfo.deviceName);
  dsiGetAddresses(this->dsiHandle, tempCallinfo.v4Connected, tempCallinfo.v6Connected,
                  tempCallinfo.ipAddresses, tempCallinfo.gatewayAddresses, tempCallinfo.dnsAddresses);
  if(tempCallinfo.v4Connected && tempCallinfo.v6Connected) {
    tempCallinfo.ipType = "IPV4V6";
  }
  else if (tempCallinfo.v6Connected) {
    tempCallinfo.ipType = "IPV6";
  }
  else if (tempCallinfo.v4Connected) {
    tempCallinfo.ipType = "IP";
  }
  dsiGetPcscfAddresses(this->dsiHandle, tempCallinfo.pcscfAddresses);
  tempCallinfo.mtu = dsiGetMtu(this->dsiHandle);

  this->compareCallParams(&tempCallinfo);

  if(updateDataCallListChangeInd && callInfoChangedCallback != nullptr) {
    auto cb = *(callInfoChangedCallback.get());
    cb();
  }

  return true;
}

bool CallInfo::compareCallParams(CallInfo *callInst) {
  if(this->v4Connected != callInst->v4Connected) {
    Log::getInstance().d("[CallInfo]: compareCallParams - v4Connected state is changed");
    this->v4Connected = callInst->v4Connected;
    setCallParamsChangedFlag(true);
  }
  if(this->v6Connected != callInst->v6Connected) {
    Log::getInstance().d("[CallInfo]: compareCallParams - v6Connected state is changed");
    this->v6Connected = callInst->v6Connected;
    setCallParamsChangedFlag(true);
  }
  if(this->deviceName.compare(callInst->deviceName) != 0) {
    Log::getInstance().d("[CallInfo]: compareCallParams - deviceName is changed");
    this->deviceName = callInst->deviceName;
    setCallParamsChangedFlag(true);
  }
  if(this->ipAddresses.compare(callInst->ipAddresses) != 0) {
    Log::getInstance().d("[CallInfo]: compareCallParams - ipAddresses is changed");
    this->ipAddresses = callInst->ipAddresses;
    setCallParamsChangedFlag(true);
  }
  if(this->gatewayAddresses.compare(callInst->gatewayAddresses) != 0) {
    Log::getInstance().d("[CallInfo]: compareCallParams - gatewayAddresses is changed");
    this->gatewayAddresses = callInst->gatewayAddresses;
    setCallParamsChangedFlag(true);
  }
  if(this->dnsAddresses.compare(callInst->dnsAddresses) != 0) {
    Log::getInstance().d("[CallInfo]: compareCallParams - dnsAddresses is changed");
    this->dnsAddresses = callInst->dnsAddresses;
    setCallParamsChangedFlag(true);
  }
  if(this->pcscfAddresses.compare(callInst->pcscfAddresses) != 0) {
    Log::getInstance().d("[CallInfo]: compareCallParams - pcscfAddresses is changed");
    this->pcscfAddresses = callInst->pcscfAddresses;
    setCallParamsChangedFlag(true);
  }
  if(this->ipType.compare(callInst->ipType) != 0) {
    Log::getInstance().d("[CallInfo]: compareCallParams - ipType is changed");
    this->ipType = callInst->ipType;
    setCallParamsChangedFlag(true);
  }
  if(this->mtu != callInst->mtu) {
    Log::getInstance().d("[CallInfo]: compareCallParams - v4Connected state changed");
    this->mtu = callInst->mtu;
    setCallParamsChangedFlag(true);
  }

  return getCallParamsChangedFlag();
}

void CallInfo::handleHandoverPreferenceUnchanged() {
  CallEventType event;
  event.callEvent = _eHandoverPreferenceUnchangedEvent;
  event.callEventData = (CallInfo *)this;

  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return;
  }
  int nextState = pCallsm->processEvent(event);
  pCallsm->setCurrentState(nextState);

  if(nextState == _eConnected) {
    Log::getInstance().d("[CallInfo]: Failing handover setupDataCall due to unchanged preference");
    setupDataCallFailResponse(DataCallFailCause_t::HANDOFF_PREFERENCE_CHANGED);
  }
}

/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param msg [description]
 */
void CallInfo::setupDataCallResponse() {
  Log::getInstance().d("[CallInfo]: setupDataCallResponse for serialId = "+std::to_string(this->serialId)+" token = "+std::to_string(this->getMessageToken()));

  if (setupDataCallCompleteCallback != nullptr ) {
    auto cb = *(setupDataCallCompleteCallback.get());
    SetupDataCallResponse_t result;
    result.respErr = ResponseError_t::NO_ERROR;
    result.call = {DataCallFailCause_t::NONE,
                  -1,
                  this->getCid(),
                  this->active,
                  this->getIpType(),
                  this->deviceName.c_str(),
                  this->ipAddresses,
                  this->dnsAddresses,
                  this->gatewayAddresses,
                  this->pcscfAddresses,
                  this->mtu};
    cb(this, result);
    setupDataCallCompleteCallback = nullptr;
  }
  else {
    Log::getInstance().d("[CallInfo]: setupDataCallCompleteCallback is nullptr");
  }
}

/**
 * @brief Respond with failure code to setupDataCall request
 * @details Get the failure reason from DSI if there is one, and return corresponding
            ril failure reason
 */
void CallInfo::setupDataCallFailResponse(DataCallFailCause_t rilReason) {
  Log::getInstance().d("[CallInfo]: setupDataCallFailResponse for serialId = "+std::to_string(this->serialId)+" token = "+std::to_string(this->getMessageToken()));

  if (setupDataCallCompleteCallback != nullptr ) {
    auto cb = *(setupDataCallCompleteCallback.get());
    SetupDataCallResponse_t result;
    result.respErr = ResponseError_t::INTERNAL_ERROR;
    result.call = {rilReason,
                  -1,
                  this->getCid(),
                  this->active,
                  this->getIpType(),
                  this->deviceName.c_str(),
                  this->ipAddresses,
                  this->dnsAddresses,
                  this->gatewayAddresses,
                  this->pcscfAddresses,
                  this->mtu};
    cb(this, result);
    setupDataCallCompleteCallback = nullptr;
  }
  else {
    Log::getInstance().d("[CallInfo]: setupDataCallCompleteCallback is nullptr");
  }
}

/**
   * @brief Respond with failure code to Deactivatedatacall request
  */
void CallInfo::deactivateDataCallFailResponse() {
  Log::getInstance().d("[CallInfo]: deactivateDataCallFailResponse for serialId = "+std::to_string(this->serialId)+" token = "+std::to_string(this->getMessageToken()));

  if(deactivateDataCallCompleteCallback != nullptr ) {
    auto cb = *(deactivateDataCallCompleteCallback.get());
    ResponseError_t result = ResponseError_t::INTERNAL_ERROR;
    cb(this, result);
    deactivateDataCallCompleteCallback = nullptr;
  }
  else {
    Log::getInstance().d("[CallInfo]: DeactivatedataCallCompleteCallback is nullptr");
  }
}


/**
 * @brief [brief description]
 * @details [long description]
 *
 * @param msg [description]
 */
void CallInfo::deactivateDataCallResponse() {
  Log::getInstance().d("[CallInfo]: deactivateDataCallResponse for serialId = "+std::to_string(this->serialId)+" token = "+std::to_string(this->getMessageToken()));

  if (deactivateDataCallCompleteCallback != nullptr ) {
    auto cb = *(deactivateDataCallCompleteCallback.get());
    ResponseError_t result = ResponseError_t::NO_ERROR;
    cb(this, result);
    deactivateDataCallCompleteCallback = nullptr;
  }
  else {
    Log::getInstance().d("[CallInfo]: deactivateDataCallCompleteCallback is nullptr");
  }
}

void CallInfo::handoffInformationUpdate(HandoffState_t state, std::shared_ptr<Message> msg) {
  if (pCallsm == nullptr) {
    Log::getInstance().d("CallStateMachine is null");
    return;
  }
  Log::getInstance().d("[CallInfo]: handoffInformationUpdate for cid = "+
      std::to_string((int)this->getCid()));

  auto m = std::static_pointer_cast<HandoverInformationIndMessage>(msg);

  if (m == nullptr) {
    Log::getInstance().d("[CallInfo]: handoffInformationUpdate message is nullptr");
    return;
  }
  Log::getInstance().d("[CallInfo]: handoverInformation msg = " + m->dump());
  CallEventType event;
  event.callEventData = (CallInfo *)this;
  dsi_ce_reason_t dsiReason = {
    .reason_type = static_cast<dsi_ce_reason_type_e>(CallEndReason::AP_ASSIST_HANDOVER),
    .reason_code = static_cast<int>(ApAssistHandoverFailCause_t::HANDOFF_FAILURE)
  };
  switch(state) {
    case HandoffState_t::PrefSysChangedSuccess:
      event.callEvent = _eHandoverApAsstPrefSysResultEvent;
      break;
    case HandoffState_t::Init:
      event.callEvent = _eHandoverInformationInitEvent;
      break;
    case HandoffState_t::Success:
    {
      event.callEvent = _eHandoverInformationSuccessEvent;
      switch (m->getIpType()) {
        case IpFamilyType_t::IPv4:
          v4HandedOver = true;
          break;
        case IpFamilyType_t::IPv6:
          v6HandedOver = true;
          break;
        default:
          break;
      }
      break;
    }
    case HandoffState_t::PrefSysChangedFailure:
    {
      event.callEvent = _eHandoverApAsstPrefSysResultFailureEvent;
      dsiReason.reason_code = static_cast<int>(ApAssistHandoverFailCause_t::APN_PREF_SYSTEM_CHANGE_REQUEST_FAILURE);
      break;
    }
    case HandoffState_t::Failure:
    {
      event.callEvent = _eHandoverInformationFailureEvent;
      if (m != nullptr && m->hasFailReason()) {
        auto reason = m->getFailReason();
        dsiReason = {
          .reason_type = static_cast<dsi_ce_reason_type_e>(reason.failure_reason_type),
          .reason_code = reason.failure_reason
        };
      }
      break;
    }
  }

  int nextState = pCallsm->processEvent(event);
  Log::getInstance().d("[CallInfo]: next state = "+std::to_string(nextState));

  pCallsm->setCurrentState(nextState);
  if (nextState == _eConnected) {
    if (state == HandoffState_t::Success) {
      setupDataCallResponse();
    } else {
      DataCallFailCause_t rilReason = CallEndReason::getCallEndReason(dsiReason);
      setupDataCallFailResponse(rilReason);
    }
  }
}

void CallInfo::createQmiWdsClients() {
  Log::getInstance().d("[CallInfo]: createQmiWdsClients");
  if (pProfileInfo == nullptr) {
    Log::getInstance().d("ProfileInfo is null");
    return;
  }

  int ep_type = -1;
  int epid = -1;
  int mux_id = -1;
  qmi_linux_get_conn_id_by_name_ex(this->getDeviceName().c_str(), &ep_type, &epid, &mux_id);
  QmiSetupRequestCallback qmiWdsSetupCallback("CallInfo-Token");

  if(this->v4Connected && wds_v4_call_endpoint == nullptr) {
    wds_v4_call_endpoint = std::shared_ptr<WDSCallModemEndPoint>(new WDSCallModemEndPoint(
                                                                "WDSCallv4ModemEndPoint_" + std::to_string(this->getCid()),
                                                                this->getCid(),
                                                                this->pProfileInfo->getApn(),
                                                                this->getDeviceName(),
                                                                IpFamilyType_t::IPv4));
    wds_v4_call_endpoint->setBindMuxDataPortParams(ep_type, epid, mux_id);
    wds_v4_call_endpoint->requestSetup("CallInfo-v4-token", &qmiWdsSetupCallback);
    wds_v4_call_endpoint->setLinkStateChangeReport(linkStateChangeReport);
  }

  if(this->v6Connected && wds_v6_call_endpoint == nullptr) {
    wds_v6_call_endpoint = std::shared_ptr<WDSCallModemEndPoint>(new WDSCallModemEndPoint(
                                                                "WDSCallv6ModemEndPoint_" + std::to_string(this->getCid()),
                                                                this->getCid(),
                                                                this->pProfileInfo->getApn(),
                                                                this->getDeviceName(),
                                                                IpFamilyType_t::IPv6));
    wds_v6_call_endpoint->setBindMuxDataPortParams(ep_type, epid, mux_id);
    wds_v6_call_endpoint->requestSetup("CallInfo-v6-token", &qmiWdsSetupCallback);
    wds_v6_call_endpoint->setLinkStateChangeReport(linkStateChangeReport);
  }
}

void CallInfo::setCallInfoChangedCallback(std::shared_ptr<std::function<void(void)>> callInfoChangedCb) {
  Log::getInstance().d("[CallInfo]: setCallInfoChangedCallback");

  callInfoChangedCallback = callInfoChangedCb;
}

void CallInfo::releaseWDSCallEPModuleQMIClient()
{
  Log::getInstance().d("[CallInfo]: releaseWDSCallEPModuleQMIClient");
  if(wds_v6_call_endpoint) {
    Log::getInstance().d("[CallInfo]: releaseWDSCallEPModuleQMIClient-wds_v6_call_endpoint");
    wds_v6_call_endpoint->releaseWDSCallEPModuleQMIClient();
  }

  if(wds_v4_call_endpoint) {
    Log::getInstance().d("[CallInfo]: releaseWDSCallEPModuleQMIClient-wds_v4_call_endpoint");
    wds_v4_call_endpoint->releaseWDSCallEPModuleQMIClient();
  }
}

void CallInfo::processPcscfAddressChangedEvent()
{
  Log::getInstance().d("[CallInfo] processPcscfAddressChangedEvent");
  dsiGetPcscfAddresses(this->dsiHandle, this->pcscfAddresses);
}

void CallInfo::setLinkStateChangeReport(bool report)
{
  Log::getInstance().d("[CallInfo]: setLinkStateChangeReport cid="+std::to_string((int)cId));
  linkStateChangeReport=report;
  if(wds_v4_call_endpoint) {
    wds_v4_call_endpoint->setLinkStateChangeReport(linkStateChangeReport);
  }
  if(wds_v6_call_endpoint) {
    wds_v6_call_endpoint->setLinkStateChangeReport(linkStateChangeReport);
  }
}

/*===========================================================================

  FUNCTION: setRilProfileId

===========================================================================*/
/*!
    @brief
    Sets the RIL provided profile id (technology specific) into the
    dsi_hndl

    @return
    true
    false
*/
/*=========================================================================*/
bool CallInfo::setRilProfileId
(
  const dsi_hndl_t dsiHndl,
  const int32_t rilProfile,
  const uint8_t rilTech
)
{
  int ret = false;
  int reti = true;
  dsi_call_param_value_t profile_id;
  dsi_call_param_value_t call_type;
  dsi_call_param_identifier_t profile_param_id = DSI_CALL_INFO_MIN;

  do
  {
    /* sanity checking */
    if ((RIL_DATA_PROFILE_DEFAULT == rilProfile))
    {
      Log::getInstance().d("[CallInfo]: default profile id"+ std::to_string(rilProfile)+"provided. " \
                      "no need to set in dsi_hndl");
      ret = true;
      break;
    }

    /* prepare dsi parameter with profile id */
    memset( &profile_id, 0, sizeof( dsi_call_param_value_t ) );
    profile_id.buf_val = NULL;
    profile_id.num_val = rilProfile;
    Log::getInstance().d("RIL provided PROFILE ID Number"+ std::to_string(profile_id.num_val));

    /* adjust the profile id according to ril.h */
    if (profile_id.num_val < (int)(RIL_DATA_PROFILE_OEM_BASE))
    {
      reti = true;
      switch(profile_id.num_val)
      {
      case RIL_DATA_PROFILE_TETHERED:
        Log::getInstance().d("RIL provided"+std::to_string(profile_id.num_val)+"profile id. Tethered call " \
                          "will be used");
        call_type.buf_val = NULL;
        call_type.num_val = DSI_CALL_TYPE_TETHERED;
        if (dsi_set_data_call_param(dsiHndl,
                                    DSI_CALL_INFO_CALL_TYPE,
                                    &call_type) != DSI_SUCCESS)
        {
          Log::getInstance().d("Couldn't set call_type"+ std::to_string(call_type.num_val));
          reti = false;
          break;
        }
        break;
      default:
        Log::getInstance().d("RIL provided"+std::to_string(profile_id.num_val)+ "profile id. This is currently "
                        "not supported");
      }
      if (reti != true)
      {
        break;
      }
    }
    else
    {
      /* adjust for the OEM base */
      profile_id.num_val -= RIL_DATA_PROFILE_OEM_BASE;
      Log::getInstance().d("profile_id.num_val"+std::to_string(profile_id.num_val)+"will be used (android provided"+ \
        std::to_string(profile_id.num_val + RIL_DATA_PROFILE_OEM_BASE));

      /* figure out whether this is umts or cdma profile id */
      if (rilTech == QDP_RADIOTECH_3GPP2)
      {
        profile_param_id = DSI_CALL_INFO_CDMA_PROFILE_IDX;
      }
      else if (rilTech == QDP_RADIOTECH_3GPP )
      {
        profile_param_id = DSI_CALL_INFO_UMTS_PROFILE_IDX;
      }
      else
      {
        Log::getInstance().d("RIL provided incorrect/malformed technology"+std::to_string(rilTech));
        break;
      }

      /* now set the profile id onto dsi_hndl */
      if ( ( dsi_set_data_call_param(dsiHndl,
                                     profile_param_id,
                                     &profile_id ) ) != DSI_SUCCESS )
      {
        Log::getInstance().d("unable to set profile id "+std::to_string(profile_id.num_val));
        break;
      }
    }

    ret = true;
  } while (0);

  if (true == ret)
  {
    Log::getInstance().d("setRilProfileId successful");

  }
  else
  {
    Log::getInstance().d("setRilProfileId failed");
  }

  return ret;
}

std::string DsiEventDataType::getEventName() const {
  switch (netEvent) {
    case DSI_EVT_INVALID:
      return "DSI_EVT_INVALID";
    case DSI_EVT_NET_IS_CONN:
      return "DSI_EVT_NET_IS_CONN";
    case DSI_EVT_NET_NO_NET:
      return "DSI_EVT_NET_NO_NET";
    case DSI_EVT_PHYSLINK_DOWN_STATE:
      return "DSI_EVT_PHYSLINK_DOWN_STATE";
    case DSI_EVT_PHYSLINK_UP_STATE:
      return "DSI_EVT_PHYSLINK_UP_STATE";
    case DSI_EVT_NET_RECONFIGURED:
      return "DSI_EVT_NET_RECONFIGURED";
    case DSI_EVT_QOS_STATUS_IND:
      return "DSI_EVT_QOS_STATUS_IND";
    case DSI_EVT_NET_NEWADDR:
      return "DSI_EVT_NET_NEWADDR";
    case DSI_EVT_NET_DELADDR:
      return "DSI_EVT_NET_DELADDR";
    case DSI_EVT_NET_PARTIAL_CONN:
      return "DSI_EVT_NET_PARTIAL_CONN";
    case DSI_NET_TMGI_ACTIVATED:
      return "DSI_NET_TMGI_ACTIVATED";
    case DSI_NET_TMGI_DEACTIVATED:
      return "DSI_NET_TMGI_DEACTIVATED";
    case DSI_NET_TMGI_ACTIVATED_DEACTIVATED:
      return "DSI_NET_TMGI_ACTIVATED_DEACTIVATED";
    case DSI_NET_TMGI_LIST_CHANGED:
      return "DSI_NET_TMGI_LIST_CHANGED";
    case DSI_NET_SAI_LIST_CHANGED:
      return "DSI_NET_SAI_LIST_CHANGED";
    case DSI_NET_CONTENT_DESC_CONTROL:
      return "DSI_NET_CONTENT_DESC_CONTROL";
    case DSI_NET_TMGI_SERVICE_INTERESTED:
      return "DSI_NET_TMGI_SERVICE_INTERESTED";
    case DSI_EVT_NET_HANDOFF:
      return "DSI_EVT_NET_HANDOFF";
    case DSI_EVT_WDS_CONNECTED:
      return "DSI_EVT_WDS_CONNECTED";
    case DSI_EVT_NET_NEWMTU:
      return "DSI_EVT_NET_NEWMTU";
    default:
      return "UNKNOWN_DSI_NET_EVENT";
  }
}

std::string CallEventType::getEventName() const {
  switch (callEvent) {
    case CallEventTypeEnum::_eConnectEvent:
      return "ConnectEvent";
    case CallEventTypeEnum::_eConnectFailEvent:
      return "ConnectFailEvent";
    case CallEventTypeEnum::_eDisconnectEvent:
      return "DisconnectEvent";
    case CallEventTypeEnum::_eDisconnectFailEvent:
      return "DisconnectFailEvent";
    case CallEventTypeEnum::_eHandoverSetupDataEvent:
      return "HandoverSetupDataEvent";
    case CallEventTypeEnum::_eHandoverApAsstPrefSysResultEvent:
      return "HandoverApAsstPrefSysResultEvent";
    case CallEventTypeEnum::_eHandoverApAsstPrefSysResultFailureEvent:
      return "HandoverApAsstPrefSysResultFailureEvent";
    case CallEventTypeEnum::_eHandoverInformationInitEvent:
      return "HandoverInformationInitEvent";
    case CallEventTypeEnum::_eHandoverInformationSuccessEvent:
      return "HandoverInformationSuccessEvent";
    case CallEventTypeEnum::_eHandoverInformationFailureEvent:
      return "HandoverInformationFailureEvent";
    case CallEventTypeEnum::_eHandoverDeactivateDataEvent:
      return "HandoverDeactivateDataEvent";
    case CallEventTypeEnum::_eHandoverTimerExpiredEvent:
      return "HandoverTimerExpiredEvent";
    case CallEventTypeEnum::_eDsiEvent:
    {
      DsiEventDataType* dsiEvent = (DsiEventDataType *)callEventData;
      if (dsiEvent != nullptr) {
        return dsiEvent->getEventName();
      }
      return "MISSING_DSI_NET_EVENT";
    }
    case CallEventTypeEnum::_eCallEvtEvent:
      return "CallEvtEvent";
    default:
      return "UNKNOWN";
  }
}
