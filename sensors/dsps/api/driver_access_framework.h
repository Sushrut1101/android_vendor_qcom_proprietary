#ifndef DRIVER_ACCESS_FRAMEWORK_H_
#define DRIVER_ACCESS_FRAMEWORK_H_

/*============================================================================*/
/**
  @file driver_access_framework.h


*/

/*============================================================================
  Copyright (c) 2014-2015 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
  ============================================================================*/
/*============================================================================
EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order. Please
use ISO format for dates.

$Header: //components/dev/ssc.slpi/1.0/tomcheng.ssc.slpi.1.0.daf_aug_26/api/driver_access_framework.h#1 $
$DateTime: 2015/08/26 11:34:48 $

when       who    what, where, why
---------- --- -----------------------------------------------------------
2015-08-25 tc  Added SNS_DAF_PROX_POLLING*, SNS_DAF_ALS_RGB_POLLING*, and
               SNS_DAF_GENERAL_SEND_BYTE_ARRAY messages
2015-07-15 dk  Defined MAX_INJECT_DATA_ARRAY to address KW concern
2015-01-15 SH  Added SNS_DAF_PLAYBACK* messages
2014-05-13 tc  Added SNS_DAF_OEM_MESSAGE_BASE
2014-02-13 tc  Initial revision

============================================================================*/

/*============================================================================
  INCLUDE FILES
  ============================================================================*/



/*============================================================================
  Preprocessor Definitions and Constants
============================================================================*/
// Lifted from the comdef.h header
/*********************** BEGIN PACK() Definition ***************************/

#if defined __GNUC__
  #define PACK(x)       x __attribute__((__packed__))
#elif defined __GNUG__
  #define PACK(x)       x __attribute__((__packed__))
#elif defined __arm
  #define PACK(x)       __packed x
#elif defined _WIN32
  #define PACK(x)       x /* Microsoft uses #pragma pack() prologue/epilogue */
#else
  #define PACK(x)       x __attribute__((__packed__))
#endif

/*============================================================================
   Type Declarations
============================================================================*/

/**
 * Defines the errors used in the sensor1 API.
 *
 * !NOTE: THE ORDERING IN THIS ENUM MUST NOT BE CHANGED!
 *
 * If you wish to reserve a message id, please contact the Qualcomm Sensors team
 */
typedef enum sns_daf_msg_e
{

  SNS_DAF_NO_MSG = 0,                                  // No message, request, response, or indication.

  SNS_DAF_BMA2X2_TUNE_DOUBLETAP_V01 = 1,
  /**< Tunes Double-Tap for the BMA2X2 device */

  SNS_DAF_GENERAL_WHO_AM_I_V01 = 2,
  /**< Identifies the device by reading the "WHO AM I" register
       This is a general message that all drivers should support. */

  SNS_DAF_GENERAL_ECHO_V01 = 3,
  /**< Sends an arbitrary message payload to a driver and expects a response
       with the same message payload.
       This is a general message that all drivers should support. */

  SNS_DAF_GENERAL_REVERB_START_V01 = 4,
  /**< Sends an arbitrary message payload to a driver and expects a response
       to acknowledge the request along with a number of indications with the
       same message payload.
       This is a general message that all drivers should support. */

  SNS_DAF_GENERAL_REVERB_IND_V01 = 5,
  /**< The indication generated by a reverb request. */

  SNS_DAF_GENERAL_REVERB_STOP_V01 = 6,
  /**< Stops a previous "REVERB_START" request. If there is no "REVERB_START"
       request to stop, then this message will do nothing.
       This is a general message that all drivers should support. */

  SNS_DAF_PLAYBACK_GET_CAPABILITIES = 7,
  /**< Requests capabilities from a playback driver. */

  SNS_DAF_PLAYBACK_START_OF_NEW_DATA = 8,
  /**< This should be sent each time a new data set is started. It will cause
       the playback driver to reset. */

  SNS_DAF_PLAYBACK_INJECT_PRIMARY_DATA_3AXIS = 9,
  /**< Used for injecting Primary data to playback driver. */

  SNS_DAF_PLAYBACK_INJECT_SECONDARY_DATA_3AXIS = 10,
  /**< Used for injecting Secondary data to playback driver. */

  SNS_DAF_GENERAL_SEND_BYTE_ARRAY_V01 = 20,
  /**< Passes a 256 byte-array to the driver. */

  SNS_DAF_PROX_POLLING_START_V01 = 50,
  /**< Start polling the proximity ADC counts at the defined interval. */

  SNS_DAF_PROX_POLLING_REPORT_V01 = 51,
  /**< Message containing the proximity's ADC counts. */

  SNS_DAF_PROX_POLLING_STOP_V01 = 52,
  /**< Stop polling the proximity ADC counts. */
  
  SNS_DAF_ALS_RGB_POLLING_START_V01 = 60,
  /**< Start polling the ALS & RGB sensorS at the defined interval. */

  SNS_DAF_ALS_RGB_POLLING_REPORT_V01 = 61,
  /**< Message containing the ALS & RGB values. */

  SNS_DAF_ALS_RGB_POLLING_STOP_V01 = 62,
  /**< Stop polling the ALS & RGB sensorS. */

  SNS_DAF_OEM_MESSAGE_BASE = 100000
  /**< All OEM-defined messages MUST START AFTER this value (i.e. 100001 and +).
       All other messages values less than this value are reserved. */

} sns_daf_msg_e;


/**
 * BMA2X2 Double-Tap Tuning Request v01
 *
 * Defines the request structure for the SNS_DAF_BMA2X2_TUNE_DOUBLETAP_V01 message
 *
 * Note: This is an "all-or-nothing" type message. All fields MUST CONTAIN A
 *       VALUE! Furthermore, if there is a failure in one field, the ENTIRE
 *       message fails.
 */
typedef PACK(struct) sns_daf_bma2x2_tune_doubletap_req_v01
{
  uint8_t tap_th;
  /**< Tap Threshold
   *   Definition: the slope threshold for detecting a tap event
   *   Valid Values: 0 to 31 - the real-world value (in mg) depends on the
   *                           range setting
   */
  uint8_t tap_shock;
  /**< Tap Shock
   *   Definition: the duration in which any slope exceeding the threshold
   *               after the first tap event is ignored
   *   Valid Values: 0 - 50 ms
   *                 1 - 75 ms
   */
  uint8_t tap_quiet;
  /**< Tap Quiet
   *   Definition: the duration in which no slope exceeding the threshold
   *               (after the tap shock duration) may occur, otherwise the tap
   *               event is canceled.
   *   Valid Values: 0 - 30 ms
   *                 1 - 20 ms
   */
  uint8_t tap_dur;
  /**< Tap Duration
   *   Definition: the duration in which a second tap event must occur after
   *               detection of the first tap event
   *   Valid Values: 0 - 50 ms
   *                 1 - 100 ms
   *                 2 - 150 ms
   *                 3 - 200 ms
   *                 4 - 250 ms
   *                 5 - 375 ms
   *                 6 - 500 ms
   *                 7 - 700 ms
   */
} sns_daf_bma2x2_tune_doubletap_req_v01;

/**
 * BMA2X2 Double-Tap Tuning Request v01 Maximums and Minimums (inclusive)
 */
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_TH_MAX     31
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_TH_MIN     0
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_SHOCK_MAX  1
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_SHOCK_MIN  0
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_QUIET_MAX  1
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_QUIET_MIN  0
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_DUR_MAX    7
#define SNS_DAF_BMA2X2_TUNE_DOUBLETAP_REQ_V01_TAP_DUR_MIN    0

/**
 * Generalized "WHO AM I" Request V01
 *
 * Defines the request structure for the SNS_DAF_GENERAL_WHO_AM_I_V01 message
 *
 * Note: This should be generic enough for all drivers to support. If a
 *       particular device does not have a "WHO AM I" register, then the
 *       response should contain "-1" in all of the appropriate fields.
 */
typedef PACK(struct) sns_daf_general_who_am_i_req_v01
{
  // Empty message structure
} sns_daf_general_who_am_i_req_v01;

/**
 * Generalized "WHO AM I" Response V01
 *
 * Defines the response structure for the SNS_DAF_GENERAL_WHO_AM_I_V01 message
 *
 * Note: This should be generic enough for all drivers to support. If a
 *       particular device does not have a "WHO AM I" register, then the
 *       response should contain "-1" in all of the appropriate fields.
 */
typedef PACK(struct) sns_daf_general_who_am_i_resp_v01
{
  uint32_t hardware_id;
  /**
   * Hardware Identifier (aka Hardware Revision)
   *
   * This is the value read out from the WHO_AM_I register, if it exists.
   * If no WHO_AM_I register exists, this field should be set to 0xFFFFFFFF.
   */
  uint32_t firmware_id;
  /**
   * Firmware Identifier (aka Firmware Revision)
   *
   * This is the ID/revision of the device's firmware, if it exists.
   * If no firmware ID exists, this field should be set to 0xFFFFFFFF.
   */
} sns_daf_general_who_am_i_resp_v01;

#define SNS_DAF_GENERAL_WHO_AM_I_NO_ID 0xFFFFFFFF

/**
 * Generalized Echo Request V01
 *
 * Defines the request structure for the SNS_DAF_GENERAL_ECHO_V01 message
 *
 * Note: All drivers should be able to support this request.
 */
typedef PACK(struct) sns_daf_general_echo_req_v01
{
  uint32_t echo;
  /**
   * Echo
   *
   * This is an arbitrary value set by the requester, to be echoed back.
   */
} sns_daf_general_echo_req_v01;

/**
 * Generalized Echo Response V01
 *
 * Defines the response structure for the SNS_DAF_GENERAL_ECHO_V01 message
 *
 * Note: All drivers should be able to support this request.
 */
typedef PACK(struct) sns_daf_general_echo_resp_v01
{
  uint32_t echo;
  /**
   * Echo
   *
   * This is the echo of the arbitrary value set by the requester.
   */
} sns_daf_general_echo_resp_v01;


/**
 * Generalized Reverb Start Request V01
 *
 * Defines the request structure for the SNS_DAF_GENERAL_REVERB_START_V01 message
 *
 * Note: All drivers should be able to support this request.
 */
typedef PACK(struct) sns_daf_general_reverb_start_req_v01
{
  uint32_t echo;
  /**
   * Echo
   *
   * This is an arbitrary value set by the requester, to be echoed back.
   */

  uint32_t reverb_period;
  /**
   * Reverb Period (in us)
   *
   * The amount of time (in us) in between reverb indications. The minimum
   * period is determined by SNS_DAF_GENERAL_REVERB_START_REQ_V01_REVERB_PERIOD_MIN
   */
} sns_daf_general_reverb_start_req_v01;

/**
 * Generalized Reverb Start Response V01
 *
 * Defines the response structure for the SNS_DAF_GENERAL_REVERB_START_V01 message
 *
 * Note: All drivers should be able to support this request.
 */
typedef PACK(struct) sns_daf_general_reverb_start_resp_v01
{
  uint32_t echo;
  /**
   * Echo
   *
   * This is the echo of the arbitrary value set by the requester.
   */
} sns_daf_general_reverb_start_resp_v01;

/**
 * Generalized Reverb Indication V01
 *
 * Defines the indication structure for the SNS_DAF_GENERAL_REVERB_IND_V01 message
 *
 * Note: All drivers should be able to support this request.
 */
typedef PACK(struct) sns_daf_general_reverb_ind_v01
{
  uint32_t echo;
  /**
   * Echo
   *
   * This is the echo of the arbitrary value set by the requester.
   */
} sns_daf_general_reverb_ind_v01;

/**
 * Generalized Reverb Start Request v01 Maximums and Minimums (inclusive)
 */
#define SNS_DAF_GENERAL_REVERB_START_REQ_V01_REVERB_PERIOD_MIN     100000  // 100000 us (10 Hz reverb)


/**
 * Generalized Reverb Stop Request V01
 *
 * Defines the request structure for the SNS_DAF_GENERAL_REVERB_STOP_V01 message
 *
 * Note: All drivers should be able to support this request.
 */
typedef PACK(struct) sns_daf_general_reverb_stop_req_v01
{
  // Empty message
} sns_daf_general_reverb_stop_req_v01;

/**
 * Generalized Reverb Stop Response V01
 *
 * Defines the response structure for the SNS_DAF_GENERAL_REVERB_STOP_V01 message
 *
 * Note: All drivers should be able to support this request.
 */
typedef PACK(struct) sns_daf_general_reverb_stop_resp_v01
{
  // Empty message
} sns_daf_general_reverb_stop_resp_v01;


/**
   Requests capabilities from the playback driver
 */
typedef PACK(struct) sns_daf_playback_get_capabilities_req
{
  // Empty message
} sns_daf_playback_get_capabilities_req;


/**
   A response sent when the get capabilities request is received.
 */
typedef PACK(struct) sns_daf_playback_get_capabilities_resp
{
  uint32_t max_buffered_samples;
  /**< Maximum number of samples the driver can buffer */

} sns_daf_playback_get_capabilities_resp;

/**
   This should be sent each time a new data set is started. It will cause
   the playback driver to reset.
*/
typedef PACK(struct) sns_daf_playback_start_of_new_data_req
{
  int32_t nominal_odr_period;
  /**< The nominal ODR (in usec betwen samples) at which the data was sampled.
   Set to -1 if the ODR is unknown. */
} sns_daf_playback_start_of_new_data_req;

/**
   Data type for 3-axis data. Used for injecting either Primary and Secondary
   data.
 */
typedef PACK(struct) sns_daf_playback_inject_data_3axis
{
  int32_t data[3];
  /**< Data, in SAE coordinates, using same data type as SMGR output */
  uint32_t timestamp_offset;
  /**< Timestamp offset (in SSC ticks) from the base timestamp */
} sns_daf_playback_inject_data;

/**
   Injects an array of 3-axis data into the playback driver
 */
#define MAX_INJECT_DATA_ARRAY 15
typedef PACK(struct) sns_daf_playback_inject_data_3axis_req
{
  int8_t  data_array_len;
  /**< Number of valid samples included in this message */

  int64_t base_timestamp;
  /**< Base timestamp of data contained in this message */

  sns_daf_playback_inject_data data_array[MAX_INJECT_DATA_ARRAY];
  /**< Data samples to inject */
} sns_daf_playback_inject_data_3axis_req;

/**
   A response to the inject_data_3axis_req.
 */
typedef PACK(struct) sns_daf_playback_inject_data_3axis_resp
{
  int8_t num_samples_saved;
  /**< Number of samples saved into the playback driver's sample buffer. Other
     samples have been dropped, and should be resent later */
} sns_daf_playback_inject_data_3axis_resp;

/**
 * PROX Polling Start Request V01
 *
 * Defines the request structure for the SNS_DAF_PROX_POLLING_START_V01 message
 */
typedef PACK(struct) sns_daf_prox_polling_start_req_v01
{
  uint32_t sampling_period_us;
  /**< The period (in us) that the proximity's ADC register needs to be
       sampled at.
       
       Note: The driver may choose to ignore this value, in which case the
             client should refer to the response message to get the sampling
             period that was actually set. */
} sns_daf_prox_polling_start_req_v01;

/**
 * PROX Polling Start Response V01
 *
 * Defines the response structure for the SNS_DAF_PROX_POLLING_START_V01 message
 */
typedef PACK(struct) sns_daf_prox_polling_start_resp_v01
{
  uint32_t actual_sampling_period_us;
  /**< The actual sampling period (in us) used by the driver. */
} sns_daf_prox_polling_start_resp_v01;

/**
 * PROX Polling Report V01
 *
 * Defines the report structure for the SNS_DAF_PROX_POLLING_REPORT_V01
 * message
 */
typedef PACK(struct) sns_daf_prox_polling_report_v01
{
  uint32_t prox_adc;
  /**< This is the value read out from the prox's ADC register(s). */
} sns_daf_prox_polling_report_v01;

/**
 * PROX Polling Stop V01
 *
 * Defines the request AND response structures for the
 * SNS_DAF_PROX_POLLING_STOP_V01 message
 */
typedef PACK(struct) sns_daf_prox_polling_stop_v01
{
  // Empty message
} sns_daf_prox_polling_stop_v01;

/**
 * ALS & RGB Polling Start Request V01
 *
 * Defines the request structure for the
 * SNS_DAF_ALS_RGB_POLLING_START_V01 message
 */
typedef PACK(struct) sns_daf_als_rgb_polling_start_req_v01
{
  uint32_t sampling_period_us;
  /**< The period (in us) that the proximity's ADC register needs to be
       sampled at.
       
       Note: The driver may choose to ignore this value, in which case the
             client should refer to the response message to get the sampling
             period that was actually set. */
} sns_daf_als_rgb_polling_start_req_v01;

/**
 * ALS & RGB Polling Start Response V01
 *
 * Defines the response structure for the
 * SNS_DAF_ALS_RGB_POLLING_START_V01 message
 */
typedef PACK(struct) sns_daf_als_rgb_polling_start_resp_v01
{
  uint32_t actual_sampling_period_us;
  /**< The actual sampling period (in us) used by the driver. */
} sns_daf_als_rgb_polling_start_resp_v01;

/**
 * ALS & RGB Polling Report V01
 *
 * Defines the report indication structure for the 
 * SNS_DAF_ALS_RGB_POLLING_REPORT_V01 message
 */
typedef PACK(struct) sns_daf_als_rgb_polling_report_v01
{
  uint32_t als_data;
  /**< Value from the ambient light sensor (in ADC counts). */
  uint32_t r_data;
  /**< Value from the red sensor (in ADC counts). */
  uint32_t g_data;
  /**< Value from the green sensor (in ADC counts). */
  uint32_t b_data;
  /**< Value from the blue sensor (in ADC counts). */
} sns_daf_als_rgb_polling_report_v01;

/**
 * ALS & RGB Polling Stop V01
 *
 * Defines the request AND response structures for the
 * SNS_DAF_ALS_RGB_POLLING_STOP_V01 message
 */
typedef PACK(struct) sns_daf_als_rgb_polling_stop_v01
{
  // Empty message
} sns_daf_als_rgb_polling_stop_v01;

/**
 * DAF General Send Byte Array V01
 *
 * Defines the request structure for the SNS_DAF_GENERAL_SEND_BYTE_ARRAY_V01
 * message.
 */
typedef PACK(struct) sns_daf_general_send_byte_array_v01
{
  uint8_t byte_array[256];
  /**< This is the array of 256 bytes to be delivered to the driver.
       Note: Message sizes cannot exceed 256 bytes. */
} sns_daf_general_send_byte_array_v01;

#endif /* DRIVER_ACCESS_FRAMEWORK_H_ */
