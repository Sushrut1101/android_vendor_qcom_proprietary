/* q3a_thread.h
 *
 * Copyright (c) 2013-2016, 2019 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

#ifndef __Q3A_THREAD_H__
#define __Q3A_THREAD_H__

#include <pthread.h>
#include <semaphore.h>
#include "aec_module.h"
#include "awb_module.h"
#include "af_module.h"

/* Generic thread handle type */
typedef void* (* q3a_thread_handler_t)(void *q3a_thread_data);

/** q3a_thread_type_t
 *
 *  This enumeration represents the types of threads in the Q3A thread module.
 **/
typedef enum {
  Q3A_THREAD_AECAWB,
  Q3A_THREAD_AF,

  Q3A_THREAD_NONE
} q3a_thread_type_t;

/** q3a_thread_ctrl_t
 *
 *    Per camera controls that affect how data is processed in the thread handle.
 *
 *    @aec_bg_be_stats_cnt:   Counter of non-processed stats, helps to decide
 *                            to process or not the stats. If falling behind in
 *                            stats processing, thread will skip the processing
 *                            and release stats buffer.
 *    @awb_bg_stats_cnt:      AWB counter of non-processed stats.
 *    @no_stats_mode:         Used to request thread to skip all stats processing,
 *                            including thouse already in the queue.
 **/
typedef struct {
  uint8_t         aec_bg_be_stats_cnt; /* BG and BE stats counter, algo only use one or the other */
  uint8_t         awb_bg_stats_cnt;
  boolean         no_stats_mode; /* true, don't take/process any stats, mainly when all stream are off */
} q3a_thread_ctrl_t;

/** q3a_thread_data_t
 *    @msg_q_lock:   Mutex lock for protecting concurrent access to the message
 *                   queue
 *    @msg_q:        The main message queue contains all the messages coming
 *                   to the port
 *    @p_msg_q:      The same as the main message queue, but messages in this
 *                   queue will be processed before those in the normal queue
 *    @active:       A flag indicating if the thread is active or not. If the
 *                   flag is FALSE, the queue will refuse to accept new messages
 *    @thread_cond:  Conditional variable to wake the thread when new message
 *                   arrives in the queue
 *    @thread_mutex: Mutex to lock the conditional variable - needed for the
 *                   signaling mechanism
 *    @thread_id:    The ID of the thread when created. Needed by the join
 *                   operation when the thread exits
 *   @thread_ctrl:    Per camera controls that affect how data is processed in the thread handle
 *   @num_of_registered_cameras:  Max suported cameras by the thread handle. - Needed
 *                            as check to verify incoming camera_id of the msg.
 *
 *  This structure is used for creating the thread handlers that will process
 *  the messages in the queues and take appropriate actions by calling the
 *  libraries and the callbacks.
 **/
typedef struct {
  pthread_mutex_t msg_q_lock;
  mct_queue_t     *msg_q;
  mct_queue_t     *p_msg_q;
  pthread_cond_t  thread_cond;
  pthread_condattr_t thread_condattr;
  pthread_mutex_t thread_mutex;
  sem_t           sem_launch; /* semaphore to sync thread create */
  pthread_t       thread_id;
  boolean         active;
  uint8_t         num_of_registered_cameras;
  q3a_thread_ctrl_t thread_ctrl[MAX_3A_MULTI_CAMERA_ID];
  boolean         deint_set;
} q3a_thread_data_t;

/** q3a_thread_port_aecawb_data_t
  *    @aec_port:    Pointer to the AEC port - needed to call the event function
  *                  of this port
  *    @aec_cb:      The callback function of the port that will take the output
  *                  from the library and pass it as an event to the port's event
  *                  function.
  *    @aec_obj:     The aec object containing all of the pointer functions to
  *                  communicate with the library. It also contains a pointer to
  *                  the internal library data so that the port's callback may
  *                  process the output data generated by the library.
  *    @awb_port:    Pointer to the AWB port - needed to call the event function
  *                  of this port
  *    @awb_cb:      The callback function of the port that will take the output
  *                  from the library and pass it as an event to the port's event
  *                  function.
  *    @awb_obj:     The awb object containing all of the pointer functions to
  *                  communicate with the library. It also contains a pointer to
  *                  the internal library data so that the port's callback may
  *                  process the output data generated by the library.
  *   @aecawb_share_algo_info:    Contains information that indicated the algorithms to be use.
  *
  *   This structure contains AEC and AWB port references.
  **/
typedef struct {
  mct_port_t        *aec_port;
  aec_callback_func aec_cb;
  aec_object_t      *aec_obj;
  stats_buffer_done_callback_func aec_stats_cb;

  mct_port_t        *awb_port;
  awb_callback_func awb_cb;
  awb_object_t      *awb_obj;
  stats_buffer_done_callback_func awb_stats_cb;
} q3a_thread_aecawb_camera_data_t;

/** q3a_thread_aecawb_data_t
 *    @thread_data: Contains the thread data associated with the aecawb handler
 *
 *  This structure is used for containing the data needed by the aecawb thread
 *  handler to operate.
 **/
typedef struct {
  q3a_thread_data_t *thread_data;
  q3a_thread_aecawb_camera_data_t camera[MAX_3A_MULTI_CAMERA_ID];
} q3a_thread_aecawb_data_t;

/** q3a_thread_aecawb_get_port_data_t
 *
 *  Used to request and to send information to work with the thread handler.
 *  Module will get reference to the thread.
 *  Module will populate the q3a_thread_aecawb_camera_data_t struct using the
 *  provided @camera_id.
 *
 *    @camera_id:     Receiver should use this index to populate the requested data.
 *    @thread_data: AEC&AWB thread_data to set & module
 *                    must fill q3a_thread_aecawb_camera_data_t data.
 **/
typedef struct {
  uint8_t camera_id;
  q3a_thread_data_t *thread_data;
  q3a_thread_aecawb_camera_data_t camera;
} q3a_thread_aecawb_get_port_data_t;

/** q3a_thread_aecawb_set_port_data_t
 *
 *  Used to request and to send information to work with the thread handler.
 *  Module will get reference to the thread.
 *  Module will populate the q3a_thread_aecawb_camera_data_t struct using the
 *  provided @camera_id.
 *
 *    @camera_id:     Receiver should use this index to populate the requested data.
 *    @awbaec_thread: thread_data to be save
 *    @aec_algo_instance: Receiver, if diferent than NULL, it should update their
 *                    algo instance reference. No need to save it, it will be
 *                    restore by RESTORE_EXT_THREAD_OBJECT event.
  *  @awb_algo_instance: Same as aec_algo_instance but for AWB.
 **/
typedef struct {
  uint8_t camera_id;
  q3a_thread_data_t *awbaec_thread_data;
  void *aec_algo_instance;
  void *awb_algo_instance;
} q3a_thread_aecawb_set_port_data_t;

/** q3a_thread_restore_thread_data_t
 *
 *  Used to restore original thread in thread was overwriten.
 *
 *    @camera_id:     Receiver should use this index to populate the requested data.
 *    @q3a_thread_data: Structure containing msg queue info for the restored thread
 **/
typedef struct {
  uint8_t camera_id;
  q3a_thread_data_t *q3a_thread_data;
  void *aec_algo_instance;
  void *awb_algo_instance;
  void *af_algo_instance;
} q3a_thread_restore_thread_data_t;


/** q3a_thread_af_camera_data_t
 *    @camera_id: Camera id, this comes from session id value.
 *    @af_port:     Pointer to the AF port - needed to call the event function
 *                  of this port
 *    @af_cb:       The callback function of the port that will take the output
 *                  from the library and pass it as an event to the port's event
 *                  function.
 *    @af_stats_cb: Release stats buffer to buffer handle.
 *    @af_obj:       The af object containing all of the pointer functions to
 *                  communicate with the library. It also contains a pointer to
 *                  the internal library data so that the port's callback may
 *                  process the output data generated by the library.
 *    @af_share_algo_info: Contains information that indicated the algorithms to be use.
 **/
typedef struct {
  mct_port_t        *af_port;
  af_callback_func  af_cb;
  stats_buffer_done_callback_func af_stats_cb;
  af_object_t       *af_obj;
} q3a_thread_af_camera_data_t;

/** q3a_thread_af_data_t
 *    @thread_data: Contains the thread data associated with the aecawb handler
 *
 *  This structure is used for containing the data needed by the af thread
 *  handler to operate.
 **/
typedef struct {
  q3a_thread_data_t *thread_data;
  q3a_thread_af_camera_data_t camera[MAX_3A_MULTI_CAMERA_ID];
} q3a_thread_af_data_t;

/** q3a_thread_af_get_port_data_t
 *
 *  Used to request and to send information to work with the thread handler.
 *  Module will get reference to the thread.
 *  Module will populate the q3a_thread_af_camera_data_t struct using the
 *  provided @camera_id.
 *
 *    @camera_id:     Receiver should use this index to populate the requested data.
 *    @thread_data: AF thread_data to set & module
 *                    must fill q3a_thread_af_camera_data_t data.
 **/
typedef struct {
  uint8_t camera_id;
  q3a_thread_data_t *thread_data;
  q3a_thread_af_camera_data_t camera;
} q3a_thread_af_get_port_data_t;

/** q3a_thread_af_set_port_data_t
 *
 *  Used to request and to send information to work with the thread handler.
 *  Module will get reference to the thread.
 *  Module will populate the q3a_thread_af_camera_data_t struct using the
 *  provided @camera_id.
 *
 *    @camera_id:     Receiver should use this index to populate the requested data.
 *    @af_thread: thread_data to be save
 *    @af_algo_instance: Receiver, if diferent than NULL, it should update their
 *                    algo instance reference. No need to save it, it will be
 *                    restore by RESTORE_EXT_THREAD_OBJECT event.
 **/
typedef struct {
  uint8_t camera_id;
  q3a_thread_data_t *af_thread_data;
  void *af_algo_instance;
} q3a_thread_af_set_port_data_t;

/** q3a_thread_aecawb_msg_type_t
 *
 *  This enumeration represents the types of the messages that the AECAWB
 *  thread handler will recognize and process. SET/GET messages are for
 *  setting and getting parameters, STATS represent event messages from the
 *  ISP that contain stats.
 **/
typedef enum {
  MSG_AEC_SET,
  MSG_AEC_GET,
  MSG_AEC_STATS,
  MSG_BG_AEC_STATS,
  MSG_BE_AEC_STATS,
  MSG_HDR_BE_AEC_STATS,
  MSG_AEC_STATS_HDR,

  MSG_AWB_SET,
  MSG_AWB_GET,
  MSG_AWB_STATS,
  MSG_BG_AWB_STATS,

  MSG_STOP_THREAD,
  MSG_AEC_SEND_EVENT,
  MSG_AWB_SEND_EVENT,
  MSG_AECAWB_STATS_MODE,/* check no_stats_mode, if true, flush all exising stats and not taking stats onwards; false, processing the stats*/
} q3a_thread_aecawb_msg_type_t;

/** q3a_thread_af_msg_type_t
 *
 *  This enumeration represents the types of the messages that the AF
 *  thread handler will recognize and process. SET/GET messages are for
 *  setting and getting parameters, STATS represent event messages from the
 *  ISP that contain stats, START/CANCEL are command messages from the HAL
 *  to start or stop the focus.
 **/
typedef enum {
  MSG_AF_START,
  MSG_AF_CANCEL,
  MSG_AF_SET,
  MSG_AF_GET,
  MSG_AF_STATS,
  MSG_BF_STATS,
  MSG_AF_STOP_THREAD,
  MSG_AF_SEND_EVENT,
  MSG_AF_STATS_MODE /* check no_stats_mode, if true, flush all exising stats and not taking stats onwards; false, processing the stats*/
} q3a_thread_af_msg_type_t;

/** msg_sync_t
 *    @msg_sem: semaphore to synchronize the "Sync" messages
 *
 *  This structure is used for creating synchronized messages in the queue.
 *  When such message arrives, the enqueue function will block until the
 *  message is processed by the thread handler and the library returns with
 *  the result.
 **/
typedef struct {
  sem_t  msg_sem;
} msg_sync_t;

/** q3a_thread_aecawb_msg_t
 *    @camera_id: Camera id, set by thread manager.
 *    @type:         Indicates the type of the message to be processed by the
 *                   thread.
 *    @sync_flag:    If the message is synced.
 *    @sync_obj:     The sync object to implement the syncing
 *    @is_priority:  A flag indicating if the message is with priority. If yes,
 *                   it will be put into the priority queue.
 *    @stats:        Calculated stats form the ISP.
 *    @aec_set_parm: Used to set a parameter for the AEC.
 *    @aec_get_parm: Used to get a parameter from the AEC.
 *    @awb_set_parm: Used to set a parameter for the AWB.
 *    @awb_get_parm: Used to get a parameter from the AWB.
 *
 *  This structure is used for creating the messages to be put in the queue
 *  of the AECABW thread handler. The messages can be made synchronized (the
 *  caller will block until the message gets processed) as well as prioritized
 *  in order to get processed before all the other messages waiting in the
 *  normal queue.
 **/
typedef struct {
  uint8_t                 camera_id;
  q3a_thread_aecawb_msg_type_t type;
  boolean         sync_flag;
  msg_sync_t      *sync_obj;
  boolean         is_priority;
  union {
    stats_t *stats;
    aec_set_parameter_t aec_set_parm;
    aec_get_parameter_t aec_get_parm;
    awb_set_parameter_t awb_set_parm;
    awb_get_parameter_t awb_get_parm;
  }u;
} q3a_thread_aecawb_msg_t;

/** q3a_thread_af_msg_t
 *    @camera_id: Camera id, this comes from session id value.
 *    @type:        Indicates the type of the message to be processed by the
 *                  thread.
 *    @sync_flag:   If the message is synced.
 *    @sync_obj:    The sync object to implement the syncing
 *    @is_priority: A flag indicating if the message is with priority. If yes,
 *                  it will be put into the priority queue.
 *    @stats:       Calculated AF stats form the ISP.
 *    @af_set_parm: Used to set a parameter for the AF.
 *    @af_get_parm: Used to get a parameter from the AF.
 *
 *  This structure is used for creating the messages to be put in the queue
 *  of the AF thread handler. The messages can be prioritized in order to get
 *  processed before all the other messages waiting in the normal queue.
 **/
typedef struct {
  uint8_t                  camera_id;
  q3a_thread_af_msg_type_t type;
  boolean                  sync_flag;
  msg_sync_t               *sync_obj;
  boolean                  is_priority;
  union {
    stats_af_t         *stats;
    af_set_parameter_t af_set_parm;
    af_get_parameter_t af_get_parm;
  }u;
} q3a_thread_af_msg_t;


/* AEC/AWB thread */
q3a_thread_aecawb_data_t* q3a_thread_aecawb_init(void);
void q3a_thread_aecawb_deinit(q3a_thread_aecawb_data_t *data);
boolean q3a_thread_aecawb_start(q3a_thread_aecawb_data_t *aecawb_data,
  q3a_thread_handler_t thread_handler, const char *thread_name);
boolean q3a_thread_aecawb_stop(q3a_thread_aecawb_data_t *aecawb_data);
boolean q3a_aecawb_thread_en_q_msg(void *aecawb_data,
  q3a_thread_aecawb_msg_t  *msg);
void q3a_thread_aecawb_free_msg(q3a_thread_aecawb_msg_t **msg_pp);
void* aecawb_thread_handler(void *aecawb_data);

/* AF thread */
q3a_thread_af_data_t* q3a_thread_af_init(void);
void q3a_thread_af_deinit(q3a_thread_af_data_t *data);
boolean q3a_thread_af_start(q3a_thread_af_data_t *af_data,
  q3a_thread_handler_t thread_handler, const char *thread_name);
boolean q3a_thread_af_stop(q3a_thread_af_data_t *af_data);
boolean q3a_af_thread_en_q_msg(void *af_data,
  q3a_thread_af_msg_t  *msg);
void q3a_thread_af_free_msg(q3a_thread_af_msg_t **msg_pp);
void* af_thread_handler(void *af_data);

#endif /* __Q3A_THREAD_H__ */
