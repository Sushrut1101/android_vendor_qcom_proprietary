/*
 * Copyright (c) 2015-2017 Qualcomm Atheros, Inc.
 *
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 */

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Copyright (c) 2011 The FreeBSD Foundation
 * All rights reserved.
 * Portions of this software were developed by David Chisnall
 * under sponsorship from the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2014-2015 The Linux Foundation. All rights reserved.
 *
 * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
 *
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This file was originally distributed by Qualcomm Atheros, Inc.
 * under proprietary terms before Copyright ownership was assigned
 * to the Linux Foundation.
 */

#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <inttypes.h>
#include <sys/socket.h>
#include <stdbool.h>
#include <linux/netlink.h>
#include "cld-diag-parser.h"
#include "dbglog.h"

#define TRUE 1
#define FALSE 0
typedef  unsigned char      boolean;

typedef struct
{
	uint32_t reserved:24;
	uint32_t diag_event_type:8;
}__attribute__((packed)) fw_diag_msg_fixed_hdr_t;

typedef struct
{
	uint32_t timestamp:24;
	uint32_t diag_event_type:8;
	/* Below 16-bit field has different formats based on event type */
	union {
		uint16_t payload_len;
		struct {
			uint8_t payload_len;
			uint8_t vdev_level:3;
			uint8_t vdev_id:5;
		}__attribute__((packed)) msg_hdr;
	}__attribute__((packed)) u;
	uint16_t diag_id;
	uint8_t  payload[0];
}__attribute__((packed)) fw_diag_msg_hdr_t;

typedef struct
{
	uint32_t unused:24;
	uint32_t diag_event_type:8;
	uint32_t timestamp;
	/* Below 16-bit field has different formats based on event type */
	union {
		uint16_t payload_len;
		struct {
			uint8_t payload_len;
			uint8_t vdev_level:3;
			uint8_t vdev_id:5;
		}__attribute__((packed)) msg_hdr;
	}__attribute__((packed)) u;
	uint16_t diag_id;
	uint8_t  payload[0];
}__attribute__((packed)) fw_diag_msg_hdr_v2_t;

typedef struct diag_entry {
	uint32_t id;
	boolean isUsed;

	/* database - userspace */
	char *format;
	char *pack;

	/* runtime message - generated by target */
	char *msg;
	uint32_t msg_len;
}diag_entry;

typedef struct file_header {
	int32_t  file_version;
	int32_t  n_entries;
	int32_t  n_usedEntries;
	int32_t  hash;
}file_header;

static diag_entry *gdiag_db = NULL;
static file_header *gdiag_header = NULL;
static int32_t gisdiag_init = FALSE;
static uint64_t base_timestamp = 0;
extern int32_t num_wrapped;

#ifdef CONFIG_ANDROID_LOG
#define debug_printf(...) do {                         \
	if (DEBUG_FLAG)                  \
		__android_log_print(ANDROID_LOG_INFO,  \
			FWDEBUG_NAME, __VA_ARGS__);    \
} while(0)
#else
#define debug_printf(...) do {} while(0);
#endif

/*
 * Flags used during conversion.
 */
#define ALT         0x001		/* alternate form */
#define LADJUST     0x004		/* left adjustment */
#define LONGDBL     0x008		/* long double */
#define LONGINT     0x010		/* long integer */
#define LLONGINT    0x020		/* long long integer */
#define SHORTINT    0x040		/* short integer */
#define ZEROPAD     0x080		/* zero (as opposed to blank) pad */
#define FPT         0x100		/* Floating point number */
#define GROUPING    0x200		/* use grouping ("'" flag) */
                                /* C99 additional size modifiers: */
#define SIZET       0x400		/* size_t */
#define PTRDIFFT    0x800		/* ptrdiff_t */
#define INTMAXT     0x1000		/* intmax_t */
#define CHARINT     0x2000		/* print char using int format */

/*
 * macros to safely extract 8, 16, 32, or 64-bit values from byte buffer
 */
#define GET_8(v, msg, msg_len) do {         \
	if (msg_len < sizeof(uint8_t)) {    \
		goto msg_error;             \
	}                                   \
	v = *msg;                           \
	msg += sizeof(uint8_t);             \
	msg_len -= sizeof(uint8_t);         \
} while (0)

#define _GET_LE16(a) ( \
	(((uint16_t)(a)[1]) << 8) | \
	 ((uint16_t)(a)[0]))
#define GET_LE16(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint16_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE16(msg);                 \
	msg += sizeof(uint16_t);            \
	msg_len -= sizeof(uint16_t);        \
} while (0)

#define _GET_LE32(a) ( \
	(((uint32_t)(a)[3]) << 24) | \
	(((uint32_t)(a)[2]) << 16) | \
	(((uint32_t)(a)[1]) << 8)  | \
	((uint32_t)(a)[0]))
#define GET_LE32(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint32_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE32(msg);                 \
	msg += sizeof(uint32_t);            \
	msg_len -= sizeof(uint32_t);        \
} while (0)

#define _GET_LE64(a) ( \
	(((uint64_t)(a)[7]) << 56) | \
	(((uint64_t)(a)[6]) << 48) | \
	(((uint64_t)(a)[5]) << 40) | \
	(((uint64_t)(a)[4]) << 32) | \
	(((uint64_t)(a)[3]) << 24) | \
	(((uint64_t)(a)[2]) << 16) | \
	(((uint64_t)(a)[1]) << 8) | \
	((uint64_t)(a)[0]))
#define GET_LE64(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint64_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE64(msg);                 \
	msg += sizeof(uint64_t);            \
	msg_len -= sizeof(uint64_t);        \
} while (0)

/*
 * pack_printf derived from Rome FW's cmnos_vprintf which
 * internally is using the FreeBSD version implementation.
 */

/*
 * Macros for converting digits to letters and vice versa
 */
#define to_digit(c)	((c) - '0')
#define is_digit(c)	((unsigned)to_digit(c) <= 9)
#define to_char(n)	((n) + '0')

/*
 * Convert an unsigned long to ASCII for printf purposes, returning
 * a pointer to the first character of the string representation.
 * Octal numbers can be forced to have a leading zero; hex numbers
 * use the given digits.
 */
static char *
__ultoa(unsigned long long val, char *endp, int base, int octzero,
        const char *xdigs)
{
	char *cp = endp;

	if (endp == NULL || xdigs == NULL) {
		debug_printf("%s: Input parameter invalid", __func__);
		return endp;
	}

	/*
	 * Handle the three cases separately, in the hope of getting
	 * better/faster code.
	 */
	switch (base) {
	case 10:
		if (val < 10) {	/* many numbers are 1 digit */
			*--cp = to_char(val);
			return (cp);
		}
		do {
			*--cp = to_char(val % 10);
			val /= 10;
		} while (val != 0);
		break;

	case 8:
		do {
			*--cp = to_char(val & 7);
			val >>= 3;
		} while (val);
		if (octzero && *cp != '0')
			*--cp = '0';
		break;

	case 16:
		do {
			*--cp = xdigs[val & 15];
			val >>= 4;
		} while (val);
		break;

	case 2:
		do {
			*--cp = to_char(val & 1);
			val >>= 1;
		} while (val);
		break;
	default:			/* oops */
		break;
	}
	return (cp);
}

/* Return successive characters in a format string. */
char fmt_next_char(const char **fmtptr)
{
	char ch;

	ch = **fmtptr;
	if (ch != '\0') {
		(*fmtptr)++;
	}
	return ch;
}

/* Return current characters in a format string. */
char fmt_cur_char(const char **fmtptr)
{
	char ch;
	ch = **fmtptr;
	return ch;
}

long long get_value_from_msg(char pack, uint8_t **msg, uint32_t *msg_len)
{
	switch (pack) {
	case 'b':
	{
		signed char val = 0;
		GET_8(val, *msg, *msg_len);
		return val;
	}
	case 'B':
	{
		unsigned char val = 0;
		GET_8(val, *msg, *msg_len);
		return val;
	}
	case 'h':
	{
		int16_t val = 0;
		GET_LE16(val, *msg, *msg_len);
		return val;
	}
	case 'H':
	{
		uint16_t val = 0;
		GET_LE16(val, *msg, *msg_len);
		return val;
	}
	case 'i':
	{
		int32_t val = 0;
		GET_LE32(val, *msg, *msg_len);
		return val;
	}
	case 'I':
	{
		uint32_t val = 0;
		GET_LE32(val, *msg, *msg_len);
		return val;
	}
	case 'q':
	{
		int64_t val = 0;
		GET_LE64(val, *msg, *msg_len);
		return val;
	}
	case 'Q':
	{
		uint64_t val = 0;
		GET_LE64(val, *msg, *msg_len);
		return val;
	}
	default:
		return 0;
	}
msg_error:
		return 0;
}

/*
 * The size of the buffer we use as scratch space for integer
 * conversions, among other things.  We need enough space to
 * write a uintmax_t in octal (plus one byte).
 */
#define	BUF	(sizeof(long long)*8)

static int
pack_printf(
    void (*write_char)(char **pbs, char *be, char c),
    char **pbuf_start,
    char *buf_end,
    const char *fmt0,
    const char *pack,
    uint8_t *msg,
    uint32_t msg_len)
{
	const char *fmt;     /* format string */
	int ch;              /* character from fmt */
	int n;               /* handy integer (short term usage) */
	char *cp;            /* handy char pointer (short term usage) */
	int flags;           /* flags as above */
	int ret;             /* return value accumulator */
	int width;           /* width from format (%8d), or 0 */
	int prec;            /* precision from format; <0 for N/A */
	char sign;           /* sign prefix (' ', '+', '-', or \0) */

	long long ulval;     /* integer arguments %[diouxX] */
	int base;            /* base for [diouxX] conversion */
	int dprec;           /* a copy of prec if [diouxX], 0 otherwise */
	int realsz;          /* field size expanded by dprec, sign, etc */
	int size;            /* size of converted field or string */
	int prsize;          /* max size of printed field */
	const char *xdigs;   /* digits for %[xX] conversion */
	char buf[BUF];       /* buffer with space for digits of uintmax_t */
	char ox[2];          /* space for 0x; ox[1] is either x, X, or \0 */
	int pad;             /* pad */

	static const char xdigs_lower[16] = "0123456789abcdef";
	static const char xdigs_upper[16] = "0123456789ABCDEF";

	fmt = (char *)fmt0;
	ret = 0;
	size = 0;
	xdigs = xdigs_lower;

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
		for (cp = (char *)fmt; (ch = fmt_cur_char(&fmt)) != '\0' && ch != '%';
			 ch = fmt_next_char(&fmt)){
			write_char(pbuf_start, buf_end, ch);
			ret++;
		}

		if (ch == '\0')
			goto done;
		fmt_next_char(&fmt);		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
		ox[1] = '\0';

rflag:		ch = fmt_next_char(&fmt);
reswitch:	switch (ch) {
		case ' ':
			/*-
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			ch = fmt_next_char(&fmt);
			prec = 0;
			while (is_digit(ch)) {
				prec = 10 * prec + to_digit(ch);
				ch = fmt_next_char(&fmt);
			}
			goto reswitch;
		case '0':
			/*-
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit(ch);
				ch = fmt_next_char(&fmt);
			} while (is_digit(ch));
			width = n;
			goto reswitch;
		case 'l':
			if (flags & LONGINT) {
				flags &= ~LONGINT;
				flags |= LLONGINT;
			} else
				flags |= LONGINT;
			goto rflag;
		case 'C':
			flags |= LONGINT; /* Do not support WCHAR */
			/*FALLTHROUGH*/
		case 'c':
			if (msg_len) {
				cp = (char *)msg++;
				msg_len--;
				size = 1;
				sign = '\0';
			}
			break;
		case 'D':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg, &msg_len);
			if (ulval < 0) {
				ulval = -ulval;
				sign = '-';
			}
			base = 10;
			goto number;
		case 'p':
			/*-
			 * ``The argument shall be a pointer to void.  The
			 * value of the pointer is converted to a sequence
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			ulval = (int)get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 16;
			xdigs = xdigs_lower;
			ox[1] = 'x';
			goto nosign;
		case 'S':
		case 's':
			/* Not Supported */
			cp = "<null>";
			size = 0;
			while (cp[size] != '\0') size++;
			sign = '\0';
			break;
		case 'O':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 8;
			goto nosign;
		case 'B':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'b':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 2;
			goto nosign;
		case 'U':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 10;
			goto nosign;
		case 'X':
			xdigs = xdigs_upper;
			goto hex;
		case 'x':
			xdigs = xdigs_lower;
hex:

			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 16;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && ulval != 0)
				ox[1] = ch;

			/* unsigned conversions */
nosign:			sign = '\0';
			/*-
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
					flags &= ~ZEROPAD;

			/*-
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 *
			 * ``The C Standard is clear enough as is.  The call
			 * printf("%#.0o", 0) should print 0.''
			 *	-- Defect Report #151
			 */
			cp = buf + BUF;
			if (ulval != 0 || prec != 0 ||
			    (flags & ALT && base == 8)){
				cp = __ultoa(ulval, cp, base,
				    flags & ALT, xdigs);
			}
			size = buf + BUF - cp;

			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
		}

		/*
		 * All reasonable formats wind up here.  At this point, `cp'
		 * points to a string which (if not flags&LADJUST) should be
		 * padded out to `width' places.  If flags&ZEROPAD, it should
		 * first be prefixed by any sign or other prefix; otherwise,
		 * it should be blank padded before the prefix is emitted.
		 * After any left-hand padding and prefixing, emit zeroes
		 * required by a decimal [diouxX] precision, then print the
		 * string proper, then emit zeroes required by any leftover
		 * floating precision; finally, if LADJUST, pad with blanks.
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
			realsz++;
		if (ox[1])
			realsz += 2;

		prsize = width > realsz ? width : realsz;
		pad =  width - realsz;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, ' ');
			}
		}

		/* prefix */
		if (sign){
			write_char(pbuf_start, buf_end, sign);
			pad--;
		}

		if (ox[1]) {	/* ox[1] is either x, X, or \0 */
			ox[0] = '0';
			write_char(pbuf_start, buf_end, ox[0]);
			pad--;
			write_char(pbuf_start, buf_end, ox[1]);
			pad--;
		}

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, '0');
			}
		}

		while (size-- > 0) {
			ch = *cp++;
			(*write_char)(pbuf_start, buf_end, ch);
		}

		/* left-adjusting padding (always blank) */
		if (flags & LADJUST){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, ' ');
			}
		}

		/* finally, adjust ret */
		ret += prsize;
	}
done:

	return (ret);
	/* NOTREACHED */
}

static void
format_pack( const char *pack,  char *buf, uint32_t buflen)
{
	char c;
	uint32_t num = 0, index = 0, i = 0;
	boolean isfound = 0;
	memset(buf, 0 , buflen);
	while ((c = fmt_next_char(&pack)) != '\0') {
		if (index >= buflen -1)
			break;
		while (is_digit(c)) {
			num = (i++ * 10) + (c - '0');
			c = fmt_next_char(&pack);
			isfound = TRUE;
		}
		if (isfound) {
			while (num--) {
				buf[index++] = c;
				if (index >= buflen -1)
					break;
			}
			num = 0;
			i = 0;
		}
		else
			buf[index++] = c;
	}
	buf[index] = '\0';
}

static int
diag_printf(const char *buf,  uint16_t vdevid,  uint16_t level,
            uint64_t timestamp, FILE *log_out)
{
	char pbuf[512];
	if (vdevid < DBGLOG_MAX_VDEVID)
		snprintf(pbuf, 512, "FWMSG: [%lu] vap-%u %s", timestamp,
			 vdevid, buf);
	else
		snprintf(pbuf, 512, "FWMSG: [%lu] %s", timestamp, buf);

	return 0;
}

/*
 * database initialization
 */
static void
diag_create_db(uint32_t n_entries)
{
	gdiag_header = calloc(1, sizeof(*gdiag_header));
	if (!gdiag_header)
		return;
	gdiag_header->n_entries = n_entries;
	gdiag_db = calloc(gdiag_header->n_entries, sizeof(*gdiag_db));
	if (!gdiag_db)
		return;
	/* hash */
	gdiag_header->hash = (gdiag_header->n_entries % 2 == 0) ?  \
		gdiag_header->n_entries / 2 :                      \
		(gdiag_header->n_entries + 1) / 2;
}

/*
 * database free
 */
static void
diag_free_db()
{
	int32_t count = 0;
	if (gdiag_db && gdiag_header) {
		for (count = 0; count < gdiag_header->n_entries; count++) {
			if (gdiag_db[count].isUsed){
				if (gdiag_db[count].format)
					free(gdiag_db[count].format);
				if (gdiag_db[count].pack)
					free(gdiag_db[count].pack);
			}
		}
	}
	if (gdiag_db)
		free(gdiag_db);
	gdiag_db = NULL;
	if (gdiag_header)
		free(gdiag_header);
	gdiag_header = NULL;
	gisdiag_init = FALSE;
}

/*
 * insert into database
 */
static int32_t
diag_insert_db(char *format, char *pack, int32_t id)
{
	/* Double Hashing  */
	int32_t i = id % gdiag_header->n_entries;
	int32_t j = gdiag_header->hash - (id % gdiag_header->hash);
	if (gdiag_header->n_entries == gdiag_header->n_usedEntries) {
		printf("db is full");
		return 0;
	}
	/* search */
	while (gdiag_db[i].isUsed) {
		i = (i + j)%gdiag_header->n_entries;
	}

	gdiag_db[i].id = id;
	gdiag_db[i].format = format;
	gdiag_db[i].pack = pack;
	gdiag_db[i].isUsed = TRUE;
	gdiag_header->n_usedEntries++;
	return 1;
}

/*
 * parser looks up entry at runtime based on 'id' extracted from FW
 * message
 */
static diag_entry*
diag_find_by_id( uint32_t id)
{
	boolean isfound = FALSE;
	int32_t count = 0;
	int32_t i = id % gdiag_header->n_entries;
	int32_t j = gdiag_header->hash - (id % gdiag_header->hash);
	if (gdiag_header->n_usedEntries == 0) {
		return NULL;
	}
	while (gdiag_db[i].isUsed != 0 && count <= gdiag_header->n_entries) {
		if (gdiag_db[i].id == id) {
			isfound = TRUE;
			break;
		}
		i = (i + j) % gdiag_header->n_entries;
		count++;
	}
	if (!isfound) {
		debug_printf("Not found in data base\n");
		return NULL;
	}
	return &gdiag_db[i];
}

/* user  supply their own function to build string in temporary
 * buffer
 */
static void dbg_write_char(char **pbuf_start, char *buf_end, char c)
{
	if ( *pbuf_start < buf_end) {
		*(*pbuf_start) = c;
		++(*pbuf_start);
	}
}

static uint32_t
get_numberofentries()
{
	FILE* fd;
	char line[1024];
	int32_t n_entries = 0, i = 0;
	boolean  isfound = FALSE;
	if ((fd = fopen(DB_FILE_PATH, "r")) == NULL) {
		diag_printf("[Error] : While opening the file\n",
		    0, 4, 0, NULL);
		return 0;
	}
	while ( fgets (line, sizeof(line), fd) != NULL ) {
		n_entries++;
	}
	/* Decrement 1 for version and the last line /r/n */
	n_entries-= 2;

	/* check if n_entries is prime number else change to prime number */
	while (1) {
		for (i = 2; i<n_entries; i++) {
			if ( n_entries % i == 0 ) {
				/* n_entries is divisible, break for loop */
				isfound = TRUE;
				break;
			}
		}
		if (!isfound && n_entries > 2)
			break;
		isfound = FALSE;
		/* Increment n_entries and check is it prime number */
		n_entries++;
	}
	fclose(fd);
	printf( "Number of entries is %d\n", n_entries);
	return n_entries;
}

static uint32_t
parse_dbfile()
{
	FILE* fd;
	uint32_t n_entries = 0;
	uint32_t id = 0;
	char line[1024], *p = NULL, *pack = NULL, *format = NULL;
	char pbuf[128], *q = NULL;
	char *save;
	n_entries = get_numberofentries( );
	diag_create_db(n_entries );
	n_entries = 0;
	/*Open the data.msc file*/
	if ((fd = fopen(DB_FILE_PATH , "r")) == NULL) {
		diag_printf("[Error] : While opening the file\n",
		    0, 4, 0, NULL);
		return 0;
	}
	memset(line, 0 , sizeof(line));
	while ( fgets (line, sizeof(line), fd) != NULL ) {
		n_entries++;
		if (n_entries == 1) {
			/* Parse for the version */
			p = strstr(line, "VERSION:");
			if (p) {
				p += strlen("VERSION:");
				gdiag_header->file_version = atoi(p);
			}
			else {
				fclose(fd);
				return 0;
			}
		} else {
			p = strtok_r(line, ",", &save);
			if (p)
				id = atoi(p);
			else
				continue;

			p = strtok_r(NULL, ",", &save);
			if (p)
				pack = strdup(p);
			else
				continue;

			p = strtok_r(NULL, "\r", &save);
			if (p) {
				format = strdup(p);
				if (format) {
					/* Check for CR */
					p = strstr(format, "\r");
					if (p)
						*p = '\0';
					else {
						p = strstr(format, "\n");
						if (p)
							*p = '\0';
					}
				}
			} else {
				/* Else CASE for pack specifier is 0  */
				if (pack) {
					/* Check for CR */
					p = strstr(pack, "\r");
					if (p)
						*p = '\0';
					else {
						p = strstr(pack, "\n");
						if (p)
							*p = '\0';
					}
					format = pack;
					pack = NULL;
				}
			}
			/* Go through the pack specifier, to find
			   pack with number */
			if (pack) {
				q = pack;
				format_pack(pack, pbuf, sizeof(pbuf));
				pack = strdup(pbuf);
				free(q);
			}
			if (!diag_insert_db(format, pack, id)) {
				fclose(fd);
				return 0;
			}
		}
		memset(line, 0 , sizeof(line));
	}
	fclose(fd);
	return n_entries;
}

void
diag_initialize()
{
	uint32_t ret;
	diag_free_db();
	ret = parse_dbfile();
	if (ret > 1)
		gisdiag_init = TRUE;
}

/*
 * ts is time stamp provided by firmware, first converting it to millisecond
 * and then returning in hh:mm:ss:msc format
 */
void miliseconds_to_time(uint64_t ts, char *time)
{
	uint8_t h, m, s;
	uint64_t ms;

	ts = ts/1000;
	ms = ts % 1000;
	ts /= 1000;
	s = ts % 60;
	ts /= 60;
	m = ts % 60;
	h = ts / 60;

	memset(time, 0, MAX_TIME_LEN);
	snprintf(time, MAX_TIME_LEN, "%02d:%02d:%02d.%03lu", h, m, s, ms);
}

uint32_t
parse_diagfw_msg(uint8_t *datap, uint32_t len, FILE *log_out,
		 uint16_t parse_flag)
{
	uint32_t count = 0;
#ifdef CONFIG_ANDROID_LOG
	uint32_t index = 0;
	uint16_t vdevlevel = 0;
#endif
	uint64_t timestamp = 0;
	uint32_t diagid = 0, id = 0;
	uint32_t moduleid = 0;
	uint32_t num_buf = 0, payloadlen = 0;
	uint16_t vdevid = 0;
	fw_diag_msg_fixed_hdr_t *diag_msg_fixed_hdr;
	fw_diag_msg_hdr_t *diag_msg_hdr;
	fw_diag_msg_hdr_v2_t *diag_msg_hdr_v2;
	char *payload;
	char buf[BUF_SIZ], payload_buf[BUF_SIZ];
	char *start = buf;
	diag_entry *entry = NULL;
	uint16_t hdr_size = 0;
	char time[MAX_TIME_LEN];
#ifdef CONFIG_ANDROID_LOG
	int32_t i =0, j =0;
	int ret = 0, total_dump_len = 0;
	uint8_t *debugp = datap;
	char dump_buffer[READ_LEN];
		memset(dump_buffer, 0, sizeof(dump_buffer));
		debug_printf("process_diagfw_msg hex dump start len %d\n", len);
		for (i = 0; i < len; i++) {
			ret = snprintf(dump_buffer + j, READ_LEN - j,
				       "0x%x ", debugp[i]);
			j += ret;
			if (!(i % 16) && (i!=0)) {
				total_dump_len += 16;
				printf("%s", dump_buffer);
				memset(dump_buffer, 0, sizeof(dump_buffer));
				printf("\n");
				j = 0;
			}
		}
		if (total_dump_len != len)
			printf("%s", dump_buffer);
		debug_printf("process_diagfw_msg hex dump end");
#endif

	if (!gisdiag_init) {
		/* If cnss_diag is started if WIFI already ON,
		* then turn on event not received hence
		* before throwing out error initialize again
		*/
		diag_initialize();
		if (!gisdiag_init) {
			diag_printf("**ERROR** Diag not Initialized",
			    0, 4, 0, NULL);
			return -1;
		}
	}
	num_buf = len;
	while (num_buf  > count) {
		diag_msg_fixed_hdr = (fw_diag_msg_fixed_hdr_t *)datap;
		diagid  = diag_msg_fixed_hdr->diag_event_type;
		if (diagid < WLAN_DIAG_TYPE_EVENT_V2) {
			diag_msg_hdr = (fw_diag_msg_hdr_t *)datap;
			timestamp  = diag_msg_hdr->timestamp;
			hdr_size = sizeof(fw_diag_msg_hdr_t);
			payloadlen = 0;
			debug_printf("\n diagid = %d  timestamp = %lu"
				     " header1 = %x heade2 = %x\n",
				     diagid, timestamp, header1, header2);
			debug_printf("\n diagid = %d  timestamp = %lu\n",
				     diagid,  timestamp);

			id = diag_msg_hdr->diag_id;
			payload = (char *)(diag_msg_hdr->payload);
			payloadlen = diag_msg_hdr->u.msg_hdr.payload_len;
			vdevid = diag_msg_hdr->u.msg_hdr.vdev_id;
#ifdef CONFIG_ANDROID_LOG
			vdevlevel = diag_msg_hdr->u.msg_hdr.vdev_level;
#endif
			if (diagid == WLAN_DIAG_TYPE_CONFIG &&
			    id == DIAG_BASE_TIMESTAMP) {
				base_timestamp = *((uint64_t *)payload);
			}
		} else {
			diag_msg_hdr_v2 = (fw_diag_msg_hdr_v2_t *)datap;
			timestamp  = (uint64_t)(diag_msg_hdr_v2->unused) << 32;
			timestamp  |= (uint32_t)(diag_msg_hdr_v2->timestamp);
			hdr_size = sizeof(fw_diag_msg_hdr_v2_t);
			payloadlen = 0;
			debug_printf("\n diagid = %d  timestamp = %lu"
				     " header1 = %x heade2 = %x\n",
				     diagid,  timestamp, header1, header2);
			debug_printf("\n diagid = %d  timestamp = %lu\n",
				     diagid,  timestamp);

			id = diag_msg_hdr_v2->diag_id;
			payload = (char *)(diag_msg_hdr_v2->payload);
			payloadlen = diag_msg_hdr_v2->u.msg_hdr.payload_len;
			vdevid = diag_msg_hdr_v2->u.msg_hdr.vdev_id;
#ifdef CONFIG_ANDROID_LOG
			vdevlevel = diag_msg_hdr_v2->u.msg_hdr.vdev_level;
#endif
		}

		timestamp  += base_timestamp;
		memset(buf, 0, BUF_SIZ);
		memset(payload_buf, 0, BUF_SIZ);

		debug_printf(" DIAG_TYPE_FW_DEBUG_MSG: "
			     "vdevid %d vdevlevel %d payloadlen = %d id = %d\n",
			     vdevid, vdevlevel, payloadlen, id);
		entry = diag_find_by_id(id);
		if (entry) {
			if ((payloadlen > 0) && (entry->format && entry->pack)) {
				debug_printf("entry->format = %s"
					     " pack = %s\n",
					     entry->format,
					     entry->pack);
				if (payloadlen < BUF_SIZ)
					memcpy(payload_buf, payload, payloadlen);
				else
					memcpy(payload_buf, payload, BUF_SIZ);
					/* Sending with BUF_SIZ to pack_printf
					 * because some times payloadlen
					 * received doesnt match with the pack
					 * specifier, in that case just print
					 * the zero
					 */
				entry->msg_len = BUF_SIZ;
				entry->msg = payload_buf;
				start = buf;
				pack_printf(dbg_write_char,
					    &start,
					    start + sizeof(buf),
					    entry->format,
					    entry->pack,
					    (uint8_t*)entry->msg,
					    entry->msg_len);
			} else if (entry->format) {
				strncpy(buf, entry->format,
					strlen(entry->format));
			}
			if (hdr_size == sizeof(fw_diag_msg_hdr_v2_t)) {
				miliseconds_to_time(timestamp, time);
				if (vdevid < DBGLOG_MAX_VDEVID)
					printf("%s [%" PRIx64 "] vap-%u %s\n", time,
					       timestamp, vdevid, buf);
				else
					printf("%s [%" PRIx64 "] %s\n", time,
					       timestamp, buf);
			} else
				printf("%s\n", buf);
		} else {
			switch (id) {
				case DIAG_WLAN_MODULE_STA_PWRSAVE:
				case DIAG_WLAN_MODULE_WAL:
				case DIAG_NAN_MODULE_ID:
				case DIAG_WLAN_MODULE_IBSS_PWRSAVE:
					if (!diag_msg_handler(id, payload,
						vdevid, timestamp)) {
						snprintf(buf, BUF_SIZ,
							 "****WARNING****, "
							 "undefined moduleid = "
							 "%d not found",
							 moduleid);
						diag_printf(buf, 0, 4,
							    timestamp,
							    NULL);
					}
					break;
				case DIAG_BASE_TIMESTAMP:
					printf("diagid: WLAN_DIAG_TYPE_CONFIG "
					       "base_timestamp received: %lu\n",
					       base_timestamp);
					break;
				default:
					snprintf(buf, BUF_SIZ,
						 "****WARNING****, FWMSG ID %d"
						 " not found", id);
					diag_printf(buf, 0, 4,
						    timestamp, NULL);
					printf("NOT found id = %d\n", id);
			}
		}
		count  += payloadlen + hdr_size;
#ifdef CONFIG_ANDROID_LOG
		index = count >> 2;
#endif
		if (parse_flag & WITHOUT_RING_FLAG)
			datap = (uint8_t *) datap + payloadlen + hdr_size;
		debug_printf("Loop end:id = %d  payloadlen = %d"
			     " count = %d index = %d\n",
			     id,  payloadlen,  count, index);
	}
	return (0);
}
