/*
 * Copyright (c) 2020 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 * Not a Contribution.
 * Apache license notifications and license are retained
 * for attribution purposes only.
 */
 /*
 * Copyright 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SYSTEM_KEYMASTER_KEYMASTER_TAGS_H_
#define SYSTEM_KEYMASTER_KEYMASTER_TAGS_H_

/**
 * This header contains various definitions that make working with keymaster tags safer and easier.
 * It makes use of a fair amount of template metaprogramming, which is genarally a bad idea for
 * maintainability, but in this case all of the metaprogramming serves the purpose of making it
 * impossible to make certain classes of mistakes when operating on keymaster authorizations.  For
 * example, it's an error to create a keymaster_param_t with tag == KM_TAG_PURPOSE and then to
 * assign KM_ALGORITHM_RSA to the enumerated element of its union, but because "enumerated" is a
 * uint32_t, there's no way for the compiler, ordinarily, to diagnose it.  Also, generic functions
 * to manipulate authorizations of multiple types can't be written, because they need to know which
 * union parameter to modify.
 *
 * The machinery in this header solves these problems.  The core elements are two templated classes,
 * TypedTag and TypedEnumTag.  These classes are templated on a tag type and a tag value, and in the
 * case of TypedEnumTag, an enumeration type as well.  Specializations are created for each
 * keymaster tag, associating the tag type with the tag, and an instance of each specialization is
 * created, and named the same as the keymaster tag, but with the KM_ prefix omitted.  Because the
 * classes include a conversion operator to keymaster_tag_t, they can be used anywhere a
 * keymaster_tag_t is expected.
 *
 * They also define a "value_type" typedef, which specifies the type of values associated with that
 * particular tag.  This enables template functions to be written that check that the correct
 * parameter type is used for a given tag, and that use the correct union entry for the tag type.  A
 * very useful example is the overloaded "Authorization" function defined below, which takes tag and
 * value arguments and correctly constructs a keyamster_param_t struct.
 *
 * Because the classes have no data members and all of their methods are inline, they have ZERO
 * run-time cost in and of themselves.  The one way in which they can create code bloat is when
 * template functions using them are expanded multiple times.  The standard method of creating
 * trivial, inlined template functions which call non-templated functions which are compact but not
 * type-safe, allows the program to have both the type-safety of the templates and the compactness
 * of the non-templated functions, at the same time.
 */

#include <hardware/hw_auth_token.h>
#include <hardware/keymaster_defs.h>

#define KM_HMAC_PARAMS_SIZE (32)

typedef struct {
    uint8_t seed[KM_HMAC_PARAMS_SIZE];
    uint8_t nonce[KM_HMAC_PARAMS_SIZE];
}hmac_sharing_params_t;

/**
 * VerificationToken enables one Keymaster instance to validate authorizations for another. See
 * verifyAuthorizations() in IKeymaster for details.
 */
typedef struct {
    /**
     * challenge is the operation handle (or other challenge) used to ensure freshness.
     */
    uint64_t challenge;
    /**
     * timestamp contains the current time (as used in auth tokens) of the secure environment that
     * generates the VerificationToken.  This can be checked against auth tokens generated by the
     * same secure environment, which avoids needing to synchronize clocks.
     */
    uint64_t timestamp;
    /**
     * A list of the parameters verified.  Empty if the only parameters verified are
     * time-related. In that case the timestamp is the payload. Unused
     */
    //uint32_t parametersVerifiedOffset;
    //uint32_t parametersVerifiedSize;

    /**
     * SecurityLevel of the secure environment that generates the token.
     */
    keymaster_security_level_t securityLevel;

    /**
     * 32-byte HMAC of the above values, computed as:
     *
     *    HMAC(H,
     *         "Auth Verification" || challenge || timestamp || securityLevel || parametersVerified)
     *
     * where:
     *
     *   ``HMAC'' is the shared HMAC key (see computeSharedHmac() in IKeymaster).
     *
     *   ``||'' represents concatenation
     *
     * The representation of challenge and timestamp is as 64-bit unsigned integers in big-endian
     * order. securityLevel is represented as a 32-bit unsigned integer in big-endian
     * order.
     *
     * If parametersVerified is non-empty, the representation of parametersVerified is an ASN.1 DER
     * encoded representation of the values. The ASN.1 schema used is the AuthorizationList schema
     * from the Keystore attestation documentation. If parametersVerified is empty, it is simply
     * omitted from the HMAC computation.
     */
    uint8_t mac[32];
}__attribute__((packed)) verification_token_t;

namespace keymaster {
// The following create the numeric values that KM_TAG_PADDING and KM_TAG_DIGEST used to have.  We
// need these old values to be able to support old keys that use them.
static const keymaster_tag_t KM_TAG_DIGEST_OLD = static_cast<keymaster_tag_t>(KM_ENUM | 5);
static const keymaster_tag_t KM_TAG_PADDING_OLD = static_cast<keymaster_tag_t>(KM_ENUM | 7);
static const keymaster_tag_t KM_TAG_USE_SECURE_PROCESSOR = static_cast<keymaster_tag_t>(KM_BOOL | 15000);
static const keymaster_tag_t KM_TAG_SOTER_IS_FROM_SOTER_TEMP = static_cast<keymaster_tag_t>(KM_BOOL | 11000);
static const keymaster_tag_t KM_TAG_SOTER_IS_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY_TEMP
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 11001);
static const keymaster_tag_t KM_TAG_SOTER_IS_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY_TEMP
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 11002);
static const keymaster_tag_t KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY_TEMP
                                    = static_cast<keymaster_tag_t>(KM_BYTES | 11003);
static const keymaster_tag_t KM_TAG_SOTER_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY_TEMP
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 11004);
static const keymaster_tag_t KM_TAG_SOTER_IS_SECMSG_FID_COUNTER_SIGNED_WHEN_SIGN_TEMP
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 11005);
static const keymaster_tag_t KM_TAG_SOTER_USE_NEXT_ATTK_TEMP
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 11006);
static const keymaster_tag_t KM_TAG_SOTER_UID_TEMP
                                    = static_cast<keymaster_tag_t>(KM_UINT | 11007);
static const keymaster_tag_t KM_TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY_BLOB_TEMP
                                    = static_cast<keymaster_tag_t>(KM_BYTES | 11008);

static const keymaster_purpose_t KM_PURPOSE_WRAP
                                    = static_cast<keymaster_purpose_t>(5);

static const keymaster_algorithm_t KM_ALGORITHM_TripleDES
                                    = static_cast<keymaster_algorithm_t>(33);

//New KM4 tags
static const keymaster_tag_t KM_TAG_ROLLBACK_RESISTANCE
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 303);
static const keymaster_tag_t KM_HARDWARE_TYPE
                                    = static_cast<keymaster_tag_t>(KM_ENUM | 304);
static const keymaster_tag_t KM_TRUSTED_USER_PRESENCE_REQUIRED
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 507);
static const keymaster_tag_t KM_TRUSTED_CONFIRMATION_REQUIRED
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 508);
static const keymaster_tag_t KM_UNLOCKED_DEVICE_REQUIRED
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 509);
static const keymaster_tag_t KM_TAG_VENDOR_PATCHLEVEL
                                    = static_cast<keymaster_tag_t>(KM_UINT | 718);
static const keymaster_tag_t KM_BOOT_PATCHLEVEL
                                    = static_cast<keymaster_tag_t>(KM_UINT | 719);
static const keymaster_tag_t KM_TAG_FBE_ICE
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 16201);
static const keymaster_tag_t KM_TAG_KEY_TYPE
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16202);

#ifdef AUTOMOTIVE_VIRTUAL_KM
static const keymaster_key_format_t KM_KEY_FORMAT_SHARED
                                    = static_cast<keymaster_key_format_t>(7);
static const keymaster_tag_t KM_TAG_SHARED_KEY
                                    = static_cast<keymaster_tag_t>(KM_BOOL | 16301);
static const keymaster_tag_t KM_TAG_SHARED_VM1
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16302);
static const keymaster_tag_t KM_TAG_SHARED_VM2
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16303);
static const keymaster_tag_t KM_TAG_SHARED_VM3
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16304);
static const keymaster_tag_t KM_TAG_SHARED_VM4
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16305);
static const keymaster_tag_t KM_TAG_SHARED_VM5
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16306);
static const keymaster_tag_t KM_TAG_SHARED_VM6
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16307);
static const keymaster_tag_t KM_TAG_SHARED_VM7
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16308);
static const keymaster_tag_t KM_TAG_SHARED_VM8
                                    = static_cast<keymaster_tag_t>(KM_UINT | 16309);
static const keymaster_tag_t KM_TAG_PURPOSE_VM1
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16311);
static const keymaster_tag_t KM_TAG_PURPOSE_VM2
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16312);
static const keymaster_tag_t KM_TAG_PURPOSE_VM3
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16313);
static const keymaster_tag_t KM_TAG_PURPOSE_VM4
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16314);
static const keymaster_tag_t KM_TAG_PURPOSE_VM5
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16315);
static const keymaster_tag_t KM_TAG_PURPOSE_VM6
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16316);
static const keymaster_tag_t KM_TAG_PURPOSE_VM7
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16317);
static const keymaster_tag_t KM_TAG_PURPOSE_VM8
                                    = static_cast<keymaster_tag_t>(KM_ENUM_REP | 16318);
#endif // AUTOMOTIVE_VIRTUAL_KM


static const keymaster_security_level_t KM_SECURITY_LEVEL_STRONGBOX
                                    = static_cast<keymaster_security_level_t>(2);
// Until we have C++11, fake std::static_assert.
template <bool b> struct StaticAssert {};
template <> struct StaticAssert<true> {
    static void check() {}
};

// An unusable type that we can associate with tag types that don't have a simple value type.
// That will prevent the associated type from being used inadvertently.
class Void {
    Void();
    ~Void();
};

/**
 * A template that defines the association between non-enumerated tag types and their value
 * types.  For each tag type we define a specialized struct that contains a typedef "value_type".
 */
template <keymaster_tag_type_t tag_type> struct TagValueType {};
template <> struct TagValueType<KM_ULONG> { typedef uint64_t value_type; };
template <> struct TagValueType<KM_ULONG_REP> { typedef uint64_t value_type; };
template <> struct TagValueType<KM_DATE> { typedef uint64_t value_type; };
template <> struct TagValueType<KM_UINT> { typedef uint32_t value_type; };
template <> struct TagValueType<KM_UINT_REP> { typedef uint32_t value_type; };
template <> struct TagValueType<KM_INVALID> { typedef Void value_type; };
template <> struct TagValueType<KM_BOOL> { typedef bool value_type; };
template <> struct TagValueType<KM_BYTES> { typedef keymaster_blob_t value_type; };
template <> struct TagValueType<KM_BIGNUM> { typedef keymaster_blob_t value_type; };

/**
 * TypedTag is a templatized version of keymaster_tag_t, which provides compile-time checking of
 * keymaster tag types. Instances are convertible to keymaster_tag_t, so they can be used wherever
 * keymaster_tag_t is expected, and because they encode the tag type it's possible to create
 * function overloadings that only operate on tags with a particular type.
 */
template <keymaster_tag_type_t tag_type, keymaster_tag_t tag> class TypedTag {
  public:
    typedef typename TagValueType<tag_type>::value_type value_type;

    inline TypedTag() {
        // Ensure that it's impossible to create a TypedTag instance whose 'tag' doesn't have type
        // 'tag_type'.  Attempting to instantiate a tag with the wrong type will result in a compile
        // error (no match for template specialization StaticAssert<false>), with no run-time cost.
        StaticAssert<(tag & tag_type) == tag_type>::check();
        StaticAssert<(tag_type != KM_ENUM) && (tag_type != KM_ENUM_REP)>::check();
    }
    inline operator keymaster_tag_t() { return tag; }
    inline long masked_tag() { return static_cast<long>(keymaster_tag_mask_type(tag)); }
};

template <keymaster_tag_type_t tag_type, keymaster_tag_t tag, typename KeymasterEnum>
class TypedEnumTag {
  public:
    typedef KeymasterEnum value_type;

    inline TypedEnumTag() {
        // Ensure that it's impossible to create a TypedTag instance whose 'tag' doesn't have type
        // 'tag_type'.  Attempting to instantiate a tag with the wrong type will result in a compile
        // error (no match for template specialization StaticAssert<false>), with no run-time cost.
        StaticAssert<(tag & tag_type) == tag_type>::check();
        StaticAssert<(tag_type == KM_ENUM) || (tag_type == KM_ENUM_REP)>::check();
    }
    inline operator keymaster_tag_t() { return tag; }
    inline long masked_tag() { return static_cast<long>(keymaster_tag_mask_type(tag)); }
};

// DECLARE_KEYMASTER_TAG is used to declare TypedTag instances for each non-enum keymaster tag.
#define DECLARE_KEYMASTER_TAG(type, name) extern TypedTag<type, KM_##name> name

DECLARE_KEYMASTER_TAG(KM_INVALID, TAG_INVALID);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_KEY_SIZE);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_MAC_LENGTH);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_CALLER_NONCE);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_MIN_MAC_LENGTH);
DECLARE_KEYMASTER_TAG(KM_ULONG, TAG_RSA_PUBLIC_EXPONENT);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_ECIES_SINGLE_HASH_MODE);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_INCLUDE_UNIQUE_ID);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_ROLLBACK_RESISTANCE);
DECLARE_KEYMASTER_TAG(KM_DATE, TAG_ACTIVE_DATETIME);
DECLARE_KEYMASTER_TAG(KM_DATE, TAG_ORIGINATION_EXPIRE_DATETIME);
DECLARE_KEYMASTER_TAG(KM_DATE, TAG_USAGE_EXPIRE_DATETIME);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_MIN_SECONDS_BETWEEN_OPS);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_MAX_USES_PER_BOOT);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_ALL_USERS);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_USER_ID);
DECLARE_KEYMASTER_TAG(KM_ULONG_REP, TAG_USER_SECURE_ID);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_NO_AUTH_REQUIRED);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_AUTH_TIMEOUT);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_ALLOW_WHILE_ON_BODY);
DECLARE_KEYMASTER_TAG(KM_BOOL, TRUSTED_USER_PRESENCE_REQUIRED);
DECLARE_KEYMASTER_TAG(KM_BOOL, TRUSTED_CONFIRMATION_REQUIRED);
DECLARE_KEYMASTER_TAG(KM_BOOL, UNLOCKED_DEVICE_REQUIRED);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_ALL_APPLICATIONS);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_APPLICATION_ID);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_APPLICATION_DATA);
DECLARE_KEYMASTER_TAG(KM_DATE, TAG_CREATION_DATETIME);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_ROLLBACK_RESISTANT);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ROOT_OF_TRUST);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ASSOCIATED_DATA);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_NONCE);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_AUTH_TOKEN);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_BOOTLOADER_ONLY);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_OS_VERSION);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_OS_PATCHLEVEL);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_UNIQUE_ID);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_CHALLENGE);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_APPLICATION_ID);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_RESET_SINCE_ID_ROTATION);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_BRAND);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_DEVICE);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_PRODUCT);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_SERIAL);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_IMEI);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_MEID);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_MANUFACTURER);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_ATTESTATION_ID_MODEL);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_VENDOR_PATCHLEVEL);
DECLARE_KEYMASTER_TAG(KM_UINT, BOOT_PATCHLEVEL);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_USE_SECURE_PROCESSOR);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SOTER_IS_FROM_SOTER_TEMP);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SOTER_IS_AUTO_SIGNED_WITH_ATTK_WHEN_GET_PUBLIC_KEY_TEMP);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SOTER_IS_AUTO_SIGNED_WITH_COMMON_KEY_WHEN_GET_PUBLIC_KEY_TEMP);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY_TEMP);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SOTER_AUTO_ADD_COUNTER_WHEN_GET_PUBLIC_KEY_TEMP);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SOTER_IS_SECMSG_FID_COUNTER_SIGNED_WHEN_SIGN_TEMP);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SOTER_USE_NEXT_ATTK_TEMP);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SOTER_UID_TEMP);
DECLARE_KEYMASTER_TAG(KM_BYTES, TAG_SOTER_AUTO_SIGNED_COMMON_KEY_WHEN_GET_PUBLIC_KEY_BLOB_TEMP);
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_FBE_ICE);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_KEY_TYPE);
#ifdef AUTOMOTIVE_VIRTUAL_KM
DECLARE_KEYMASTER_TAG(KM_BOOL, TAG_SHARED_KEY);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM1);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM2);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM3);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM4);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM5);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM6);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM7);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_SHARED_VM8);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM1);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM2);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM3);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM4);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM5);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM6);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM7);
DECLARE_KEYMASTER_TAG(KM_UINT, TAG_PURPOSE_VM8);
#endif //AUTOMOTIVE_VIRTUAL_KM

// DECLARE_KEYMASTER_ENUM_TAG is used to declare TypedEnumTag instances for each enum keymaster tag.
#define DECLARE_KEYMASTER_ENUM_TAG(type, name, enumtype)                                           \
    extern TypedEnumTag<type, KM_##name, enumtype> name

DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM_REP, TAG_PURPOSE, keymaster_purpose_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, TAG_ALGORITHM, keymaster_algorithm_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM_REP, TAG_BLOCK_MODE, keymaster_block_mode_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM_REP, TAG_DIGEST, keymaster_digest_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, TAG_DIGEST_OLD, keymaster_digest_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM_REP, TAG_PADDING, keymaster_padding_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, TAG_PADDING_OLD, keymaster_padding_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, TAG_BLOB_USAGE_REQUIREMENTS,
                           keymaster_key_blob_usage_requirements_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, TAG_ORIGIN, keymaster_key_origin_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, TAG_USER_AUTH_TYPE, hw_authenticator_type_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM_REP, TAG_KDF, keymaster_kdf_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, TAG_EC_CURVE, keymaster_ec_curve_t);
DECLARE_KEYMASTER_ENUM_TAG(KM_ENUM, HARDWARE_TYPE, keymaster_security_level_t);

//
// Overloaded function "Authorization" to create keymaster_key_param_t objects for all of tags.
//

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_BOOL, Tag> tag) {
    return keymaster_param_bool(tag);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_UINT, Tag> tag, uint32_t value) {
    return keymaster_param_int(tag, value);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_UINT_REP, Tag> tag, uint32_t value) {
    return keymaster_param_int(tag, value);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_ULONG, Tag> tag, uint64_t value) {
    return keymaster_param_long(tag, value);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_ULONG_REP, Tag> tag, uint64_t value) {
    return keymaster_param_long(tag, value);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_DATE, Tag> tag, uint64_t value) {
    return keymaster_param_date(tag, value);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_BYTES, Tag> tag, const void* bytes,
                                           size_t bytes_len) {
    return keymaster_param_blob(tag, reinterpret_cast<const uint8_t*>(bytes), bytes_len);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_BYTES, Tag> tag,
                                           const keymaster_blob_t& blob) {
    return keymaster_param_blob(tag, blob.data, blob.data_length);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_BIGNUM, Tag> tag, const void* bytes,
                                           size_t bytes_len) {
    return keymaster_param_blob(tag, reinterpret_cast<const uint8_t*>(bytes), bytes_len);
}

template <keymaster_tag_t Tag>
inline keymaster_key_param_t Authorization(TypedTag<KM_BIGNUM, Tag> tag,
                                           const keymaster_blob_t& blob) {
    return keymaster_param_blob(tag, blob.data, blob.data_length);
}

template <keymaster_tag_t Tag, typename KeymasterEnum>
inline keymaster_key_param_t Authorization(TypedEnumTag<KM_ENUM, Tag, KeymasterEnum> tag,
                                           KeymasterEnum value) {
    return keymaster_param_enum(tag, value);
}

template <keymaster_tag_t Tag, typename KeymasterEnum>
inline keymaster_key_param_t Authorization(TypedEnumTag<KM_ENUM_REP, Tag, KeymasterEnum> tag,
                                           KeymasterEnum value) {
    return keymaster_param_enum(tag, value);
}

}  // namespace keymaster

#endif  // SYSTEM_KEYMASTER_KEYMASTER_TAGS_H_
