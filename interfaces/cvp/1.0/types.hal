/*!
 *
 * Copyright (c) 2018 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 */
package vendor.qti.hardware.cvp@1.0;

enum cvpConstant : uint32_t {
 CVP_MAX_PLANE = 2,
 CVP_OPTICALFLOW_MV_WEIGHTS_SIZE = 7,
 CVP_MAX_PYRAMID_DETECTOR_CLASSIFIER_OCTAVES = 3,
 CVP_MAX_PYRAMID_DETECTOR_CLASSIFIER_SCALES_PER_OCTAVE = 3,
 CVP_MAX_PYRAMID_DETECTOR_CLASSIFIER_LEVELS = 10,
 CVP_MAX_PYRAMID_FPX_OCTAVES = 5,
 CVP_MAX_PYRAMID_FPX_SCALES_PER_OCTAVE = 6,
 CVP_MAX_PYRAMID_FPX_LEVELS = 30,
};


//------------------------------------------------------------------------------
/// @brief
///    CVP session
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
typedef uint64_t cvpHalSession;

//------------------------------------------------------------------------------
/// @brief
///    Handle for CVP
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
typedef uint64_t cvpHalHandle;

//------------------------------------------------------------------------------
/// @brief
///    CVP DSP session Handle
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
typedef uint64_t cvpHalSessionDSP;

//------------------------------------------------------------------------------
/// @brief
///    DSP Handle for CVP
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
typedef uint64_t cvpHalHandleDSP;

//------------------------------------------------------------------------------
/// @brief
///    Defines the status returned by a function.
///
/// @param CVP_SUCCESS
///    Success
/// @param CVP_EFAIL
///    General failure
/// @param CVP_EUNALIGNPARAM
///    Unaligned pointer parameter
/// @param CVP_EBADPARAM
///    Bad parameters
/// @param CVP_EINVALSTATE
///    Called at invalid state
/// @param CVP_ENORES
///    Insufficient resources, memory, thread...
/// @param CVP_EUNSUPPORTED
///    Unsupported feature
/// @param CVP_ECLOCKEXCEEDSLIMIT
///    Clock / Bandwidth Requested Exceeds Limits.Unrecoverable Fatal Error.
/// @param CVP_EFATAL
///    Generic Unrecoverable Fatal Error.
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
enum cvpHalStatus : uint32_t {
   CVP_SUCCESS = 0,
   CVP_EFAIL,
   CVP_EUNALIGNPARAM,
   CVP_EBADPARAM,
   CVP_EINVALSTATE,
   CVP_ENORES,
   CVP_EUNSUPPORTED,
   CVP_ECLOCKEXCEEDSLIMIT,
   CVP_EFATAL,
};

//------------------------------------------------------------------------------
/// @brief
///    Defines Asynchronous Error Event Generated by CVP Hardware.
///
/// @param CVP_EVFATAL
///    Unrecoverable CVP Hardware Error Event
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
enum cvpHalEvent : uint32_t
{
   CVP_EVFATAL = 0,
};

//------------------------------------------------------------------------------
/// @brief
///    Enumeration representing several Color Formats supported throughout
///    CVP.
/// @param CVP_COLORFORMAT_GRAY_8BIT
///    Gray 8 bit in one plane. These are the alignment requirements:
///    - Y (luma) width stride: 128 byte aligned.
///    - Y (luma) height stride: 32 byte aligned.
/// @param CVP_COLORFORMAT_UBWC_GRAY
///    UBWC Gray format. Contains two planes of a lossless-compressed gray image.
///    First plane is the meta information and the second plane is the actual
///    image data. These are the alignment requirements:
///    - Y (luma) meta width stride: 64 byte aligned
///    - Y (luma) meta height stride: 16 byte aligned
///    - Y (luma) width stride: 128 byte aligned
///    - Y (luma) height stride: 32 byte aligned
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
enum cvpHalColorFormat : uint32_t {
   CVP_COLORFORMAT_GRAY_8BIT,
   CVP_COLORFORMAT_UBWC_GRAY
};

//------------------------------------------------------------------------------
/// @brief
///    Direction option for Optical Flow.
/// @param CVP_OPTICALFLOW_UNIDIRECTIONAL
///    Either forward or backward optical flow only. There will be only 1
///    output for either forward or backward optical flow.
/// @param CVP_OPTICALFLOW_BIDRECTIONAL
///    Bidirectional optical flow. There will be 2 outputs for forward and
///    backward optical flow respectively.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
enum cvpHalOpticalFlowDirection : uint32_t
{
   CVP_OPTICALFLOW_UNIDIRECTIONAL,
   CVP_OPTICALFLOW_BIDRECTIONAL
};


//------------------------------------------------------------------------------
/// @brief
///    Mode option for Optical Flow.
/// @param CVP_OPTICALFLOW_ONE_PASS
///    One Pass Optical Flow
/// @param CVP_OPTICALFLOW_SEVEN_PASS
///    Seven Pass Optical Flow
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
enum cvpHalOpticalFlowMode : uint32_t
{
   CVP_OPTICALFLOW_ONE_PASS,
   CVP_OPTICALFLOW_SEVEN_PASS
};

//------------------------------------------------------------------------------
/// @brief
///    Feature Point Extraction (FPX) mode
/// @param CVP_FPX_PEAK_8x8
///    One feature point is detected in each 8x8 block.
/// @param CVP_FPX_ZONE
///    Top 8 feature points per zone are written out.
///
/// @ingroup cvp_feature_detection
//------------------------------------------------------------------------------
enum cvpHalFpxMode : uint32_t
{
   CVP_FPX_PEAK_8x8,
   CVP_FPX_ZONE
};

//------------------------------------------------------------------------------
/// @brief
///    Enumeration representing Detector output channel options.
/// @param CVP_DETECTOR_36_CHANNELS
///    36 channels output.
/// @param CVP_DETECTOR_13_CHANNELS
///    13 channels output.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
enum cvpHalDetectorChannel : uint32_t
{
   CVP_DETECTOR_36_CHANNELS,
   CVP_DETECTOR_13_CHANNELS
};

//------------------------------------------------------------------------------
/// @brief
///    Enumeration for output enablement.
/// @param CVP_OUTPUT_MODE_CLASSIFIER
///    Enable output for classifier. The input for Classifier is from Detector in the hardware pipeline
/// @param CVP_OUTPUT_MODE_CLASSIFIER_FPX
///    Enable output for both Feature Point Extraction (FPX) and Classifier.
///    The input for Classifier is from Detector in the hardware pipeline
///
/// @ingroup cvp_feature_detection, cvp_object_detection, cvp_machine_learning
//------------------------------------------------------------------------------
enum cvpHalDetectionClassificationMode : uint32_t
{
   CVP_OUTPUT_MODE_CLASSIFIER,
   CVP_OUTPUT_MODE_CLASSIFIER_FPX
};

//------------------------------------------------------------------------------
/// @brief
///    NCC mode
/// @param CVP_NCC_BEST_SCORE
///    Only give the best result output.
/// @param CVP_NCC_ALL_SCORE
///    Give all NCC score output.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
enum cvpHalNccScoreType : uint32_t
{
   CVP_NCC_BEST_SCORE,
   CVP_NCC_ALL_SCORE
};


// -----------------------------------------------------------------------------
/// @brief
///    Structure representing a CVP version.
/// @details
///     CVP version contains Major.Minor.Revision number.
///     An increase in "Major" indicates that a previously released API has changed,
///     so a developer may encounter compilation issues which require modification
///     of their code in order to adhere to the modified API.  Qualcomm will make
///     every effort to minimize these changes.  Additionally, new functions and
///     implementation modifications may be present.
///     An increase in "Minor" indicates that new functions have been added to the
///     library, so additional functionality is available, however existing APIs
///     have not changed.  Additionally, implementation modifications may be
///     present.
///     An increase in "Revision" indicates that implementation modifications only have
///     been made.
/// @param nMajor
///    Major version number.
/// @param nMinor
///    Minor version number.
/// @param nRevision
///    Revision version number.
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
struct cvpHalVersion
{
   uint32_t nMajor;
   uint32_t nMinor;
   uint32_t nRevision;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing the power requirement information.
/// @param ise_cycles
///    ise cycles.
/// @param vpss_cycles
///    vpss cycles.
/// @param ddr_bw
///    DDR bandwidth
/// @param sys_cache_bw
///    sys cache bandwidth
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
struct cvpHalPowerReq
{
    uint32_t ise_cycles;
    uint32_t vpss_cycles;
    uint32_t ddr_bw;
    uint32_t sys_cache_bw;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing the image information for CVP.
/// @param eFormat
///    Enum representing the color format of the image.
/// @param nWidth
///    Width of the Image.
/// @param nHeight
///    Height of the Image.
/// @param nPlane
///    Number of Image Planes. Valid values are 1 - CVP_MAX_PLANE.
/// @param nWidthStride
///    Array of width stride values. Represent width strides of the planes in the order
///    that they appear in the respective formats. Width stride value is in bytes which
///    is the number of bytes from beginning of one line of the plane buffer to the next.
///    The stride must meet the color format alignment requirement.
/// @param nAlignedSize
///    Array of aligned size values. Represent aligned sizes of the planes in the
///    order that they appear in the respective formats.
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
struct cvpHalImageInfo {
   cvpHalColorFormat eFormat;
   uint32_t       nWidth;
   uint32_t       nHeight;
   uint32_t       nPlane;
   uint32_t[cvpConstant:CVP_MAX_PLANE]       nWidthStride;
   uint32_t[cvpConstant:CVP_MAX_PLANE]       nAlignedSize;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing an image for CVP
/// @param pPlane
///    Pointer to the memory location with contains the image data for each plane.
///    The memory size for pPlane[i] is equal to
///    sImageInfo.nWidthStride[i] * sImageInfo.nHeightStride[i].
/// @param sImageInfo
///    Structure of image information.
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
struct cvpHalImage {
   uint64_t           pImageIndex;
   cvpHalImageInfo    sImageInfo;
};

// -----------------------------------------------------------------------------
/// @brief
///    Structure representing a pyramid level with uint16_t data type.
/// @param pData
///    Pointer to the uint16_t data.
/// @param nWidth
///    Width of pyramid at the level
/// @param nHeight
///    Height of pyramid at the level
/// @param nStride
///    Width stride which is the number of bytes from beginning of one line of the data
///    buffer to the next.
/// @param nChannels
///    Number of data channels.
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
struct cvpHalPyramidLevelu16
{
   uint64_t  pIndexData;
   uint32_t  nWidth;
   uint32_t  nHeight;
   uint32_t  nStride;
   uint32_t  nChannels;
};

// -----------------------------------------------------------------------------
/// @brief
///    Structure representing a pyramid with uint16_t data type.
/// @param pPyramidLevel
///    Pointer to the pyramid level structure. Memory should be allocated
///    nLevels * sizeof(cvpPyramidLevelu16) bytes.
/// @param nOctaves
///    Number of octaves. Image is halved in size between ajacent octaves.
/// @param nScalesPerOctave
///    Number of scales per octave. This includes the octave.
/// @param nLevels
///    Number of pyramid levels.
///
/// @ingroup cvp_type
//------------------------------------------------------------------------------
struct cvpHalPyramidu16
{
   vec<cvpHalPyramidLevelu16> pPyramidLevel;
   uint32_t            nOctaves;
   uint32_t            nScalesPerOctave;
   uint32_t            nLevels;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing Motion Vector
///
/// @param nMVX_L0
///    Represented by bit 8:0 MVX_L0 - Signed Horizontal motion vector for block 0.
/// @param nMVY_L0
///    Represented by bit 15:9. MVY_L0 - Signed Vertical motion vector for block 0.
/// @param nReserved
///    Represented by bit 30:16. Unused reserved bit.
/// @param nConf
///    Represented by bit 31. Motion vector confidence.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalMotionVector {
   int32_t nMVX_L0   ;   //   8:  0
   int32_t nMVY_L0   ;   //  15:  9
   int32_t nReserved ;  //  30: 16
   int32_t nConf     ;   //  31
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing optical flow statistic packets.
///
/// @param nVariance
///    8x8 block variance.
/// @param nMean
///    8x8 block mean.
/// @param nReserved
///    Unused reserved bit.
/// @param nBestMVSad
///    SAD of the best MV of 8x8 block.
/// @param nSad
///    SAD of the (0,0) MVs.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalOFStats {
   uint16_t nVariance;
   uint8_t  nMean;
   uint8_t  nReserved;
   uint16_t nBestMVSad;
   uint16_t nSad;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing Optical Flow output (Refer to Progrmming Guide for details)
/// @param pMotionVector
///    Pointer to the array of motion vectors.
/// @param pStats
///    Pointer to the array of stats packets.
/// @param nMVSize
///    Size of the motion vector array.
/// @param nStatsSize
///    Size of the stats packet array.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalOpticalFlowOutput
{
   uint64_t         pIndexMotionVector;
   uint64_t         pIndexStats;
   uint32_t         nMVSize;
   uint32_t         nStatsSize;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for optical flow configuration.
/// @param sImageInfo
///    Structure for image information.
/// @param eDirection
///    Enum representing the optical flow direction.
/// @param bStatsEnable
///    Flag to enable or disable the stats packet.
/// @param eMode
///    Enum representing the Optical Flow mode
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalConfigOpticalFlow
{
   cvpHalImageInfo             sImageInfo;
   cvpHalOpticalFlowDirection  eDirection;
   bool                        bStatsEnable;
   cvpHalOpticalFlowMode       eMode;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for optical flow configuration - Advanced.
/// @param nMvDist
///    MV Distance threshold. Higher the value, sparser MVs are searched.
///    Valid values are 1,2,3 and 4. Default value is 2.
/// @param nMvWeights
///    Smoothness for different candidates. It is an array of CVP_OPTICALFLOW_MV_WEIGHTS_SIZE
///    elements. Assign higher values to 1st 5 for more global motion,
///    6th for smoothness, 7th for local motion.
///    Each element can take values 1 to 20. Default values are {10,2,2,1,1,7,20}
/// @param nMedianFiltType
///    Type of median filtering. Valid values are {0,1,2,5,6}. Default value is 5.
/// @param nThresholdMedFilt
///    Median filtering threshold.
///    Valid values are 700,900,1000,1200,1400,1444 and 1600. Default value is 900.
/// @param nSmoothnessPenaltyThresh
///    Cost Threshold.
///    Valid values are 200 to 2000 (in steps of 50). Default value is 500.
/// @param nSearchRangeX
///    Search range in X direction. Range is ± of the value.
///    Valid values are 128, 96 and 64. Default value is 96.
/// @param nSearchRangeY
///    Search range in Y direction. Range is ± of the value.
///    Valid values are 64 and 48. Default value is 48.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalAdvConfigOpticalFlow
{
   uint32_t            nMvDist;
   uint32_t[cvpConstant:CVP_OPTICALFLOW_MV_WEIGHTS_SIZE]            nMvWeights;
   uint32_t            nMedianFiltType;
   uint32_t            nThresholdMedFilt;
   uint16_t            nSmoothnessPenaltyThresh;
   int16_t             nSearchRangeX;
   int16_t             nSearchRangeY;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for Optical Flow output buffer requirement
/// @param nMotionVectorBytes
///    The required size in bytes for motion vectors.
/// @param nStatsBytes
///    The required size in bytes for stats packets.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalOpticalFlowOutBuffReq
{
   uint32_t nMotionVectorBytes;
   uint32_t nStatsBytes;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for Memory allocation return
/// @param nHandle
///    Return handle with fd to fill buffers.
/// @param nIndx
///    Index of mapping used on vendor for the corresponding VA.
///
/// @ingroup cvp_hal
//------------------------------------------------------------------------------
struct cvpHalMallocOut
{
   handle nHandle;
   uint64_t nIndex;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing DFS output
/// @param pDisparityMap
///    Pointer to the Disparity Map.
/// @param pOcclusionMask
///    Pointer to the occlusion mask. This will be NULL if bOcclusionMaskEnable
///    is set to false. One bit per occlusion mask.
/// @param nDisparityMapSize
///    Number of pDisparityMap
/// @param nOcclusionMaskSize
///    Number of pOcclusionMask
/// @ingroup cvp_3D_reconstruction
//------------------------------------------------------------------------------
struct cvpHalDfsOutput
{
   uint64_t pIndexDisparityMap;
   uint64_t pIndexOcclusionMask;
   uint32_t nDisparityMapSize;
   uint32_t nOcclusionMaskSize;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for depth from stereo (DFS) configuration.
/// @param sLeftImageInfo
///    Structure for the left image information.
/// @param sRightImageInfo
///    Structure for the right image information.
/// @param nMaxDisparity
///    [Input] Max disparity in integer precision. Range: 4-64. Numbers outside this range
///    are not supported.
/// @param nDisparityOffset
///    Valid range is [0, 254-nMaxDisparity]
///    Default value is 0 depending on camera calibration.
/// @param bOcclusionMaskEnable
///    Flag to enable occlusion mask
///    When enabled, occlusion mask output will be available. Otherwise, occlusion mask
///    output will be skipped
/// @param bMedianFilterEnable
///    Flag to enable median filter
/// @param bOcclusionFillingEnable
///    Flag to enable filling
///
/// @ingroup cvp_3D_reconstruction
//------------------------------------------------------------------------------
struct cvpHalConfigDfs
{
   cvpHalImageInfo sLeftImageInfo;
   cvpHalImageInfo sRightImageInfo;
   uint32_t        nMaxDisparity;
   uint32_t        nDisparityOffset;
   bool            bOcclusionMaskEnable;
   bool            bMedianFilterEnable;
   bool            bOcclusionFillingEnable;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for DFS output buffer requirement
/// @param nDisparityMapBytes
///    The required size in bytes for disparity map.
/// @param nOcclusionMaskBytes
///    The required size in bytes for occlusion mask.
///
/// @ingroup cvp_3D_reconstruction
//------------------------------------------------------------------------------
struct cvpHalDfsOutBuffReq
{
   uint32_t nDisparityMapBytes;
   uint32_t nOcclusionMaskBytes;
};

//------------------------------------------------------------------------------
/// @brief
///    Configuration structure for Feature Point Extraction specific to Zone mode.
///    The zone width and height are defined as the number of 8x8 blocks.
/// @param nZoneWidth
///    Zone width. This should be an even number. Min is 2 and max is 30.
/// @param nZoneHeight
///    Zone height. This should be an even number. Min is 2 and max is 30.
///
/// @ingroup cvp_feature_detection
//------------------------------------------------------------------------------
struct cvpHalConfigFpxZone
{
    uint32_t nZoneWidth;
    uint32_t nZoneHeight;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for feature point extraction (FPX) configuration.
/// @param sImageInfo
///    Structure for the image information.
/// @param eMode
///    Enum representing the FPX mode.
/// @param nRobustness
///    This parameter controls the robustness of the feature point detector.
///    Lower robustness setting produces more candidate feature points and vice versa.
///    Valid range is 0 to 127. Default value is 10.
/// @param sZoneConfig
///    Configuration for Zone mode. It will be used only if eMode is
///    CVP_FPX_ZONE.
///
/// @ingroup cvp_feature_detection
//------------------------------------------------------------------------------
struct cvpHalConfigFpx
{
   cvpHalImageInfo     sImageInfo;
   cvpHalFpxMode       eMode;
   uint8_t             nRobustness;
   cvpHalConfigFpxZone sZoneConfig;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for FPX output buffer requirement.
/// @param nFeaturePointBytes
///    The required size in bytes for feature point output.
/// @param eMode
///    Enum representing the FPX mode.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalFeaturePointOutBuffReq
{
   uint32_t   nFeaturePointBytes;
   cvpHalFpxMode eMode;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing feature point extraction (FPX) 64-bit data point.
/// @param nLocX
///    The x coordinate.
/// @param nLocY
///    The y coordinate.
/// @param nScore
///    The score.
/// @param nPadding
///    Unused, for padding.
///
/// @ingroup cvp_feature_detection
//------------------------------------------------------------------------------
struct cvpHalFeaturePointData
{
    uint16_t nLocX;
    uint16_t nLocY;
    uint16_t nScore;
    uint16_t nPadding;
};

//------------------------------------------------------------------------------
/// @brief
///    Struct representing feature point extraction (FPX) output depending on the chosen
///    mode.
/// @param pFeaturePoints
///    Pointer to the output depending on the chosen mode.
/// @param pPeak8x8
///    Pointer to the 64-bit data point if CVP_FPX_PEAK_8x8 was chosen.
///    In raster scan order, within 16x16, vertical raster scan order. Refer to Programming Guide.
/// @param pZone
///    Pointer to the 64-bit data point if CVP_FPX_ZONE was chosen.
///    In zone raster scan order, top 8 for each zone.
/// @param nWidth
///    If CVP_FPX_PEAK_8x8 was chosen, it is the number of 8x8 blocks along the image width.
///    If CVP_FPX_ZONE was chosen, it is the number of zones along the image width.
/// @param nHeight
///    If CVP_FPX_PEAK_8x8 was chosen, it is the number of 8x8 blocks along the image height.
///    If CVP_FPX_ZONE was chosen, it is the number of zones along the image height.
/// @param nSize
///    Number of pFeaturePoints data.
/// @param nMaxFpxScore
///    Maximum FPX score. This value is used to calculate the next feature point
///    score shift using cvpGetFpxScoreShift().
///
/// @ingroup cvp_feature_detection
//------------------------------------------------------------------------------
struct cvpHalFeaturePointOutput
{
   uint64_t pIndexFeaturePoints;
   uint32_t nWidth;
   uint32_t nHeight;
   uint32_t nSize;
   uint32_t nMaxFpxScore;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure representing Detector Classifier pipeline output.
/// @param sClassifierOut
///    Output structure for the classification process.
///    The nLevels are equal to (nOctaves * nScalesPerOctave) + 1.
/// @param sFpxOut
///    Output structure for the Feature Point Extraction process. The FPX mode
///    is CVP_FPX_PEAK_8x8.
/// @param bValidClassifier
///    Boolean value showing whether Classifier output is valid.
/// @param bValidFpx
///    Boolean value showing whether Feature Point Extraction output is valid.
///
/// @ingroup cvp_feature_detection, cvp_object_detection, cvp_machine_learning
//------------------------------------------------------------------------------
struct cvpHalDetectionClassificationOutput
{
   cvpHalPyramidu16         sClassifierOut;
   cvpHalFeaturePointOutput sFpxOut;
   bool                     bValidClassifier;
   bool                     bValidFpx;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for detector configuration.
/// @param sImageInfo
///    Structure for image information.
/// @param nOctaves
///    Number of octaves. Image size is halved between ajacent octaves.
/// @param nScalesPerOctave
///    Number of scales per octave. Total scales = num_oct*num_scales+1
/// @param eOutChannels
///    Output channels option.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalConfigDetector
{
   cvpHalImageInfo       sImageInfo;
   uint8_t               nOctaves;
   uint8_t               nScalesPerOctave;
   cvpHalDetectorChannel eOutChannels;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for Classifier configuration.
/// @param nIntPrec
///    Classifier integer precision. The number of integer bits in the final output width
///    and the rest are fractional bits.  Must be >= 1.
///
/// @ingroup cvp_machine_learning
//------------------------------------------------------------------------------
struct cvpHalConfigClassifier
{
    uint8_t nIntPrec;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for classifier packet information.
/// @param pTemplateData
///    Pointer to the model data and bias. The size of pTemplateData depends on
///    cvpDetectorChannel. There is alignment requirement to the cvpDetectorChannel.
///    For CVP_DETECTOR_36_CHANNELS, channelAlignment is equal to 8.
///    For CVP_DETECTOR_13_CHANNELS, channelAlignment is equal to 16.
///    The buffer structure contains all template data with int16_t type followed
///    by all the bias with int32_t type.
///    The size = (nTemplateWidth * nTemplateHeight * channelAlignment *
///    nTemplates * sizeof(int16_t)) + (nTemplates * sizeof(int32_t))
/// @param nTemplateWidth
///    Templates width.
/// @param nTemplateHeight
///    Templates height.
/// @param nTemplates
///    Number of templates.
///
/// @ingroup cvp_machine_learning
//------------------------------------------------------------------------------
struct cvpHalClassifierPacket
{
   uint64_t  pIndexTemplateData;
   uint32_t  nTemplateWidth;
   uint32_t  nTemplateHeight;
   uint32_t  nTemplates;
};

//------------------------------------------------------------------------------
/// @brief
///    Configuration structure for CVP - Detection Classification pipeline.
///    It contains Feature Point Extraction (FPX), Detector, and Classifier.
///
/// @param sDetectorConfig
///    Structure for Detector config.
/// @param sClassifierConfig
///    Structure for Classifier config.
/// @param eMode
///    Mode option for Feature Point Extraction, Detector or Classifier.
/// @param nRobustness
///    This parameter controls the robustness of the feature point detector.
///    Lower robustness setting produces more candidate feature points and vice versa.
///    Valid range is 0 to 127. Default value is 10.
///
/// @ingroup cvp_feature_detection, cvp_object_detection, cvp_machine_learning
//------------------------------------------------------------------------------
struct cvpHalConfigDetectorClassifier
{
   cvpHalConfigDetector              sDetectorConfig;
   cvpHalConfigClassifier            sClassifierConfig;
   cvpHalDetectionClassificationMode eMode;
   uint8_t                           nRobustness;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for Detection Classification output buffer requirement
/// @param nClassifierBytesPerTemplate
///    The required size in bytes for pyramid Classification output data for each
///    classification template. The total
///    cvpDetectionClassificationOutput.sClassifierOut.pPyramidLevel[i].pData will be
///    equal to nClassifierBytesPerTemplate[i] * cvpClassifierPacket.nTemplates.
/// @param nClassifierLevels
///    Number of Classifier pyramid levels.
/// @param nFeaturePointBytes
///    The required size in bytes for feature point output
///    (cvpDetectionClassificationOutput.sFpxOut.pPoints)
///
/// @ingroup cvp_feature_detection, cvp_object_detection, cvp_machine_learning
//------------------------------------------------------------------------------
struct cvpHalDetectionClassificationOutBuffReq
{
   uint32_t[cvpConstant:CVP_MAX_PYRAMID_DETECTOR_CLASSIFIER_LEVELS] nClassifierBytesPerTemplate;
   uint32_t nClassifierLevels;
   uint32_t nFeaturePointBytes;
};

//------------------------------------------------------------------------------
/// @brief
///    Packed structure for NCC search windows.
/// @details
///    NCC search windows can be accessible using either two 64 bit values or
///    a data structure containing all parameter of NCC search window.
///    Locations are in UQ13.2 format
/// @param nWindows
///    Represented by bit 1:0. Number of the last used windows. Possible value
///    is 0, 1, 2, 3. There must be at least one window for NCC search.
///    UQ13.2 means the x and y locations are in quad pixel precision (i.e. floating point
///    precision can be 0, 0.25, 0.5, 0.75).
/// @param nLocX_0
///    Represented by bit 16:2. Top left X position for windows 0.
/// @param nLocY_0
///    Represented by bit 31:17. Top left Y position for windows 0.
/// @param nLocX_1
///    Represented by bit 46:32. Top left X position for windows 1.
/// @param nReserved_0
///    Represented by bit 47. Unused reserved bit.
/// @param nLocY_1
///    Represented by bit 62:48. Top left Y position for windows 1.
/// @param nReserved_1
///    Represented by bit 63. Unused reserved bit.
/// @param nLocX_2
///    Represented by bit 78:64. Top left X position for windows 2.
/// @param nReserved_2
///    Represented by bit 79. Unused reserved bit.
/// @param nLocY_2
///    Represented by bit 94:80. Top left Y position for windows 2.
/// @param nReserved_3
///    Represented by bit 95. Unused reserved bit.
/// @param nLocX_3
///    Represented by bit 110:96. Top left X position for windows 3.
/// @param nReserved_4
///    Represented by bit 111. Unused reserved bit.
/// @param nLocY_3
///    Represented by bit 126:112. Top left Y position for windows 3.
/// @param nReserved_5
///    Represented by bit 127. Unused reserved bit.
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalNccWindows
{
   uint64_t nWindows    ;   //: 2;    //   1:  0
   uint64_t nLocX_0     ;   //: 15;   //  16:  2
   uint64_t nLocY_0     ;   //: 15;   //  31: 17
   uint64_t nLocX_1     ;   //: 15;   //  46: 32
   uint64_t nReserved_0 ;   //: 1;    //  47
   uint64_t nLocY_1     ;   //: 15;   //  62: 48
   uint64_t nReserved_1 ;   //: 1;    //  63
   uint64_t nLocX_2     ;   //: 15;   //  78: 64
   uint64_t nReserved_2 ;   //: 1;    //  79
   uint64_t nLocY_2     ;   //: 15;   //  94: 80
   uint64_t nReserved_3 ;   //: 1;    //  95
   uint64_t nLocX_3     ;   //: 15;   // 110: 96
   uint64_t nReserved_4 ;   //: 1;    // 111
   uint64_t nLocY_3     ;   //: 15;   // 126:112
   uint64_t nReserved_5 ;   //: 1;    // 127
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for NCC output.
/// @param pNccScore
///    Pointer to the NCC score. Min buffer size is nNccScoreSize * sizeof(uint32_t)
///    The score memory layout is depending on eScoreType.
///    If eScoreType == CVP_NCC_BEST_SCORE, then size of buffer is
///    nNccRequests * 4 * 2 bytes. Each template has 4*16 bit for max ref window =4.
///    If num of ref window is not 4, then 0 padding.
///    If eScoreType == CVP_NCC_ALL_SCORE, then size of buffer is
///    nNccRequests * 4 * 12 * 12 * 2 bytes. All score results will be saved as 4x1 pixels in
///    vertical raster scan order.
///    Refer to Programming Guide for details
/// @param pBestPosition
///    Pointer to the structure for the best position for each search window.
///    Min buffer size is nBestPositionSize * sizeof(cvpNccWindows) bytes.
/// @param nNccScoreSize
///    Number of pNccScore.
/// @param nBestPositionSize
///    Number of pBestPosition which is equal to nNccRequests.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalNccOutput
{
   uint64_t        pIndexNccScore;
   uint64_t        pIndexBestPosition;
   uint32_t        nNccScoreSize;
   uint32_t        nBestPositionSize;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for NCC configuration.
/// @param sImageInfo
///    Structure for image information.
/// @param eScoreType
///    NCC output score type.
/// @param bSubPelEnable
///    Boolean value showing if NCC SubPel is enabled(True) or disabled(False).
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalConfigNcc
{
   cvpHalImageInfo    sImageInfo;
   cvpHalNccScoreType eScoreType;
   bool               bSubPelEnable;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for NCC output buffer Requirement
/// @param nNccScoreBytes
///    The required size in bytes for NCC score buffer.
/// @param nBestPositionBytes
///    The required size in bytes for best position buffer.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalNccOutBuffReq
{
   uint32_t nNccScoreBytes;
   uint32_t nBestPositionBytes;
};

// -----------------------------------------------------------------------------
/// @brief
///    Structure representing a pyramid image
/// @param pImage
///    Pointer to the image structure array.
/// @param nOctaves
///    Number of octaves. Image size is halved between adjacent octaves.
/// @param nScalesPerOctave
///    Number of scales per octave. This includes the octave.
/// @param nLevels
///    Number of levels which is the number of pImages.
///    It is equal to nOctaves * nScalesPerOctave.
///
/// @ingroup cvp_image_transform
//------------------------------------------------------------------------------
struct cvpHalPyramidImage
{
   vec<cvpHalImage> pVecImage;
   uint32_t  nOctaves;
   uint32_t  nScalesPerOctave;
   uint32_t  nLevels;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for pyramid configuration.
/// @param sImageInfo
///    Structure for image information.
/// @param nOctaves
///    Number of octaves. Image size is halved between adjacent octaves.
/// @param nScalesPerOctave
///    Number of scales per octave. This includes the octave.
///    Number of levels is equal to nScalesPerOctave * nOctaves.
///
/// @ingroup cvp_image_transform
//------------------------------------------------------------------------------
struct cvpHalConfigPyramidImage
{
   cvpHalImageInfo sImageInfo;
   uint32_t     nOctaves;
   uint32_t     nScalesPerOctave;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for Pyramid Image output buffer requirement
/// @param nImageBytes
///    The required size in bytes for pyramid image (sImage.pImage[i])
///    where i = level index).
///    Must not allocate buffer for the base image (sImage.pImage[0]). It will set the
///    input image information into pImage[0].
/// @param nLevels
///    Number of pyramid levels.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalPyramidImageOutBuffReq
{
   uint32_t[cvpConstant:CVP_MAX_PYRAMID_FPX_LEVELS] nImageBytes;
   uint32_t nLevels;
};

// -----------------------------------------------------------------------------
/// @brief
///    Structure representing Feature Point pyramid. Max is CVP_MAX_PYRAMID_FPX_OCTAVES.
///    Feature point extraction (FPX) can be done at the octave level only.
/// @param sFeaturePoint
///    List of Feature Point output structure. The sFeaturePoint[i].pPoints pointer
///    value will be NULL if bFpxEnable[i] is set to false.
/// @param nOctaves
///    Number of octaves that has Feature Point Extraction output.
///
/// @ingroup cvp_feature_detection
//------------------------------------------------------------------------------
struct cvpHalPyramidFpx
{
   cvpHalFeaturePointOutput[cvpConstant:CVP_MAX_PYRAMID_FPX_OCTAVES]  sFeaturePoint;
   uint32_t               nOctaves;
};

// -----------------------------------------------------------------------------
/// @brief
///    Structure representing pyramid image and pyramid Feature Point Extraction output
/// @param sImage
///    Image pyramid output
/// @param sFpx
///    Feature Point Extraction (FPX) pyramid output
///
/// @ingroup cvp_image_transform, cvp_feature_detection
//------------------------------------------------------------------------------
struct cvpHalPyramidOutput
{
   cvpHalPyramidImage  sImage;
   cvpHalPyramidFpx    sFpx;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for pyramid configuration.
/// @param sImageInfo
///    Structure for image information.
/// @param nOctaves
///    Number of octaves. Image size is halved between adjacent octaves.
/// @param nScalesPerOctave
///    Number of scales per octave. This includes the octave.
///    Number of levels is equal to nScalesPerOctave * nOctaves.
/// @param bFpxEnable
///    List of flags (max is CVP_MAX_PYRAMID_FPX_OCTAVES) to enable Feature Point
///    Extraction for each octave.
/// @param eMode
///    Enum representing the Feature Point Extraction mode.
/// @param nFpxRobustness
///    This parameter controls the robustness of the feature point detector.
///    Lower robustness setting produces more candidate feature points and vice versa.
///    Valid range is 0 to 127. Default value is 10.
/// @param sZoneConfig
///    Configuration for Zone mode. It will be used only if eMode is
///    CVP_FPX_ZONE.
///
/// @ingroup cvp_image_transform, cvp_feature_detection
//------------------------------------------------------------------------------
struct cvpHalConfigPyramid
{
   cvpHalImageInfo      sImageInfo;
   uint32_t          nOctaves;
   uint32_t          nScalesPerOctave;
   bool[cvpConstant:CVP_MAX_PYRAMID_FPX_OCTAVES]             bFpxEnable;
   cvpHalFpxMode        eMode;
   uint8_t           nFpxRobustness;
   cvpHalConfigFpxZone[cvpConstant:CVP_MAX_PYRAMID_FPX_OCTAVES]  sZoneConfig;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for Pyramid Feature Point Extraction output buffer requirement
/// @param nFeaturePointBytes
///    The required size in bytes for pyramid FPX output
///    (sFpx.sFeaturePoint[i].pPoints where i = level index)
/// @param nOctaves
///    Number of octaves.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalPyramidFpxOutBuffReq
{
   uint32_t[cvpConstant:CVP_MAX_PYRAMID_FPX_OCTAVES] nFeaturePointBytes;
   uint32_t nOctaves;
};

//------------------------------------------------------------------------------
/// @brief
///    Structure for Pyramid output buffer requirement
/// @param sImage
///    The output buffer requirement for pyramid image.
/// @param sFpx
///    The output buffer requirement for pyramid Feature Point Extraction.
///
/// @ingroup cvp_object_detection
//------------------------------------------------------------------------------
struct cvpHalPyramidOutBuffReq
{
   cvpHalPyramidImageOutBuffReq  sImage;
   cvpHalPyramidFpxOutBuffReq    sFpx;
};
