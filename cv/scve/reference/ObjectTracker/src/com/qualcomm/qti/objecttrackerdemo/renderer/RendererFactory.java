/*
 * Copyright (c) 2014-2015 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

package com.qualcomm.qti.objecttrackerdemo.renderer;

import java.util.concurrent.atomic.AtomicInteger;

import com.qualcomm.qti.objecttracker.misc.CoordinateSpace;
import com.qualcomm.qti.objecttrackerdemo.renderer.primitives.EffectRenderer;
import com.qualcomm.qti.objecttrackerdemo.renderer.primitives.InputTextureRenderer;
import com.qualcomm.qti.objecttrackerdemo.renderer.primitives.MagnifyRenderer;
import com.qualcomm.qti.objecttrackerdemo.renderer.primitives.PipRenderer;
import com.qualcomm.qti.objecttrackerdemo.renderer.primitives.RedHighlightRenderer;
import com.qualcomm.qti.objecttrackerdemo.renderer.primitives.Renderer;
import com.qualcomm.qti.objecttrackerdemo.renderer.primitives.TextureFormat;
import com.qualcomm.qti.objecttrackerdemo.ui.RoiContainer;
import com.qualcomm.qti.objecttrackerdemo.ui.RoiContainer.Shape;

/**
 * This class manages app state related to renderers, and allows clients to check if their
 * renderers are stale, and if so, recreate them.
 */
public class RendererFactory {
    /**
     * The mode in which the requested renderer will be used
     */
    public enum Usage {
        /** The renderer will be used for the preview display */
        PREVIEW,

        /** The renderer will be used to produce a high-res snapshot */
        SNAPSHOT,

        /** The renderer will be used to produce a recorded video */
        VIDEO
    }

    /**
     * The type of {@link Renderer}s that will be created by {@link
     * RendererFactory#createRenderer(Usage, CoordinateSpace, CoordinateSpace, TextureFormat)}
     */
    public enum Type {
        /**
         * A normal renderer for the specified {@link Usage}
         */
        NORMAL,

        /**
         * A special effect renderer
         */
        EFFECT,

        /**
         * A picture-in-picture renderer
         */
        PICTURE_IN_PICTURE,

        /**
         * A magnifying glass renderer
         */
        MAGNIFY
    }

    /**
     * This value represents a generation smaller than any that will be generated by
     * {@link #getGeneration()}. Classes can use this as their initial generation count.
     */
    public static final int INVALID_GENERATION = 0;

    private final AtomicInteger generation = new AtomicInteger(INVALID_GENERATION + 1);
    private final RoiContainer roiContainer;

    // These members may be accessed from multiple thread contexts; protect with lock
    private final Object lock = new Object();
    private Type renderType = Type.NORMAL;

    /**
     * Construct a {@link RendererFactory}
     * @param roiContainer the {@link RoiContainer} associated with the current tracking session
     * @throws IllegalArgumentException if roiContainer is null
     */
    public RendererFactory(RoiContainer roiContainer) {
        if (roiContainer == null) {
            throw new IllegalArgumentException("roiContainer may not be null");
        }

        this.roiContainer = roiContainer;
    }

    /**
     * Set the {@link Type} of {@link Renderer} that this factory will create.
     * <p/><i>NOTE: this should be invoked on the UI thread</i>
     * @param type one of the {@link Type} values
     * @throws IllegalArgumentException if type is null
     */
    public void setRenderType(Type type) {
        if (type == null) {
            throw new IllegalArgumentException("type may not be null");
        }

        synchronized (lock) {
            renderType = type;
                generation.incrementAndGet();
            }

        roiContainer.setRoiShape(type == Type.MAGNIFY ? Shape.OVAL : Shape.RECTANGLE);
    }

    /**
     * Retrieve the "generation" of the renderers produced by the factory. Each time the rendering
     * state changes, the generation will increase. Clients can check this each time they render to
     * determine whether their renderers are stale.
     * @return a generation value > {@link #INVALID_GENERATION}
     */
    /*package*/ int getGeneration() {
        return generation.get();
    }

    /**
     * Construct a new renderer appropriate for the current application state
     * @param usage the mode in which the returned renderer will be used
     * @param cameraSpace {@link CoordinateSpace} of the renderer input frames
     * @param outputSpace {@link CoordinateSpace} which the renderer will render into
     * @param textureFormat {@link TextureFormat} of the renderer input frames
     * @return a new subclass of {@link BaseRenderer}, appropriate for the current application state
     * @throws IllegalArgumentException if usage, cameraSpace, outputSpace, or textureFormat
     *      are null
     */
    /*package*/ Renderer createRenderer(Usage usage, CoordinateSpace cameraSpace,
            CoordinateSpace outputSpace, TextureFormat textureFormat) {
        if (usage == null) {
            throw new IllegalArgumentException("usage may not be null");
        } else if (cameraSpace == null) {
            throw new IllegalArgumentException("cameraSpace may not be null");
        } else if (outputSpace == null) {
            throw new IllegalArgumentException("outputSpace may not be null");
        } else if (textureFormat == null) {
            throw new IllegalArgumentException("textureFormat may not be null");
        }

        synchronized (lock) {
            switch (renderType) {
            case NORMAL:
                if (usage == Usage.PREVIEW) {
                    return new InputTextureRenderer(cameraSpace, outputSpace, textureFormat);
                } else {
                    return new RedHighlightRenderer(cameraSpace, outputSpace, textureFormat);
                }

            case EFFECT:
                return new EffectRenderer(cameraSpace, outputSpace, textureFormat);

            case PICTURE_IN_PICTURE:
                return new PipRenderer(cameraSpace, outputSpace, textureFormat);

            case MAGNIFY:
                return new MagnifyRenderer(cameraSpace, outputSpace, textureFormat);

            default:
                throw new IllegalStateException("Unexpected renderType");
            }
        }
    }
}
