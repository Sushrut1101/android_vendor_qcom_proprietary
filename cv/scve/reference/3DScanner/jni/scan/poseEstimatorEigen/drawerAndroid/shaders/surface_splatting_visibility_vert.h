/*
 * Copyright (c) 2015-2016 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */
char surface_splatting_visibility_vert [] = 
"#version 300 es\n"
"\n"
"layout(location = 0) in vec3 iPosition;\n"
"layout(location = 1) in vec3 iNormal;\n"
"layout(location = 2) in vec3 iColor;\n"
"\n"
"uniform mat4 gCS_view;\n"
"uniform mat4 gCS_projection;\n"
"uniform mat4 gMS_model;\n"
"\n"
"uniform mat4 gBB_inverseModel;\n"
"uniform vec3 gBB_max;\n"
"uniform vec3 gBB_min;\n"
"uniform float gBB_enableCulling;\n"
"\n"
"uniform vec3 gCS_viewDirection;\n"
"uniform float gCS_diskRadius;\n"
"uniform float gCS_filterRadius;\n"
"uniform float gCS_splatSize;\n"
"\n"
"out highp vec3 vs_center;\n"
"out highp vec3 vs_normal;\n"
"out highp vec3 vs_s_k;\n"
"out highp vec3 vs_t_k;\n"
"\n"
"vec3 adjust_tangent(vec3 v_0, vec4 p, float h) {\n"
"    //adjust vector s.t. the length is greater than radius of low-pass filter\n"
"    vec3 v_k;\n"
"    float scale = 1.0 / (p.z * p.z - v_0.z * v_0.z);\n"
"    v_k.x = scale * (v_0.x * p.z - v_0.z * p.x);\n"
"    v_k.y = scale * (v_0.y * p.z - v_0.z * p.y);\n"
"    v_k.z = 0.0;\n"
"\n"
"    //length is already\n"
"    float mag = length(v_k);\n"
"    if(mag > h)\n"
"        return v_0;\n"
"\n"
"    return v_k * p.z * h / mag;\n"
"}\n"
"\n"
"float compute_splat_radius(vec3 s, vec3 t, float eye_z, float splat_size) {\n"
"    //compute bounding sphere around splat\n"
"    float r = sqrt(max(dot(s, s), dot(t, t)));\n"
"    //splat_size = near_plane * viewport_height / (near_plane_height)\n"
"    return r * splat_size / eye_z;\n"
"}\n"
"\n"
"void transform_tangent_vectors(vec4 p, out vec3 n, out vec3 s_k, out vec3 t_k) {\n"
"    n = (gCS_view * (gMS_model * vec4(iPosition + iNormal, 1.0)) - p).xyz;\n"
"    //n' = n dot(center, n)^-1\n"
"    n = n / dot(p.xyz, n);\n"
"\n"
"    s_k = normalize(cross(p.xyz, n)) * gCS_diskRadius;\n"
"    s_k = adjust_tangent(s_k, p, gCS_filterRadius);\n"
"\n"
"    t_k = normalize(cross(n, s_k)) * gCS_diskRadius;\n"
"    t_k = adjust_tangent(t_k, p, gCS_filterRadius);\n"
"\n"
"}\n"
"\n"
"void main() {\n"
"    vec4 world_pos = gMS_model * vec4(iPosition, 1.0);\n"
"    vec4 aabb_space = gBB_inverseModel * world_pos;\n"
"    if(gBB_enableCulling > 0.5 || (all(lessThanEqual(aabb_space.xyz, gBB_max.xyz)) &&\n"
"            all(greaterThanEqual(aabb_space.xyz, gBB_min.xyz)))) {\n"
"        //bring all coordinates into camera space\n"
"        vec4 p_cs = gCS_view * (world_pos);\n"
"        vs_center = p_cs.xyz;\n"
"        gl_Position = gCS_projection * p_cs;\n"
"\n"
"        transform_tangent_vectors(p_cs, vs_normal, vs_s_k, vs_t_k);\n"
"        if(dot(vs_normal, -gCS_viewDirection) < 0.0)\n"
"            gl_Position = vec4(-2, -2, 0, 1.0);\n"
"        else\n"
"           //heuristic for splat size\n"
"            gl_PointSize = compute_splat_radius(\n"
"                vs_s_k, vs_t_k, gl_Position.w, gCS_splatSize);\n"
"    } else\n"
"        gl_Position = vec4(-2, -2, 0, 1.0);\n"
"}\n"
; 
