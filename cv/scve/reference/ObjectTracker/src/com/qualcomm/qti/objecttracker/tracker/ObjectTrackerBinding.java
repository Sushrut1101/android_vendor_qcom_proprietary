/*
 * Copyright (c) 2014 Qualcomm Technologies, Inc. All Rights Reserved.
 * Qualcomm Technologies Proprietary and Confidential.
 */

package com.qualcomm.qti.objecttracker.tracker;

import java.util.HashSet;

import android.graphics.Point;
import android.graphics.Rect;

/**
 * This class provides Java bindings for the SCVE Object Tracker APIs
 */
/*package*/ class ObjectTrackerBinding {
    /**
     * This data class holds the results of tracking operations from the native library
     */
    /*package*/ static class Result {
        /**
         * The ID of the tracked object, as previously returned by a call to
         * {@link ObjectTrackerBinding#registerObject(byte[], Rect)} or
         * {@link ObjectTrackerBinding#registerObject(byte[], Point, boolean)}
         */
        public final int id;

        /**
         * The confidence value returned by the tracker, from 0..100. If tracking is lost, the
         * reported confidence will be 0.
         */
        public final int confidence;

        /**
         * The position of the tracked object within the image frame, or an empty {@link Rect} if
         * tracking is lost
         */
        public final Rect pos;

        private Result(int id, int confidence, int left, int top, int right, int bottom) {
            this.id = id;
            this.confidence = confidence;
            this.pos = new Rect(left, top, right, bottom);
        }
    }

    /**
     * The value returned by {@link #registerObject(byte[], Point, boolean)} if the object
     * registration is still pending, and the caller should continue to call this method each
     * frame (with <tt>firstTime = false</tt>) until either the object is successfully registered,
     * or the tracker is unable to register the object.
     */
    public static final int PENDING_REGISTRATION = -1;

    /**
     * The maximum number of objects which can be tracked simultaneously. Any attempt to register
     * another object past this number will throw a {@link TooManyObjectsRegisteredException}.
     */
    public static final int MAX_NUM_TRACKED_OBJECTS = 9;

    private final Rect imageRect;
    private final int stride;
    private final HashSet<Integer> trackedObjects = new HashSet<Integer>();
    private boolean released;

    static {
        System.loadLibrary("objecttrackerref_jni");
        nClassInit();
    }

    /**
     * Construct an {@link ObjectTrackerBinding}
     * @param operationMode The operation mode for the SCVE engine. One of the values from {@link
     *      OperationMode}.
     * @param precision The precision of tracking that the object tracker should perform. One of the
     *      values from {@link Precision}.
     * @param width Width of the image frames, in px. Since the input colour format is NV21, it
     *      must be evenly divisible by 2.
     * @param height Height of the image frames, in px. Since the input colour format is NV21, it
     *      must be evenly dvisible by 2.
     * @param stride Stride of the image frames, in bytes. Must be >= width.
     * @throws InternalObjectTrackerException for any internal errors generated by the tracker
     */
    public ObjectTrackerBinding(OperationMode operationMode, Precision precision,
            int width, int height, int stride) throws InternalObjectTrackerException {
        if (operationMode == null) {
            throw new IllegalArgumentException("operationMode cannot be null");
        } else if (precision == null) {
            throw new IllegalArgumentException("precision cannot be null");
        } else if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("width and height must be >= 0");
        } else if (stride < width) {
            throw new IllegalArgumentException("stride must be >= width");
        } else if (stride % 2 != 0) {
            throw new IllegalArgumentException("stride for NV21-encoded frames must be even");
        } else if (height % 2 != 0) {
            throw new IllegalArgumentException("height for NV21-encoded frames must be even");
        }

        imageRect = new Rect(0, 0, width, height);
        this.stride = stride;
        nInit(operationMode.ordinal(), precision.ordinal(), width, height, stride);
    }

    /**
     * Close the {@link ObjectTrackerBinding}. After invoking this, all other object tracker
     * methods on this instance will throw a {@link ObjectTrackerNotRunningException}.
     */
    public void release() {
        if (!released) {
            released = true;
            nRelease();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        release();
    }

    /**
     * Get the minimum dimension (width or height) of a region of interest for the current image
     * frame size
     * @return the minimum dimension (in px) of the width or height of a region of interest
     * @throws ObjectTrackerNotRunningException if the {@link ObjectTrackerBinding} has been
     *      {@link #release()}d
     */
    public int getMinRoiDimension() {
        if (released) {
            throw new ObjectTrackerNotRunningException();
        }

        return nGetMinRoiDimension();
    }

    /**
     * Get the maximum dimension (width or height) of a region of interest for the current image
     * frame size
     * @return the maximum dimension (in px) of the width or height of a region of interest
     * @throws ObjectTrackerNotRunningException if the {@link ObjectTrackerBinding} has been
     *      {@link #release()}d
     */
    public int getMaxRoiDimension() {
        if (released) {
            throw new ObjectTrackerNotRunningException();
        }

        return nGetMaxRoiDimension();
    }

    /**
     * Register a new object to track, via an initial region of interest {@link Rect}.
     * @param imageDataNV21 The NV21-encoded image frame from which to register the object
     * @param rect A {@link Rect} containing the initial region of interest containing the object
     *      to track
     * @return a unique identifier for the object, which will persist for the duration of tracking
     *      of this object
     * @throws ObjectTrackerNotRunningException if the {@link ObjectTrackerBinding} has been
     *      {@link #release()}d
     * @throws ObjectRegistrationFailedException if the tracker was unable to register an object
     *      from this region of interest
     * @throws TooManyObjectsRegisteredException if the tracker indicates it is not able to track
     *      an additional object
     * @throws InternalObjectTrackerException for any internal errors generated by the tracker
     */
    public int registerObject(byte[] imageDataNV21, Rect rect) throws
            ObjectRegistrationFailedException, TooManyObjectsRegisteredException,
            InternalObjectTrackerException {
        if (imageDataNV21 == null || imageDataNV21.length < getMinFrameSize()) {
            throw new IllegalArgumentException("imageDataNV21 null or too small to encode frame");
        } else if (rect == null || rect.isEmpty() || !imageRect.contains(rect)) {
            throw new IllegalArgumentException("rect must be non-empty and be entirely inside " +
                    "the frame");
        } else if (released) {
            throw new ObjectTrackerNotRunningException();
        } else if (trackedObjects.size() > MAX_NUM_TRACKED_OBJECTS) {
            throw new TooManyObjectsRegisteredException("Max number of tracked objects (" +
                    MAX_NUM_TRACKED_OBJECTS + ") reached");
        }

        int id = nRegisterObjectByRect(imageDataNV21, rect.left, rect.top, rect.right, rect.bottom);
        trackedObjects.add(id);
        return id;
    }

    /**
     * Register an object to track, via a single indicated {@link Point}. Note that this may be a
     * multi-frame process; if {@link #PENDING_REGISTRATION} is returned, you must continue to
     * invoke {@link #registerObject(byte[], Point, boolean)} on each subsequent frame (with
     * <tt>firstTime = false</tt>) until either a unique identifier for the object is returned, or
     * object registration fails (as indicated by an {@link ObjectRegistrationFailedException}).
     * @param imageDataNV21 The NV21-encoded image frame from which to register the object
     * @param point The point indicating the object to register
     * @param firstTime Pass <tt>true</tt> for this parameter the first time you invoke this method
     *      for a particular frame. If the result is {@link #PENDING_REGISTRATION}, pass
     *      <tt>false</tt> on each subsequent frame, until registration either succeeds or fails.
     * @return {@link #PENDING_REGISTRATION} if the registration attempt requires additional image
     *      frames, or a unique identifier for the object if it is successfully registered. This
     *      identifier will persist for the duration of tracking of this object.
     * @throws ObjectTrackerNotRunningException if the {@link ObjectTrackerBinding} has been
     *      {@link #release()}d
     * @throws ObjectRegistrationFailedException if the tracker was unable to register an object
     *      from this point
     * @throws TooManyObjectsRegisteredException if the tracker indicates it is not able to track
     *      an additional object
     * @throws InternalObjectTrackerException for any internal errors generated by the tracker
     */
    public int registerObject(byte[] imageDataNV21, Point point, boolean firstTime) throws
            ObjectRegistrationFailedException, TooManyObjectsRegisteredException,
            InternalObjectTrackerException {
        if (imageDataNV21 == null || imageDataNV21.length < getMinFrameSize()) {
            throw new IllegalArgumentException("imageDataNV21 null or too small to encode frame");
        } else if (point == null || !imageRect.contains(point.x, point.y)) {
            throw new IllegalArgumentException("point must be non-null and inside the image frame");
        } else if (released) {
            throw new ObjectTrackerNotRunningException();
        } else if (trackedObjects.size() > MAX_NUM_TRACKED_OBJECTS) {
            throw new TooManyObjectsRegisteredException("Max number of tracked objects (" +
                    MAX_NUM_TRACKED_OBJECTS + ") reached");
        }

        int id = nRegisterObjectByPoint(imageDataNV21, point.x, point.y, firstTime);
        if (id != PENDING_REGISTRATION) {
            trackedObjects.add(id);
        }
        return id;
    }

    /**
     * Unregister an object for tracking
     * @param id The unique identifier of the object to unregister. It should have been previously
     *      registered, via either {@link #registerObject(byte[], Rect)} or
     *      {@link #registerObject(byte[], Point, boolean)}.
     * @throws ObjectTrackerNotRunningException if the {@link ObjectTrackerBinding} has been
     *      {@link #release()}d
     * @throws InvalidObjectIdentifierException if id is not a tracked object identifier
     * @throws InternalObjectTrackerException for any internal errors generated by the tracker
     */
    public void unregisterObject(int id) throws InvalidObjectIdentifierException,
            InternalObjectTrackerException {
        if (id == PENDING_REGISTRATION || !trackedObjects.remove(id)) {
            throw new InvalidObjectIdentifierException(id + " is not a valid object identifier");
        } else if (released) {
            throw new ObjectTrackerNotRunningException();
        }
        nUnregisterObject(id);
    }

    /**
     * Perform tracking of all registered objects on a new image frame, and return the new object
     * positions, if the tracker is able to locate them.
     * @param imageDataNV21 The NV21-encoded image frame against which to perform tracking
     * @return an array of {@link Result}s, one for each tracked object
     * @throws ObjectTrackerNotRunningException if the {@link ObjectTrackerBinding} has been
     *      {@link #release()}d
     * @throws NoObjectsRegisteredException if {@link #trackObjects(byte[])} is invoked when no
     *      objects are registered for tracking
     * @throws InternalObjectTrackerException for any internal errors generated by the tracker
     */
    public Result[] trackObjects(byte[] imageDataNV21) throws NoObjectsRegisteredException,
            InternalObjectTrackerException {
        if (imageDataNV21 == null || imageDataNV21.length < getMinFrameSize()) {
            throw new IllegalArgumentException("imageDataNV21 null or too small to encode frame");
        } else if (released) {
            throw new ObjectTrackerNotRunningException();
        } else if (trackedObjects.isEmpty()) {
            throw new NoObjectsRegisteredException();
        }
        return nTrackObjects(imageDataNV21);
    }

    private int getMinFrameSize() {
        return ((stride * imageRect.bottom * 3) / 2);
    }

    /////////////////////////////////// NATIVE TRACKER INTERFACE ///////////////////////////////////

    // N.B. This field is accessed from JNI code. Do not rename or modify from Java side.
    private long nativeInstanceData;

    private static native void nClassInit();
    private native void nInit(int operationMode, int precision, int width, int height, int stride)
            throws InternalObjectTrackerException;
    private native void nRelease();
    private native int nGetMinRoiDimension();
    private native int nGetMaxRoiDimension();
    private native int nRegisterObjectByRect(byte[] imageDataNV21, int left, int top, int right,
            int bottom) throws ObjectRegistrationFailedException, TooManyObjectsRegisteredException,
            InternalObjectTrackerException;
    private native int nRegisterObjectByPoint(byte[] imageDataNV21, int x, int y, boolean firstTime)
            throws ObjectRegistrationFailedException, TooManyObjectsRegisteredException,
            InternalObjectTrackerException;
    private native void nUnregisterObject(int id) throws InternalObjectTrackerException;
    private native Result[] nTrackObjects(byte[] imageDataNV21) throws NoObjectsRegisteredException,
            InternalObjectTrackerException;
}
