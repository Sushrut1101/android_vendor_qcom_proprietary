// =======================================================================
// Copyright (c) 2016-2019 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
// =======================================================================

/** @cond */
#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"

#define IHavenTokenApp_SIG_SEC_LEVEL_HW UINT32_C(7)
#define IHavenTokenApp_SIG_SEC_LEVEL_SEK UINT32_C(6)
#define IHavenTokenApp_SIG_SEC_LEVEL_SEU UINT32_C(5)
#define IHavenTokenApp_SIG_SEC_LEVEL_TEEK UINT32_C(4)
#define IHavenTokenApp_SIG_SEC_LEVEL_TEEU UINT32_C(3)
#define IHavenTokenApp_SIG_SEC_LEVEL_RICHOSK UINT32_C(2)
#define IHavenTokenApp_SIG_SEC_LEVEL_RICHOSU UINT32_C(1)
#define IHavenTokenApp_KEYTYPE_NONE UINT32_C(0)
#define IHavenTokenApp_KEYTYPE_DEMO UINT32_C(1)
#define IHavenTokenApp_KEYTYPE_GROUPLOW UINT32_C(2)
#define IHavenTokenApp_KEYTYPE_GROUP UINT32_C(3)
#define IHavenTokenApp_KEYTYPE_PERCHIP UINT32_C(4)
#define IHavenTokenApp_KEYTYPE_RESERVED_1 UINT32_C(5)
#define IHavenTokenApp_KEYTYPE_RESERVED_2 UINT32_C(6)
#define IHavenTokenApp_KEYTYPE_GROUPTEST UINT32_C(7)
#define IHavenTokenApp_KEYTYPE_BEST_PRIVACY_PRESERVING_AVAILABLE UINT32_C(8)
#define IHavenTokenApp_KEYTYPE_QDAK UINT32_C(9)
#define IHavenTokenApp_KEYTYPE_QDAKTEST UINT32_C(10)
#define IHavenTokenApp_KEYTYPE_DEMO_NPP UINT32_C(11)
#define IHavenTokenApp_OPT_NONE UINT64_C(0x0000000000000000)
#define IHavenTokenApp_OPT_SIMDATA UINT64_C(0x0000000000000001)
#define IHavenTokenApp_OPT_APPCERT UINT64_C(0x0000000000000002)
#define IHavenTokenApp_OPT_LOCATION UINT64_C(0x0000000000000004)
#define IHavenTokenApp_OPT_LONGRTIC UINT64_C(0x0000000000000008)
#define IHavenTokenApp_OPT_RTIC_CURRENT UINT64_C(0x0000000000000020)
#define IHavenTokenApp_OPT_NON_PRIVACY_PRESERVING UINT64_C(0x0000000000000080)
#define IHavenTokenApp_OPT_CIPHER_SUITE_1 UINT64_C(0x0000000000000100)
#define IHavenTokenApp_OPT_CIPHER_SUITE_2 UINT64_C(0x0000000000000200)
#define IHavenTokenApp_OPT_CIPHER_SUITE_3 UINT64_C(0x0000000000000400)
#define IHavenTokenApp_LICENSE_OPT_NONE UINT32_C(0x00000000)
#define IHavenTokenApp_LICENSE_OPT_NO_OEMID_CHECK UINT32_C(0x00000001)
#define IHavenTokenApp_LICENSE_OPT_NO_HWVERSION_CHECK UINT32_C(0x00000002)
#define IHavenTokenApp_LICENSE_OPT_NO_FEATUREID_CHECK UINT32_C(0x00000004)
#define IHavenTokenApp_LICENSE_OPT_NO_TIME_CHECK UINT32_C(0x00000008)
#define IHavenTokenApp_LICENSE_OPT_CLOCK_NOT_SET_OK UINT32_C(0x00000010)
#define IHavenTokenApp_LICENSE_OPT_SELECT_TEST_ROOT UINT32_C(0x00000020)
#define IHavenTokenApp_LICENSE_OPT_USAGE_ENCRYPT UINT32_C(0x00000040)

#define IHavenTokenApp_ERROR_NOMEM INT32_C(10)
#define IHavenTokenApp_ERROR_SIGNING_KEY_UNAVAIL INT32_C(11)
#define IHavenTokenApp_ERROR_CBOR_ENCODE_ERR INT32_C(12)
#define IHavenTokenApp_ERROR_CERT_PKHASH INT32_C(13)
#define IHavenTokenApp_ERROR_INVALID_CERT INT32_C(14)
#define IHavenTokenApp_ERROR_CERT_FEATUREID INT32_C(15)
#define IHavenTokenApp_ERROR_CERT_EXPIRED INT32_C(16)
#define IHavenTokenApp_ERROR_CERT_OEM INT32_C(17)
#define IHavenTokenApp_ERROR_CERT_HWVERSION INT32_C(18)
#define IHavenTokenApp_ERROR_CERT_ISVCERTHASH INT32_C(19)
#define IHavenTokenApp_ERROR_DATA_MARSHAL INT32_C(20)
#define IHavenTokenApp_ERROR_HASH_GENERATION INT32_C(21)
#define IHavenTokenApp_ERROR_CERT_NOT_TRUSTED INT32_C(22)
#define IHavenTokenApp_ERROR_CERT_GENERAL_ERR INT32_C(23)
#define IHavenTokenApp_ERROR_DATA_TOO_BIG INT32_C(24)
#define IHavenTokenApp_ERROR_OFFSET_TOO_LARGE INT32_C(25)
#define IHavenTokenApp_ERROR_OUT_OF_ORDER INT32_C(26)
#define IHavenTokenApp_ERROR_NO_DATA INT32_C(27)
#define IHavenTokenApp_ERROR_RPMB_ERR INT32_C(28)
#define IHavenTokenApp_ERROR_ENCRYPTION INT32_C(29)
#define IHavenTokenApp_ERROR_NOT_ALLOWED INT32_C(30)
#define IHavenTokenApp_ERROR_LICENSE_TOO_BIG INT32_C(31)
#define IHavenTokenApp_ERROR_PRIVILEGE_ERR INT32_C(32)
#define IHavenTokenApp_ERROR_TOO_MUCH_APPDATA INT32_C(33)
#define IHavenTokenApp_ERROR_SECURITYLEVEL_NOT_SUPPORTED INT32_C(34)
#define IHavenTokenApp_ERROR_UNSUPPORTED_PAYLOAD_HASH INT32_C(35)
#define IHavenTokenApp_ERROR_SIGNING_ERR INT32_C(36)
#define IHavenTokenApp_ERROR_DEVICE_NOT_SECURE INT32_C(37)
#define IHavenTokenApp_ERROR_GROUPKEY_ERR INT32_C(38)
#define IHavenTokenApp_ERROR_CERT_DEVICEID INT32_C(39)
#define IHavenTokenApp_ERROR_SFS_ERR INT32_C(40)
#define IHavenTokenApp_ERROR_CERT_NOTYETVALID INT32_C(41)
#define IHavenTokenApp_ERROR_OPTS_NOT_SUPPORTED INT32_C(42)
#define IHavenTokenApp_ERROR_KEYSEQ_NOT_SUPPORTED INT32_C(43)
#define IHavenTokenApp_ERROR_KEYMGR_ERR INT32_C(44)
#define IHavenTokenApp_ERROR_CERT_PRODUCTID INT32_C(45)

#define IHavenTokenApp_OP_start 0
#define IHavenTokenApp_OP_addDataItem 1
#define IHavenTokenApp_OP_getSize 2
#define IHavenTokenApp_OP_getBytes 3
#define IHavenTokenApp_OP_finish 4
#define IHavenTokenApp_OP_setTime 5
#define IHavenTokenApp_OP_processLicense 6
#define IHavenTokenApp_OP_processLicense_TEE 7

static inline int32_t
IHavenTokenApp_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IHavenTokenApp_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
IHavenTokenApp_start(Object self, uint32_t uKeySelect_val, uint64_t nOpts_val, const void *LicenseCert_ptr, size_t LicenseCert_len)
{
  ObjectArg a[2];
  struct {
    uint64_t m_nOpts;
    uint32_t m_uKeySelect;
  } i;
  a[0].b = (ObjectBuf) { &i, 12 };
  i.m_uKeySelect = uKeySelect_val;
  i.m_nOpts = nOpts_val;
  a[1].bi = (ObjectBufIn) { LicenseCert_ptr, LicenseCert_len * 1 };

  return Object_invoke(self, IHavenTokenApp_OP_start, a, ObjectCounts_pack(2, 0, 0, 0));
}

static inline int32_t
IHavenTokenApp_addDataItem(Object self, const void *DataItem_ptr, size_t DataItem_len, const void *Label_ptr, size_t Label_len, const void *Data_ptr, size_t Data_len)
{
  ObjectArg a[3];
  a[0].bi = (ObjectBufIn) { DataItem_ptr, DataItem_len * 1 };
  a[1].bi = (ObjectBufIn) { Label_ptr, Label_len * 1 };
  a[2].bi = (ObjectBufIn) { Data_ptr, Data_len * 1 };

  return Object_invoke(self, IHavenTokenApp_OP_addDataItem, a, ObjectCounts_pack(3, 0, 0, 0));
}

static inline int32_t
IHavenTokenApp_getSize(Object self, uint64_t *pnSize_ptr)
{
  ObjectArg a[1];
  a[0].b = (ObjectBuf) { pnSize_ptr, sizeof(uint64_t) };

  return Object_invoke(self, IHavenTokenApp_OP_getSize, a, ObjectCounts_pack(0, 1, 0, 0));
}

static inline int32_t
IHavenTokenApp_getBytes(Object self, uint64_t uOffset_val, void *pBuffer_ptr, size_t pBuffer_len, size_t *pBuffer_lenout)
{
  ObjectArg a[2];
  a[0].b = (ObjectBuf) { &uOffset_val, sizeof(uint64_t) };
  a[1].b = (ObjectBuf) { pBuffer_ptr, pBuffer_len * 1 };

  int32_t result = Object_invoke(self, IHavenTokenApp_OP_getBytes, a, ObjectCounts_pack(1, 1, 0, 0));

  *pBuffer_lenout = a[1].b.size / 1;

  return result;
}

static inline int32_t
IHavenTokenApp_finish(Object self)
{
  return Object_invoke(self, IHavenTokenApp_OP_finish, 0, 0);
}

static inline int32_t
IHavenTokenApp_setTime(Object self, uint64_t UTCTime_val)
{
  ObjectArg a[1];
  a[0].b = (ObjectBuf) { &UTCTime_val, sizeof(uint64_t) };

  return Object_invoke(self, IHavenTokenApp_OP_setTime, a, ObjectCounts_pack(1, 0, 0, 0));
}

static inline int32_t
IHavenTokenApp_processLicense(Object self, const void *LicenseCert_ptr, size_t LicenseCert_len, uint32_t OptFlags_val, const void *IntermediateCert_ptr, size_t IntermediateCert_len, uint32_t FeatureID_val, const void *ISVCertHash_ptr, size_t ISVCertHash_len, void *Licensee_ptr, size_t Licensee_len, size_t *Licensee_lenout, void *Issuer_ptr, size_t Issuer_len, size_t *Issuer_lenout, void *SerialNumber_ptr, size_t SerialNumber_len, size_t *SerialNumber_lenout, void *PublicKey_ptr, size_t PublicKey_len, size_t *PublicKey_lenout)
{
  ObjectArg a[8];
  struct {
    uint32_t m_OptFlags;
    uint32_t m_FeatureID;
  } i;
  a[0].b = (ObjectBuf) { &i, 8 };
  a[1].bi = (ObjectBufIn) { LicenseCert_ptr, LicenseCert_len * 1 };
  i.m_OptFlags = OptFlags_val;
  a[2].bi = (ObjectBufIn) { IntermediateCert_ptr, IntermediateCert_len * 1 };
  i.m_FeatureID = FeatureID_val;
  a[3].bi = (ObjectBufIn) { ISVCertHash_ptr, ISVCertHash_len * 1 };
  a[4].b = (ObjectBuf) { Licensee_ptr, Licensee_len * 1 };
  a[5].b = (ObjectBuf) { Issuer_ptr, Issuer_len * 1 };
  a[6].b = (ObjectBuf) { SerialNumber_ptr, SerialNumber_len * 1 };
  a[7].b = (ObjectBuf) { PublicKey_ptr, PublicKey_len * 1 };

  int32_t result = Object_invoke(self, IHavenTokenApp_OP_processLicense, a, ObjectCounts_pack(4, 4, 0, 0));

  *Licensee_lenout = a[4].b.size / 1;
  *Issuer_lenout = a[5].b.size / 1;
  *SerialNumber_lenout = a[6].b.size / 1;
  *PublicKey_lenout = a[7].b.size / 1;

  return result;
}

static inline int32_t
IHavenTokenApp_processLicense_TEE(Object self, const void *LicenseCert_ptr, size_t LicenseCert_len, uint32_t OptFlags_val, const void *IntermediateCert_ptr, size_t IntermediateCert_len, uint32_t FeatureID_val, const void *ISVCertHash_ptr, size_t ISVCertHash_len, void *Licensee_ptr, size_t Licensee_len, size_t *Licensee_lenout, void *Issuer_ptr, size_t Issuer_len, size_t *Issuer_lenout, void *SerialNumber_ptr, size_t SerialNumber_len, size_t *SerialNumber_lenout, void *PublicKey_ptr, size_t PublicKey_len, size_t *PublicKey_lenout, uint64_t *CalleeID_ptr)
{
  ObjectArg a[9];
  struct {
    uint32_t m_OptFlags;
    uint32_t m_FeatureID;
  } i;
  a[0].b = (ObjectBuf) { &i, 8 };
  a[1].bi = (ObjectBufIn) { LicenseCert_ptr, LicenseCert_len * 1 };
  i.m_OptFlags = OptFlags_val;
  a[2].bi = (ObjectBufIn) { IntermediateCert_ptr, IntermediateCert_len * 1 };
  i.m_FeatureID = FeatureID_val;
  a[3].bi = (ObjectBufIn) { ISVCertHash_ptr, ISVCertHash_len * 1 };
  a[4].b = (ObjectBuf) { Licensee_ptr, Licensee_len * 1 };
  a[5].b = (ObjectBuf) { Issuer_ptr, Issuer_len * 1 };
  a[6].b = (ObjectBuf) { SerialNumber_ptr, SerialNumber_len * 1 };
  a[7].b = (ObjectBuf) { PublicKey_ptr, PublicKey_len * 1 };
  a[8].b = (ObjectBuf) { CalleeID_ptr, sizeof(uint64_t) };

  int32_t result = Object_invoke(self, IHavenTokenApp_OP_processLicense_TEE, a, ObjectCounts_pack(4, 5, 0, 0));

  *Licensee_lenout = a[4].b.size / 1;
  *Issuer_lenout = a[5].b.size / 1;
  *SerialNumber_lenout = a[6].b.size / 1;
  *PublicKey_lenout = a[7].b.size / 1;

  return result;
}



